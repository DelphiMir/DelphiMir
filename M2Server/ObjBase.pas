unit ObjBase;
// If you get an error on the next line, you need to reextract SourceFiles.rar
{$I defines.inc}
interface
uses
  {svn, }nixtime, Windows, Classes, SysUtils, DateUtils, Forms, StrUtils, Math, SDK, Grobal2,
  ItmUnit, MD5Unit, ADODB , Relationship, Envir, Mudutil;

type
  TClientAction = (cHit,cMagHit,cRun,cWalk,cDigUp,cTurn);
const
  gMan          = 0;
  gWoMan        = 1;
  //직업변경
  g_Warrior     = 0;
  g_Wizard      = 1;
  g_Monk        = 2;
  g_Assassin    = 3;
  g_Bonze       = 4;
  g_WarriorUp   = 5;
  g_WizardUp    = 6;
  g_MonkUp      = 7;
  g_AssassinUp  = 8;
  g_BonzeUp     = 9;
  
  //연인 해제 위자료(10만전)
  COMPENSATORY_PAYMENT = 100000;             //연인 스쳐사망
  //일방적인 연인 해제 위자료(30만전)
  COMPENSATORY_PAYMENT_ONEWAY = 300000;      //연인 스쳐사망

type
  TBaseObject = class;

  pTStartPoint=^TStartPoint;
  TStartPoint=record
    sMapName:String[MapNameLen];
    nX:Integer;
    nY:Integer;
    nSize:Integer;
    Envir:TEnvirnoment;
  end;

  pTSendMessage=^TSendMessage;
  TSendMessage=record
     wIdent:word;
     wParam:word;
     nParam1:integer;
     nParam2:integer;
     nParam3:integer;
     dwDeliveryTime:dword;
     BaseObject:TBaseObject;
     boLateDelivery:Boolean;
     Buff:pointer;
  end;

  pTVisibleBaseObject=^TVisibleBaseObject;
  TVisibleBaseObject=record
    BaseObject:TBaseObject;
    nVisibleBFlag:Integer;
  end;

  pTVisibleMapItem=^TVisibleMapItem;
  TVisibleMapItem=record
     nX,nY:integer;
     MapItem:pTMapItem;
     sName:String;
     wLooks:word;
     nVisibleFlag:integer;
  end;

  TBaseObject = class
    m_sMapName                :String[MapNameLen]; //0x04
    m_sStoreName              :String[20];    //개인상점
    m_sHDDCode                :string;        //수정되었습니다.
    m_sCharName               :String[ActorNameLen]; //0x15
    m_sPetName                :String[ActorNameLen];
    m_nPetEatRage             :Integer;  //영물 아이템 먹기 범위
    m_nCurrX                  :Integer;    //0x24
    m_nCurrY                  :Integer;    //0x28
    m_btDirection             :Byte;       //0x2C
    m_btGender                :Byte;       //0x2D
    m_btHair                  :Byte;       //0x2E
    m_btJob                   :Byte;       //0x2F
    m_btMask                  :Byte;       //변신탈
    m_btHumEffect             :Byte;       //기퍼짐
    m_btEventEffect           :Byte;       //빼빼로 이팩트
    m_WEffect                 :Byte;
    m_nGold                   :Integer;    //0x30
    m_Abil                    :TAbility; //TAbility;   //0x34 -> 0x5B
    m_nCharStatus             :Integer;    //0x5C
    m_sHomeMap                :String[MapNameLen]; //0x78
    m_nHomeX                  :Integer;    //0x8C
    m_nHomeY                  :Integer;    //0x90

    m_boOnHorse               :Boolean;    //0x95
    m_btHorseType             :Integer;
    m_btFishType              :Integer;        //낚시 중
    m_btDressEffType          :Byte;
    
    m_nPkPoint                :Integer;    //0xAC      //피케이

    m_nKillPoint              :Integer;    //킬/데스
    m_nDeathPoint             :Integer;    //킬/데스

    m_boAllowGroup            :Boolean;    //0xB0      //그룹
    m_boCheckGroup            :Boolean;
    m_boCheckHero             :Boolean;
    m_GroupClass              :Boolean;
    m_boAllowGuild            :Boolean;    //0xB1
    m_nIncHealth              :Integer;    //0x0B4
    m_nIncSpell               :Integer;    //0x0B8
    m_nIncStayHealth          :Integer;    //지속물약 - 개인
    m_nIncStaySpell           :Integer;    //지속물약
    m_dwStayHPTick            :LongWord;   //지속물약
    m_dwStayMPTick            :LongWord;   //지속물약
    m_dwStayHPTime            :LongWord;   //지속물약
    m_dwStayMPTime            :LongWord;   //지속물약
    m_dwIncStayHealthTick     :LongWord;   //지속물약
    m_dwIncStaySpellTick      :LongWord;   //지속물약

    m_nGrIncStayHealth          :Integer;    //지속물약 - 그룹
    m_nGrIncStaySpell           :Integer;    //지속물약
    m_dwGrStayHPTick            :LongWord;   //지속물약
    m_dwGrStayMPTick            :LongWord;   //지속물약
    m_dwGrStayHPTime            :LongWord;   //지속물약
    m_dwGrStayMPTime            :LongWord;   //지속물약
    m_dwGrIncStayHealthTick     :LongWord;   //지속물약
    m_dwGrIncStaySpellTick      :LongWord;   //지속물약

    m_nIncHealing             :Integer;    //0x0BC
    m_nFightZoneDieCount      :Integer;    //0x0C0
    m_BonusAbil               :TNakedAbility; //0x0CA TNakedAbility
    m_CurBonusAbil            :TNakedAbility; //0x0DE
    m_nBonusPoint             :Integer;        //0x0F4
    m_nMasterUpExp            :Integer;        //0x0F8
    m_boAllowGuildReCall      :Boolean;        //0xFC

    m_dBodyLuck               :Double;        //0x100
    m_nBodyLuckLevel          :Integer;       //0x108
    m_wGroupRcallTime         :Word;          //0x10C        //그룹 재요청
    m_boAllowGroupReCall      :Boolean;       //0x10E        //천지합일
    m_QuestUnitOpen           :TQuestUnit;    //0x10F
    m_QuestUnit               :TQuestUnit;    //0x11C
    m_QuestFlag               :TQuestFlag;    //0x128 129

    m_MissionFlag             :TMissionFlag;
    m_MissionInfo             :TMissionInfos;
    m_MissionArithmometer     :TMissionArithmometer;
    m_MissionIndex            :TMissionIndex;

    m_nCharStatusEx           :Integer;
    m_dwFightExp              :LongWord;      //0x194
    m_WAbil                   :TAbility;      //0x198
    m_AddAbil                 :TAddAbility;   //0x1C0
    m_nViewRange              :Integer;       //0x1E4
    m_wStatusTimeArr          :TStatusTime;   //각 상태의 남은 시간(초)표시
    m_btStatusValue           :array [0..MAX_STATUS_ATTRIBUTE -1] of byte;  //상태의 능력치 추가
    m_dwStatusArrTick         :array [0..MAX_STATUS_ATTRIBUTE -1] of LongWord; //상태의 시간 체크
    m_wStatusArrValue         :array [0..120] of Word; //0x218     // 범위 때에 따라 증가 해줘야함   버프
    m_wStatusArrFlag          :array [0..120] of byte;
    m_dwStatusArrTimeOutTick  :array [0..120] of LongWord; // :Tarry220;           //0x220
    ExtraAbil: array[0..EXTRAABIL_SIZE-1] of byte;  //상승 능력치 값
    ExtraAbilFlag: array[0..EXTRAABIL_SIZE-1] of byte; //플래그(Byte)
    ExtraAbilTimes: array[0..EXTRAABIL_SIZE-1] of Longword; //일정시간동안, 파괴,마력,도력,공속,체력,마력 상승
    m_wAppr                   :Word;         //0x238
    m_btRaceServer            :Word;         //0x23A     //몹레이스
    m_btRaceImg               :Word;         //0x23B
    m_btHitPoint              :Byte;         //0x23C    //명중력, 무공에 의해서 계산된다.
    m_nHitPlus                :ShortInt;      //0x23D     //전사의 무공의 파워가 업됨.. (1/3으로 고정)
    m_nHitDouble              :ShortInt;      //0x23E      //10 = +100% 25는 +250%
    m_dwGroupRcallTick        :LongWord;     //0x240
    m_boRecallSuite           :Boolean;      //0x244
    m_boTestGa                :Boolean;      //0x246
    m_boGsa                   :Boolean;      //0x247
    m_nHealthRecover          :ShortInt;        //0x248
    m_nSpellRecover           :ShortInt;        //0x249
    m_btAntiPoison            :Byte;         //0x24A
    m_nPoisonRecover          :ShortInt;     //0x24B
    m_nAntiMagic              :ShortInt;     //0x24C
    m_nLuck                   :Integer;      //0x250
    m_nPoisonIncrease         :Integer;
    m_nFreezingIncrease       :Integer;
    m_nPerHealth              :Integer;      //0x254
    m_nPerHealing             :Integer;      //0x258
    m_nPerSpell               :Integer;      //0x25C

    m_dwIncHealthSpellTick    :LongWord;     //0x260
    m_btGreenPoisoningPoint   :Byte;         //0x264
    m_btThunderPower          :Integer;
    m_btThunderWavePoint      :Byte;
    m_boSunchunUse            :Boolean;
    HemorrhageLevel           :integer;  //혈풍격의 중독
    ThunderLevel              :integer;
    m_nGoldMax                :Integer;      //0x268
    m_btSpeedPoint            :Byte;         //0x26C
    m_btPermission            :Byte;         //0x26D
    m_btColumn                :Byte;         //홍보단
    m_nHitSpeed               :ShortInt;     //0x26E  //1-18
    m_btLifeAttrib            :Byte;         //0x26F
    m_btCoolEye               :Byte;         //0x270
    m_Slave                   :TBaseObject;    //0x274   //소환몹
    m_GroupOwner              :TBaseObject;    //0x274
    m_GroupMembers            :TStringList;  //0x278       //그룹
    m_boHearWhisper           :Boolean;      //0x27C
    m_boBanShout              :Boolean;      //0x27D
    m_boBanStoreShout         :Boolean;      //0x27D
    m_boBanGuildChat          :Boolean;      //0x27E
    m_boBanGroupChat          :Boolean;      //0x27E
    m_boBanSysMsg             :Boolean;      //0x27E
    m_boHearMsg               :Boolean;
    m_boAllowRental           :Boolean;      //대여
    m_boAllowDeal             :Boolean;      //0x27F
    m_BlockWhisperList        :TStringList;  //0x280
    m_dwShoutMsgTick          :LongWord;     //외치기 딜레이
    m_dwMacroMsgTick          :LongWord;     //매크로 딜레이
    m_Master                  :TBaseObject;    //0x288
    m_dwMasterRoyaltyTick     :LongWord;     //0x28C
    m_dwMasterTick            :LongWord;      //0x290
      n294                    :Integer;      //0x294
    m_btSlaveExpLevel         :Byte;         //0x298   1-7
    m_btSlaveMakeLevel        :Byte;         //0x299
    m_SlaveList               :TList;        //0x29C
    m_PetList                 :TList;        //영물

    m_boSlaveRelax            :Boolean;      //0x2A0
    m_btAttatckMode           :Byte;         //0x2A1
    m_btNameColor             :Byte;       //0x2A2
    m_nLight                  :Integer;    //0x2A4
    m_boGuildWarArea          :Boolean;    //0x2A8
    m_Castle                  :TObject;    //0x2AC
    BoCrimeforCastle                   :Boolean;    //0x2B0
    CrimeforCastleTime               :LongWord;   //0x2B4
    m_boSuperMan              :Boolean;    //0x2B8
      HoldPlace                   :Boolean;     //자리를 점유하고 있는지 여부
      bo2BA                   :Boolean;    //0x2BA
    m_boWarChack              :Boolean;
    m_boAnimal                :Boolean;    //0x2BB
    m_boNoItem                :Boolean;    //0x2BC
    m_boFixedHideMode         :Boolean;    //0x2BD
    m_boStickMode             :Boolean;    //0x2BE
      bo2BF                   :Boolean;    //0x2BF
    m_boNoAttackMode          :Boolean;    //0x2C0
    m_boNoTame                :Boolean;    //0x2C1
    m_NoPoison                :Boolean;
    m_boSkeleton              :Boolean;    //0x2C2
    m_nMeatQuality            :Integer;    //0x2C4
    m_nBodyLeathery           :Integer;    //0x2C8
    m_boHolySeize             :Boolean;    //0x2CC    //결계
    m_dwHolySeizeTick         :LongWord;     //0x2D0
    m_dwHolySeizeInterval     :LongWord;     //0x2D4

    m_boPobakSeize            :Boolean;    //포박술
    m_dwPobakSeizeTick        :LongWord;
    m_dwPobakSeizeInterval    :LongWord;

    m_boCrazyMode             :Boolean;      //0x2D8
    m_dwCrazyModeTick         :LongWord;     //0x2DC
    m_dwCrazyModeInterval     :LongWord;     //0x2E0
    m_boHallucMode            :Boolean;      //Hallucination
    m_dwHallucModeTick        :LongWord;
    m_dwHallucModeInterval    :LongWord;
    
    m_boShowHP                :Boolean;      //0x2E4

    m_dwShowHPTick            :LongWord;     //0x2E8
    m_dwShowHPInterval        :LongWord;     //0x2EC
      bo2F0                   :Boolean;      //0x2F0
    m_dwDupObjTick            :LongWord;     //0x2F4
    m_PEnvir                  :TEnvirnoment; //0x2F8
    m_boGhost                 :Boolean;    //0x2FC
    m_dwGhostTick             :LongWord;   //0x300
    m_boDeath                 :Boolean;    //0x304
    m_boDropDurg              :Boolean;    //환템 드랍 방지
    m_boAliveMsg              :Boolean; //소생 여부 메시지
    m_dwDeathTick             :LongWord;   //0x308
  //  m_btMonsterWeapon         :Byte;       //0x30C
    m_dwStruckTick            :LongWord;   //0x310
    m_boWantRefMsg            :Boolean;    //0x314
    m_boAddtoMapSuccess       :Boolean;    //0x315
    m_bo316                   :Boolean;    //0x316

    m_boRentaling             :Boolean;    //대여
    m_RentalLastTick          :LongWord;    //대여
    m_RentalCreat             :TBaseObject;   //대여

    m_boDealing               :Boolean;    //0x31
    m_DealLastTick            :LongWord;   //0x318
    m_DealCreat               :TBaseObject;  //0x31C
    m_boDealGT                :Boolean;
    m_MyGuild                 :TOBject;    //0x320
    m_nGuildRankNo            :Integer;    //0x324
    m_sGuildRankName          :String;     //0x328
    m_sScriptLable            :String;     //0x32C
    m_btAttackSkillCount      :Byte;
    m_btAttackSkillPointCount :Byte;         //0x330
    m_btAssassinHitCount      :Byte;
    m_btAssassinHitPointCount :Byte;
    m_btManaEaterCount        :Byte;
    m_btManaEaterPointCount   :Byte;
    m_btHemorrhageCount       :Byte;
    m_btHemorrhagePointCount  :Byte;
      bt331                   :Byte;
      bt332                   :Byte;
      bt333                   :Byte;
      //0x334
      bo335                   :Boolean;    //0x335
      bo336                   :Boolean;    //0x336
      bo337                   :Boolean;    //0x337
    m_boMission               :Boolean;    //0x338
    m_nMissionX               :Integer;    //0x33C
    m_nMissionY               :Integer;    //0x340
    nPowerDefen, nPowerDefen2               :Integer;
    nPowerMagDefen, nPowerMagDefen2            :Integer;
    m_boPenetrateMode         :Boolean;
    m_boYeongMu               :Boolean;    //월영무
    m_PenetrateLastTick       :LongWord;
    m_boHideMode              :Boolean;    //월영술
    m_boStoneMode             :Boolean;    //0x345
    m_boCoolEye               :Boolean;    //BoViewFixedHide 은신을 볼 확률
    m_boUserUnLockDurg        :Boolean;    //미지수
    m_boTransparent           :Boolean;    //BoFixedHideMode
    m_boAdminMode             :Boolean;    //0x349
    m_boObMode                :Boolean;    //0x34A   //감시자
    m_boTeleport              :Boolean;    //0x34B
    m_boParalysis             :Boolean;    //0x34C
    m_boAllParalysis          :Boolean;
    m_boUnParalysis           :Boolean;
    m_boRevival               :Boolean;    //0x34D
    m_boUnRevival             :Boolean;
      bo34E                   :boolean;
      bo34F                   :Boolean;
    m_dwRevivalTick           :LongWord;   //0x350
    m_boFlameRing             :Boolean;    //0x354
    m_boRecoveryRing          :Boolean;    //0x355
    m_boMagicShield           :Boolean;    //0x357
    m_boUnMagicShield         :Boolean;
    m_boMuscleRing            :Boolean;    //0x358
    m_boFastTrain             :Boolean;    //0x359
    m_boFastTrain2            :Boolean;    //수련의물약
    m_boCounterAttack         :Boolean;     //영정갑주 반격

    m_nPowerRate7             :integer;
    m_nKillMonExpRate11       :Integer;

    m_boProbeNecklace         :Boolean;    //0x35A
    m_boGuildMove             :Boolean;
    m_boSupermanItem          :Boolean;
    m_bopirit                 :Boolean;

    m_boNoDropBagItem         :Boolean;
    m_boNoDropUseItem         :Boolean;
    m_boExpItem               :Boolean;
    m_boPowerItem             :Boolean;

    m_rExpItem                :Real;
    m_rPowerItem              :Real;
    m_dwPKDieLostExp          :LongWord;   //PK 
    m_nPKDieLostLevel         :Integer;    //PK

    m_boAbilSeeHealGauge      :Boolean;    //0x35B
    m_boAbilMagBubbleDefence  :Boolean;    //주술의막
    m_boAbilMagProtectDefence  :Boolean;
    m_btMagBubbleDefenceLevel :Byte;
    m_btMagProtectDefenceLevel :Byte;
    m_boAbilMagicUp           :Boolean; //심연술
    m_btMagicUpLevel          :Byte; //심연술
    m_boAbilCelestialDefence  :Boolean;    //선천기공
    m_btCelestialDefenceLevel :Byte;       //0x35D
    m_boAbilMagKumGangDefence :Boolean;    //금강불괴
    m_btMagKumGangDefenceLevel:Byte;
    m_dwSearchTime            :LongWord;   //0x360
    m_dwSearchTick            :LongWord;   //0x364
    m_dwRunTick               :LongWord;   //0x368
    m_nRunTime                :Integer;    //0x36C
    m_nHealthTick             :Integer;    //0x370
    m_nSpellTick              :Integer;    //0x374
    m_TargetCret              :TBaseObject;  //0x378
    m_dwTargetFocusTick       :LongWord;   //0x37C
    m_LastHiter               :TBaseObject;  //0x380
    BoDontMove  : Boolean;
    m_LastHiterTick           :LongWord;   //0x384
    m_ExpHitter               :TBaseObject;  //0x388
    m_ExpHitterTick           :LongWord;   //0x38C
    m_dwTeleportTick          :LongWord;   //0x390
    LatestSpaceScrollTime     :longword;  //공성중 내성 도약서
    m_dwProbeTick             :LongWord;   //0x394
    m_dwMapMoveTick           :LongWord;   //0x398
    m_dwMapMoveTick2          :LongWord;
    m_boPKFlag                :Boolean;    //0x39C
    MasterFeature : Longint; // 주인의 모습
    ForceMoveToMaster : boolean;
    m_dwPKTick                :LongWord;   //0x3A0
    m_nHongMoSuite            :Integer;    //0x3A8
    m_n3AC                    :Integer;    //0x3AC
    m_db3B0                   :Double;     //0x3B0
    SuckupEnemyHealthRate     :integer;    //이 % 만큼 상대의 체력을 빼앗아 옴
    SuckupEnemyHealth         :Real;       //상대의 체력을 빼앗아 옴

    SuckupEnemyManaRate       :integer;    //이 % 만큼 상대의 마력을 빼앗아 옴
    SuckupEnemyMana           :Real;       //상대의 마력을 빼앗아 옴

    BoDisapear  : Boolean;
    m_dwPoisoningTick         :LongWord;   //0x3B8
    m_dwHemorrHageTick        :LongWord;
    m_dwOhaengTick            :LongWord;
    m_dwDecPkPointTick        :LongWord;   //0x3BC
    m_DecLightItemDrugTick    :LongWord;   //0x3C0
    m_dwVerifyTick            :LongWord;   //0x3C4
    m_dwCheckRoyaltyTick      :LongWord;   //0x3C8

    m_dwCheckStatiey          :LongWord;   //0x3C8
    m_btAiMode                :Byte;
    m_boHeroCall: Boolean;
    m_boHeroBackCall : Boolean;
    m_dwCallTargetTick: LongWord;
    m_dwHPMPTick              :LongWord;   //0x3D0
    m_MsgList                 :TList;      //0x3D4
    m_VisibleHumanList        :TList;      //0x3D8
    m_VisibleItems            :TList;      //0x3DC
    m_VisibleEvents           :TList;      //0x3E0
    m_SendRefMsgTick          :LongWord;   //0x3E4
    m_boInFreePKArea          :Boolean;    //0x3E8
      LIst_3EC                :TList;      //0x3EC
      dwTick3F0               :LongWord;   //0x3F0
      dwTick3F4               :LongWord;   //0x3F4
    m_dwHitTick               :Integer;   //0x3F8
    m_dwWalkTick              :Integer;   //0x3FC
    m_dwSearchEnemyTick       :LongWord;   //0x400
    m_boNameColorChanged      :Boolean;    //0x404
    m_boIsVisibleActive       :Boolean;
    RefObjCount : integer;  // 이 Object을 시야내에 두고 있는 Object의 숫자, 0 이상일때 AI 작동

    m_nProcessRunCount        :ShortInt;
    m_VisibleActors           :TList;      //0x408
    m_AutoItem: TList;
    m_ItemList                :TList;      //0x40C
    m_DealItemList            :TList;      //0x410
    m_RentalItemList          :TList;      //대여

    m_nRentalDay              :Integer;    //대여 기간
    m_nRentalGolds            :Integer;    //대여 금전
    m_boRentalOK              :Boolean;    //0x418

    m_nDealGolds              :Integer;    //0x414
    m_boDealOK                :Boolean;    //0x418
    m_nExGolds                :Integer;    //환전
    m_nExGameGolds            :Integer;    //환전

    m_nCGolds                :Integer;    //환전
    m_nCGameGolds            :Integer;    //환전

    m_MagicList               :TList;      //0x41C
    m_UseItems                :THumanUseItems;  //0x420  + D8 -> 4F8
    m_SayMsgList              :TList;
    m_StorageItemList         :TList;      //0x4F8
    m_nWalkSpeed              :Integer;   //0x4FC
    m_nWalkStep               :Integer;    //0x500
    m_nWalkCount              :Integer;    //0x504
    m_dwWalkWait              :LongWord;   //0x508
    m_dwWalkWaitTick          :LongWord;   //0x50C
    m_boWalkWaitLocked        :Boolean;    //0x510
    m_nNextHitTime            :Integer;    //0x514
    m_MagicOneSwordSkill      :pTUserMagic;    //0x518 //외수검법
    m_MagicPowerHitSkill      :pTUserMagic;    //0x51C
    m_AssassinHitSkill        :pTUserMagic;        //절명검법
    m_MagicHemorrhageSkill    :pTUserMagic;        //혈풍격
    m_MagicGukCheSkill        :pTUserMagic;        //격체전공
    m_MagicWindbladeSkill     :pTUserMagic;    //0x524   //풍검술
    m_MagicErgumSkill         :pTUserMagic;    //0x520
    m_MagicTaguSkill          :pTUserMagic;    //타구봉법 - 승려
    m_MagicBanwolSkill        :pTUserMagic;    //0x524
    m_MagicFireSwordSkill     :pTUserMagic;    //0x528
    m_MagicDeathSwordSkill    :pTUserMagic;   //살생도
    m_MagicNanCrsSkill        :pTUserMagic;  //난화혈풍참
    m_MagicCrsSkill           :pTUserMagic;
    m_MagicCrsBongskill       :pTUserMagic;
    m_MagicTwnHitSkill        :pTUserMagic;    //0x528  //쌍룡참
    m_MagicThunderShaolin     :pTUserMagic;   //뇌룡봉법
    m_MagicFireShaolin        :pTUserMagic;   //천화봉법
    m_MagicVampSkill          :PTUserMagic;         //흡기
    m_MagicChunMuSkill        :pTUserMagic;
    m_boPowerHit              :Boolean;
    m_boUseGodShield          :Boolean;       //나한기공
    m_boEmbrace               :Boolean;
    m_boAssassinHit           :Boolean;  //0x52C
    m_boManaEater             :Boolean;
     m_boHemorrhage           :Boolean;
    m_boUseWindblade          :Boolean;     //0x52E  //풍검술
    m_boUseThrusting          :Boolean;     //0x52D
    m_boUseTagu               :Boolean;
    m_boUseHalfMoon           :Boolean;     //0x52E
    m_boUseVamp               :Boolean;     //0x52E      //흡기
    m_boFireHitSkill          :Boolean;     //0x52F
    m_boDeathHitSkill         :Boolean;
    m_boCrsHitkill            :Boolean;
    m_boNanCrsHitkill         :Boolean;
    m_boCrsBongHitkill        :Boolean;
    m_bo41kill                :Boolean;
    m_boChunMuSkill           :integer;
    m_boTwinHitSkill          :integer;      //쌍룡참
    m_boThunderHitSkill       :integer;
    m_boFireShaolinSkill      :integer;
    m_bo43kill                :Boolean;
    m_dwLatestFireHitTick     :LongWord;    //0x530
    m_dwLatestDeathHitTick    :LongWord;
    m_dwDoMotaeboTick         :LongWord;    //0x534
    m_dwSonicWaveTick         :LongWord;
    m_dwLatestTwinHitTick     :LongWord;
    m_dwLatestThHitTick       :LongWord;
    m_dwLatestFireShTick      :LongWord;
    m_dwLatestBaldoHitTick    :LongWord;
    m_boDenyRefStatus         :Boolean;
    m_boAddToMaped            :Boolean;
    m_boDelFormMaped          :Boolean;
    m_boFastParalysis         :Boolean;
    m_boNastyMode             :Boolean;
    m_boCanLooseDura          :Boolean;
    m_boHighLevelEffect       :Boolean;  //레벨50 이팩트

    m_boOhaeng                :Boolean; //음양오행진

    m_HumLevelEffectTick      :LongWord;  //이팩트 틱 카운트
    MeltArea : integer;
    BodyState: integer;  //몸의 상태
    PushedCount: integer;

    BoLoseTargetMoment : Boolean;   //잠시 목표를 잃음(sonmg)

    M_StorageItemstr          :TStringList;    //여관
    M_StorageItemTick         :LongWord;       //여관
    M_StorageItemboot         :Boolean;        //여관

    m_boStore: Boolean;     //개인상점
    m_StoreItemList: TList;   //개인상점

    //타겟 레벨에 따른 경험치 적용
      MultiplyTargetLevelMin : integer;
      MultiplyTargetLevelMax : integer;

    m_nHeroGrade: Byte;
    m_btHeroAutoDurg :Byte;
    m_sMasterName: string[ACTORNAMELEN];
    m_btLimitLevel: Byte;
  private

    function  GetGuldLevelExp(nLevel: Integer): Integer;  //문파성장
    function  InSafeArea: Boolean;

    function  Walk(nIdent:Integer): Boolean;
    function  AddToMap():Boolean;
    procedure UseLamp();
    procedure CheckPKStatus();

    procedure UpdateVisibleEvent(wX,wY:Integer;MapEvent:TObject);
    procedure GetAccessory(UserItem:TUserItem;var AddAbility:TAddAbility);


    procedure DecPKPoint(nPoint:Integer);

    function  GetNamecolor: Byte;
    procedure LeaveGroup();
    procedure DelMember(BaseObject:TBaseObject);
    procedure HearMsg(sMsg:String);
  public
    constructor Create();
    destructor Destroy; override;
    function  GetLevelExp(nLevel: Integer): LongWord;
     procedure UpdateVisibleGay(BaseObject:TBaseObject);virtual;
     procedure UpdateVisibleItem(wX,wY:Integer;MapItem:PTMapItem);
    procedure SendMsg(BaseObject:TBaseObject;wIdent,wParam:Word;nParam1,nParam2,nParam3:Integer;sMsg:String);
    procedure DelaySendMsg(BaseObject:TBaseObject;wIdent,wParam:Word;nParam1,nParam2,nParam3:Integer;sMsg:String;dwDelay:LongWord);
    procedure SendDefMsg(BaseObject: TBaseObject; wIdent: Word; Recog: Integer; Param, tag, Series: Word; sMsg: string);
    procedure SendDefSocket(BaseObject: TBaseObject; wIdent: Word; Recog: Integer; Param, tag, Series: Word; sMsg: string);
    procedure SendDelayRefMsg(wIdent,wParam:Word;nParam1,nParam2,nParam3:Integer;sMsg:String;dwDelay:LongWord);
    procedure SendFirstMsg(BaseObject:TBaseObject;wIdent,wParam:Word;lParam1,lParam2,lParam3:Integer;sMsg:String);
    procedure SendDelayMsg(BaseObject:TBaseObject;wIdent,wParam:Word;lParam1,lParam2,lParam3:Integer;sMsg:String;dwDelay:LongWord);  virtual;
    procedure SendRefMsg(wIdent,wParam:Word;nParam1,nParam2,nParam3:Integer;sMsg:String);
    procedure SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1,lParam2, lParam3: Integer; sMsg: String); virtual;
    procedure SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: String; dwDelay: LongWord);  virtual;
    procedure SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: String);
    procedure SendAttackMsg(wIdent:Word;btDir:Byte;nX,nY:Integer);
    procedure SysMsg(sMsg:String;MsgColor:TMsgColor;MsgType:TMsgType);
    procedure MoveMsg(sMsg: string);    //화면공지
    procedure SendGroupText(sMsg:String);
    procedure MonsterSayMsg(AttackBaseObject:TBaseObject;MonStatus:TMonStatus);
    function  IsVisibleHuman():Boolean;
    procedure RecalcLevelAbilitys; virtual;
    procedure RecalcHitSpeed(); virtual;
    procedure DoDamageWeapon(nWeaponDamage:Integer);
    function GetFeatureEx: Word;
    function GetObjectMark(): Byte;    //문파 마크
    function  RecalcBagWeight():Integer;
    function  GetCharColor(BaseObject:TBaseObject):Byte;
    procedure GetObjectEffect();     //기퍼짐
    procedure GetObjectEventEffect();     //빼빼로
    function  PKLevel():Integer;
    function  InStartZone():Boolean;  //안전지대
    function  InSafeZone():Boolean;OverLoad;
    function  InSafeZone(Envir:TEnvirnoment;nX,nY:Integer):Boolean;OverLoad;
    procedure OpenHolySeizeMode(dwInterval:LongWord);    //걸계
    procedure OpenPobakSeizeMode(dwInterval:LongWord); //포박술
    procedure BreakHolySeizeMode;
    procedure BreakPobakSeizeMode;
    procedure OpenCrazyMode(nTime:Integer);
    procedure BreakCrazyMode();
    procedure OpenHallucMode(nTime:Integer);
    procedure BreakHallucMode();
    procedure HealthSpellChanged();
    function  _Attack(var wHitMode:Word;AttackTarget:TBaseObject):Boolean;
    function  GetHitStruckDamage(Target:TBaseObject;nDamage:integer):Integer;
    procedure HasLevelUp(nLevel: Integer); virtual;
    procedure HasLevelUp2(nLevel: Integer); //등선변환
    procedure HasLevelUp3(nLevel: Integer); //보너스포인트
    procedure HasLevelUpGuild(nLevel: Integer);  //문파성장
    procedure GoldChanged();
    function CanAttack(BaseObject: TBaseObject; nRange: Integer; var btDir: Byte): Boolean; overload;
    procedure AttackDir(TargeTBaseObject:TBaseObject;wHitMode:Word;nDir:Integer);virtual;
    procedure PointChanged();
    function  IncGold(tGold:Integer):Boolean;
    function  DecGold(nGold:Integer):Boolean;

    procedure GameGoldChanged;
    procedure BoxMsg(sMsg:String; mode: integer);
    function  CanMove: Boolean; //0051633C
    function  GetHitSpeed: Integer;
    function  GetWalkSpeed: Integer;


    function  AllowFireHitSkill():Boolean;    //염화결
    function  AllowTwinHitSkill():Boolean;
    procedure HalfMoonOnOff(boSwitch: Boolean);
    procedure ThrustingOnOff(boSwitch:Boolean);
    procedure SkillNanCrsOnOff(boSwitch: Boolean);   //난화혈풍참
    procedure DamageSpell(nSpellPoint:Integer);
    function  CretInNearXY(TargeTBaseObject:TBaseObject;nX,nY:Integer):Boolean;

      function  GetGuildRelation (cert1:TBaseObject; cert2:TBaseObject):Integer;
      function  IsGoodKilling(cert:TBaseObject):Boolean;
      procedure IncPkPoint(nPoint:Integer);
      function IncKillPoint(point : integer; onlyFameCur : Boolean = FALSE) : Boolean; //킬/데스
      function IncDeathPoint(point : integer; onlyFameCur : Boolean = FALSE) : Boolean;     //킬/데스
      procedure ZeroFamePoint;    //킬/데스 초기화
      function  UseCurrentFamePoint(usepoint : integer) : Boolean;    //킬 점수 사용

      procedure AddBodyLuck(dLuck:Double);
      procedure MakeWeaponUnlock();        //저주 표시
      procedure ScatterGolds(GoldOfCreat:TBaseObject);
      function  DropGoldDown (nGold:Integer;boFalg:Boolean;GoldOfCreat,DropGoldCreat:TBaseObject):Boolean;
      function  DropItemDown(UserItem: pTUserItem; nScatterRange:Integer;boDieDrop:Boolean;ItemOfCreat,DropCreat:TBaseObject): Boolean;virtual;
      procedure DamageHealth(nDamage:Integer);
      procedure IncHealth(nPlus:Integer);
      function  GetAttackPower(nBasePower, nPower: Integer): Integer;
      procedure  HitHit2 (target: TBaseObject; hitpwr, magpwr: integer; all: Boolean);
      procedure  HitHitEx2 (target: TBaseObject; rmmsg, hitpwr, magpwr: integer; all: Boolean);
      function  CharPushed(nDir,nPushCount:Integer): Integer;
      function  CharDrawingRush (ndir, rushlevel: integer ; isHumanSkill : Boolean): Boolean;  //끌어당김
      function  GetDropPosition (nOrgX,nOrgY,nRange:Integer;var nDX:Integer;var nDY:Integer):Boolean;
      function  GetBackDir(nDir: integer): Integer;
      function  GetMapBaseObjects (tEnvir:TEnvirnoment;nX,nY:Integer;nRage:Integer;rList:TList):Boolean;
      function  GetObliqueMapBaseObjects (penv: TEnvirnoment; x, y, area, dir: integer; rlist: TList): Boolean;
      function  MagPassThroughMagic(sx, sy, tx, ty, ndir, magpwr: integer;
        undeadattack: Boolean): integer;
      function  MagPassThroughMagic2(sx, sy, tx, ty, ndir, magpwr: integer;
        undeadattack: Boolean): integer;
      function  MagPassThroughMagic3(sx, sy, tx, ty, ndir, magpwr: integer;    //맹독검기
        undeadattack: Boolean): integer;

      function  MagPosionThroughMagic(sx, sy, tx, ty, ndir, magpwr: integer;  //몹 공격하는 것
        undeadattack: Boolean; mode: integer): integer;

      function  MagPassIlSum(sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer;    //일섬
      function  MagMaPassIlSum(sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer;    //마혈광섬
      procedure KickException;
      function  GetMagStruckDamage(BaseObject:TBaseObject;nDamage:Integer):Integer;virtual;
      procedure DamageBubbleDefence(nInt:Integer);
      procedure DamageProtectDefence(nInt:Integer);
      procedure DamageCelestialDefence(nInt:Integer);
      procedure BreakOpenHealth;
      function  GetCharStatus: UINT;
      procedure MakeOpenHealth;
      procedure IncHealthSpell(nHP, nMP: Integer);
      procedure ItemDamageRevivalRing;
      procedure GainExp(dwExp: LongWord); virtual;
      procedure GetExp(dwExp: LongWord); virtual;
      procedure WinExp(dwExp: LongWord); virtual;
      function  CalcGetExp(nLevel: Integer;nExp:Integer): Integer;
      procedure GainSlaveExp(nLevel: Integer);
      procedure MapRandomMove(sMapName:String;nInt:Integer);
      procedure NoMapRandomMove(sMapName:String;nInt:Integer);
      procedure TurnTo(nDir:integer);
      procedure TurnToPet(nDir:integer);
      procedure FeatureChanged();
      function  GetFeatureToLong():Integer;
      function  GetPoseCreate():TBaseObject;
      function  GetFeature(BaseObject: TBaseObject):Integer;
      function GetAddStatus(): Integer;     //문파 마크
      function GetAddStatus2(): Integer;     //빼빼로 이팩트
      function  IsGroupMember(target: TBaseObject): Boolean;
      function  IsSlave(target: TBaseObject): Boolean;
      procedure AbilCopyToWAbil();
    procedure ChangePKStatus(boWarFlag: Boolean);
    procedure StruckDamage(var nDamage:integer);virtual;
    function  sub_4C4CD4(sItemName:String;var nCount:Integer):pTUserItem;
    procedure StatusChanged;
    function  GeTBaseObjectInfo():String;
    function  GetDirBaseObjectsCount(btDir, nRage: Integer): Integer;
    procedure TrainSkill(UserMagic:pTUserMagic;nTranPoint:Integer);
    function  CheckMagicLevelup(UserMagic:pTUserMagic):Boolean;
    function  MagCanHitTarget(nX,nY:Integer;TargeTBaseObject:TBaseObject):Boolean;virtual;
    procedure CheckMagicSpecialAbility(Magic: pTUserMagic);
    function  MagBubbleDefenceUp(nLevel,nSec:Integer):Boolean;        //주술의막
    function  MagProtectDefenceUp(nLevel,nSec:Integer):Boolean;       //호신강기
    function  CelestialDefenceUp(nLevel, nSec: Integer): Boolean;      //선천기공
    function  MagKumGangDefenceUp(nLevel,nSec,nDSec:Integer):Boolean;        //금강불괴
    function  WalkSpeedUp(nSec: Integer):Boolean;   //경신보
    function  BloodWaterUp(TargeTBaseObject:TBaseObject; nLevel, nSec: Integer): Boolean;      //혈룡수
    function  MagicUp(nPower, nSec: Integer):Boolean;         //심연술
    function  ThunderWave(nPower, nSec: Integer):Boolean;     //복호장
    function  BloodUp(nPower, nSec: Integer):Boolean;         //혈룡검법
    function  SkySword(nPower, nSec: Integer):Boolean;         //천상비술
    function  CatSword(nPower, nSec, nDel: Integer):Boolean;   //묘설란
    procedure ApplyMeatQuality();
    function  TakeBagItems(BaseObject:TBaseObject):Boolean;
    function  AddItemToBag(UserItem: PTUserItem;var boot:Boolean): Boolean; virtual;    //물약
    function  AddItemToBagCategories(UserItem: PTUserItem;var boot:Boolean): Boolean; virtual;  //물약
    function  DelBagItem(nIndex:Integer):Boolean;overload;
    function  DelBagItem(nItemIndex:Integer;sItemName:String):Boolean;overload;
    procedure WeightChanged();
    function  IsTrainingSkill(nIndex:Integer):Boolean;
    procedure SetQuestFlagStatus(nFlag:Integer;nValue:Integer);
    function  GetQuestFalgStatus(nFlag:integer):Integer;
    procedure SetQuestUnitOpenStatus(nFlag:Integer;nValue:Integer);
    function  GetQuestUnitOpenStatus(nFlag:integer):Integer;
    procedure SetQuestUnitStatus(nFlag:Integer;nValue:Integer);
    function  GetQuestUnitStatus(nFlag:integer):Integer;
    function GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean; overload;
    function GetAttackDir(BaseObject: TBaseObject; nRange: Integer; var btDir: Byte): Boolean; overload;
    function  TargetInSpitRange(BaseObject:TBaseObject;var btDir:Byte):Boolean;
    procedure MonsterRecalcAbilitys();
    procedure MonsterRecalcAbilitys2();
    procedure RefNameColor;
    procedure SetPKFlag(BaseObject:TBaseObject); virtual;
    procedure SetLastHiter(BaseObject:TBaseObject); virtual;
    function  EnterAnotherMap(Envir:TEnvirnoment;nDMapX,nDMapY:Integer):Boolean;
    function  sub_4DD704():Boolean;
    function  DefenceUp(nSec:Integer):Boolean;
    function  MagDefenceUp(nSec:Integer):Boolean;

    function  HeathRecoveryOhaeng(nSec,npoint:Integer):Boolean;   //음양오행진
    function  HeathRecoveryUp(nSec,npoint:Integer):Boolean;  //흡성대법
    function  SpellRecoveryUp(nSec,npoint:Integer):Boolean;  //강마진법

    function  MagProtectionField(nPower, nTime:Integer):Boolean;   //호신기막
    function  MagProtectionField5(nPower, nTime:Integer):Boolean;   //양용왕사라짐
    function  AttPowerUp(nPower, nTime: Integer): Boolean;
    function  MagicPowerUpWindMoon(nTime: Integer): Boolean;  //청풍명월
    function  MagicPowerUpBloodMoon(nTime: Integer): Boolean;  //적혈무영
    function  AttPowerDown(nPower, nTime: Integer): Boolean;
    function  MagRage(nPower, nTime: Integer): Boolean;   //첨기폭
    function  AttSpeedUp(nPower, nTime: Integer): Boolean; //체신풍
    function  DelayOhaeng(nTime: Integer): Boolean; //음양오행진
    function  SpeedUp(nPower, nTime: Integer): Boolean;  //풍신술
    function  MagSuraDefenceUp(nPower, nTime: Integer): Boolean;  //수라강림
    function  MagPenetrate(nPower, nTime: Integer): Boolean; //망자의눈
    function  ChenMuUp(nPower, nTime, nDelay: Integer): Boolean;  //천무
    function  SunChunJingiHPUP(nPower, nTime, nDelay: Integer): Boolean;    //선천진기 - 승려
    function  TempPowerUp(nAbil, nPower, nTime: Integer): Boolean;
    procedure RefShowName;
    function  MakeSlave(sMonName:String;nMakeLevel,nExpLevel,nMaxMob:Integer;dwRoyaltySec:LongWord):TBaseObject;
    function  MakeSlaveBonze(sMonName:String; nMakeLevel,dwRoyaltySec:Integer; targ: TBaseObject):TBaseObject;
    function NewMakeSlave (sname: string; slevel, max_slave, royaltysec: integer): TBaseObject;
    function DarkBodyMakeSlave (sname: string; slevel, royaltysec: integer; targ: TBaseObject): TBaseObject; //열화신
    function BonzeBodyMakeSlave (sname: string; slevel, royaltysec, no: integer): TBaseObject;  //은형술
    function  MakePosion(nType,nTime,nPoint:Integer):Boolean;
    function  GetFrontPosition(var nX: Integer; var nY: Integer):Boolean;virtual;
    function  GetFrontSecPosition(var nX: Integer; var nY: Integer):Boolean;virtual;
    function GetFrontPositionEx(var nX: Integer; var nY: Integer;n:byte = 3): Boolean;
    function GetRecallPosition(x, y, wide: integer; var dx, dy: integer): boolean;
    function  GetBackPosition(var nX:Integer;var nY:Integer):Boolean; overload;
    function  GetBackPosition(btDirection: Byte; var nX, nY: Integer): Boolean;  overload;
    function  GetBackPosition2(var nX:Integer;var nY:Integer):Boolean;
    function  RunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer):Boolean;
    function  WalkTo(btDir: Byte;boFlag:boolean): Boolean;
    function  PetWalkTo(btDir: Byte;boFlag:boolean): Boolean;
    function  DownWalkTo(btDir: Byte;boFlag:boolean): Boolean;  //월영술
    function  AssWalkTo(btDir: Byte;boFlag:boolean): Boolean; //열화신
    procedure  RandomSpaceMove (mname: string; mtype: integer);
    procedure  RandomSpaceMoveInRange (mtype, InRange, OutRange: integer);
    procedure SpaceMove(sMap: String; nX, nY: Integer; nInt:Integer);   //nomove작업
    procedure NoSpaceMove(sMap: String; nX, nY: Integer; nInt:Integer);
    procedure SpaceMagMove(nX, nY: Integer; nInt: Integer); //일섬
    procedure SpaceMaMagMove(nX, nY: Integer; nInt: Integer); //마혈광섬
    procedure SpaceGTMoveEX(sMap: String; nX, nY: Integer; nInt,GTNumber:Integer);//gt spacemoves
    function  sub_4C5370(nX, nY:Integer;nRange: Integer;var nDX, nDY:Integer):Boolean;
    function  CheckItems(sItemName:String):pTUserItem;
    function  MagMakeDefenceArea(nX,nY,nRange,nSec:Integer;btState:Byte):Integer;
    function  MagMakeAddDefenceArea(nX,nY,nRange,nSec,point:Integer;btState:Byte):Integer; //흡성대법 강마진법
    function  MagMakeCurseArea(xx, yy, range, sec ,pwr ,skilllevel: integer; BoMag: Boolean): integer;   //저주술1
    function MagBKWindCut (xx,yy,skilllevel, nPower: integer): Boolean;     //은형술
    procedure BWindCutHit (TargeTBaseObject: TBaseObject ; hitPwr ,magpwr: integer );
    function  MagChangePosition(nTargetX, nTargetY: Integer): Boolean;     //서우
    function  MagCheckBuff(): Boolean;     //견빙수호장
    function  MagBigPosion(xx, yy, range, sec ,pwr ,skilllevel: integer; BoMag: Boolean): Boolean;   //독무
    procedure  MagCurse(sec , pwrrate: integer);
    function  sub_4C3538():Integer;
    function  IsGuildMaster():Boolean;
    function  IsMyGuildMaster: Boolean;   //장원 외치기
    procedure LoadSayMsg();
    procedure DisappearA();
    function  GetShowName():String;virtual;
    procedure DropUseItems(BaseObject:TBaseObject; DieFromMob : Boolean); virtual;
    procedure ScatterBagItems(ItemOfCreat:TBaseObject); virtual;
    function  GetMessage(Msg:pTProcessMessage):Boolean;virtual; //FFFF
    procedure Initialize();virtual;//FFFE
    procedure Disappear();virtual;//FFFD
    function  Operate(ProcessMsg:pTProcessMessage):Boolean;virtual;//FFFC
    procedure SearchViewRange();virtual;//dynamic;
    procedure Run();virtual;//dynamic;//FFFB
    procedure ProcessSayMsg(sMsg:String); virtual;//FFFA
    procedure MakeGhost;virtual;
    procedure Die();virtual;//FFF9;
    procedure Alive; dynamic; //다시 살아나다.
    procedure ReAlive();virtual;//FFF8;
    procedure ReAliveMsg();virtual;//소생술
    procedure RecalcAbilitys();virtual; //FFF7
    function  IsProtectTarget(BaseObject:TBaseObject):Boolean; virtual; //FFF6
    function  IsAttackTarget(BaseObject:TBaseObject):Boolean; virtual; //FFF5
    function  IsProperTarget(BaseObject:TBaseObject):Boolean; virtual; //FFF4
    function  IsFriend(cret: TBaseObject): Boolean;
    function  IsProperFriend(BaseObject:TBaseObject):Boolean; virtual; //FFF3
    function  IsReincarnation(BaseObject: TBaseObject): Boolean; virtual;
    procedure SetTargetCreat(BaseObject:TBaseObject); virtual; //FFF2
    procedure DelTargetCreat(); virtual; //FFF1    //losetarget;

    function  MakePet(sMonName:String):TBaseObject; //영물
    procedure PetAbility(sMonName,sValues:String; mode:boolean);   //영물버프
    procedure RecallSlave(sSlaveName:String);
    function  SlaveCount(sSlaveName:String):Integer;

    procedure reloadmonitem();

    function   ExistAttackSlaves: Boolean; //공격중인 소환수가 있는지 검사
    function   GetExistSlave( MonName_ : string ):TBaseObject;

    function  GetMagicInfo(nMagicID:Integer):pTUserMagic;
    function  GetMagicRun(nMagicID: Integer): Boolean;
    procedure AddItemSkill(nIndex:Integer);
    procedure DelItemSkill(nIndex:Integer);
    function  CheckPrivateClean(): Boolean;
    function   UpgradeResultToStr( iSum: integer; strOpt: string; iBefore, iAfter: integer; fProb: double; iJewelStdMode: integer ):string;          //스쳐
    procedure WindbladeOnOff(boSwitch: Boolean);    //풍검술
    procedure AddMapCount;                 //관리자시스템
    procedure DelMapCount;                 //관리자시스템
    function MessageCount(): Integer;      //관리자시스템
  end;
  TAnimalObject =class(TBaseObject)
    m_nTargetX                    :Integer;    //0x538
    m_nTargetY                    :Integer;    //0x53C
    m_boRunAwayMode               :Boolean;    //0x540
    m_dwRunAwayStart              :LongWord;   //0x544
    m_dwRunAwayTime               :LongWord;    //0x548
  private

  public
    constructor Create();
    procedure SearchTarget();
    procedure sub_4C959C;
    function  Operate(ProcessMsg:pTProcessMessage):Boolean;override; //FFFC
    procedure Run;override;  //FFFB
    procedure DelTargetCreat();override;//FFF1
    procedure SetTargetXY(nX,nY:Integer);virtual; //FFF0
    procedure GotoTargetXY(); virtual; //0FFEF
    procedure GotoTargetAssXY(); virtual; //0FFEF
    procedure Wondering(); virtual; //0FFEE
    procedure Attack(TargeTBaseObject: TBaseObject; nDir: Integer);dynamic;//0FFED
    procedure Struck(Hiter: TBaseObject);dynamic; //FFEC

    procedure HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer;nMagPower:integer;boFlag:Boolean);
  end;

  TPetObject =class(TBaseObject)     //영물
    m_nTargetX                    :Integer;    //0x538
    m_nTargetY                    :Integer;    //0x53C
    m_boRunAwayMode               :Boolean;    //0x540
    m_dwRunAwayStart              :LongWord;   //0x544
    m_dwRunAwayTime               :LongWord;    //0x548
    m_boDupMode                   :Boolean;
    m_dwThinkTick                 :LongWord;    //0x548
  private
    function Think: Boolean;
  public
    constructor Create();
    destructor Destroy; override;
    function  Operate(ProcessMsg:pTProcessMessage):Boolean; override;//FFFC
    function StartPickUpItem(nRage:integer): Boolean; //픽업
    function MousePickUpItem(nRage,x,y:integer): Boolean; //픽업
    procedure Run; override;
    procedure Die; override;
    function GotoTargetXY():Boolean;
    procedure Wondering();
    function GetShowName: String; override;
  end;


  TPlayObject = class(TAnimalObject)
    m_DefMsg                  :TDefaultMessage;  //0x550
    m_sOldSayMsg              :String;     //0x560
    m_nSayMsgCount            :Integer;    //0x560
    m_dwSayMsgTick            :LongWord;   //0x568
    m_boDisableSayMsg         :Boolean;    //0x56C
    m_dwDisableSayMsgTick     :LongWord;   //0x570
    m_dwCheckDupObjTick       :LongWord;   //0x574
    m_dwThunderWaveTick       :LongWord;
      dwTick578               :LongWord;   //0x578
    m_boInSafeArea            :Boolean;    //0x580
    m_boInSafezone            :boolean;
      n584                    :Integer;    //0x584
      n588                    :Integer;    //0x584
    m_sUserID                 :string[11]; //0x58C
    m_sIPaddr                 :string;     //0x598
    m_sIPLocal                :String;
    m_nSocket                 :Integer;    //0x59C nSocket
    m_nGSocketIdx             :Integer;    //0x5A0 wGateIndex SOCKET ID
    m_nGateIdx                :Integer;    //0x5A8 nGateIdx
    m_nSoftVersionDate        :Integer;    //0x5AC
    m_dLogonTime              :TDateTime;  //0x5B0
    m_dwLogonTick             :LongWord;   //0x5B8
    m_dwLoginTick             :LongWord;
    n_sLoginCount             :Integer;
    m_boReadyRun              :Boolean;    //0x5BC
    m_nSessionID              :Integer;    //0x5C0
    m_nPayMent                :Integer;    //0x5C4
    m_nPayMode                :Integer;    //0x5C8
    m_SessInfo                :pTSessInfo;
    m_dwLoadTick              :LongWord;   //0x5CC
    m_nServerIndex            :Integer;    //0x5D0
    m_boEmergencyClose        :Boolean;    //0x5D4
    m_boSoftClose             :Boolean;    //0x5D5
    m_boKickFlag              :Boolean;    //0x5D6  (Byte)(@kick )
    m_boReconnection          :Boolean;    //0x5D7
    m_boRcdSaved              :Boolean;    //0x5D8
    m_boSwitchData            :Boolean;    //0x5D9
    m_nWriteChgDataErrCount   :Integer;    //0x5DC
    m_sSwitchMapName          :String;     //0x5E0
    m_nSwitchMapX             :Integer;    //0x5E4
    m_nSwitchMapY             :Integer;    //0x5E8
    m_boSwitchDataSended      :Boolean;    //0x5EC
    m_dwChgDataWritedTick     :LongWord;   //0x5F0
      m_dw5D4                 :LongWord;   //0x5F4
      n5FC                    :Integer;    //0x5FC

    m_dwMagicAttackTick       :LongWord;   //0x600
    m_dwMagicAttackInterval   :integer;   //0x604
    m_dwAttackTick            :LongWord;   //0x608
    m_dwAttackCount           :LongWord;   //0x610
    m_dwAttackCountA          :LongWord;   //0x614
    m_dwMagicAttackCount      :LongWord;   //0x618
    m_nOverSpeedCount         :Integer;   //0x624
    LatestWalkTime: longword;
    WalkTimeOverCount         :integer;
    WalkTimeOverSum           :integer;
    m_boDieInFight3Zone       :Boolean;    //0x628
    m_Script                  :pTScript;    //0x62C
    m_NPC                     :TBaseObject;   //0x630
    m_nVal                    :array[0..9] of Integer;     //0x634 - 658
    m_nMval                   :array[0..99] of Integer;
    m_DyVal                   :array[0..9] of Integer; //0x65C - 680

    //스피드핵
    m_dwRunTime               :LongWord;
    m_dwHitTime               :LongWord;
    m_dwMagicHitTime          :LongWord;
    m_boHitDelay              :Boolean;
    m_boMagicHitDelay         :Boolean;
    m_boRunDelay              :Boolean;

    m_nHitCount               :Integer;
    m_nMagicHitCount          :Integer;
    m_nRunCount               :Integer;

    m_sPlayDiceLabel          :String;
    m_boTimeRecall            :Boolean;   //0x684
    m_boTimeRecallGroup       :Boolean;   //0x684
    m_dwTimeRecallTick        :LongWord;  //0x688

    m_boCastleRecall          :Boolean;   //0x684
    m_dwCastleRecallTick      :LongWord;  //0x688

    m_sRankName               :string;
    m_nRankColor              :Integer;
    m_sMoveMap                :String;    //0x68C
    m_nMoveX                  :Integer;   //0x690
    m_nMoveY                  :Integer;   //0x694
      bo698                   :Boolean;   //0x698
      n69C                    :Integer;   //0x69C
    m_dwSaveRcdTick           :LongWord;  //0x6A0
    m_btBright                :Byte;
    m_boNewHuman              :Boolean;   //0x6A8
    m_boSendNotice            :Boolean;   //0x6A9
    m_dwWaitLoginNoticeOKTick :LongWord;
    m_boLoginNoticeOK         :Boolean;   //0x6AA
      bo6AB                   :Boolean;   //0x6AB
    m_boExpire                :Boolean;   //0x6AC
    m_dwShowLineNoticeTick    :LongWord;  //0x6B0
    m_nShowLineNoticeIdx      :Integer;   //0x6B4

    //m_AddUseItems             :array[9..12] of TUserItem;
    m_nSoftVersionDateEx      :Integer;
    m_CanJmpScriptLableList   :TStringList;
    m_nScriptGotoCount        :Integer;
    m_sScriptCurrLable        :String;
    m_sScriptGoBackLable      :String;
    m_wOldIdent               :Word;
    m_btOldDir                :Byte;

    m_boFirstAction           :Boolean;
    m_dwActionTick            :LongWord;

    m_dwLoveRecallTick        :LongWord;   //연인 스쳐 이동 딜

    m_btReLevel               :Byte;      //전직
    m_btReColorIdx            :Byte;
    m_dwReColorTick           :LongWord;
    m_nKillMonExpMultiple     :Integer;
    m_dwGetMsgTick            :LongWord;

    m_boSetStoragePwd         :Boolean;
    m_boReConfigPwd           :Boolean;
    m_boCheckOldPwd           :Boolean;
    m_boUnLockPwd             :Boolean;
    m_boUnLockStoragePwd      :Boolean;
    m_boPasswordLocked        :Boolean;
    m_btPwdFailCount          :Byte;
    m_boLockLogon             :Boolean;
    m_boLockLogoned           :Boolean;
    m_sTempPwd                :String[7];
    m_sSystemPwd              :String[7];
    m_sStoragePwd             :String[6];  //창고암호
    m_boStoragePwd            :Boolean;    //창고암호
    m_PoseBaseObject          :TBaseObject;
    m_boFilterSendMsg         :Boolean;
    m_nKillMonDropRate        :Integer;  //드롭율
    m_dwKillMonDropRateTime   :LongWord; //드롭율
    m_dwDropRateTick          :LongWord; //드롭율
    m_nKillMonExpRate         :Integer;
    m_nKillMonExpRate2        :Integer; //경험치 가산
  //  m_nKillMonExpRate3        :Integer; //검성 검후 경치
    m_nKillMonExpRate4        :Integer; //사제 경치
    m_nKillMonExpRate5        :Integer;  //초보문파 경험치
    m_nKillMonExpRate6        :Integer; //문파성장 경험치
    m_nKillMonExpRate7        :Integer; //gm 이벤트 경험치
    m_nKillMonExpRate8        :Integer;
    m_nKillMonExpRate9        :Integer;   //영웅
    m_nKillMonExpRate10       :Integer;   //그룹버프
    m_nPowerRate              :Integer;
    m_nPowerRate2             :Integer;   //천령수 공력
    m_nPowerRate3             :Integer;   //공력수 공력
    m_nPowerRate4             :Integer;   //문파성장 공력
    m_nPowerRate5             :Integer;   //영웅버프
    m_nPowerRate6             :Integer;   //그룹버프 공격력
    m_dwKillMonExpRateTime    :LongWord;
    m_dwKillMonExpRateTime2   :LongWord; //경험치 가산
    m_dwKillMonExpRateTime3   :LongWord; //검성 검후 경치
    m_dwKillMonExpRateTime4   :LongWord; //사제 경치
    m_dwKillMonExpRateTime5   :LongWord;
    m_dwKillMonExpRateTime8   :LongWord;  //솔플경치
    m_dwPowerRateTime         :LongWord;
    m_dwPowerRateTime2        :LongWord;  //천령수 공력
    m_dwPowerRateTime3        :LongWord;  //공력수 공력
    m_dwRateTick              :LongWord;
    m_dwRateTick2             :LongWord;  //경험치 가산
    m_dwRateTick3             :LongWord;  //검성 검후 경치
    m_dwRateTick4             :LongWord;  //사제 경치
    m_dwRateTick8             :LongWord;

    m_dwPowerRateTick         :LongWord;
    m_dwPowerRateTick2        :LongWord;  //천령수 공력
    m_dwPowerRateTick3        :LongWord;  //문파성장 공력

    m_boCanUseItem            :Boolean;
    m_boCanDeal               :Boolean;
    m_boCanRental             :Boolean;   //대여
    m_boCanDrop               :Boolean;
    m_boCanGetBackItem        :Boolean;
    m_boCanWalk               :Boolean;
    m_boCanRun                :Boolean;
    m_boCanHit                :Boolean;
    m_boCanSpell              :Boolean;
    m_boCanSendMsg            :Boolean;

    m_boSendMsgFlag           :Boolean;
    m_boSendMsgFlag1           :Boolean;
    m_boChangeItemNameFlag    :Boolean;

    m_nGameGold               :Integer;
    m_nBankGold               :Integer;
    m_boDecGameGold           :Boolean;
    m_dwDecGameGoldTime       :LongWord;
    m_dwDecGameGoldTick       :LongWord;
    m_nDecGameGold            :Integer;

    m_boIncGameGold           :Boolean;
    m_dwIncGameGoldTime       :LongWord;
    m_dwIncGameGoldTick       :LongWord;
    m_nIncGameGold            :Integer;

    m_nGamePoint              :Integer;
    m_dwIncGamePointTick      :LongWord;

    m_nPCPoint                :Integer;
    m_dwPCPointTick           :LongWord;

    m_dwDecHPTick             :LongWord;
    m_dwIncHPTick             :LongWord;

    m_GetWhisperHuman         :TPlayObject;

    m_sRankLevelName          :String;        //랭크네임
    m_boFilterAction          :Boolean;
    m_dwAutoGetExpTick        :LongWord;
    m_nAutoGetExpTime         :Integer;
    m_nAutoGetExpPoint        :Integer;
    m_AutoGetExpEnvir         :TEnvirnoment;
    m_boAutoGetExpInSafeZone  :Boolean;
    m_DynamicVarList          :TList;
    m_dwClientTick            :LongWord;
    m_boTestSpeedMode         :Boolean;
    m_fivegotick              :LongWord; //비광의탈 딜레이
    m_dwMassPoison            :LongWord; //독무 딜레이
    m_dwChunGong              :LongWord; //천공 딜레이
    m_WalkSpeedUpTick         :LongWord; //경신보 딜레이
    m_MagMakeShadowTick       :LongWord; //열화신 딜레이
    m_MagGreatWallTick        :LongWord;
    m_ChenMuUpTick            :LongWord; //천무 딜레이
    m_AbyssTick               :LongWord; //심연술 딜레이
    m_BloodSword              :LongWord; //혈룡검법 딜레이
    m_ThunderWave             :LongWord;
    m_ThunderClap             :LongWord;
    m_SkyTick                 :LongWord; //천상비술 딜레이
    m_CatSword                :LongWord; //묘설란 딜레이
    m_SpaceMove               :LongWord; //이형환위 딜레이
    m_Authenitcity            :LongWord; //진위보 딜레이
    m_Summon                  :LongWord; //격공섭물 딜레이
    m_SuperIce                :LongWord; //빙월격 딜레이
    m_Allfire                 :LongWord; //만천염옥 딜레이
    m_IceShok                 :LongWord; //빙뇌천 딜레이
    m_DontEatTick             :LongWord; //일격비 물약
    m_Penetrate               :LongWord; //망자의눈 딜레이
    m_KumGang                 :LongWord; //금강불괴 딜레이
    m_Roeseon                 :LongWord; //뢰선풍 딜레이
    m_Ohaeng                  :LongWord; //음양오행진 딜레이

    m_YeongMuTick             :LongWord; //월영무 딜레이
    m_Shadow                  :LongWord; //영적추 딜레이
    m_TigerHit                :LongWord; //백호강타 딜레이
    m_Kyo                     :LongWord; //교악 딜레이
    m_Singi                   :LongWord; //신기묘산 딜레이
    m_AllThunder              :LongWord; //운중뢰격 딜레이
    m_CLOUD                   :LongWord; //암독만계 딜레이
    m_JuckSalDel              :LongWord; //천인적살풍 딜레이
    m_Fahangbo                :LongWord; //파황보 딜레이
    nFahangboCount            :Byte; //파황보 카운트
    m_MagKangHo               :LongWord; //강호술 딜레이
    m_130Time                 :LongWord;
    m_132Time                 :LongWord;
    m_133Time                 :LongWord;
    m_134Time                 :LongWord;
    m_135Time                 :LongWord;
    m_137Time                 :LongWord;
    m_138Time                 :LongWord;
    m_139Time                 :LongWord;
    m_140Time                 :LongWord;
    m_141Time                 :LongWord;
    nRunCount:Integer;
    dwRunTimeCount:LongWord;
    m_dwDelayTime:LongWord;
    m_dwchecksafearea:dword;

    m_dwBBSDelayTime:LongWord;
    m_dwBBSPostDelay:LongWord;
    m_dwQueryBagItemsTick        :LongWord; //가방정리
    m_dwQueryFriendItemsTick     :LongWord;
    m_dwTigerTick                :LongWord;
    m_dwPickUpTick: LongWord;
    m_dwPickUpTick2: LongWord;
    g_boItemAuto            :integer;
    g_boItemAll             :integer;
    g_boItemGold            :integer;
    g_boItemWeapon          :integer;
    g_boItemDress           :integer;
    g_boItemHelmet          :integer;
    g_boItemBoots           :integer;
    g_boItemBelt            :integer;
    g_boItemAccessory       :integer;
    g_boItemEtc             :integer;

    m_nCheckMsgArr: array[TCheckMsgClass] of Byte;
    m_CheckMsgList: TList;

    m_boWaitHeroDate: Boolean;
    g_dwLastHeroTurnTick: LongWord;
    g_dwLastHeroMoveTick: LongWord;

    m_sTempHeroName: string[ACTORNAMELEN];
    m_sHeroCharName: string[ACTORNAMELEN]; //亶衿츰냔
    m_MyHero: TBaseObject;
    m_dwRecallHeroTick: LongWord;
  private
    function  ClientDropGold(nGold:Integer):Boolean;
    function  PlayGetPoseCreate: TPlayObject;
    procedure ClientQueryStorageItems(Idx:Integer);    //여관     //창고
    procedure ClientQueryUserState(PlayObject:TPlayObject;nX,nY:Integer);
    procedure ClientQueryGuildGrow(PlayObject:TPlayObject);  //문파성장
    procedure ClientQueryGuildGrow2(PlayObject:TPlayObject);  //문파성장
    function  ClientDropItem(sItemName:String;nItemIdx:Integer):Boolean;        //아이템 버림
    function  ClientPickUpItem: Boolean;
    procedure ClientOpenDoor(nX,nY:Integer);

    procedure ClientGetTopInfo(ProcessMsg: pTProcessMessage);
    procedure ClientGetRockPapers(ProcessMsg: pTProcessMessage);
    procedure ClientAlive(ProcessMsg: pTProcessMessage);

    procedure ClientaddBundleItems(mode,MaxAmount:integer;ItemIdx:String); //물약 겹치기 부분
    procedure ClientaddBundleStorageItems(mode,MaxAmount:integer;ItemIdx:String);
    procedure ClientUseItems(nItemIdx:Integer;sItemName:String);
    function  UseStdmodeFunItem(StdItem:TItem):Boolean;
    procedure ClientGetButchItem(BaseObject:TBaseObject;nX,nY,btDir:Integer);
    procedure ClientChangeMagicKey(nSkillIdx,nKey:integer);
    procedure ClientClickNPC(NPC:Integer);
    procedure ClientMerchantDlgSelect(nParam1: Integer;sMsg: String);
    procedure ClientMerchantQuerySellPrice(nParam1,nMakeIndex:Integer;sMsg: String);

    procedure ClientCompoundItem(ProcessMsg: pTProcessMessage);   //아이템합성

    procedure ClientUserSellItem(nParam1,nMakeIndex:Integer;sMsg: String);
    procedure ClientUserItemLock(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserItemWake(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserItemReStore(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserBuyItem(nIdent,nParam1,nInt,nZz,amins:Integer;sMsg: String);
    procedure ClientUserPBuyItem(nIdent,nParam1,nInt,nZz,amins:Integer;sMsg: String);
    procedure ClientQueryRepairCost(nParam1,nInt:Integer;sMsg: String);
    procedure ClientQueryWakeCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientQueryReStoreCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientRepairItem(nParam1,nInt:Integer;sMsg: String);
    procedure ClientCheckWeapon(nParam1,nInt:Integer;sMsg: String); //제련 확인
    procedure ClientTradeGT(nParam1:Integer);

    procedure ClientPriceDisassemble(nParam1,nMakeIndex:Integer;sMsg: String);   //각성분해
    procedure ClientDisassemble(nParam1,nMakeIndex:Integer;sMsg: String);        //각성분해

    procedure ClientWakeUpItem(mode,nMakeIndex:Integer);

    procedure ClientPriceDismantle(nParam1,nMakeIndex:Integer;sMsg: String);     //일반분해
    procedure ClientDismantle(nParam1,nMakeIndex:Integer;sMsg: String);          //일반분해

    {그룹}
    procedure ClientGroupClose();
    procedure ClientCreateGroup(ProcessMsg: pTProcessMessage);   //그룹 만들기
    procedure AddGroupMember(PlayObject: TPlayObject);
    procedure ClientAddGroupMember(sHumName:String);   //그룹원 추가
    procedure ClientDelGroupMember(sHumName:String);    //그룹원 삭제


    {대여}
    procedure ClientRentalTry(sHumName:String); //대여
    procedure ClientAddRentalItem(nItemIdx:integer;sItemName:String; nAmount,nDay:Integer); //대여
    procedure ClientDelRentalItem(nItemIdx:integer;sItemName:String);   //대여
    procedure ClientCancelRental();    //대여
    procedure ClientChangeRentalGold(nGold:Integer);      //대여
    procedure ClientRentalEnd();    //대여

    procedure ClientGetCheckMsg(ProcessMsg: pTProcessMessage);
    procedure ClientCheckMsg(tClass: TCheckMsgClass; AddPointer: Pointer; nSelect: Integer);

    procedure ClientDealTry(sHumName:String);
    procedure ClientAddDealItem(nItemIdx:integer;sItemName:String; nAmount:Integer);
    procedure ClientDelDealItem(nItemIdx:integer;sItemName:String);
    procedure ClientDelDealItem2(nItemIdx:integer;sItemName:String);
    procedure ClientCancelDeal();
    procedure ClientChangeDealGold(nGold:Integer);
    procedure ClientDealEnd();

    procedure ClientCancelStore;       //개인상점
    procedure ClientStartStore(sMsg: string; nItemCount: Integer);  //개인상점
    procedure ClientQueryUserStoreState(PlayObject: TPlayObject; nX, nY: Integer); //개인상점
    procedure ClientBuySroreItem(PlayObject: TPlayObject; sMsg: string);  //개인상점

    procedure ClientCancelEx();   //환전 취소
    procedure ClientChangeExGold(nGold:Integer);     //환전
    procedure ClientChangeExGameGold(nGold:Integer); //환전
    procedure ClientExEnd();   //환전 완료
    procedure ClientChangeExRate();     //환전 시세

    procedure ClientGetWakeUpItems(nItemIdx: Integer; mode: byte; sData: string);
    procedure ClientGetWakeUp(nItemIdx: Integer; mode: byte; sData: string);

    procedure ClientStorageItem(NPC:TObject;nItemIdx:Integer;sMsg:String; nMode:Integer);   //여관     //창고
    procedure ClientTakeBackStorageItem(NPC:TObject;nItemIdx:Integer;sMsg:String; nMode:Integer);     //여관       //창고
    procedure ClientStorageSetPassWord(PlayObject: TPlayObject; sMsg: string; Mode: Integer);     //창고암호
    procedure ClientCheckStoragePw(PlayObject: TPlayObject);       //창고암호

    procedure ClientGetStorage(PlayObject: TPlayObject);

    procedure ClientUpwaoinItem(NPC:TObject;nMakeIndex:Integer;sMsg:String);     //재련

    procedure AddAucItem(nItemIdx:Integer;sMsg:String); //경매


    procedure ConsignItem(nItemIdx:Integer;sMsg:String); //위탁 판매
    procedure ComStorageItem(NPC:TObject;nItemIdx{,Amount}:Integer); //공용창고
    procedure GuildStorageItem(NPC:TObject;nItemIdx{,Amount}:Integer); //문파창고

    procedure ServerGetMakeItemSel (npcid: TObject; itemname: string);     //제조스쳐
    procedure ServerGetMakeItem (npcid: TObject; itemname: string);        //제조스쳐

    procedure ClientOpenGuildDlg();
    procedure ClientGuildHome();
    procedure ClientGuildMemberList();
    procedure ClientGuildAddMember(sHumName:String);
    procedure ClientGuildDelMember(sHumName:String);
    procedure ClientGuildUpdateNotice(sNotict:String);
    procedure ClientGuildUpdateRankInfo(sRankInfo:String);
    procedure ClientGuildAlly();
    procedure ClientGuildBreakAlly(sGuildName:String);
    procedure ClientAdjustBonus(nPoint:Integer;sMsg:String);

    procedure ClientSendFriendsList(PlayObject:TPlayObject);
    procedure ClientFriendStatusChanged(sPlayerName: String; onin:byte);
    procedure ClientFriendChangeState(PlayObject:TPlayObject; Online: Boolean = True);
    procedure ClientAddFriend(sPlayerName:String);
    procedure ClientDelFriend(sPlayerName:String);
    procedure ClientReqAddFriend(sPlayerName:String);
    procedure ClientReqDelFriend(sPlayerName:String);
    procedure ClientFriendChange(ProcessMsg: pTProcessMessage);

    procedure ClientGetSayItem(ProcessMsg: pTProcessMessage);

    procedure PetSummon(PlayObject:TPlayObject; PetID:integer);
    procedure NotPetSummon();

    //사제 스쳐
    procedure ServerGetMentorRequest(ReqType: integer; ReqSeq: integer; ReqRe: integer; Master:String);
    procedure ServerGetMentorDelete(ReqType: integer; OtherName: string);
    procedure ServerGetMentorDelete2(ReqType: integer; OtherName: string);
    procedure ServerSetMentorDBAdd(Character, Other, State, Date: string; mode: byte);
    procedure ServerGetMentorDBGetList();
    procedure ServerSetMentorDBDelete(body : String);
    procedure ServerSetMentorDBChange(Taget, Name : String ; State ,date : integer );
    function ServerGetMentorDBDate: integer;

    procedure RecalcPupilAbilitys(Up:integer);    //제자 버프

    //연인 스쳐 ....
    procedure ServerGetRelationOptionChange(OptionType: integer; Enable: integer);     //사제 스쳐
    procedure ServerGetRelationRequest(ReqType: integer; ReqSeq: integer);
    procedure ServerGetRelationDelete(ReqType: integer; OtherName: string);
    procedure ServerGetRelationDeleteRequestOk(ReqType: integer; OtherName: string);
    procedure ServerGetRelationDeleteRequestFail(ReqType: integer;
      OtherName: string);
    procedure ServerSetRelationDBAdd(Character, Other, State, level, Sex, Date: string);
    procedure ServerGetRelationDBGetList();
    procedure ServerSetRelationDBDelete(body : String);
    procedure ServerSetRelationDBChange(Name,State : String);

    //쪽지
    procedure ClientRequestMailList(PlayObject: TPlayObject);
    procedure ClientSendMail(ProcessMsg: pTProcessMessage);
    procedure ClientMailStatus(ProcessMsg: pTProcessMessage);
    procedure ClientDeleteMail(ProcessMsg: pTProcessMessage);

    procedure ClientRejectList(PlayObject: TPlayObject);
    procedure ClientAddReject(ProcessMsg: pTProcessMessage);
    procedure ClientDelReject(ProcessMsg: pTProcessMessage);

    procedure ClientRequestGTList(ProcessMsg: pTProcessMessage);
    procedure ClientRequestDecoList(ProcessMsg: pTProcessMessage);
    procedure ClientBuyGT(ProcessMsg:pTProcessMessage);
    procedure ClientBuyDecoItem(ProcessMsg:pTProcessMessage);
    procedure ClientRequestBBSList(ProcessMsg: pTProcessMessage);       //장원게시판
    procedure ClientRequestBBSMsg(ProcessMsg: pTProcessMessage);       //장원게시판
    procedure ClientPostBBSMsg(ProcessMsg: pTProcessMessage;Body:String);         //장원게시판
    procedure ClientDeleteBBSMsg(ProcessMsg: pTProcessMessage);        //장원게시판

    function  ClientChangeDir(wIdent:Word;nX,nY,nDir:Integer):Boolean;
    function  ClientWalkXY(wIdent:Word;nX, nY:Integer): Boolean;
    function  ClientDownWalkXY(wIdent:Word;nX, nY:Integer): Boolean; //월영술

    function  ClientHorseRunXY(wIdent:Word;nX,nY:Integer):Boolean;
    function  ClientRunXY(wIdent:Word;nX,nY:Integer):Boolean;
    function  ClientSpeedRunXY(wIdent:Word;nX,nY:Integer;nFlag:Integer):Boolean; //경신보
    function  ClientDownRunXY(wIdent:Word;nX,nY:Integer;nFlag:Integer):Boolean; //월영술
    function  ClientHitXY(wIdent:Word;nX,nY,nDir:Integer;TargeTBaseObject: TBaseObject):Boolean;
    function  ClientSitDownHit(nX,nY,nDir:Integer):Boolean;
    function  ClientSpellXY(wIdent:Word;nKey:Integer;nTargetX, nTargetY:Integer;TargeTBaseObject: TBaseObject):Boolean;
    function  ClientBowXY(wIdent:Word;nKey:Integer;nTargetX, nTargetY:Integer;TargeTBaseObject: TBaseObject):Boolean;

    function  CheckTakeOnItems(nWhere: Integer;var StdItem:TStdItem):Boolean; //아이템 착용
    function  GetUserItemWeitht(nWhere: Integer):Integer;
    function ProcessUserCmd(sCmd: string): Boolean;

    procedure SendDelDealItem(UserItem:pTUserItem);
    procedure SendAddDealItem(UserItem:pTUserItem);
    procedure OpenDealDlg(BaseObject:TBaseObject);

    procedure SendDelRentalItem(UserItem:pTUserItem);    //대여
    procedure SendAddRentalItem(UserItem:pTUserItem);    //대여
    procedure OpenRentalDlg(BaseObject:TBaseObject;mode:integer);   //대여

    function  EatItems(StdItem:TItem;UserItem:pTUserItem):Boolean; //물약
    function  EatUseItems(nShape:integer):Boolean;
    function  ReadBook(StdItem:TItem):Boolean;
    function  DayBright():Byte;
  //  procedure BaseObjectMove(sMap,sX,sY:String);
    procedure NoBaseObjectMove(sMap,sX,sY:String);
    function  RepairWeapon():Boolean;
    function  SuperRepairWeapon():Boolean;
    function  RepairItemNormaly( psSeed: TItem; puSeed: PTUserItem ): Boolean;   //뼈망치, 바느질
    function  RepairItemSuper( psSeed: TItem; puSeed: PTUserItem ): Boolean;     //장신구, 재단
    function  WinLottery():Boolean;
    procedure ChangeServerMakeSlave(SlaveInfo:pTSlaveInfo);
    function  WeaptonMakeLuck():Boolean;   //행운
    function  PileStones(nX,nY:Integer):Boolean;
 //   function  RunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer):Boolean;   //달리기
    function  SpeedRunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer):Boolean;   //경신보
    function  DownRunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer):Boolean;   //경신보
   // procedure ThrustingOnOff(boSwitch:Boolean);
    procedure TaguOnOff(boSwitch:Boolean);  //타구봉법 - 승려

  //  procedure HalfMoonOnOff(boSwitch: Boolean);
    procedure SkillCrsOnOff(boSwitch: Boolean);
  //  procedure SkillNanCrsOnOff(boSwitch: Boolean);   //난화혈풍참
    procedure SkillCrsBongOnOff(boSwitch: Boolean);     //회풍천봉법
  //  function  AllowFireHitSkill():Boolean;    //염화결
    function  AllowChunMuSkill(UserMagic: pTUserMagic): Boolean;  //천무
    function  AllowDeathHitSkill():Boolean;    //살생도
 //   function  AllowTwinHitSkill():Boolean;
    function  AllowThunderHitSkill():Boolean;   //뇌룡봉법
    function  AllowFireShaolinSkill():Boolean;   //천화봉법
    function  RandomOreDura: integer;
    procedure MakeMine();     //광산
    procedure MakeMine2();
    procedure MakeMine3();
    procedure MakeMine4();    //석초광산


    function  GetRangeHumanCount():Integer;
    procedure GetHomePoint();
    function  GetStartPoint(var StartPoint:pTStartPoint):Boolean;

    procedure MobPlace(sX, sY, sMonName, sCount: String);


    procedure LogonTimcCost;
    procedure SendNotice();
    procedure SendNoticeEx(MD5: string);
    procedure SendLogon();
    procedure SendServerConfig();
    procedure SendServerStatus();
    procedure SendCompoundInfos;         //아이템합성
//    procedure SendUserName(PlayObject:TPlayObject;nX,nY:Integer);
//    function  CretInNearXY(TargeTBaseObject:TBaseObject;nX,nY:Integer):Boolean;
  //  procedure ClientQueryUserName(target: TBaseObject; x, y: integer);
    procedure SendUseitems();
    procedure SendUseMagic();
    procedure SendDelItemList(ItemList:TStringList);
    procedure SendAdjustBonus();
    procedure SendChangeGuildName();
    procedure SendMapDescription();
    procedure SendGoldInfo(boSendName:Boolean);

    procedure ShowMapInfo(sMap, sX, sY: String);

    function  CancelGroup():Boolean;

    function  DoMotaebo(nDir:Byte;nMagicLevel:Integer):Boolean;
    function  DoBaldo(nDir:Byte;UserMagic: pTUserMagic):Boolean;
    function  FinalBun(nDir:Byte;nMagicLevel:Integer):Boolean; //일격비
    procedure SendSerieMagicBlasthitMsg(UserMagic: pTUserMagic);      //참진격
    function BlastMotaebo(nDir: Byte; UserMagic: pTUserMagic): Boolean;    //참진격

    function  DoSpell(UserMagic:pTUserMagic;nTargetX,nTargetY:Integer;BaseObject:TBaseObject):boolean;
    procedure ReadAllBook;
    function  CheckItemsNeed(StdItem:TItem):Boolean;
    function  CheckItemBindUse(UserItem:pTUserItem):Boolean;
    procedure RecalcAdjusBonus;

    procedure ProcessClientPassword(ProcessMsg: pTProcessMessage);
    function CheckDenyLogon: Boolean;
    function CheckHDDLogon(nCode:string): Boolean;    //수정되었습니다.
    procedure ProcessSpiritSuite;
    procedure CheckSpeedCount(var nCount: Integer; sHitName: string);     //스피드핵
    function HorseRunTo(btDir: Byte; boFlag: boolean): Boolean;

    procedure ClientShopCardItem();               //환상점
    procedure ClientShopBuyItem(ItemName:string);     //환상점

    procedure ClientUponfish;    //낚시 아이템 획득
    procedure ClientUponfish2;    //낚시 아이템 획득

    procedure ClientUponfish3;    //낚시이벤트 아이템 획득
    procedure ClientUponfish4;    //낚시이벤트 아이템 획득

    procedure ClienFishItemDuraChange;                 //낚시
    procedure ClienFishName(fishName: String);      //낚시
    function ClienFishItemIdx: Integer;    //낚시 확률 아이템
    procedure ClienIncFishIdx;
    function ClienFishItemCheck: Boolean;         //낚시
    procedure ClientGuildMark(MarkImg: Integer);  //문파 마크
    procedure ClientGuildGrowUp(GrowUP,Point: Integer); //문파성장
    // 카운트 아이템
      procedure ServerSendItemCountChanged (mindex, icount, increase: integer; itmname: string);
    // 업그레이드용 내부함수(sonmg)
      function  GetTotalValueOfOption( pu: PTUserItem; pstd, psJewelry: TItem; var strResult, strEtc: string ) : integer;     //스쳐


      procedure ServerGetLoverLogout;     //연인 스쳐
      procedure ServerGetMentorLogout ;    //사제 스쳐
      function  GetCharMapInfo( charname : string ) : String;

  public
    m_nKillMonExpRate3        :Integer; //검성 검후 경치
    fLover:     TRelationShipMgr;  //연인 스쳐
    fMentor:    TMentorShipMgr; //사제 스쳐
    constructor Create();
    destructor Destroy; override;
    procedure ClientQueryBagItems(ver:String);      //가방
    procedure SendSocket(DefMsg: pTDefaultMessage; sMsg: String);virtual;
    procedure SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: String);
    procedure SearchViewRange();override;
    procedure UpdateVisibleGay(BaseObject:TBaseObject);override;
    function AddCheckMsg(sMsg: string; tClass: TCheckMsgClass; AddPointer: TPlayObject; AddTime: LongWord = 62): pTCheckMsg;
    procedure PKDie(PlayObject: TPlayObject);
    procedure GameTimeChanged();
    procedure RunNotice();
    function  GemItem(Gem:Integer;ItemIdx:Integer):integer;    //보옥(구 시스템)
    procedure GemItemFail(UserItem:pTUserItem;msg:String);      //보옥(구 시스템)
    procedure CraftFailed(datat:string);
    function PetEatItemOption(StdItem:TItem):Boolean;
    procedure PetOption(datat:string);  //영물옵션
    procedure ChangeItem(datat:string);  //변환

    procedure ClientQueryUserName(target: TBaseObject; x, y: integer);
    procedure SpeedCloseFunc;      //스피드핵
    procedure BaseObjectMove(sMap,sX,sY:String);
    function  GetAllowGroupReCall():Integer; //천지합일 표시
    function  IncPCPoint(nPoint:Integer):Boolean;
    procedure DecPCPoint(nPoint:Integer);
    procedure IncGameGold(nGameGold: Integer);
    function  IsEnoughBag():Boolean;
    function  IsAddWeightAvailable(nWeight:Integer):Boolean;
    procedure SendAddItemmode(UserItem:pTUserItem;idx:integer);     //물약
    procedure SendAddItem(UserItem:pTUserItem;idx:integer);
    procedure SendAddStorage(UserItem:pTUserItem );     //여관   //창고
    procedure SendAddStorageMode(UserItem:pTUserItem;idx:integer);     //여관

    procedure SendAddHeroAuto(UserItem:pTUserItem );     //여관   //창고

    procedure SendDelItems(UserItem:pTUserItem);
    procedure SendDelItemWithFlag (UserItem: pTUserItem; wBreakdown: Word);   //스쳐
    procedure ItemTimeRun;                       //여관
    procedure Whisper(whostr, saystr: string);
    procedure LoverWhisper (whostr, saystr: string);
    procedure MasterWhisper(whostr, saystr: string);
    procedure ClientHeroAI(nMode: Integer);

    procedure ClientHeroCall();
    procedure ClientHeroBackCall();
    procedure ClientHeroMasterDefen();

    procedure ClientAddAutoItem(nItemIdx: Integer; sMsg: String);
    procedure ClientDelAutoItem(nItemIdx: Integer; sMsg: String);

    procedure ClientTakeOnItems(btWhere:Byte;nItemIdx:integer;sItemName:String;iex:integer);   //아이템 착용
    procedure ClientTakeOffItems(btWhere:Byte;nItemIdx:integer;sItemName:String;iex:integer);   //아이템 벗음

    procedure ClientNewHeroCreate(nMerchant:integer;sData: String);
    procedure ClientHeroProtect(nX, nY: Integer);
    procedure ClientHeroTarget(BaseObject: TBaseObject; nX, nY: Integer); //영웅공격
    procedure ClientHeroTurn(nX, nY: Integer; nDir: Byte);
    procedure ClientHeroSpell(BaseObject: TBaseObject; tx, ty, MagNum: Integer);    //영웅무공

    procedure ClientHeroLogOut(BaseObject: TBaseObject);
    procedure ClientHeroLogOn(nType: Byte);
    procedure RecalcHeroAddAbilitys();

    procedure ClientMasterBagToHeroBag(nItemIdx: Integer; sItemName: string);
    procedure ClientHeroBagToMasterBag(nItemIdx: Integer; sItemName: string);
    procedure ClientHeroStorageItem(NPC:TObject;nItemIdx:Integer;sMsg:String; nMode:Integer);   //여관     //창고
    procedure ClientHeroTakeBackStorageItem(NPC:TObject;nItemIdx:Integer;sMsg:String; nMode:Integer);     //여관       //창고

    function  IsBlockWhisper(sName:String):Boolean;
    function  DoSonicWave(nDir:Byte;nMagicLevel, Damage:Integer):Boolean; //법륜연공 - 승려
    procedure MoveToHome();
    function  FindItemNameEx (iname: string; var count, durasum, duratop: integer): PTUserItem;
    function  QuestTakeCheckItem(CheckItem:pTUserItem):Boolean;
    function  QuestTakeCheckItem2(CheckItem:pTUserItem; wBreakdown: Word):Boolean;
    procedure GainExp(dwExp:LongWord); override;      //경험치
    procedure GetExp(dwExp:LongWord); override;     //경험치
    procedure WinExp(dwExp:LongWord); override;      //경험치
    procedure GetGuildExp(dwGExp:Integer);       //문파성장 경험치
  //  function  DecGold(nGold:Integer):Boolean;
    procedure DecGameGold(nGameGold: Integer);
    procedure Run();override;
    function  Operate(ProcessMsg:pTProcessMessage):Boolean;override;
    procedure RecalcAbilitys();override; //FFF7
    function  GetSpellPoint(UserMagic:pTUserMagic):Integer;
    procedure MakeSaveRcd(var HumanRcd:THumData);

    procedure RentalCancel();  //대여
    procedure RentalCancelA(); //대여
    procedure NotPetSummon2(sMonName:String); //영물

    procedure RecalcGroupAbilitys();    //그룹버프
    procedure RecalcGuildLevelAbilitys(Up:integer);    //문파성장

    procedure DealCancel();
    procedure DealCancelA();
    procedure ExChangeCancel();  //환전 취소
    function  GetShowName():String;override;

    procedure GetBackRentalItems();   //대여

    procedure GetBackDealItems();    //거래


    procedure GetBacExChange();  //환전 취소

    procedure StoreCancel;      //개인상점
    procedure GetBackStoreItems(); //개인상점

    procedure Disappear();override;//FFFD
    procedure GoldChange(sChrName:String;nGold:Integer);
    procedure ProcessUserLineMsg(sData:String);
    procedure ProcessSayMsg(sData:String);override;
    function GetItemInfo(str: string): string;
    procedure ClearStatusTime();   //죽은 경우 상태 리셋
    procedure UserLogon();virtual;
    procedure RefRankInfo(nRankNo:Integer;sRankName:string);
    procedure RefUserState;
    procedure SendGroupMembers(BaseObject: TPlayObject);
    procedure SendGroupMsg(BaseObject: TPlayObject; wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
    procedure SendGroupSocket(BaseObject: TPlayObject; wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
    procedure SendRefGroupMsg(BaseObject: TPlayObject; wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
    procedure JoinGroup(PlayObject:TPlayObject);
    procedure ChangeGroup(PlayObject: TPlayObject);
    function  GeTBaseObjectInfo():String;
    function  GetWalkMsgCount():Integer;
    function  GetRunMsgCount():Integer;
    function  GetTurnMsgCount():Integer;
    function  GetSiteDownMsgCount():Integer;
    function  GetDigUpMsgCount():Integer;
    procedure SetScriptLabel(sLabel: String);
    procedure GetScriptLabel(sMsg:String);
    function  LableIsCanJmp(sLabel:String):Boolean;
    function  GetMyInfo():String;
    procedure MakeGhost;override;
    procedure ScatterBagItems(ItemOfCreat:TBaseObject); override;
    procedure ClientSeparateItems(bMakeIndex,namount:integer);    //물약
    procedure DropUseItems(BaseObject:TBaseObject; DieFromMob : Boolean); override;
    procedure RecallHuman(sHumName:String);
    procedure SendAddMagic(UserMagic:pTUserMagic);
    procedure SendDelMagic(UserMagic:pTUserMagic);
    procedure ReQuestGuildWar(sGuildName:String);
    procedure SendUpdateItem(UserItem:pTUserItem);
    procedure SendComUpdateItem(UserItem:pTUserItem);
    procedure GetBagUseItems(var btDc:Byte;var btSc:Byte;var btMc:Byte;var btDura:Byte);
    procedure RecallGuild();
    procedure RecallGuildGT();     //장원 전체 소환
    procedure IndividualGuildGT(sHuman: string);     //장원 개인 소환
    function CallToGT(Number,x,y:Integer):Boolean;  //장원 이동

    function RandomToGT(sMap:String;Number:Integer):Boolean;  //장원 이동

    function MoveToGT(Number:Integer):Boolean;  //장원 소환 이동

    procedure CmdGetUserItems(Cmd: pTGameCmd; sHumanName, sItemName, sItemCount, sType: string); //회수
    procedure CmdAddUserItems(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer); //회수

  //protected
    procedure CmdEndGuild();
    procedure CmdMemberFunction(sCmd,sParam:String);
    procedure CmdMemberFunctionEx(sCmd,sParam:String);


    procedure CmdDearRecall(sCmd:String);       //연인 스쳐 이동

    procedure CmdCharSpaceMove (CharName_: string);   //연인 스쳐 이동
    function  CmdLoverCharSpaceMove (CharName_: string): Boolean;  //연인 스쳐 이동
    procedure CmdBreakLoverRelation;   //연인 스쳐 해제

    procedure CmdSbkDoorControl(sCmd,sParam:String);

    procedure CmdClearBagItem(Cmd:pTGameCmd;sHumanName:String);      //가방정리
    procedure CmdShowUseItemInfo(Cmd:pTGameCmd;sHumanName:String);

    procedure CmdBindUseItem(Cmd:pTGameCmd;sHumanName,sItem,sType:String);
    procedure CmdUnBindUseItem(Cmd:pTGameCmd;sHumanName,sItem,sType:String);
    procedure CmdLockLogin(Cmd:pTGameCmd);
    procedure CmdViewDiary(sCMD:String;nFlag:Integer);
    procedure CmdUserMoveXY(sCMD,sX,sY:String);
    procedure CmdSearchHuman(sCMD,sHumanName:String);
    procedure CmdGroupRecall(sCMD:String);
    procedure CmdAllowGroupReCall(sCmd,sParam:String);

    procedure CmdGuildRecall(sCmd,sParam:String);


    procedure CmdChangeAttackMode(nMode:Integer;sParam1,sParam2,sParam3,sParam4,sParam5,sParam6,sParam7:String);
    procedure CmdChangeSalveStatus();
    procedure CmdTakeOnHorse(sCmd,sParam:String);
    procedure CmdTakeOffHorse(sCmd,sParam:String);

    procedure CmdPrvMsg(sCmd:String;nPermission:Integer;sHumanName:String);
    procedure CmdHumanLocal(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdMapMove(Cmd:pTGameCmd;sMapName:String);

    procedure CmdPositionMove(Cmd:pTGameCmd;sMapName,sX,sY:String);
    procedure CmdMapClickMove(Cmd:pTGameCmd;sX,sY:String);

    procedure CmdShoutGreen(Cmd:pTGameCmd;sStr:String);
    procedure CmdShoutPurple(Cmd:pTGameCmd;sStr:String);

    procedure CmdPositionGtMove(Cmd:pTGameCmd;sMapName,sX,sY,number:String);
    procedure CmdHomeMove(Cmd:pTGameCmd);    //마을이동
    procedure CmdMaskClear(Cmd:pTGameCmd);    //변신탈 해제
    procedure CmdHumanInfo(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdReLoadAdmin(sCmd:String);
    procedure CmdReLoadColumn(sCmd:String);  //홍보단
    procedure CmdReloadNpc(sParam:String);
    procedure CmdReloadManage(Cmd:pTGameCmd;sParam:String);
    procedure CmdReloadRobotManage;
    procedure CmdReloadRobot;
    procedure CmdReloadMonItems();
    procedure CmdAdjustExp(Human:TPlayObject;nExp:Integer);
    procedure CmdAddGuild(Cmd:pTGameCmd;sGuildName,sGuildChief:String);
    procedure CmdDelGuild(Cmd:pTGameCmd;sGuildName:String);
    procedure CmdGuildWar(sCmd,sGuildName:String);
    procedure CmdChangeSabukLord(Cmd:pTGameCmd;sCastleName,sGuildName:String;boFlag:Boolean);
    procedure CmdForcedWallconquestWar(Cmd:pTGameCmd;sCastleName:String);
    procedure CmdOPTraining(sHumanName,sSkillName:String;nLevel:Integer);
    procedure CmdOPDeleteSkill(sHumanName,sSkillName:String);
    procedure CmdReloadGuildAll();
    procedure CmdReAlive(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdAdjuestLevel(Cmd:pTGameCmd;sHumanName:String;nLevel:Integer);
    procedure CmdAdjuestExp(Cmd:pTGameCmd;sHumanName,sExp:String);

    procedure CmdAddKillPoint(sCmd, sHumanName ,sCtr,strFameCur : string);    //킬 포인트 주기 명령어
    procedure CmdAddDeathPoint(sCmd, sHumanName ,sCtr,strFameCur : string);    //데스 포인트 주기 명령어

    procedure CmdBackStep(sCmd:String;nType,nCount:Integer);
    procedure CmdFreePenalty(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdKillDeathZero(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdPKpoint(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdIncPkPoint(Cmd:pTGameCmd;sHumanName:String;nPoint:Integer);

    procedure CmdHair(Cmd:pTGameCmd;sHumanName:String;nHair:Integer);
    procedure CmdTrainingSkill(Cmd:pTGameCmd;sHumanName,sSkillName:String;nLevel:Integer);
    procedure CmdTrainingMagic(Cmd:pTGameCmd;sHumanName,sSkillName:String;nLevel:Integer);

    procedure CmdDelSkill(Cmd:pTGameCmd;sHumanName,sSkillName:String);
    procedure CmdDeleteItem(Cmd:pTGameCmd;sHumanName,sItemName:String;nCount:Integer);
    procedure CmdClearMission(Cmd:pTGameCmd;sHumanName:String);

    procedure CmdTraining(sSkillName:String;nLevel:Integer);
    procedure CmdChangeJob(Cmd:pTGameCmd;sHumanName,sJobName:String);
    procedure CmdChangeJobUp(Cmd:pTGameCmd;sHumanName,sJobName:String);   //등선변환
    procedure CmdChangeGender(Cmd:pTGameCmd;sHumanName,sSex:String);
    procedure CmdMission(Cmd:pTGameCmd;sX,sY:String);
    procedure CmdMobPlace(Cmd:pTGameCmd;sX,sY,sMonName,sCount:String);
    procedure CmdMobLevel(Cmd:pTGameCmd;Param:String);
    procedure CmdMobCount(Cmd:pTGameCmd;sMapName:String);
    procedure CmdHumanCount(Cmd:pTGameCmd;sMapName:String);

    procedure CmdGMEventAbill(Cmd:pTGameCmd;Abil,Index,MinLevel,MaxLevel:String);    //GM 이벤트

    procedure CmdDisableFilter(sCmd,sParam1:String);
    procedure CmdChangeUserFull(sCmd,sUserCount:String);
    procedure CmdChangeZenFastStep(sCmd,sFastStep:String);

    procedure CmdReconnection(sCmd,sIPaddr,sPort:String);
    procedure CmdContestPoint(Cmd:pTGameCmd;sGuildName:String);
    procedure CmdStartContest(Cmd:pTGameCmd;sParam1:String);
    procedure CmdEndContest(Cmd:pTGameCmd;sParam1:String);

    procedure CmdAnnouncement(Cmd:pTGameCmd;sGuildName:String);
    procedure CmdKill(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdMakeItem(Cmd:pTGameCmd;sItemName:String;nCount:Integer);
   // procedure CmdMakeItem1(Cmd:pTGameCmd;sItemName:String;nCount:Integer); //유저 생산 명령어
    procedure CmdTRACK(Cmd:pTGameCmd;sItemName:String;nCount:Integer);
    procedure CmdSmakeItem(Cmd:pTGameCmd;nWhere,nValueType,nValue:Integer);
    procedure CmdYourmakeItem(Cmd:pTGameCmd;sHumName:String;nWhere,nValueType,nValue:Integer);
    procedure CmdBonuPoint(Cmd:pTGameCmd;sHumName:String;nCount:Integer);
    procedure CmdDelBonuPoint(Cmd:pTGameCmd;sHumName:String);
    procedure CmdRestBonuPoint(Cmd:pTGameCmd;sHumName:String);

    procedure CmdFireBurn(nInt,nTime,nN:Integer);
    procedure CmdTestFire(sCmd:String;nRange,nType,nTime,nPoint:Integer);

    procedure CmdTestStatus(sCmd:String;nType,nTime:Integer);

    procedure CmdDelGold(Cmd:pTGameCmd;sHumName:String;nCount:Integer);
    procedure CmdAddGold(Cmd:pTGameCmd;sHumName:String;nCount:Integer);
    procedure CmdDelGameGold(sCmd,sHumName:String;nPoint:Integer);
    procedure CmdAddGameGold(sCmd,sHumName:String;nPoint:Integer);
    procedure CmdGameGold(Cmd:pTGameCmd;sHumanName:String;sCtr:String;nGold:Integer);
    procedure CmdGamePoint(Cmd:pTGameCmd;sHumanName:String;sCtr:String;nPoint:Integer);
    procedure CmdPCPoint(Cmd:pTGameCmd;sHumanName:String;sCtr:String;nPoint:Integer);

    procedure CmdMob(Cmd:pTGameCmd;sMonName:String;nCount,nLevel:Integer; nExpRatio:Integer = -1);

    procedure CmdFiveGo(sCmd:String;nPerMission:Integer);

    procedure CmdRefineWeapon(Cmd:pTGameCmd;nDC,nMC,nSC,nHit:Integer);
    procedure CmdRecallMob(Cmd:pTGameCmd;sMonName:String;nCount,nLevel:Integer);
    procedure CmdLuckPoint(sCmd:String;nPerMission:Integer;sHumanName:String);
    procedure CmdChangeLuckPoint(Cmd:pTGameCmd;sHumanName:String;nPoint:Integer);
    procedure CmdLotteryTicket(sCmd:String;nPerMission:Integer;sParam1:String);
    procedure CmdReloadGuild(sCmd:String;nPerMission:Integer;sParam1:String);
    procedure CmdloadGuild(sCmd:String;nPerMission:Integer;sParam1: String); //초보문파
    procedure CmdReloadLineNotice(sCmd:String;nPerMission:Integer;sParam1:String);
    procedure CmdReloadAbuse(sCmd:String;nPerMission:Integer;sParam1:String);

    procedure CmdMobNpc(sCmd:String;nPermission:Integer;sParam1,sParam2,sParam3,sParam4:String);
    procedure CmdNpcScript(sCmd:String;nPermission:Integer;sParam1,sParam2,sParam3:String);
    procedure CmdDelNpc(sCmd:String;nPermission:Integer;sParam1:String);
    procedure CmdALLLOCK(sCmd:String;nPermission:Integer;sParam1:String);
    procedure CmdSFC(sCmd:String;nPermission:Integer;sParam1:String);
    procedure CmdKickHuman(Cmd:pTGameCmd;sHumName:String);
    procedure CmdTing(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdSuperTing(Cmd:pTGameCmd;sHumanName,sRange:String);
    procedure CmdMapMoveHuman(Cmd:pTGameCmd;sSrcMap,sDenMap:String);
    procedure CmdShutup(Cmd:pTGameCmd;sHumanName,sTime:String);
    procedure CmdShowMapInfo(Cmd:pTGameCmd;sParam1:String);

    procedure CmdShutupRelease(Cmd:pTGameCmd;sHumanName:String;boAll:Boolean);
    procedure CmdShutupList(Cmd:pTGameCmd;sParam1:String);
    procedure CmdSvnInfo(Cmd:pTGameCmd;sParam1:String);
    procedure CmdShowSbkGold(Cmd:pTGameCmd;sCastleName,sCtr,sGold:String);
    procedure CmdRecallHuman(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdReGotoHuman(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdShowHumanFlag(sCmd:String;nPermission:Integer;sHumanName,sFlag:String);
    procedure CmdShowHumanUnitOpen(sCmd:String;nPermission:Integer;sHumanName,sUnit:String);
    procedure CmdShowHumanUnit(sCmd:String;nPermission:Integer;sHumanName,sUnit:String);



    procedure CmdChangeAdminMode(sCmd:String;nPermission:Integer;sParam1:String;boFlag:Boolean);
    procedure CmdChangeObMode(sCmd:String;nPermission:Integer;sParam1:String;boFlag:Boolean);
    procedure CmdChangeSuperManMode(sCmd:String;nPermission:Integer;sParam1:String;boFlag:Boolean);
    procedure CmdChangeLevel(Cmd:pTGameCmd;sParam1:String);


    procedure CmdStartQuest(Cmd:pTGameCmd;sQuestName:String);
    procedure CmdSetPermission(Cmd:pTGameCmd;sHumanName,sPermission:String);
    procedure CmdSetColumn(Cmd:pTGameCmd;sHumanName,sColumn:String);     //홍보단
    procedure CmdClearMapMonster(Cmd:pTGameCmd;sMapName,sMonName,sItems:String);
    procedure CmdReNewLevel(Cmd:pTGameCmd;sHumanName,sLevel:String);

    procedure CmdDenyIPaddrLogon(Cmd:pTGameCmd;sIPaddr,sFixDeny:String);
    procedure CmdDelDenyIPaddrLogon(Cmd:pTGameCmd;sIPaddr,sFixDeny:String);
    procedure CmdShowDenyIPaddrLogon(Cmd:pTGameCmd;sIPaddr,sFixDeny:String);

    procedure CmdDenyAccountLogon(Cmd:pTGameCmd;sAccount,sFixDeny:String);
    procedure CmdDelDenyAccountLogon(Cmd:pTGameCmd;sAccount,sFixDeny:String);
    procedure CmdShowDenyAccountLogon(Cmd:pTGameCmd;sAccount,sFixDeny:String);

    procedure CmdDenyCharNameLogon(Cmd:pTGameCmd;sCharName,sFixDeny:String);
    procedure CmdDelDenyCharNameLogon(Cmd:pTGameCmd;sCharName,sFixDeny:String);
    procedure CmdShowDenyCharNameLogon(Cmd:pTGameCmd;sCharName,sFixDeny:String);
    procedure CmdViewWhisper(Cmd:pTGameCmd;sCharName,sParam2:String);
    procedure CmdSpirtStart(sCmd:String;sParam1:String);
    procedure CmdSpirtStop(sCmd:String;sParam1:String);
    procedure CmdSetMapMode(sCmd:String;sMapName,sMapMode,sParam1,sParam2:String);
    procedure CmdShowMapMode(sCmd:String;sMapName:String);
    procedure CmdClearHumanPassword(sCmd:String;nPermission:Integer;sHumanName:String);

    procedure CmdChangeItemName(sCmd,sMakeIndex,sItemIndex,sItemName:String);
    procedure CmdDisableSendMsg(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdEnableSendMsg(Cmd:pTGameCmd;sHumanName:String);
    procedure CmdDisableSendMsgList(Cmd:pTGameCmd);
    procedure CmdTestGetBagItems(Cmd:pTGameCmd;sParam:String);
    procedure CmdMobFireBurn(Cmd:pTGameCmd;sMap,sX,sY,sType,sTime,sPoint:String);
    procedure CmdTestSpeedMode(Cmd:pTGameCmd);

    procedure savelipiitemnamestr(ProcessMsg: pTProcessMessage);  //환상점 선물
    procedure saveMyShopCartstr(ProcessMsg: pTProcessMessage);   //환상점  관심
    procedure Giftstlisopen(PlayObject:TPlayObject);           //환상점  선물
    procedure DEllMyShopCartstr(idx:Integer;itemstr:string);   //환상점 관심

    procedure CmdTradeGT(Cmd:pTGameCmd);
    procedure MentorShipDeleteOther(ReqType: integer; OtherName: string; day :integer);     //사제 스쳐 해제
    procedure MentorShipDeleteOther2(ReqType: integer; OtherName: string);     //사제 스쳐 해제

    function RelationShipDeleteOther(ReqType: integer; OtherName: string): boolean;     //연인 스쳐 해제

    // 운영자 명령어 added by sonmg.2003/10/02
    function CheckSeedItem (puSeed: PTUserItem ;psSeed, psJewelry: TItem) : Integer;       //스쳐
    function CheckJewelryItem (iStdMode: integer) : Boolean;          //스쳐
    function SumOfOptions(puSeedItem: PTUserItem; psSeedItem: TItem) : integer;       //스쳐
    function CalcUpgradeProbability(puSeedItem, puJewelryItem: PTUserItem; psSeedItem, psJewelryItem: TItem; iExecCount: Integer; var iRetSum: integer; var fRetProb: Double) : integer;       //스쳐
    procedure CmdUpgradeItem (seedname, jewelryname: string; seedindex, jewelryindex, ExecCount : integer);        //스쳐
    function  DoUpgradeItem( puSeed: PTUserItem; psSeed, psJewelry: TItem ): integer;   //스쳐

    //킬/데스 명성
    function GetFameName( var nGrade: integer ) : string;
    function GetColumnName( ) : string;   //칼럼이름
    function GetNameRank( ) : string;
    function GetRankColor( ) : integer;
    function CheckAmulet(nCount:Integer;nType:Integer;var Idx:Integer):Boolean;
     procedure UseAmulet(nCount:Integer;nType:Integer;var Idx:Integer);

  end;

  procedure AddUserLog(sMsg:String);

implementation

uses M2Share, Guild, HUtil32, EDcode, ObjNpc, IdSrvClient, Event, ObjHero,
  ObjMon, LocalDB, Castle, EncryptUnit, svMain, ObjMon2, ObjMon3, GuildTerritory,
  UEncrypt;




constructor TPetObject.Create;//004C9190
begin
  inherited Create;
  m_boDupMode:=False;
  m_dwThinkTick:=GetTickCount();
  m_nViewRange:=5;
  m_nRunTime:=250;
  m_nTargetX:= -1;
  m_btRaceServer:=RC_PET;
  m_dwSearchTime:=3000 + Random(2000);
  m_dwSearchTick:=GetTickCount();
  m_dwWalkTick:=GetCurrentTime - LongWord(Random(3000));
  m_boRunAwayMode:=False;
  m_dwRunAwayStart:=GetTickCount();
  m_dwRunAwayTime:=0;
  m_boFixedHideMode := False;
end;

function TPetObject.Think():Boolean; //004A8E54
var
  nOldX,nOldY:integer;
begin
  Result:=False;
  if (GetTickCount - m_dwThinkTick) > 3 * 1000 then begin
    m_dwThinkTick:=GetTickCount();
    if m_PEnvir.GetXYObjCount(m_nCurrX,m_nCurrY) >= 2 then m_boDupMode:=True;
    if not IsProperTarget(m_TargetCret) then m_TargetCret:=nil;
  end; //004A8ED2
  if m_boDupMode and (not BoDontMove) then begin
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    PetWalkTo(Random(8),True);
    if (nOldX <> m_nCurrX) or (nOldY <> m_nCurrY) then begin
      m_boDupMode:=False;
      Result:=True;
    end;
  end;
end;

function TPetObject.GotoTargetXY:Boolean; //004C9694
var
  I     :Integer;
  nDir  :Integer;
  n10   :Integer;
  n14   :Integer;
  n20   :Integer;
  nOldX :Integer;
  nOldY :Integer;
begin
  Result := False;
  if BoDontMove then exit;
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    n10:=m_nTargetX;
    n14:=m_nTargetY;
    dwTick3F4:=GetTickCount();
    nDir:=DR_DOWN;
    if n10 > m_nCurrX then begin
      nDir:=DR_RIGHT;
      if n14 > m_nCurrY then
        nDir:=DR_DOWNRIGHT;
      if n14 < m_nCurrY then
        nDir:=DR_UPRIGHT;
    end else begin //004C9728
      if n10 < m_nCurrX then begin
          nDir:=DR_LEFT;
        if n14 > m_nCurrY then
          nDir:=DR_DOWNLEFT;
        if n14 < m_nCurrY then
          nDir:=DR_UPLEFT;
      end else begin //004C9760
        if n14 > m_nCurrY then
          nDir:=DR_DOWN
        else if n14 < m_nCurrY then
          nDir:=DR_UP;
      end;
   end;
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    PetWalkTo(nDir,True);
    n20:=Random(3);
    Result:= True;
    for I := DR_UP to DR_UPLEFT do begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
        if n20 <> 0 then Inc(nDir)
        else if nDir > 0 then Dec(nDir)
        else nDir:=DR_UPLEFT;
        if (nDir > DR_UPLEFT) then nDir:=DR_UP;
        PetWalkTo(nDir,True);
        Result:= True;
      end;
    end;
  end; //004C980B
end;


function TPetObject.Operate(ProcessMsg:pTProcessMessage):Boolean; //004C9280
begin
   Result:=inherited Operate(ProcessMsg);
end;


procedure TPetObject.Wondering; //004C9810
begin
  if BoDontMove then exit;
  if (Random(15)= 0) then
    if (Random(2) = 1) then TurnToPet(Random(8))
    else PetWalkTo(m_btDirection,True);
end;

destructor TPetObject.Destroy; //004A8C24
begin
  inherited Destroy;
end;


function TPetObject.StartPickUpItem(nRage:integer): Boolean;     //픽업
  function PickUpItem(nX, nY: Integer): Boolean;

    function IsSelf(BaseObject:TBaseObject):Boolean;
    begin
      if (BaseObject = nil) or (m_Master = BaseObject) then Result:=True
      else Result:=False;
    end;
    function IsOfGroup(BaseObject:TBaseObject):Boolean;
    var
      I: Integer;
      GroupMember:TBaseObject;
    begin
      Result:=False;
      if m_Master.m_GroupOwner = nil then exit;
      for I := 0 to m_Master.m_GroupOwner.m_GroupMembers.Count - 1 do begin    //그룹
        GroupMember:=TBaseObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
        if GroupMember = BaseObject then begin
          Result:=True;
          break;
        end;
      end;
    end;
    function PickUpMasterItem(PlayObject: TPlayObject; MapItem: PTMapItem; var ItemName: string): Boolean;
    var
      UserItem: PTUserItem;
      StdItem: TItem;
      sSendMsg: string;
      I, ItemIdx:Integer;
      boot:Boolean;
      GroupObject: TPlayObject;
      PlayList: array[0..13] of TPlayObject;
      PlayCount: Integer;
      nCount, nMyCount, nAddCount: Integer;
    begin
      if (CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0) and ((PlayObject.g_boItemAll = 1) or (PlayObject.g_boItemGold = 1)) then begin
        if m_PEnvir.DeleteFromMap (nX, nY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
          if (m_Master.m_GroupOwner <> nil) and m_Master.m_GroupOwner.m_GroupClass then begin
            SendRefMsg(RM_ITEMHIDE, 1, Integer(MapItem), nX, nY, '');
            PlayCount := 0;
            for i := 0 to m_Master.m_GroupOwner.m_GroupMembers.Count - 1 do begin
              if PlayCount > High(PlayList) then break;
              GroupObject := TPlayObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
              if (not GroupObject.m_boGhost) and (GroupObject <> PlayObject) and
                (GroupObject.m_PEnvir = PlayObject.m_PEnvir) and
                (abs(GroupObject.m_nCurrX - PlayObject.m_nCurrX) <= g_Config.nSendRefMsgRange) and           //범위가 멀어지면,,
                (abs(GroupObject.m_nCurrY - PlayObject.m_nCurrY) <= g_Config.nSendRefMsgRange) then begin
                PlayList[PlayCount] := GroupObject;
                Inc(PlayCount);
              end;
            end;
            if PlayCount > 0 then begin
              nCount := MapItem.Count div (PlayCount + 1);
              nMyCount := MapItem.Count mod PlayCount;
              for i := 0 to PlayCount - 1 do begin
                if PlayObject = PlayList[i] then
                  nAddCount := nCount + nMyCount
                else
                  nAddCount := nCount;
                if PlayList[i].IncGold(nAddCount) then begin
                  if g_boGameLogGold then //004C5E8C
                   AddGameDataLog('4' +  #9 +
                     PlayList[i].m_sMapName + #9 +
                     IntToStr(PlayList[i].m_nCurrX) + #9 +
                     IntToStr(PlayList[i].m_nCurrY) + #9 +
                     PlayList[i].m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠 - 숄혤렘駕(롸잚)]');
                  PlayList[i].GoldChanged;
                  Result := True;
                end else
                  Inc(nMyCount, nAddCount);
              end;
              nAddCount := nCount + nMyCount;
            end else begin
              nAddCount := MapItem.Count;
            end;
            if PlayObject.IncGold(nAddCount) then begin
              if g_boGameLogGold then //004C5E8C
                AddGameDataLog('4' +  #9 +
                     PlayObject.m_sMapName + #9 +
                     IntToStr(nX) + #9 +
                     IntToStr(nY) + #9 +
                     PlayObject.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠 - 숄혤렘駕(홍꼬)]');
              PlayObject.GoldChanged;
              Result := True;
            end;
            if Result then begin
              DisPose(MapItem);
              ItemName := sSTRING_GOLDNAME;
            end else
              m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
          end else begin
            if PlayObject.IncGold (MapItem.Count) then begin
              SendRefMsg (RM_ITEMHIDE, 0, Integer(MapItem), nX, nY, '');
              if g_boGameLogGold then //004C5E8C
               AddGameDataLog('4' +  #9 +
                     PlayObject.m_sMapName + #9 +
                     IntToStr(nX) + #9 +
                     IntToStr(nY) + #9 +
                     PlayObject.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(MapItem.Count) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠숄혤]');
              PlayObject.GoldChanged;
              Dispose(MapItem);
              ItemName := sSTRING_GOLDNAME;
              Result := True;
            end else
              m_PEnvir.AddToMap (nX, nY, OS_ITEMOBJECT, TObject(MapItem));
          end;
        end;
        exit;
      end;
      //일반 아이템
      if PlayObject.IsEnoughBag then begin
      if m_PEnvir.DeleteFromMap (nX, nY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
        New(UserItem);
        UserItem^ := MapItem.UserItem;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        if (StdItem <> nil) and TPlayObject(m_Master).IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))
          and TPlayObject(m_Master).PetEatItemOption(StdItem) then begin      //5,6,90,99 무기 10,11,12 옷 15 투구 62 신발  64 허리띠  19,20,21,22,23,24,26,63 장신구  48 빼고 기타

          ItemIdx := SetSayItem(UserItem);
          sSendMsg := '[#7' + PlayObject.m_sCharName + '#7]삿돤죄';
          sSendMsg := sSendMsg + '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(UserItem.MakeIndex) + '} ';
          sSendMsg := sSendMsg + '。';

          SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), nX, nY, '');
          PlayObject.AddItemToBag(UserItem,boot);
          if boot then
          PlayObject.SendAddItem(UserItem,1);
          if StdItem.NeedIdentify = 1 then
                AddGameDataLog('4' + #9 +
                  PlayObject.m_sMapName + #9 +
                  IntToStr(nX) + #9 +
                  IntToStr(nY) + #9 +
                  PlayObject.m_sCharName + #9 +
                  StdItem.Name +'('+ IntToStr(UserItem.Amount) +')' + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  '0' + #9 + '[쥣膠숄혤]');
          Dispose(MapItem);
          ItemName := StdItem.Name;
          Result := True;
          if m_Master.m_GroupOwner <> nil then begin    //그룹 획득 메시지
            for i:=0 to m_Master.m_GroupOwner.m_GroupMembers.Count-1 do begin
              PlayObject:=TPlayObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
              if PlayObject = nil then Continue;
              PlayObject.SysMsg (sSendMsg, c_BlueWhite, t_Hint);
            end;
          end;
        end else begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
      end;
    end;


  var
    MapItem:pTMapItem;
    PlayObject:TPlayObject;
    PlayList: array[0..13] of TPlayObject;
    PlayCount, nError: Integer;
    I:Integer;
    ItemName: string;
  begin
    Result := False;
    nError := 0;
    try
    nError := 1;
    if (m_Master = nil) or m_boDeath or m_boGhost then Exit;
    if (m_Master.m_boDeath) and (m_Master.m_boGhost) and (m_Master.m_btRaceServer <> RC_PLAYOBJECT) then Exit;
    if m_Master.InSafeZone or InSafeZone then Exit;
    if m_Master.m_boDealing or m_Master.m_boRentaling then exit; //교환중에는 물건을 주울 수 없다.
    nError := 2;
    MapItem := m_PEnvir.GetItem(nX, nY);
    if MapItem = nil then Exit;
    nError := 3;
    if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
      MapItem.OfBaseObject:=nil;
    end;
    nError := 4;
    if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then begin
      exit;
    end;
    nError := 5;
    if MapItem.DropBaseObject <> nil then begin
      if (TBaseObject(MapItem.DropBaseObject).m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) then Exit;
    end;
    nError := 6;
    if (m_Master.m_GroupOwner <> nil) and m_Master.m_GroupOwner.m_GroupClass and (CompareText(MapItem.Name, sSTRING_GOLDNAME) <> 0) then begin
      PlayCount := 0;
      nError := 7;
      for I := 0 to m_Master.m_GroupOwner.m_GroupMembers.Count - 1 do begin
        if PlayCount > High(PlayList) then
          break;
        PlayObject := TPlayObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
        if PlayObject.IsEnoughBag and (not PlayObject.m_boGhost) and (m_PEnvir = PlayObject.m_PEnvir) and
          (abs(m_nCurrX - PlayObject.m_nCurrX) <= g_Config.nSendRefMsgRange) and
          (abs(m_nCurrY - PlayObject.m_nCurrY) <= g_Config.nSendRefMsgRange) then begin
          PlayList[PlayCount] := PlayObject;
          Inc(PlayCount);
        end;
      end;
      nError := 8;
      if PlayCount > 0 then begin
        PlayCount := Random(PlayCount);
        Result := PickUpMasterItem(PlayList[PlayCount], MapItem, ItemName);
      end;
      nError := 9;
    end else
      Result := PickUpMasterItem(TPlayObject(m_Master), MapItem, ItemName);

    except
      MainOutMessage(Format('[Exception] TPet.PickUpItem :: %d', [nError]));
    end;
  end;
var
  nStartX ,nEndX, nStartY, nEndY, x, y, nError: integer;
begin
  Result := False;
  nError := 0;
  try
  if GetTickCount - TPlayObject(m_Master).m_dwPickUpTick < 1000 then Exit;
  nError := 1;
  nStartX:=m_nCurrX - nRage;
  nEndX:=m_nCurrX + nRage;
  nStartY:=m_nCurrY - nRage;
  nEndY:=m_nCurrY + nRage;
  nError := 2;
  for x:= nStartX to nEndX do begin
    for y := nStartY to nEndY do begin
      nError := 3;
      if PickUpItem(x, y) then begin
        nError := 4;
        TPlayObject(m_Master).m_dwPickUpTick := GetTickCount;
        Result := True;
        SendRefMsg(RM_HIT,m_btDirection,m_nCurrX,m_nCurrY,Integer(Self),'');
        nError := 5;
        Exit;
      end;
    end;
  end;
  except
    MainOutMessage(Format('[Exception] TPet.StartPickUpItem :: %d', [nError]));
  end;
end;

function TPetObject.MousePickUpItem(nRage,x,y:integer): Boolean;     //픽업
  function PickUpItem(nX, nY: Integer): Boolean;

    function IsSelf(BaseObject:TBaseObject):Boolean;
    begin
      if (BaseObject = nil) or (m_Master = BaseObject) then Result:=True
      else Result:=False;
    end;
    function IsOfGroup(BaseObject:TBaseObject):Boolean;
    var
      I: Integer;
      GroupMember:TBaseObject;
    begin
      Result:=False;
      if m_Master.m_GroupOwner = nil then exit;
      for I := 0 to m_Master.m_GroupOwner.m_GroupMembers.Count - 1 do begin    //그룹
        GroupMember:=TBaseObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
        if GroupMember = BaseObject then begin
          Result:=True;
          break;
        end;
      end;
    end;
    function PickUpMasterItem(PlayObject: TPlayObject; MapItem: PTMapItem; var ItemName: string): Boolean;
    var
      UserItem: PTUserItem;
      StdItem: TItem;
      sSendMsg: string;
      I, ItemIdx:Integer;
      boot:Boolean;
      GroupObject: TPlayObject;
      PlayList: array[0..13] of TPlayObject;
      PlayCount: Integer;
      nCount, nMyCount, nAddCount: Integer;
    begin
      if (CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0) {and ((PlayObject.g_boItemAll = 1) or (PlayObject.g_boItemGold = 1))} then begin
        if m_PEnvir.DeleteFromMap (nX, nY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
          if (m_Master.m_GroupOwner <> nil) and m_Master.m_GroupOwner.m_GroupClass then begin
            SendRefMsg(RM_ITEMHIDE, 1, Integer(MapItem), nX, nY, '');
            PlayCount := 0;
            for i := 0 to m_Master.m_GroupOwner.m_GroupMembers.Count - 1 do begin
              if PlayCount > High(PlayList) then break;
              GroupObject := TPlayObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
              if (not GroupObject.m_boGhost) and (GroupObject <> PlayObject) and
                (GroupObject.m_PEnvir = PlayObject.m_PEnvir) and
                (abs(GroupObject.m_nCurrX - PlayObject.m_nCurrX) <= g_Config.nSendRefMsgRange) and           //범위가 멀어지면,,
                (abs(GroupObject.m_nCurrY - PlayObject.m_nCurrY) <= g_Config.nSendRefMsgRange) then begin
                PlayList[PlayCount] := GroupObject;
                Inc(PlayCount);
              end;
            end;
            if PlayCount > 0 then begin
              nCount := MapItem.Count div (PlayCount + 1);
              nMyCount := MapItem.Count mod PlayCount;
              for i := 0 to PlayCount - 1 do begin
                if PlayObject = PlayList[i] then
                  nAddCount := nCount + nMyCount
                else
                  nAddCount := nCount;
                if PlayList[i].IncGold(nAddCount) then begin
                  if g_boGameLogGold then //004C5E8C
                   AddGameDataLog('4' +  #9 +
                     PlayList[i].m_sMapName + #9 +
                     IntToStr(PlayList[i].m_nCurrX) + #9 +
                     IntToStr(PlayList[i].m_nCurrY) + #9 +
                     PlayList[i].m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠 - 숄혤렘駕(롸잚)]');
                  PlayList[i].GoldChanged;
                  Result := True;
                end else
                  Inc(nMyCount, nAddCount);
              end;
              nAddCount := nCount + nMyCount;
            end else begin
              nAddCount := MapItem.Count;
            end;
            if PlayObject.IncGold(nAddCount) then begin
              if g_boGameLogGold then //004C5E8C
                AddGameDataLog('4' +  #9 +
                     PlayObject.m_sMapName + #9 +
                     IntToStr(nX) + #9 +
                     IntToStr(nY) + #9 +
                     PlayObject.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠 - 숄혤렘駕(홍꼬)]');
              PlayObject.GoldChanged;
              Result := True;
            end;
            if Result then begin
              DisPose(MapItem);
              ItemName := sSTRING_GOLDNAME;
            end else
              m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
          end else begin
            if PlayObject.IncGold (MapItem.Count) then begin
              SendRefMsg (RM_ITEMHIDE, 0, Integer(MapItem), nX, nY, '');
              if g_boGameLogGold then //004C5E8C
               AddGameDataLog('4' +  #9 +
                     PlayObject.m_sMapName + #9 +
                     IntToStr(nX) + #9 +
                     IntToStr(nY) + #9 +
                     PlayObject.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(MapItem.Count) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠숄혤]');
              PlayObject.GoldChanged;
              Dispose(MapItem);
              ItemName := sSTRING_GOLDNAME;
              Result := True;
            end else
              m_PEnvir.AddToMap (nX, nY, OS_ITEMOBJECT, TObject(MapItem));
          end;
        end;
        exit;
      end;
      //일반 아이템
      if PlayObject.IsEnoughBag then begin
      if m_PEnvir.DeleteFromMap (nX, nY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
        New(UserItem);
        UserItem^ := MapItem.UserItem;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        if (StdItem <> nil) and TPlayObject(m_Master).IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex)) and (StdItem.StdMode <> 48)
         { and TPlayObject(m_Master).PetEatItemOption(StdItem)} then begin      //5,6,90,99 무기 10,11,12 옷 15 투구 62 신발  64 허리띠  19,20,21,22,23,24,26,63 장신구  48 빼고 기타

          ItemIdx := SetSayItem(UserItem);
          sSendMsg := '[#7' + PlayObject.m_sCharName + '#7]삿돤죄';
          sSendMsg := sSendMsg + '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(UserItem.MakeIndex) + '} ';
          sSendMsg := sSendMsg + '。';

          SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), nX, nY, '');
          PlayObject.AddItemToBag(UserItem,boot);
          if boot then
          PlayObject.SendAddItem(UserItem,1);
          if StdItem.NeedIdentify = 1 then
                AddGameDataLog('4' + #9 +
                  PlayObject.m_sMapName + #9 +
                  IntToStr(nX) + #9 +
                  IntToStr(nY) + #9 +
                  PlayObject.m_sCharName + #9 +
                  StdItem.Name +'('+ IntToStr(UserItem.Amount) +')' + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  '0' + #9 + '[쥣膠숄혤]');
          Dispose(MapItem);
          ItemName := StdItem.Name;
          Result := True;
          if m_Master.m_GroupOwner <> nil then begin    //그룹 획득 메시지
            for i:=0 to m_Master.m_GroupOwner.m_GroupMembers.Count-1 do begin
              PlayObject:=TPlayObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
              if PlayObject = nil then Continue;
              PlayObject.SysMsg (sSendMsg, c_BlueWhite, t_Hint);
            end;
          end;
        end else begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
      end;
    end;

  var
    MapItem:pTMapItem;
    PlayObject:TPlayObject;
    PlayList: array[0..13] of TPlayObject;
    PlayCount: Integer;
    I:Integer;
    ItemName: string;
  begin
    Result := False;
    if (m_Master = nil) or m_boDeath or m_boGhost then Exit;
    if (m_Master.m_boDeath) and (m_Master.m_boGhost) and (m_Master.m_btRaceServer <> RC_PLAYOBJECT) then Exit;
    if m_Master.InSafeZone or InSafeZone then Exit;
    if m_Master.m_boDealing or m_Master.m_boRentaling then exit; //교환중에는 물건을 주울 수 없다.

    MapItem := m_PEnvir.GetItem(nX, nY);
    if MapItem = nil then Exit;

    if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
      MapItem.OfBaseObject:=nil;
    end;
    if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then begin
      exit;
    end;

    if MapItem.DropBaseObject <> nil then begin
      if (TBaseObject(MapItem.DropBaseObject).m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) then Exit;
    end;
    if (m_Master.m_GroupOwner <> nil) and m_Master.m_GroupOwner.m_GroupClass and (CompareText(MapItem.Name, sSTRING_GOLDNAME) <> 0) then begin
      PlayCount := 0;
      for I := 0 to m_Master.m_GroupOwner.m_GroupMembers.Count - 1 do begin
        if PlayCount > High(PlayList) then
          break;
        PlayObject := TPlayObject(m_Master.m_GroupOwner.m_GroupMembers.Objects[i]);
        if PlayObject.IsEnoughBag and (not PlayObject.m_boGhost) and (m_PEnvir = PlayObject.m_PEnvir) and
          (abs(m_nCurrX - PlayObject.m_nCurrX) <= g_Config.nSendRefMsgRange) and
          (abs(m_nCurrY - PlayObject.m_nCurrY) <= g_Config.nSendRefMsgRange) then begin
          PlayList[PlayCount] := PlayObject;
          Inc(PlayCount);
        end;
      end;
      if PlayCount > 0 then begin
        PlayCount := Random(PlayCount);
        Result := PickUpMasterItem(PlayList[PlayCount], MapItem, ItemName);
      end;
    end else
      Result := PickUpMasterItem(TPlayObject(m_Master), MapItem, ItemName);
  end;
  
begin
  Result := False;
  if GetTickCount - TPlayObject(m_Master).m_dwPickUpTick2 < 1000 then Exit;
  if (abs(m_nCurrX - X) <= (nRage+1)) and (abs(m_nCurrY - Y) <= (nRage+1)) then begin
    if PickUpItem(x, y) then begin
      TPlayObject(m_Master).m_dwPickUpTick2 := GetTickCount;
      Result := True;
      SendRefMsg(RM_HIT,m_btDirection,m_nCurrX,m_nCurrY,Integer(Self),'');
      Exit;
    end;
  end;
end;

procedure TPetObject.Run; //004A9020
var
  nX,nY, nError:Integer;
begin
  nError:= 0;
  Try
    nError:= 1;
  if (not m_boFixedHideMode) and (not m_boStoneMode) and CanMove then begin
    nError:= 2;
    if Think then begin
      inherited Run;
      exit;
    end;
    nError:= 3;
    if m_boWalkWaitLocked then begin
      if (GetTickCount - m_dwWalkWaitTick) > m_dwWalkWait then begin
        m_boWalkWaitLocked:=False;
      end;
    end;
    nError:= 4;
    if not m_boWalkWaitLocked and (GetCurrentTime - m_dwWalkTick > GetWalkSpeed) then begin
      m_dwWalkTick:=GetCurrentTime;
      Inc(m_nWalkCount);
      nError:= 5;
      if m_nWalkCount > m_nWalkStep then begin
        m_nWalkCount:=0;
        m_boWalkWaitLocked:=True;
        m_dwWalkWaitTick:=GetTickCount();
      end; //004A9151
      nError:= 6;
      if not m_boRunAwayMode then begin
        nError:= 7;
        if (m_Master <> nil) then begin
          nError:= 8;
          if (m_TargetCret = nil) or (BoLoseTargetMoment) then begin
            BoLoseTargetMoment := FALSE;
            m_Master.GetBackPosition(nX,nY);    //주인의 뒤로 감
            if (abs(m_nTargetX - nX) > 2) or (abs(m_nTargetY - nY) > 2) then begin
              m_nTargetX:=nX;
              m_nTargetY:=nY;
              if (abs(m_nCurrX - nX) <= 4) and (abs(m_nCurrY - nY) <= 4) then begin
                if m_PEnvir.GetMovingObject(nX,nY,True) <> nil then begin
                  m_nTargetX:=m_nCurrX;
                  m_nTargetY:=m_nCurrY;
                end;
              end;
            end;
          end; //004A92A5 if m_TargetCret = nil then begin
          nError:= 9;
          if ((m_PEnvir <> m_Master.m_PEnvir) or     //주인과 너무 떨어져 있으면...
             (abs(m_nCurrX-m_Master.m_nCurrX) > 20) or
             (abs(m_nCurrY-m_Master.m_nCurrY) > 20)) then begin
            SpaceGTMoveEX(m_Master.m_PEnvir.sMapName, m_nTargetX, m_nTargetY, 1,m_Master.m_PEnvir.Flag.nGuildTerritory);
          end; // 004A937E
        end;// 004A937E if m_Master <> nil then begin
       nError:= 10;
        if (m_Master <> nil) and (m_TargetCret = nil) then begin
          nError:= 11;
          if (TPlayObject(m_Master).g_boItemAuto = 1) then begin
            nError:= 12;
            if StartPickUpItem(m_Master.m_nPetEatRage) then begin       //픽업
              nError:= 13;
              Exit;
            end;
          end;
        end;
      end else begin //004A9344
        nError:= 14;
        if (m_dwRunAwayTime > 0) and ((GetTickCount - m_dwRunAwayStart) > m_dwRunAwayTime) then begin
          m_boRunAwayMode:=False;
          m_dwRunAwayTime:=0;
        end;
      end; //004A937E
      nError:= 15;
      if m_nTargetX <> -1 then begin
        if not GotoTargetXY then Wondering();
      end;
      nError:= 16;

    end;
  end;
  nError:= 17;
  inherited Run;

  except
    MainOutMessage(Format('[Exception] TPet.Run :: %d', [nError]));
  end;
end;

procedure TPetObject.Die;
begin
  m_WAbil.HP := 0;
  MakeGhost();
  inherited Die;
end;

function TPetObject.GetShowName: String;
begin
  Result := '쥣膠';
  try
    if m_Master <> nil then begin
      Result := m_Master.m_sPetName + '\' + m_Master.m_sCharName +'돨쥣膠';  //이름
    end;
  except
    MainOutMessage('[Exception] TPet.GetShowName');
  end;
end;


{ TBaseObject }

constructor TBaseObject.Create; //4B780C
begin
  m_boGhost               := False;
  m_dwGhostTick           := 0;
  m_boDeath               := False;
  m_boAliveMsg            := False;
  m_dwDeathTick           := 0;
  m_SendRefMsgTick        := GetTickCount();
  m_btDirection           := 4;
  m_btRaceServer          := RC_MONSTER;
  m_btRaceImg             := 0;
  m_btHair                := 0;
  m_btJob                 := jWarr;
  m_nGold                 := 0;
  m_wAppr                 := 0;
  HoldPlace                   := True;
  m_boWarChack            := False;
  m_nViewRange            := 5;
  m_sHomeMap              := '0';

  m_btPermission          := 0;
  m_btColumn              := 0;
  m_nLight                := 0;
  m_btNameColor           := 255;
  m_nHitPlus              := 0;
  m_nHitDouble            := 0;
  m_dBodyLuck             := 0;
  m_wGroupRcallTime       := 0;      //그룹 재요청
  m_dwGroupRcallTick      := GetTickCount();
  m_boRecallSuite         := False;
  m_boTestGa              := False;
  m_boGsa                 := False;
  bo2BA                   := False;
  m_boAbilSeeHealGauge    := False;
  m_boPowerHit            := False;
  m_boUseGodShield        := False;
  m_boEmbrace             := False;
  m_boAssassinHit         := False;
  m_boManaEater           := False;
  m_boHemorrhage          := False;
  m_boUseWindblade        := False;       //풍검술
  m_boUseThrusting        := False;
  m_boUseTagu             := False;
  m_boUseHalfMoon         := False;
  m_boCrsBongHitkill      := False;
  m_boUseVamp             := TRUE;             //흡기
  m_boFireHitSkill        := False;
  m_boDeathHitSkill       := False; //살생도
  m_boChunMuSkill         := 0;
  m_boTwinHitSkill        := 0;   //쌍룡참
  m_boThunderHitSkill     := 0;
  m_boFireShaolinSkill    := 0;
  m_btHitPoint            := 5;
  m_btSpeedPoint          := 15;
  m_nHitSpeed             := 0;
  m_btLifeAttrib          := 0;
  m_btAntiPoison          := 0;
  m_nPoisonRecover        := 0;
  m_nHealthRecover        := 0;
  m_nSpellRecover         := 0;
  m_nAntiMagic            := 0;
  m_nLuck                 := 0;
  m_nPoisonIncrease       := 0;
  m_nFreezingIncrease     := 0;
  m_nIncSpell             := 0;
  m_nIncHealth            := 0;
  m_nIncHealing           := 0;
  m_nIncStayHealth        := 0;       //지속물약-개인
  m_nIncStaySpell         := 0;       //지속물약
  m_dwStayHPTime          := 0;       //지속물약
  m_dwStayMPTime          := 0;       //지속물약
  m_dwIncStayHealthTick   := GetTickCount();        //지속물약
  m_dwIncStaySpellTick    := GetTickCount();        //지속물약

  m_nGrIncStayHealth        := 0;     //지속물약-그룹
  m_nGrIncStaySpell         := 0;     //지속물약
  m_dwGrStayHPTime          := 0;     //지속물약
  m_dwGrStayMPTime          := 0;     //지속물약
  m_dwGrIncStayHealthTick   := GetTickCount();        //지속물약
  m_dwGrIncStaySpellTick    := GetTickCount();        //지속물약

  m_nPerHealth            := 5;
  m_nPerHealing           := 5;
  m_nPerSpell             := 5;
  m_dwIncHealthSpellTick  := GetTickCount();
  m_btGreenPoisoningPoint := 0;
  m_btThunderPower        := 0;
  m_btThunderWavePoint    := 0;
  m_boSunchunUse          := False;
  HemorrhageLevel         := 0;
  ThunderLevel            := 0;
  m_nFightZoneDieCount    := 0;
  m_nGoldMax              := g_Config.nHumanMaxGold;
  m_nCharStatus           := 0;
  m_nCharStatusEx         := 0;
  FillChar(m_wStatusTimeArr,SizeOf(TStatusTime),#0); //스테이트
  FillChar(m_btStatusValue,SizeOf(byte)*MAX_STATUS_ATTRIBUTE,#0); //스테이트
  FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);
  FillChar(m_CurBonusAbil, SizeOf(TNakedAbility), #0);

  FillChar(m_wStatusArrValue, Sizeof(m_wStatusArrValue), 0);
  FillChar(m_wStatusArrFlag, Sizeof(m_wStatusArrFlag), 0);
  FillChar(m_dwStatusArrTimeOutTick, SizeOf(m_dwStatusArrTimeOutTick), #0);

  FillChar (ExtraAbil, sizeof(byte) * EXTRAABIL_SIZE, #0);
  FillChar (ExtraAbilFlag, sizeof(byte) * EXTRAABIL_SIZE, #0);
  FillChar (ExtraAbilTimes, sizeof(longword) * EXTRAABIL_SIZE, #0);

  m_boAllowGroup          := False;         //그룹
  m_boCheckGroup          := True;
  m_boCheckHero           := False;
  m_boAllowGuild          := False;

  m_btAttatckMode         := 0;          //공격모드
  m_boInFreePKArea        := False;
  m_boGuildWarArea        := False;
  BoCrimeforCastle                   := False;
  m_boSuperMan            := False;
  m_boSkeleton            := False;
  bo2BF                   := False;
  m_boHolySeize           := False;     //결계
  m_boPobakSeize          := False;
  m_boOnHorse             := False;      //호랑이

  m_btMask                := 0;     //변신탈
  m_btHumEffect           := 0;     //기퍼짐
  m_btEventEffect         := 0;     //빼빼로 이팩트
  m_WEffect               := 0;
  m_boCrazyMode           := False;
  m_boHallucMode          := False; //Hallucination
  m_boShowHP              := False;
  bo2F0                   := False;
  m_boAnimal              := False;
  m_boNoItem              := False;
  m_nBodyLeathery         := 50;
  m_boFixedHideMode       := False;
  m_boStickMode           := False;
  m_boNoAttackMode        := False;
  m_boNoTame              := False;
  m_NoPoison              := False;
  m_boPKFlag              := False;
  MasterFeature := 0;
  ForceMoveToMaster := FALSE;
  m_nHongMoSuite          := 0;
  m_db3B0                 := 0;
  SuckupEnemyHealthRate   := 0;
  SuckupEnemyHealth       := 0;
  SuckupEnemyManaRate     := 0;
  SuckupEnemyMana         := 0;
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  m_MsgList               := TList.Create;
  m_VisibleHumanList      := TList.Create;
  LIst_3EC                := TList.Create;
  m_VisibleActors         := TList.Create;
  m_VisibleItems          := TList.Create;
  m_VisibleEvents         := TList.Create;
  m_AutoItem              := TList.Create;
  m_ItemList              := TList.Create;
  m_DealItemList          := TList.Create;
  m_RentalItemList        := TList.Create; //대여
  m_boIsVisibleActive     := False;
  RefObjCount := 0;
  m_nProcessRunCount      := 0;
  m_nDealGolds            := 0;
  m_nRentalDay            := 0;  //대여 기간
  m_nRentalGolds          := 0;  //대여 금전
  m_nExGolds              := 0;  //환전
  m_nExGameGolds          := 0;  //환전
  m_MagicList             := TList.Create;
  m_StorageItemList       := TList.Create;   //여관       //창고
  FillChar(m_UseItems, SizeOf(THumanUseItems), 0);
  m_MagicOneSwordSkill    := nil;   //외수검법
  m_MagicGukCheSkill      := nil;   //격체전공
  m_MagicPowerHitSkill    := nil;   //예도검법
  m_AssassinHitSkill      := nil;   //절명검법
  m_MagicHemorrhageSkill  := nil;   //혈풍격

  m_MagicWindBladeSkill   := nil;   //풍검술
  m_MagicErgumSkill       := nil;   //어검술
  m_MagicTaguSkill        := nil;
  m_MagicBanwolSkill      := nil;   //반월검법
  m_MagicFireSwordSkill   := nil;   //염화결
  m_MagicDeathSwordSkill  := nil;
  m_MagicCrsSkill         := nil;   //광풍참
  m_MagicNanCrsSkill      := nil;   //난화혈풍참
  m_MagicCrsBongskill     := nil;
  m_MagicTwnHitSkill      := nil;   //쌍룡참
  m_MagicThunderShaolin   := nil;
  m_MagicFireShaolin      := nil;
  m_MagicVampSkill        := nil;   //흡기
  m_MagicChunMuSkill      := nil;
  m_Slave                 := nil;
  m_GroupOwner            := nil;
  m_Castle                := nil;
  m_Master                := nil;
  n294                    := 0;
  m_btSlaveExpLevel       := 0;

  m_GroupMembers          := TStringList.Create;  //그룹
  m_boHearWhisper         := True;
  m_boBanShout            := True;
  m_boBanStoreShout       := True;
  m_boBanGuildChat        := True;
  m_boBanGroupChat        := True;
  m_boBanSysMsg           := True;
  m_boHearMsg             := True;
  m_boAllowRental         := True;
  m_boAllowDeal           := True;
  m_boAllowGroupReCall    := False;      //천지합일
  m_BlockWhisperList      := TStringList.Create;
  m_SlaveList             := TList.Create;
  m_PetList               := TList.Create;
  FillChar(m_WAbil, SizeOf(TAbility), #0);
  FillChar(m_QuestUnitOpen, SizeOf(TQuestUnit),#0);
  FillChar(m_QuestUnit,SizeOf(TQuestUnit),#0);

  SafeFillChar(m_MissionIndex, SizeOf(m_MissionIndex), 0);


  m_Abil.Level            := 1;
  m_Abil.AC               := 0;
  m_Abil.MAC              := 0;
  m_Abil.DC               := MakeLong(1,4);
  m_Abil.MC               := MakeLong(1,2);
  m_Abil.SC               := MakeLong(1,2);
  m_Abil.HP               := 15;
  m_Abil.MP               := 15;
  m_Abil.MaxHP            := 15;
  m_Abil.MaxMP            := 15;
  m_Abil.Exp              := 0;
  m_Abil.MaxExp           := 50;
  m_Abil.Weight           := 0;
  m_Abil.MaxWeight        := 100;
  m_boWantRefMsg          := False;
  m_boRentaling           := False;   //대여
  m_boDealing             := False;
  m_RentalCreat           := nil; //대여
  m_DealCreat             := nil;
  m_MyGuild               := nil;
  m_nGuildRankNo         := 0;
  m_sGuildRankName       := '';
  m_sScriptLable         := '';
  m_boMission            := False;
  m_boPenetrateMode      := False;
  nPowerDefen        := 0;
  nPowerMagDefen     := 0;
  m_boYeongMu            := False;    //월영무
  m_PenetrateLastTick    := 0;
  m_boHideMode           := False;    //월영술
  m_boStoneMode          := False;
  m_boCoolEye            := False;
  m_boUserUnLockDurg     := False;     //미지수
  m_boTransparent        := False;
  m_boAdminMode          := False;
  m_boObMode             := False;   //감시자
  m_dwRunTick            := GetTickCount + LongWord(Random(1500));
  m_nRunTime             := 250;
  m_dwSearchTime         := Random(2000) + 2000;
  m_dwSearchTick         := GetTickCount;
  m_dwDecPkPointTick     := GetTickCount;
  m_DecLightItemDrugTick := GetTickCount();
  BoDisapear := FALSE;
  m_dwPoisoningTick      := GetTickCount;
  m_dwHemorrHageTick     := GetTickCount;
  m_dwOhaengTick         := GetTickCount;
  m_dwVerifyTick         := GetTickCount();
  m_dwCheckRoyaltyTick   := GetTickCount();
  m_dwCheckStatiey       := GetTickCount();
  m_btAiMode             := 0;
  m_boHeroCall       := False;
  m_boHeroBackCall   := False;
  m_dwHPMPTick           := GetTickCount();
  m_dwShoutMsgTick       := 0;     //외치기 딜레이
  m_dwMacroMsgTick       := 0;  //매크로 딜레이
  m_dwTeleportTick       := 0;
  LatestSpaceScrollTime  := 0;
  m_dwProbeTick          := 0;
  m_dwMapMoveTick        := GetTickCount();
  m_dwMapMoveTick2       := GetTickCount();
  m_dwMasterTick         := 0;
  m_nWalkSpeed           := 1400;     //걷기 속도
  m_nNextHitTime         := 3000;
  m_nWalkCount           := 0;
  m_dwWalkWaitTick       := GetTickCount();
  m_boWalkWaitLocked     := False;
  m_nHealthTick         := 0;
  m_nSpellTick          := 0;
  m_TargetCret          := nil;
  m_LastHiter           := nil;
  m_ExpHitter           := nil;
  m_SayMsgList          := nil;
  m_boDenyRefStatus     := False;
  m_btFishType          := 0;       //낚시 중
  m_btHorseType         := -1;
  m_btDressEffType      := 0;
  m_dwPKDieLostExp      := 0;
  m_nPKDieLostLevel     := 0;

  m_boAddToMaped := False; //관리자시스템
  m_boDelFormMaped := False; //관리자시스템

  BoDontMove  := FALSE;
  m_boFastParalysis       := False;

  m_boNastyMode           := False;
  m_boCanLooseDura        := True;
  m_boHighLevelEffect     := TRUE; //레벨50 이팩트
  m_boOhaeng                := False;
  m_HumLevelEffectTick    := GetTickCount(); //이팩트 틱 카운트

  BoLoseTargetMoment := FALSE; //스쳐
  MeltArea := 2;
  BodyState := 0;
  PushedCount := 0;

  MultiplyTargetLevelMin := 0;
  MultiplyTargetLevelMax := 0;

  M_StorageItemstr        := TStringList.Create;     //여관     //창고
  M_StorageItemTick       := GetTickCount;         //여관      //창고
  M_StorageItemboot       :=False;                //여관       //창고

  m_nHeroGrade := 0;
  m_sMasterName := '';
  m_btLimitLevel := 0;
  m_btHeroAutoDurg := 0;
end;

destructor TBaseObject.Destroy;//004B80C0
var
  I           :Integer;
  SendMessage :pTSendMessage;
  nCheckCode  :Integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::Destroy Code: %d';
begin
 nCheckCode:=0;
  try
    nCheckCode:=1;
    for I:=0 to m_MsgList.Count -1 do begin
      nCheckCode:=2;
      SendMessage:=m_MsgList.Items[I];
      if (SendMessage.wIdent = RM_SENDDELITEMLIST) and (SendMessage.nParam1 <> 0) then begin
        nCheckCode:=3;
        if TStringList(SendMessage.nParam1) <> nil then begin
          TStringList(SendMessage.nParam1).Free;
          nCheckCode:=4;
        end;
      end;
      if (SendMessage.wIdent = RM_10401) and (SendMessage.nParam1 <> 0) then begin
        nCheckCode:=5;
        Dispose(pTSlaveInfo(SendMessage.nParam1));
      end;
      nCheckCode:=6;
      if (SendMessage.Buff <> nil) then begin
        nCheckCode:=7;
        FreeMem(SendMessage.Buff);
      end;
      Dispose(SendMessage);
      nCheckCode:=8;
    end;//004B81EE
    nCheckCode:=9;
    FreeAndNil(m_MsgList);
    nCheckCode:=10;
    FreeAndNil(m_VisibleHumanList);
    nCheckCode:=11;
    for i:=0 to LIst_3EC.Count -1 do begin

    end;//004B8249
    LIst_3EC.Free;
    nCheckCode:=12;
    if m_VisibleActors <> nil then begin
      if m_VisibleActors.Count > 0 then begin
        for i := 0 to m_VisibleActors.Count - 1 do begin
          if pTVisibleBaseObject(m_VisibleActors.Items[i]) <> nil then
            DisPose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
        end;
      end;
      nCheckCode := 13;
      FreeAndNil(m_VisibleActors);
    end;
    nCheckCode:=14;
    if m_VisibleItems <> nil then begin
      if m_VisibleItems.Count > 0 then begin
        for i := 0 to m_VisibleItems.Count - 1 do begin
          if pTVisibleMapItem(m_VisibleItems.Items[i]) <> nil then
            DisPose(pTVisibleMapItem(m_VisibleItems.Items[i]));
        end;
      end;
      nCheckCode := 15;
      FreeAndNil(m_VisibleItems);
    end;
    nCheckCode:=16;
    m_VisibleEvents.Free;
    nCheckCode:=17;
    if m_ItemList <> nil then begin
      if m_ItemList.Count > 0 then begin
        for i := 0 to m_ItemList.Count - 1 do begin
          if pTUserItem(m_ItemList.Items[i]) <> nil then
            DisPose(pTUserItem(m_ItemList.Items[i]));
        end;
      end;
      nCheckCode := 18;
      FreeAndNil(m_ItemList);
    end;
    nCheckCode:=19;
    if m_DealItemList <> nil then begin  //거래 아이템 리스트
      if m_DealItemList.Count > 0 then begin
        for i := 0 to m_DealItemList.Count - 1 do begin
          if pTUserItem(m_DealItemList.Items[i]) <> nil then
            DisPose(pTUserItem(m_DealItemList.Items[i]));
        end;
      end;
      FreeAndNil(m_DealItemList);
      nCheckCode := 20;
    end;
    if m_AutoItem <> nil then begin
      if m_AutoItem.Count > 0 then begin
       for I := 0 to m_AutoItem.Count - 1 do begin
         if pTUserItem(m_AutoItem.Items[i]) <> nil then
            DisPose(pTUserItem(m_AutoItem.Items[i]));
       end;
      end;
      nCheckCode := 128;
      FreeAndNil(m_AutoItem);
    end;

    if m_RentalItemList <> nil then begin  //대여 아이템 리스트
      if m_RentalItemList.Count > 0 then begin
        for i := 0 to m_RentalItemList.Count - 1 do begin
          if pTUserItem(m_RentalItemList.Items[i]) <> nil then
            DisPose(pTUserItem(m_RentalItemList.Items[i]));
        end;
      end;
      FreeAndNil(m_RentalItemList);
      nCheckCode := 20;
    end;

    for i:=0 to m_MagicList.Count -1 do begin
      Dispose(pTUserMagic(m_MagicList.Items[i]));
    end;//004B83D8
    FreeAndNil(m_MagicList);
    nCheckCode := 21;

    if m_StorageItemList <> nil then begin         //여관         //창고
      if m_StorageItemList.Count > 0 then begin
        for i := 0 to m_StorageItemList.Count - 1 do begin
          if pTUserItem(m_StorageItemList.Items[i]) <> nil then
            DisPose(pTUserItem(m_StorageItemList.Items[i]));
        end;
      end;
      FreeAndNil(m_StorageItemList);
      nCheckCode := 22;
    end;
    FreeAndNil(m_GroupMembers);   //그룹
    nCheckCode:=23;
    FreeAndNil(m_BlockWhisperList);
    nCheckCode:=24;
    FreeAndNil(m_SlaveList);
    nCheckCode:=25;
    FreeAndNil(m_PetList);

    if M_StorageItemstr <> nil then     //여관          //창고
     FreeAndNil(M_StorageItemstr);
  except
    on e: Exception do begin
      MainOutMessage(format(sExceptionMsg,[nCheckCode]));
      MainOutMessage(E.Message);
    end;
  end;
  {
  for I := 0 to CertCheck.Count - 1 do begin
    if CertCheck.Items[I] = Self then begin
      CertCheck.Delete(I);
      break;
    end;
  end;
  }
  inherited;
end;

procedure TBaseObject.ChangePKStatus(boWarFlag:Boolean);//004B84C8
begin
  if m_boInFreePKArea <> boWarFlag then begin
    m_boInFreePKArea:=boWarFlag;
    m_boNameColorChanged:=True;
  end;
end;

function TBaseObject.GetDropPosition (nOrgX,nOrgY,nRange:Integer;var nDX:Integer;var nDY:Integer):Boolean;//004C5238
var
 i,ii,iii:Integer;
 nItemCount,n24,n28,n2C:integer;
begin
  n24:=999;
  Result:=False;
  n28:=0; //09/10
  n2C:=0; //09/10
  for I := 1 to nRange do begin
    for II := -I to I  do begin
      for III := -I to I do begin
        nDX:=nOrgX + III;
        nDY:=nOrgY + II;
        if m_PEnvir.GetItemEx(nDX,nDY,nItemCount) = nil then begin
          if m_PEnvir.BoCanGetItem then begin
            Result:=True;
            break;
          end;
        end else begin
          if m_PEnvir.BoCanGetItem and (n24 > nItemCount) then begin
            n24:=nItemCount;
            n28:=nDX;
            n2C:=nDY;
          end;
        end;
      end;
      if Result then break;
    end;
    if Result then break;
  end;
  if not Result then begin
    if n24 < 8 then begin
      nDX:=n28;
      nDY:=n2C;
    end else begin
      nDX:=nOrgX;
      nDY:=nOrgY;
    end;
  end;
end;
//004C5478
function  TBaseObject.DropItemDown (UserItem:pTUserItem;nScatterRange:Integer;boDieDrop:Boolean;ItemOfCreat,DropCreat:TBaseObject): Boolean;  //아이템 버리기
var
   dx, dy, idura: integer;
   MapItem, pr: pTMapItem;
   StdItem:TItem;
   logcap: string;
   ItemCount:integer;
   countstr : string;
   sUserItemName: string;
begin
   Result := FALSE;
   countstr := '';
   StdItem:= UserEngine.GetStdItem (UserItem.wIndex);
   if StdItem <> nil then begin
      if StdItem.StdMode = 40 then begin   //고기
         idura := UserItem.Dura;
         idura := idura - 2000;
         if idura < 0 then idura := 0;
         UserItem.Dura := idura;
      end;
      New(MapItem);
      MapItem.UserItem := UserItem^;
      MapItem.Name := StdItem.Name;
      if (StdItem.StdMode in [0,1,3,45,46]) and (UserItem.Amount > 1)  then begin      //갯수 아이템 일경우
        countstr :=  '(' + IntToStr(UserItem.Amount) + ')';
        MapItem.Name := FilterStdShowName(StdItem,StdItem.Name) + countstr;
      end else begin
        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then begin
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        end;
        if sUserItemName <> '' then
          MapItem.Name := FilterStdShowName(StdItem,sUserItemName);
      end;
      MapItem.Looks := StdItem.Looks;
      MapItem.AniCount := StdItem.AniCount;
      MapItem.Reserved := 0;
      MapItem.Grade := StdItem.Grade;
      MapItem.Count := 1;
      MapItem.OfBaseObject:=ItemOfCreat;
      MapItem.dwCanPickUpTick:=GetTickCount();
      MapItem.DropBaseObject:=DropCreat;

      if StdItem.StdMode = 48 then begin  //상현아이템
        MapItem.Name := GetDecoName(MakeWord(UserItem.btValue[5],UserItem.btValue[6])) + '[' + IntToStr(Round(UserItem.DuraMax/1000)) + ']' + '/' + IntToStr(MapItem.Grade) + '/' + '1';
        MapItem.Looks := MakeWord(UserItem.btValue[5],UserItem.btValue[6]) + 10000;
      end else begin
        MapItem.Name := MapItem.Name + '/' + IntToStr(MapItem.Grade) + '/' + '0';
      end;
      if m_btRaceServer = 234 then begin  //if the race = parts of em then the drop should be randomly below the mob not at it's location
        dx := random(10);
        dy := random(10) + 5;
        nScatterRange:=2;
        GetDropPosition ((m_nCurrX - 5) + dx, m_nCurrY + dy, nScatterRange, dx, dy);
      end else
      if m_btRaceServer in [138,140] then begin  //팎莖침질
        dx := random(8);
        dy := random(8) + 7;
        nScatterRange:=2;
        GetDropPosition ((m_nCurrX - 7) + dx, m_nCurrY + dy, nScatterRange, dx, dy);
      end else
      if StdItem.StdMode = 48 then begin //상현아이템
        dx:= m_nCurrx;
        dy:= m_nCurry;
        m_PEnvir.GetItemEx(dx,dy,itemcount);
        if (itemcount > 0) or (m_PEnvir.m_GuildTerritory =  nil) then begin
          Dispose (MapItem);
          exit;
        end;
        TTerritory(TGuild(m_MyGuild).m_Territory).NewDecoration(UserItem,dx,dy,m_PEnvir,True);
      end else
        GetDropPosition (m_nCurrX, m_nCurrY, nScatterRange, dx, dy);
      pr := m_PEnvir.AddToMap (dx, dy, OS_ITEMOBJECT, TObject (MapItem));
      if pr = MapItem then begin

         SendRefMsg (RM_ITEMSHOW, MapItem.Looks, integer(MapItem), dx, dy, MapItem.Name);
         if boDieDrop then logcap := '15'
         else logcap := '7';
        // if not IsCheapStuff (StdItem.StdMode) then
            //004C5716
            if StdItem.NeedIdentify = 1 then
             if logcap = '7' then
              AddGameDataLog(logcap + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                        '0' + #9 + '[땔폴]');
            if logcap = '15' then
             AddGameDataLog(logcap + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                        '0' + #9 + '[숄혤]');

         Result := TRUE;
      end else begin
         Dispose (MapItem);
      end;
   end;
end;

procedure TBaseObject.GoldChanged();//004C49F4
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self,RM_GOLDCHANGED,0,0,0,0,'');
  end;
  if m_nGold > g_Config.nHumanMaxGold then begin
    MainOutMessage('[쏜귑긴뫘] 실ッ: ' + m_sCharName + ' 쏜귑鑒좆: ' + IntToStr(m_nGold) );
  end;
end;

procedure TBaseObject.PointChanged();//004C49F4
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self,RM_POINTCHANGED,0,0,0,0,'');
  end;
end;

procedure TBaseObject.GameGoldChanged();//004C49F4
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendUpdateMsg(Self,RM_GAMEGOLDCHANGED,0,0,0,0,'');
  end;
end;

procedure TBaseObject.BoxMsg(sMsg:String; mode: integer);
begin
  if m_btRaceServer <> RC_PLAYOBJECT then begin
    MainOutMessage('TCreature.BoxMsg : not Human');
    exit;
  end;

  SendMsg(Self,RM_MENU_OK,0,Integer(Self),0,0,sMsg);
end;

function TBaseObject.CanMove: Boolean;
begin
  if (not m_boDeath) and (not m_boGhost) and
    (m_wStatusTimeArr[POISON_STONE] = 0) and
    (m_wStatusTimeArr[POISON_FREEZE] = 0) and
    (m_wStatusTimeArr[POISON_STUN] = 0)  then   //쌍룡참 버그
    Result := True
  else
    Result := False;
end;

function TBaseObject.GetHitSpeed: Integer;
begin
  if (m_wStatusTimeArr[POISON_SLOWDOWN] > 0) then begin
    Result := (m_nNextHitTime div 2) + m_nNextHitTime;
    exit;
  end else begin
    Result := m_nNextHitTime;
  end;
end;

function TBaseObject.GetWalkSpeed: Integer;
begin
  if (m_wStatusTimeArr[POISON_SLOWDOWN] > 0) then begin
    Result := (m_nWalkSpeed div 2) + m_nWalkSpeed;
    exit;
  end else begin
    Result := m_nWalkSpeed;
  end;
end;

function  TPlayObject.ClientPickUpItem: Boolean; //004C5CB0        //아이템 획득
  function IsSelf(BaseObject:TBaseObject):Boolean;
  begin
    if (BaseObject = nil) or (Self = BaseObject) then Result:=True
    else Result:=False;
  end;
  function IsOfGroup(BaseObject:TBaseObject):Boolean;
  var
    I: Integer;
    GroupMember:TBaseObject;
  begin
    Result:=False;
    if m_GroupOwner = nil then exit;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin    //그룹
      GroupMember:=TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if GroupMember = BaseObject then begin
        Result:=True;
        break;
      end;
    end;
  end;
  function PickUpItem(PlayObject: TPlayObject; MapItem: PTMapItem; var ItemName: string): Boolean;
  var
    UserItem, AddUserItem: PTUserItem;
    StdItem: TItem;
    nBack: Integer;
    GroupObject: TPlayObject;
    i, ItemIdx, nDura: Integer;
    nCount, nMyCount, nAddCount: Integer;
    PlayList: array[0..13] of TPlayObject;
    PlayCount: Integer;
    sSendMsg: string;
    boot: Boolean;
    nDateDropped:DWord;
  begin
    Result := False;
    ItemName := '';
    //금전
    if CompareText (MapItem.Name, sSTRING_GOLDNAME) = 0 then begin
      if m_PEnvir.DeleteFromMap (m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
        if (m_GroupOwner <> nil) and m_GroupOwner.m_GroupClass then begin
          SendRefMsg(RM_ITEMHIDE, 1, Integer(MapItem), m_nCurrX, m_nCurrY, '');
          PlayCount := 0;
          for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
            if PlayCount > High(PlayList) then break;
            GroupObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
            if (not GroupObject.m_boGhost) and (GroupObject <> PlayObject) and
              (GroupObject.m_PEnvir = PlayObject.m_PEnvir) and
              (abs(GroupObject.m_nCurrX - PlayObject.m_nCurrX) <= g_Config.nSendRefMsgRange) and           //범위가 멀어지면,,
              (abs(GroupObject.m_nCurrY - PlayObject.m_nCurrY) <= g_Config.nSendRefMsgRange) then begin
              PlayList[PlayCount] := GroupObject;
              Inc(PlayCount);
            end;
          end;
          if PlayCount > 0 then begin
            nCount := MapItem.Count div (PlayCount + 1);
            nMyCount := MapItem.Count mod PlayCount;
            for i := 0 to PlayCount - 1 do begin
              if PlayObject = PlayList[i] then
                nAddCount := nCount + nMyCount
              else
                nAddCount := nCount;
              if PlayList[i].IncGold(nAddCount) then begin
                if g_boGameLogGold then //004C5E8C
                 AddGameDataLog('4' +  #9 +
                     PlayList[i].m_sMapName + #9 +
                     IntToStr(PlayList[i].m_nCurrX) + #9 +
                     IntToStr(PlayList[i].m_nCurrY) + #9 +
                     PlayList[i].m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[숄혤렘駕(롸잚)]');
                PlayList[i].GoldChanged;
                Result := True;
              end else
                Inc(nMyCount, nAddCount);
            end;
            nAddCount := nCount + nMyCount;
          end else begin
            nAddCount := MapItem.Count;
          end;
          if PlayObject.IncGold(nAddCount) then begin
            if g_boGameLogGold then //004C5E8C
              AddGameDataLog('4' +  #9 +
                     PlayObject.m_sMapName + #9 +
                     IntToStr(PlayObject.m_nCurrX) + #9 +
                     IntToStr(PlayObject.m_nCurrY) + #9 +
                     PlayObject.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[숄혤렘駕(홍꼬)]');
            PlayObject.GoldChanged;
            Result := True;
          end;
          if Result then begin
            DisPose(MapItem);
            ItemName := sSTRING_GOLDNAME;
          end else
            m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
        end else begin
          if PlayObject.IncGold (MapItem.Count) then begin
            SendRefMsg (RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY, '');
            if g_boGameLogGold then //004C5E8C
             AddGameDataLog('4' +  #9 +
                     PlayObject.m_sMapName + #9 +
                     IntToStr(PlayObject.m_nCurrX) + #9 +
                     IntToStr(PlayObject.m_nCurrY) + #9 +
                     PlayObject.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(MapItem.Count) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[홍꼬]');
            PlayObject.GoldChanged;
            Dispose(MapItem);
            ItemName := sSTRING_GOLDNAME;
            Result := True;
          end else
            m_PEnvir.AddToMap (m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
        end;
      end;
      exit;
    end;
    //일반 아이템
    if IsEnoughBag then begin
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin
      New(UserItem);
      UserItem^ := MapItem.UserItem;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);

      if StdItem.StdMode = 48 then begin //상현아이템
        nDateDropped:=Makelong(MakeWord(UserItem.btValue[1],UserItem.btValue[2]),MakeWord(UserItem.btValue[3], UserItem.btValue[4]));
        inc(nDateDropped,120000);
        if (m_MyGuild = nil) or (TTerritory(TGuild(m_MyGuild).m_Territory)=nil)  or (UserItem.btValue[0] <> TTerritory(TGuild(m_MyGuild).m_Territory).TerritoryNumber) then begin
          SysMsg('撻唐契삔鏤蹈돨契삔옵鹿賈痰촘拳켠陋干契삔鏤蹈。',c_Red,t_Hint);
          StdItem := nil;
        end;
        if (stditem <> nil) and (nDateDropped < DateTimeToUnix(Now())) then begin //fastest way to stop ppl from picking up
          if IsGuildMaster = false then begin
            SysMsg('2롸爐빈꼽옵鹿疼늴賈痰촘拳켠。',c_Red,t_Hint);
            StdItem := nil;
          end;
        end;
        if StdItem <> nil then
          TTerritory(TGuild(m_MyGuild).m_Territory).DeleteDecoration(m_nCurrX,m_nCurry,m_PEnvir);
      end;

      if (StdItem <> nil) then begin
        ItemIdx := SetSayItem(UserItem);
        sSendMsg := '[#7' + PlayObject.m_sCharName + '#7]삿돤죄';
        sSendMsg := sSendMsg + '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(UserItem.MakeIndex) + '} ';
        sSendMsg := sSendMsg + '。';

        SendRefMsg(RM_ITEMHIDE, 1, Integer(MapItem), m_nCurrX, m_nCurrY, '');
        PlayObject.AddItemToBag(UserItem,boot);
        if boot then
        PlayObject.SendAddItem(UserItem,1);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('4' +  #9 +
                                    PlayObject.m_sMapName + #9 +
                                    IntToStr(PlayObject.m_nCurrX) + #9 +
                                    IntToStr(PlayObject.m_nCurrY) + #9 +
                                    PlayObject.m_sCharName + #9 +
                                    StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                                    IntToStr(UserItem.MakeIndex) + #9 +
                                    '1' + #9 +
                                    '0' + #9 + '[홍꼬]');

        DisPose(MapItem);
        ItemName := StdItem.Name;
        Result := True;
        if m_GroupOwner <> nil then begin
          for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
            PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
            if PlayObject = nil then Continue;
            PlayObject.SysMsg(sSendMsg, c_BlueWhite, t_Hint);
          end;
        end;
      end else begin
        DisPose(UserItem);
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
      end;
    end;
    end;
  end;

var
  MapItem:pTMapItem;
  I:Integer;
  PlayObject:TPlayObject;
  PlayList: array[0..13] of TPlayObject;
  PlayCount: Integer;
  ItemName: string;
begin
  Result:=False;
  if m_boDealing or m_boRentaling then exit; //교환중에는 물건을 주울 수 없다.
  MapItem:=m_PEnvir.GetItem (m_nCurrX,m_nCurrY);
  if MapItem = nil then exit;

  if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
    MapItem.OfBaseObject:=nil;
  end;
  if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then begin
    SysMsg(g_sCanotPickUpItem,c_Red,t_Hint);
    exit;
  end;

  if (m_GroupOwner <> nil) and m_GroupOwner.m_GroupClass and (CompareText(MapItem.Name, sSTRING_GOLDNAME) <> 0) then begin
    PlayCount := 0;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
      if PlayCount > High(PlayList) then
        break;
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if PlayObject.IsEnoughBag and (not PlayObject.m_boGhost) and (m_PEnvir = PlayObject.m_PEnvir) and
        (abs(m_nCurrX - PlayObject.m_nCurrX) <= g_Config.nSendRefMsgRange) and
        (abs(m_nCurrY - PlayObject.m_nCurrY) <= g_Config.nSendRefMsgRange) then begin
        PlayList[PlayCount] := PlayObject;
        Inc(PlayCount);
      end;
    end;
    if PlayCount > 0 then begin
      PlayCount := Random(PlayCount);
      Result := PickUpItem(PlayList[PlayCount], MapItem, ItemName);
    end;
  end else
    Result := PickUpItem(Self, MapItem, ItemName);
end;



procedure TPlayObject.RunNotice;//004DA588
var
  Msg:TProcessMessage;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::RunNotice';
begin
  if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then begin
    if m_boKickFlag then SendDefMessage(SM_OUTOFCONNECTION,0,0,0,0,'');
    MakeGhost();
  end else begin
    try
      if not m_boSendNotice then begin
        SendNotice();
        m_boSendNotice:=True;
        m_dwWaitLoginNoticeOKTick:=GetTickCount();
      end else begin
        if GetTickCount - m_dwWaitLoginNoticeOKTick > 40 * 1000 {10 * 1000} then begin
          m_boEmergencyClose:=True;
        end;
        while GetMessage(@Msg) do begin
          if Msg.wIdent = CM_LOGINNOTICEOK_EX then begin
          //  SetClientVersion(Msg.nParam1);
            SendNoticeEx(Msg.sMsg);
            m_dwWaitLoginNoticeOKTick := GetTickCount();
          end
          else if msg.wIdent = CM_LOGINNOTICEOK then begin
            m_boLoginNoticeOK:=True;
            m_dwClientTick:=Msg.nParam1;
           // SysMsg(IntToStr(m_dwClientTick),c_Red,t_Notice);
          end;
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  end;
end;
procedure TPlayObject.WinExp(dwExp: LongWord);     //경험치
begin
  dwExp:=g_Config.dwKillMonExpMultiple * dwExp;
  dwExp:=LongWord(m_nKillMonExpMultiple) * dwExp;

  dwExp:=ROUND((m_nKillMonExpRate / 100) * dwExp);
  dwExp:=ROUND((m_nKillMonExpRate2 / 100) * dwExp); //경험치가산
  dwExp:=ROUND((m_nKillMonExpRate3 / 100) * dwExp); //검성 검후 경험치
  dwExp:=ROUND((m_nKillMonExpRate4 / 100) * dwExp); //사제 경치
  dwExp:=ROUND((m_nKillMonExpRate5 / 100) * dwExp);  //초보문파 경험치
  dwExp:=ROUND((m_nKillMonExpRate6 / 100) * dwExp);   //문파성장 경험치
  dwExp:=ROUND((m_nKillMonExpRate7 / 100) * dwExp); //gm 이벤트 경험치
  dwExp:=ROUND((m_nKillMonExpRate8 / 100) * dwExp); //gm 이벤트 경험치
  dwExp:=ROUND((m_nKillMonExpRate9 / 100) * dwExp);
  dwExp:=ROUND((m_nKillMonExpRate10 / 100) * dwExp);
  dwExp:=ROUND((m_nKillMonExpRate11 / 100) * dwExp);
  if m_PEnvir.Flag.boEXPRATE then
    dwExp:=ROUND((m_PEnvir.Flag.nEXPRATE / 100) * dwExp);

  if m_boExpItem then begin
    dwExp:=ROUND(m_rExpItem * dwExp);
  end;
  GetExp(dwExp);
end;

procedure TPlayObject.GetExp(dwExp: LongWord);//004BEB74    //경험치
var
 Hum: TPlayObject;
 ListCnt :integer;
begin

  Inc(m_Abil.Exp,dwExp);
  AddBodyLuck(dwExp * 0.002);
  SendMsg(Self,RM_WINEXP,0,dwExp,0,0,'');

  if m_Abil.Exp >= m_Abil.MaxExp then begin
    Dec(m_Abil.Exp,m_Abil.MaxExp);
    if m_Abil.Level < MAXUPLEVEL then begin
      Inc(m_Abil.Level);
    end;

    HasLevelUp(m_Abil.Level - 1);
    AddBodyLuck(100);
    AddGameDataLog('12' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_Abil.Level) + #9 +
                     IntToStr(m_Abil.Exp) + #9 +
                     m_sCharName + #9 +
                     '0' + #9 +
                     '0' + #9 +
                     '1' + #9 +
                     '0' + #9 + '[薨 ]');
    IncHealthSpell(2000,2000);


    if fMentor <> nil then begin   //사제 스쳐
      if fMentor.GetMode = 0 then begin   //내가 제자
        Hum := UserEngine.GetPlayObject(fMentor.GetMentorName);
        if Hum <> nil then begin
          if Hum.fMentor.GetMentorName <> '' then begin
            ListCnt := ((m_Abil.Level - 1 ) * 210);
            Hum.m_nMasterUpExp := Hum.m_nMasterUpExp + ListCnt;
             if Hum.m_nMasterUpExp >= 7200 then
               Hum.m_nMasterUpExp := 7200;
             if ListCnt >= 7200 then
               ListCnt := 7200;

            ListCnt := Round(ListCnt / 60);

            Hum.SysMsg(format(g_sChangeMasterExpRateMsg,[ListCnt]),c_BlueWhite,t_Hint);
          end;
        end;
      end;
    end;

  end;
end;

procedure TPlayObject.GetGuildExp(dwGExp:Integer);   //문파성장 경험치
var
  GuildRank:pTGuildRank;
  I,II:Integer;
  PlayObject:TPlayObject;
begin
  TGuild(m_MyGuild).nGuildExp := TGuild(m_MyGuild).nGuildExp + dwGExp;

  if TGuild(m_MyGuild).nGuildExp >= TGuild(m_MyGuild).nGuildMaxExp then begin
    TGuild(m_MyGuild).nGuildExp := TGuild(m_MyGuild).nGuildExp - TGuild(m_MyGuild).nGuildMaxExp ;
    if TGuild(m_MyGuild).nGuildLevel < MAXUPGUILDLEVEL then begin
      TGuild(m_MyGuild).nGuildLevel := TGuild(m_MyGuild).nGuildLevel + 1;
      TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint + 1;
    end;
    HasLevelUpGuild(TGuild(m_MyGuild).nGuildLevel - 1);
  end;
  TGuild(m_MyGuild).SaveGuildInfoFile();
  TGuild(m_MyGuild).LoadGuildConfig(TGuild(m_myGuild).sGuildName + '.ini');
  SysMsg('콱삿돤죄' + IntToStr(dwGExp) + '듐契삔쒔駱令。',c_Green,t_Hint);

  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    for II:=0 to GuildRank.MemberList.Count -1 do begin
      PlayObject:=TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject = nil then Continue;
        PlayObject.ClientQueryGuildGrow2(Self);
    end;
  end;


end;

procedure TBaseObject.RecalcLevelAbilitys();//004BF7DC
var
  nLevel,n:integer;
begin
{$IF OEMVER = OEM775}

{$ELSE}
  nLevel:=m_Abil.Level;
  case m_btJob of
    jTaos: begin
      m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)));

      m_Abil.MaxMP:=_MIN(High(Word),13 + ROUND(((nLevel / g_Config.nLevelValueOfTaosMP)* 2.2 * nLevel)));

      m_Abil.MaxWeight:=50 + ROUND((nLevel / 4) * nLevel);
      m_Abil.MaxWearWeight:=15 + ROUND((nLevel / 50) * nLevel);
      m_Abil.MaxHandWeight:=12 + ROUND((nLevel / 42) * nLevel);

      n:=nLevel div 7;
      m_Abil.DC:=MakeLong(_MAX(n-1, 0), _MAX(1, n));
      m_Abil.MC:=0;
      m_Abil.SC:=MakeLong(_MAX(n-1, 0), _MAX(1, n));
      m_Abil.AC:=0;

      n:=ROUND(nLevel / 6);
      m_Abil.MAC:=MakeLong(n div 2, n + 1);
    end;
    jUpTao: begin
      m_Abil.MaxHP:=_MIN(High(Word),14 + 95 + ROUND(((nLevel / g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)));

      m_Abil.MaxMP:=_MIN(High(Word),13 + 75 + ROUND(((nLevel / g_Config.nLevelValueOfTaosMP)* 2.2 * nLevel)));

      m_Abil.MaxWeight:=50 + ROUND((nLevel / 4) * nLevel);
      m_Abil.MaxWearWeight:=15 + ROUND((nLevel / 50) * nLevel);
      m_Abil.MaxHandWeight:=12 + ROUND((nLevel / 42) * nLevel);

      n:=nLevel div 7;
      m_Abil.DC:=MakeLong(_MAX(n-1, 0), _MAX(1, n));
      m_Abil.MC:=0;
      m_Abil.SC:=MakeLong(_MAX(n-1, 0), _MAX(1, n + 5));
      m_Abil.AC:=0;

      n:=ROUND(nLevel / 6);
      m_Abil.MAC:=MakeLong(n div 2, n + 1);
    end;

    jWizard: begin
      m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)));

      m_Abil.MaxMP:=_MIN(High(Word),13 + ROUND((nLevel / 5 + 2) * 2.2 * nLevel));
      m_Abil.MaxWeight:=50 + ROUND((nLevel / 5) * nLevel);
      m_Abil.MaxWearWeight:= 15 + ROUND((nLevel / 100) * nLevel);
      m_Abil.MaxHandWeight:= 12 + ROUND((nLevel / 90) * nLevel);

      n:=nLevel div 7;
      m_Abil.DC:=MakeLong(_MAX(n-1, 0), _MAX(1, n));
      m_Abil.MC:=MakeLong(_MAX(n-1, 0), _MAX(1, n));
      m_Abil.SC:=0;
      m_Abil.AC:=0;
      m_Abil.MAC:=0;
    end;

    jUpWiz: begin
      m_Abil.MaxHP:=_MIN(High(Word),14 + 50 + ROUND(((nLevel / g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)));

      m_Abil.MaxMP:=_MIN(High(Word),13 + 120 + ROUND((nLevel / 5 + 2) * 2.2 * nLevel));
      m_Abil.MaxWeight:=50 + ROUND((nLevel / 5) * nLevel);
      m_Abil.MaxWearWeight:= 15 + ROUND((nLevel / 100) * nLevel);
      m_Abil.MaxHandWeight:= 12 + ROUND((nLevel / 90) * nLevel);

      n:=nLevel div 7;
      m_Abil.DC:=MakeLong(_MAX(n-1, 0), _MAX(1, n));
      m_Abil.MC:=MakeLong(_MAX(n-1, 0), _MAX(1, n + 5));
      m_Abil.SC:=0;
      m_Abil.AC:=0;
      m_Abil.MAC:=0;
    end;

    jWarr: begin
      m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));

      m_Abil.MaxMP:=_MIN(High(Word),11 + ROUND(nLevel * 3.5));
      m_Abil.MaxWeight:= 50 + ROUND((nLevel / 3) * nLevel);
      m_Abil.MaxWearWeight:= 15 + ROUND((nLevel / 20) * nLevel);
      m_Abil.MaxHandWeight:= 12 + ROUND((nLevel / 13) * nLevel);

      m_Abil.DC:= MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
      m_Abil.SC:= 0;
      m_Abil.MC:= 0;
      m_Abil.AC:= MakeLong(0, (nLevel div 11));
      m_Abil.MAC:= 0;
    end;
    jUpWarr: begin
      m_Abil.MaxHP:=_MIN(High(Word),14 + 120 + ROUND(((nLevel / g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) * nLevel)));

      m_Abil.MaxMP:=_MIN(High(Word),11 + 50 + ROUND(nLevel * 3.5));
      m_Abil.MaxWeight:= 50 + ROUND((nLevel / 3) * nLevel);
      m_Abil.MaxWearWeight:= 15 + ROUND((nLevel / 20) * nLevel);
      m_Abil.MaxHandWeight:= 12 + ROUND((nLevel / 13) * nLevel);

      m_Abil.DC:= MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5 + 4)));
      m_Abil.SC:= 0;
      m_Abil.MC:= 0;
      m_Abil.AC:= MakeLong(0, (nLevel div 11 + 1));
      m_Abil.MAC:= 0;
    end;
    jAssassin: begin     //자객 피
      m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND(((nLevel / 5 + 3.4 + nLevel / 52) * nLevel)));
      m_Abil.MaxMP:=_MIN(High(Word),11 + ROUND(nLevel * 5));

      m_Abil.MaxWeight:=67 + ROUND((nLevel / 3.6) * nLevel);
      m_Abil.MaxWearWeight:=15 + ROUND((nLevel / 35) * nLevel);
      m_Abil.MaxHandWeight:=12 + ROUND((nLevel / 28) * nLevel);

      n:=nLevel;
      m_Abil.DC:= MakeLong(_MAX((n div 5) - 1, 1), _MAX(1, (n div 5)));      //파괴
      m_Abil.SC:= 0;
      m_Abil.MC:= 0;
      m_Abil.AC:=MakeLong(0, (n div 14));
      m_Abil.MAC:= MakeLong(_MAX((n div 10) - 1, 0), _MAX((n div 6) - 1, 1));
    end;
    jUpAssa : begin     //자객 피
      m_Abil.MaxHP:=_MIN(High(Word),14 + 100 + ROUND(((nLevel / 5 + 3.4 + nLevel / 52) * nLevel)));
      m_Abil.MaxMP:=_MIN(High(Word),11 + 70 + ROUND(nLevel * 5));
      m_Abil.MaxWeight:=67 + ROUND((nLevel / 3.6) * nLevel);
      m_Abil.MaxWearWeight:=15 + ROUND((nLevel / 35) * nLevel);
      m_Abil.MaxHandWeight:=12 + ROUND((nLevel / 28) * nLevel);

      n:=nLevel;
      m_Abil.DC:= MakeLong(_MAX((n div 5) - 1, 1), _MAX(1, (n div 5 + 2)));      //파괴
      m_Abil.SC:= 0;
      m_Abil.MC:= 0;
      m_Abil.AC:=MakeLong(0, (n div 14));
      m_Abil.MAC:= MakeLong(_MAX((n div 10) - 1, 0), _MAX((n div 6) - 1 + 1, 1));
    end;
    jBonze,jUpBoz: begin     //승려
    //  m_Abil.MaxHP:=_MIN(High(Word),15 + ROUND(((nLevel / 6 + 2.5) * nLevel)));
      m_Abil.MaxHP := _MIN(High(Word), 15 + Round(((nLevel * 3.4) + (nLevel / 2.6) * nLevel / 4.0)));
      m_Abil.MaxMP := _MIN(High(Word), 11 + Round(((nLevel / 11) * 3.0) * (nLevel / 1.8)));

      m_Abil.MaxWeight := 50 + Round((nLevel / 3.5) * nLevel);
      m_Abil.MaxWearWeight := 15 + Round((nLevel / 53.4) * nLevel);
      m_Abil.MaxHandWeight := 12 + Round((nLevel / 54.4) * nLevel);

      n := nLevel div 15;
      m_Abil.DC := MakeLong( _MAX( Round(nLevel / 6.2) - 1 , 1), _MAX(1, Round(nLevel / 4.4) - 1 ) ) ;
      m_Abil.SC := MakeLong( _MAX(n - 1, 1), _MAX(1, Round(1/(nLevel + 10.5) + nLevel/12.2)));

      m_Abil.MC := 0;

      m_Abil.MAC := MakeLong(0, Round(nLevel / 12));
      m_Abil.AC := MakeLong(0, Round(nLevel / 8));
    end;
  end;
  if m_Abil.HP > m_Abil.MaxHP then m_Abil.HP:=m_Abil.MaxHP;
  if m_Abil.MP > m_Abil.MaxMP then m_Abil.MP:=m_Abil.MaxMP;
{$IFEND}
end;

procedure TBaseObject.HasLevelUp(nLevel:Integer);//004BED6C
var
  ListCnt : integer;
  BaseObject: TBaseObject;
begin
  m_Abil.MaxExp:=GetLevelExp(m_Abil.Level);
  RecalcLevelAbilitys();
  RecalcAbilitys();
  m_nCharStatus:=GetCharStatus();
  GetObjectEffect;   //기퍼짐
  StatusChanged();
  FeatureChanged();
  //Changed 'from' SendMsg so everyone can see effect
 // SendRefMsg(RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
  if m_btRaceServer = RC_PLAYOBJECT then begin
    SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
    if (m_GroupOwner <> nil) then begin
      TPlayObject(m_GroupOwner).SendGroupMsg(TPlayObject(Self), SM_GROUPINFO2, 0, 0, 0, 0, '');
    end;
  end else begin
    SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
  end;
{$IFDEF FOR_ABIL_POINT}

   if prevlevel + 1 = Abil.Level then begin
      BonusPoint := BonusPoint + GetBonusPoint (Job, Abil.Level);
      SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
   end else begin
      if prevlevel <> Abil.Level then begin
         BonusPoint := GetLevelBonusSum (Job, Abil.Level);
         FillChar (BonusAbil, sizeof(TNakedAbility), #0);
         FillChar (CurBonusAbil, sizeof(TNakedAbility), #0);
         RecalcLevelAbilitys;
         SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end;
   end;
{$ENDIF}

  if (g_FunctionNPC <> nil) then
    g_FunctionNPC.GotoLable(TPlayObject(Self),'@LevelUp',False);
end;

procedure TBaseObject.HasLevelUp2(nLevel:Integer);//004BED6C    //등선변환
begin
  m_Abil.MaxExp:=GetLevelExp(m_Abil.Level);
  RecalcLevelAbilitys();
  RecalcAbilitys();
  m_nCharStatus:=GetCharStatus();
  GetObjectEffect;   //기퍼짐
  StatusChanged();
  FeatureChanged();
  SendRefMsg(RM_LEVELUP2, 0, m_Abil.Exp, 0, 0, '');


{$IFDEF FOR_ABIL_POINT}

   if prevlevel + 1 = Abil.Level then begin
      BonusPoint := BonusPoint + GetBonusPoint (Job, Abil.Level);
      SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
   end else begin
      if prevlevel <> Abil.Level then begin
         BonusPoint := GetLevelBonusSum (Job, Abil.Level);
         FillChar (BonusAbil, sizeof(TNakedAbility), #0);
         FillChar (CurBonusAbil, sizeof(TNakedAbility), #0);
         RecalcLevelAbilitys;
         SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end;
   end;
{$ENDIF}

  if (g_FunctionNPC <> nil) then
    g_FunctionNPC.GotoLable(TPlayObject(Self),'@LevelUp2',False);
end;

procedure TBaseObject.HasLevelUp3(nLevel:Integer);//보너스 포인트
begin
  m_Abil.MaxExp:=GetLevelExp(m_Abil.Level);
  RecalcLevelAbilitys();
  RecalcAbilitys();
  m_nCharStatus:=GetCharStatus();
  GetObjectEffect;   //기퍼짐
  StatusChanged();
  FeatureChanged();
  //Changed 'from' SendMsg so everyone can see effect
  SendRefMsg(RM_LEVELUP3, 0, m_Abil.Exp, 0, 0, '');

{$IFDEF FOR_ABIL_POINT}

   if prevlevel + 1 = Abil.Level then begin
      BonusPoint := BonusPoint + GetBonusPoint (Job, Abil.Level);
      SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
   end else begin
      if prevlevel <> Abil.Level then begin
         BonusPoint := GetLevelBonusSum (Job, Abil.Level);
         FillChar (BonusAbil, sizeof(TNakedAbility), #0);
         FillChar (CurBonusAbil, sizeof(TNakedAbility), #0);
         RecalcLevelAbilitys;
         SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      end;
   end;
{$ENDIF}

  if (g_FunctionNPC <> nil) then
    g_FunctionNPC.GotoLable(TPlayObject(Self),'@LevelUp',False);
end;

procedure TBaseObject.HasLevelUpGuild(nLevel:Integer);//문파성장
begin
  TGuild(m_MyGuild).nGuildMaxExp :=GetGuldLevelExp(TGuild(m_MyGuild).nGuildLevel);

  RecalcAbilitys();
end;

function TBaseObject.IncGold(tGold: Integer):Boolean;//004BF64C
begin
  Result:=False;
  if tGold < 0 then exit;

  if Int64(m_nGold) + tGold <= g_Config.nHumanMaxGold then begin
     m_nGold := m_nGold + tGold;
     Result:=True;

     if tGold >= 5000000 then begin
       if g_boGameLogGold then
         //로그 남겨야 함
         AddGameDataLog('14'+ #9 + //금전_
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     sSTRING_GOLDNAME{'금전'} + #9 +
                     IntToStr(tGold) + ''#9 +
                     IntToStr(m_Abil.level) + #9 +
                     IntToStr(m_nGold) + #9 + '[삿돤쏜귑]');
     end;

  end;
end;

function TPlayObject.IncPCPoint(nPoint: Integer):Boolean;//004BF64C
begin
  Result:=False;
  if nPoint < 0 then exit;

  if m_nPCPoint + nPoint <= 2000000 then begin
     Inc(m_nPCPoint, nPoint);
     Result:=True;
  end;
end;

procedure TPlayObject.IncGameGold(nGameGold: Integer);
begin
  Inc(m_nGameGold, nGameGold);
end;


procedure AddUserLog(sMsg: String);//004E42F8
begin
  MainOutMessage(sMsg);
end;

function TBaseObject.WalkTo(btDir:Byte;boFlag:boolean):Boolean;//004C3F64
var
  nOX,nOY,nNX,nNY,n20,n24:Integer;
  //Envir:TEnvirnoment;
  bo29:Boolean;
  PlayObject :TPlayObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::WalkTo';
begin
  Result:=False;
  if m_boHolySeize or m_boPobakSeize then exit;   //결계 포박 걸리면 못걷는다.
  try
    nOX:=m_nCurrX;
    nOY:=m_nCurrY;
    m_btDirection:=btDir;
    nNX:=0;
    nNY:=0;
   case btDir of
      DR_UP         :begin nNX:= m_nCurrX;   nNY:= m_nCurrY-1; end;
      DR_UPRIGHT    :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY-1; end;
      DR_RIGHT      :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY; end;
      DR_DOWNRIGHT  :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY+1; end;
      DR_DOWN       :begin nNX:= m_nCurrX;   nNY:= m_nCurrY+1; end;
      DR_DOWNLEFT   :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY+1; end;
      DR_LEFT       :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY; end;
      DR_UPLEFT     :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY-1; end;
   end;
   if (nNX >= 0) and ((m_PEnvir.m_nWidth - 1 ) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 1) >= nNY) then begin
     bo29:=True;
     if bo2BA and not m_PEnvir.CanSafeWalk(nNX,nNY) then bo29:=False;
     if m_Master <> nil then begin
       m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX,m_Master.m_nCurrY,m_Master.m_btDirection,1,n20,n24);
       if (nNX = n20) and (nNY = n24) then bo29:=False;
     end;
     if bo29 then begin
       if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nNX,nNY,boFlag) > 0 then begin
         m_nCurrX:=nNX;
         m_nCurrY:=nNY;
       end;
     end;
   end;
   if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then begin
     if Walk(RM_WALK) then begin             //걷기
       if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;   //BoHumHideMode
       Result:=True;
     end else begin
       m_PEnvir.DeleteFromMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
       m_nCurrX:=nOX;
       m_nCurrY:=nOY;
       m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
     end;
   end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;


function TBaseObject.PetWalkTo(btDir:Byte;boFlag:boolean):Boolean;//004C3F64
var
  nOX,nOY,nNX,nNY,n20,n24:Integer;
  bo29:Boolean;
  PlayObject :TPlayObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::PetWalkTo';
begin
  Result:=False;
  try
    nOX:=m_nCurrX;
    nOY:=m_nCurrY;
    m_btDirection:=btDir;
    nNX:=0;
    nNY:=0;
   case btDir of
      DR_UP         :begin nNX:= m_nCurrX;   nNY:= m_nCurrY-1; end;
      DR_UPRIGHT    :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY-1; end;
      DR_RIGHT      :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY; end;
      DR_DOWNRIGHT  :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY+1; end;
      DR_DOWN       :begin nNX:= m_nCurrX;   nNY:= m_nCurrY+1; end;
      DR_DOWNLEFT   :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY+1; end;
      DR_LEFT       :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY; end;
      DR_UPLEFT     :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY-1; end;
   end;
   if (nNX >= 0) and ((m_PEnvir.m_nWidth - 1 ) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 1) >= nNY) then begin
     bo29:=True;
     if m_Master <> nil then begin
       m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX,m_Master.m_nCurrY,m_Master.m_btDirection,1,n20,n24);
       if (nNX = n20) and (nNY = n24) then bo29:=False;
     end;
     if bo29 then begin
       if m_PEnvir.PetMoveToMovingObject(m_nCurrX,m_nCurrY,Self,nNX,nNY,boFlag) > 0 then begin
         m_nCurrX:=nNX;
         m_nCurrY:=nNY;
       end;
     end;
   end;
   if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then begin
     if Walk(RM_WALK) then begin         
       Result:=True;
     end else begin
       m_PEnvir.DeleteFromMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
       m_nCurrX:=nOX;
       m_nCurrY:=nOY;
       m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
     end;
   end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;


function TBaseObject.DownWalkTo(btDir:Byte;boFlag:boolean):Boolean;//004C3F64      //월영술
var
  nOX,nOY,nNX,nNY,n20,n24:Integer;
  bo29:Boolean;
  PlayObject :TPlayObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::DownWalkTo';
begin
  Result:=False;
  if m_boHolySeize or m_boPobakSeize then exit;   //결계 포박 걸리면 못걷는다.
  try
    nOX:=m_nCurrX;
    nOY:=m_nCurrY;
    m_btDirection:=btDir;
    nNX:=0;
    nNY:=0;
   case btDir of
      DR_UP         :begin nNX:= m_nCurrX;   nNY:= m_nCurrY-1; end;
      DR_UPRIGHT    :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY-1; end;
      DR_RIGHT      :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY; end;
      DR_DOWNRIGHT  :begin nNX:= m_nCurrX+1; nNY:= m_nCurrY+1; end;
      DR_DOWN       :begin nNX:= m_nCurrX;   nNY:= m_nCurrY+1; end;
      DR_DOWNLEFT   :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY+1; end;
      DR_LEFT       :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY; end;
      DR_UPLEFT     :begin nNX:= m_nCurrX-1; nNY:= m_nCurrY-1; end;
   end;
   if (nNX >= 0) and ((m_PEnvir.m_nWidth - 1 ) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 1) >= nNY) then begin
     bo29:=True;
     if bo2BA and not m_PEnvir.CanSafeWalk(nNX,nNY) then bo29:=False;
     if m_Master <> nil then begin
       m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX,m_Master.m_nCurrY,m_Master.m_btDirection,1,n20,n24);
       if (nNX = n20) and (nNY = n24) then bo29:=False;
     end;
     if bo29 then begin
       if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nNX,nNY,boFlag) > 0 then begin
         m_nCurrX:=nNX;
         m_nCurrY:=nNY;
       end;
     end;
   end;
   if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then begin
     if Walk(RM_DOWN) then begin             //걷기
       if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;
       Result:=True;
     end else begin
       m_PEnvir.DeleteFromMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
       m_nCurrX:=nOX;
       m_nCurrY:=nOY;
       m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
     end;
   end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TBaseObject.AssWalkTo(btDir:Byte;boFlag:boolean):Boolean;//004C3F64
var
  nOX,nOY,nNX,nNY,n20,n24:Integer;
  bo29:Boolean;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::runTo';
begin
  Result:=False;
  if m_boHolySeize or m_boPobakSeize then exit;   //결계 포박 걸리면 못걷는다.
  try
    nOX:=m_nCurrX;
    nOY:=m_nCurrY;
    m_btDirection:=btDir;
    nNX:=0;
    nNY:=0;
   case btDir of
      DR_UP         :begin nNX:= m_nCurrX;   nNY:= m_nCurrY-2; end;
      DR_UPRIGHT    :begin nNX:= m_nCurrX+2; nNY:= m_nCurrY-2; end;
      DR_RIGHT      :begin nNX:= m_nCurrX+2; nNY:= m_nCurrY; end;
      DR_DOWNRIGHT  :begin nNX:= m_nCurrX+2; nNY:= m_nCurrY+2; end;
      DR_DOWN       :begin nNX:= m_nCurrX;   nNY:= m_nCurrY+2; end;
      DR_DOWNLEFT   :begin nNX:= m_nCurrX-2; nNY:= m_nCurrY+2; end;
      DR_LEFT       :begin nNX:= m_nCurrX-2; nNY:= m_nCurrY; end;
      DR_UPLEFT     :begin nNX:= m_nCurrX-2; nNY:= m_nCurrY-2; end;
   end;
   if (nNX >= 0) and ((m_PEnvir.m_nWidth - 2 ) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 2) >= nNY) then begin
     bo29:=True;
     if bo2BA and not m_PEnvir.CanSafeWalk(nNX,nNY) then bo29:=False;
     if m_Master <> nil then begin
       m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX,m_Master.m_nCurrY,m_Master.m_btDirection,2,n20,n24);
       if (nNX = n20) and (nNY = n24) then bo29:=False;
     end;
     if bo29 then begin
       if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nNX,nNY,boFlag) > 0 then begin
         m_nCurrX:=nNX;
         m_nCurrY:=nNY;
       end;
     end;
   end;
   if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then begin
     if Walk(RM_RUN) then begin
       if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;
       Result:=True;
     end else begin
       m_PEnvir.DeleteFromMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
       m_nCurrX:=nOX;
       m_nCurrY:=nOY;
       m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
     end;
   end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.IsEnoughBag: Boolean;//004C4990
begin
  Result:=False;
  if m_ItemList.Count < MAXBAGITEM then
    Result:=True;
end;

function TPlayObject.IsAddWeightAvailable(nWeight:Integer): Boolean; //004C4A78
begin
  Result:=False;
  if (m_WAbil.Weight + nWeight) <= m_WAbil.MaxWeight then
    Result:=True;
end;

procedure TPlayObject.SendAddItemmode(UserItem:pTUserItem;idx:integer);      //물약
var
  Item:TItem;
  ClientItem:TClientItem;
  sUserItemName: string;
  opt: integer;
begin
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
  if Item = nil then exit;
  Item.GetStandardItem(ClientItem.S);
  opt := Item.GetItemAddValue(UserItem, ClientItem.S);

  sUserItemName := '';
  sUserItemName := FilterStdShowName(Item,Item.Name);
  if UserItem.btValue[11] = 1 then
   sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
  if sUserItemName <> '' then
   ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

  ClientItem.MakeIndex:=UserItem.MakeIndex;
  ClientItem.Dura:=UserItem.Dura;
  ClientItem.DuraMax:=UserItem.DuraMax;
  ClientItem.Amount:=UserItem.Amount;
  ClientItem.UpgradeOpt := opt;
  m_DefMsg:=MakeDefaultMsg(SM_ADDITEM2,Integer(Self),0,0,idx);
  SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
end;

procedure TPlayObject.SendAddItem(UserItem:pTUserItem;idx:integer); //004D0824  //아이템 획득
var
  Item:TItem;
  StdItem:TStdItem;
  ClientItem:TClientItem;
  PlayObject:TPlayObject;
  I :integer;
  CharName1:TCharName1;
  sSendMsg:String;
  sUserItemName, stditemname: string;
  opt: integer;
begin
  sSendMsg:= '';
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
  if not (Item.StdMode in [2,46]) then begin

  if (Item.Reserved and 16 <> 0) then begin
    stditemname:= FilterStdShowName(Item,Item.Name);
    if (self.m_btJob in [g_Bonze,g_BonzeUp]) then begin         //승려
      if self.m_WAbil.Level >= 80 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '60');
      end else if self.m_WAbil.Level >= 70 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '50');
      end else if self.m_WAbil.Level >= 60 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '40');
      end else if self.m_WAbil.Level >= 50 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '30');
      end else if self.m_WAbil.Level >= 40 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '20');
      end else if self.m_WAbil.Level >= 30 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '10');
      end else begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '00');
      end;
    end else begin
      if self.m_WAbil.Level >= 80 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '6');
      end else if self.m_WAbil.Level >= 70 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '5');
      end else if self.m_WAbil.Level >= 60 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '4');
      end else if self.m_WAbil.Level >= 50 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '3');
      end else if self.m_WAbil.Level >= 40 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '2');
      end else if self.m_WAbil.Level >= 30 then begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '1');
      end else begin
        UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName);
      end;
    end;
    Item:=UserEngine.GetStdItem(UserItem.wIndex);
  end;

  if (Item.Reserved and 32 <> 0) then begin
    stditemname := FilterStdShowName(Item,Item.Name);
    if (self.m_btJob in [g_Warrior,g_WarriorUp]) then
      UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '1');
    if (self.m_btJob in [g_Wizard,g_WizardUp])then
      UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '2');
    if (self.m_btJob in [g_Monk,g_MonkUp]) then
      UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '3');
    if (self.m_btJob in [g_Assassin,g_AssassinUp]) then                     //자객
      UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '4');
    if (self.m_btJob in [g_Bonze,g_BonzeUp]) then                         //승려
      UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '5');
    Item:=UserEngine.GetStdItem(UserItem.wIndex);
  end;

  end;


  if Item = nil then exit;
  Item.GetStandardItem(ClientItem.S);
  opt := Item.GetItemAddValue(UserItem, ClientItem.S);

  sUserItemName := '';

  sUserItemName := FilterStdShowName(Item,Item.Name);

  if UserItem.btValue[11] = 1 then
    sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
  if sUserItemName <> '' then
    ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

  ClientItem.MakeIndex:=UserItem.MakeIndex;
  ClientItem.Dura:=UserItem.Dura;
  ClientItem.DuraMax:=UserItem.DuraMax;
  ClientItem.Amount:=UserItem.Amount;
  ClientItem.UpgradeOpt := opt;
  m_DefMsg:=MakeDefaultMsg(SM_ADDITEM,Integer(Self),0,0,idx);
  SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));

  //그룹 획득 메시지
  if m_GroupOwner <> nil then begin
    for i:=0 to m_GroupOwner.m_GroupMembers.Count-1 do begin
      PlayObject:=TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if PlayObject = nil then Continue;
      PlayObject.SendDefMessage(SM_ADDGROUPITEM, Integer(self), UserItem.Amount, Item.Grade, 0, ClientItem.s.Name);
    end;
  end;
end;

procedure TPlayObject.SendAddStorage(UserItem:pTUserItem); //004D0824      //여관  //창고
var
  Item:TItem;
  StdItem:TStdItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: String;
begin
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
  if Item = nil then exit;
  Item.GetStandardItem(ClientItem.S);
  opt := Item.GetItemAddValue(UserItem, ClientItem.S);

  sUserItemName := '';
  sUserItemName := FilterStdShowName(Item,Item.Name);
  if UserItem.btValue[11] = 1 then
   sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
  if sUserItemName <> '' then
   ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

  ClientItem.MakeIndex:=UserItem.MakeIndex;
  ClientItem.Dura:=UserItem.Dura;
  ClientItem.DuraMax:=UserItem.DuraMax;
  ClientItem.Amount:=UserItem.Amount;
  ClientItem.UpgradeOpt := opt;
  m_DefMsg:=MakeDefaultMsg(SM_ADDSTORAGE,Integer(Self),0,0,1);
  SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
end;

procedure TPlayObject.SendAddStorageMode(UserItem:pTUserItem;idx:integer);      //물약2
var
  Item:TItem;
  StdItem:TStdItem;
  ClientItem:TClientItem;
  sUserItemName: string;
  opt: integer;
begin
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
  if Item = nil then exit;
  Item.GetStandardItem(ClientItem.S);
  opt := Item.GetItemAddValue(UserItem, ClientItem.S);

  sUserItemName := '';
  sUserItemName := FilterStdShowName(Item,Item.Name);
  if UserItem.btValue[11] = 1 then
   sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
  if sUserItemName <> '' then
   ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

  ClientItem.S.Name := GetItemName(UserItem);
  ClientItem.MakeIndex:=UserItem.MakeIndex;
  ClientItem.Dura:=UserItem.Dura;
  ClientItem.DuraMax:=UserItem.DuraMax;
  ClientItem.Amount := UserItem.Amount;
  ClientItem.UpgradeOpt := opt;

  m_DefMsg:=MakeDefaultMsg(SM_ADDSTORAGEITEM,Integer(Self),0,0,idx);
  SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
end;

procedure TPlayObject.SendAddHeroAuto(UserItem:pTUserItem); //004D0824      //여관  //창고
var
  Item:TItem;
  StdItem:TStdItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: String;
begin
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
  if Item = nil then exit;
  Item.GetStandardItem(ClientItem.S);
  opt := Item.GetItemAddValue(UserItem, ClientItem.S);

  sUserItemName := '';
  sUserItemName := FilterStdShowName(Item,Item.Name);
  if UserItem.btValue[11] = 1 then
   sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
  if sUserItemName <> '' then
   ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

  ClientItem.MakeIndex:=UserItem.MakeIndex;
  ClientItem.Dura:=UserItem.Dura;
  ClientItem.DuraMax:=UserItem.DuraMax;
  ClientItem.Amount:=UserItem.Amount;
  ClientItem.UpgradeOpt := opt;
  m_DefMsg:=MakeDefaultMsg(SM_ADDHEROAUTO,Integer(Self),0,0,1);
  SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
end;

procedure TPlayObject.ItemTimeRun;   //여관       //창고
var
 I:Integer;
begin
  if M_StorageItemboot and (M_StorageItemstr.Count > 0) then begin
    if (GetTickCount - M_StorageItemTick) > 1000 then begin
     m_DefMsg:=MakeDefaultMsg(SM_STORAGEITEMS,Integer(Self),0,0,0);
     SendSocket(@m_DefMsg,M_StorageItemstr.Strings[0]);
     M_StorageItemstr.Delete(0);
     M_StorageItemTick := GetTickCount;
   end;
 end;

end;

function TBaseObject.IsGroupMember(target:TBaseObject):Boolean; //004C3908    //그룹
var
  I: Integer;
begin
  Result:=False;
  if m_GroupOwner = nil then exit;
  for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
    if m_GroupOwner.m_GroupMembers.Objects[i] = target then begin
      Result:=True;
      break;
    end;
  end;
end;

function TBaseObject.IsSlave(target:TBaseObject):Boolean; //004C3908    소환몹
var
  I: Integer;
begin
  Result:=False;
  if (target.m_Master = self)
    and (target.m_btRaceServer in [JIN_WHITESKELETON,MONSTER_WHITESKELETON,MONSTER_ELFMONSTER,MONSTER_ELFWARRIOR, MONSTER_ANGEL, MONSTER_DARKANGEL])then begin
     Result:=True;
  end;
end;

//004D1558
procedure TPlayObject.Whisper(whostr, saystr: string);
var
  PlayObject:TPlayObject;
  svidx:Integer;
begin
  PlayObject:=UserEngine.GeTPlayObject(whostr);
  if PlayObject <> nil then begin
    if not PlayObject.m_boReadyRun then begin
      SysMsg(whostr + g_sCanotSendmsg, c_Red,t_Hint);
      exit;
    end;
    if not PlayObject.m_boHearWhisper or PlayObject.IsBlockWhisper(m_sCharName) then begin
      SysMsg (whostr + g_sUserDenyWhisperMsg, c_Red,t_Hint);
      exit;
    end;
    if (m_btPermission <> 10) and (PlayObject.m_btPermission > 0) then begin
      UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [寧겹] ' + m_sCharName + ': ' +saystr, 10);  //운영자귓속말  //채팅시스템
    end;
    if m_btPermission > 0 then begin
      UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [밗잿逃] ' + m_sCharName + ': ' +saystr, 10);  //운영자귓속말  //채팅시스템
      PlayObject.SendMsg (PlayObject,RM_WHISPER,0,g_Config.btGMWhisperMsgFColor,g_Config.btGMWhisperMsgBColor,0,m_sCharName + #9 + saystr);
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg (m_GetWhisperHuman,RM_WHISPER,0,g_Config.btGMWhisperMsgFColor,g_Config.btGMWhisperMsgBColor,0, m_sCharName + #9 + PlayObject.m_sCharName + ' ' + saystr);

      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg (PlayObject.m_GetWhisperHuman,RM_WHISPER,0,g_Config.btGMWhisperMsgFColor,g_Config.btGMWhisperMsgBColor,0, m_sCharName + #9 + PlayObject.m_sCharName + ' ' + saystr);
    end else begin
      PlayObject.SendMsg (PlayObject,RM_WHISPER,0,g_Config.btWhisperMsgFColor,g_Config.btWhisperMsgBColor,0,m_sCharName + #9 + saystr);
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg (m_GetWhisperHuman,RM_WHISPER,0,g_Config.btWhisperMsgFColor,g_Config.btWhisperMsgBColor,0, m_sCharName + #9 + PlayObject.m_sCharName + ' ' + saystr);

      if (PlayObject.m_GetWhisperHuman <> nil) and (not PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg (PlayObject.m_GetWhisperHuman,RM_WHISPER,0,g_Config.btWhisperMsgFColor,g_Config.btWhisperMsgBColor,0, m_sCharName + #9 + PlayObject.m_sCharName + ' ' + saystr);
    end;



  end else begin
   { if UserEngine.FindOtherServerUser (whostr, svidx) then begin
      UserEngine.SendServerGroupMsg (SS_WHISPER, svidx, whostr + '/' + m_sCharName + '=> ' + saystr);
    end else begin   }
      SysMsg (whostr + ' ' + g_sUserNotOnLine, c_Red,t_Hint);
  //  end;
  end;
end;

{----------------------------------------------------------}

procedure TPlayObject.LoverWhisper (whostr, saystr: string);
var
   hum: TPlayObject;
   svidx: integer;
begin
   hum := TPlayObject (UserEngine.GetPlayObject (whostr));
   if hum <> nil then begin

      if not hum.m_boReadyRun then begin
         SysMsg (whostr + g_sCanotSendmsg, c_Red,t_Hint);
         exit;
      end;
      if not hum.m_boHearWhisper or hum.IsBlockWhisper (m_sCharName) then begin
         SysMsg (whostr + g_sUserDenyWhisperMsg, c_Red,t_Hint);
         exit;
      end;

      hum.SendMsg (self, RM_LM_WHISPER, 0, 0, 0, 0, m_sCharName + #9 + saystr);
   end else begin
         SysMsg (whostr + g_sUserNotOnLine, c_Red,t_Hint);
   end;
end;

procedure TPlayObject.MasterWhisper (whostr, saystr: string);
var
   hum: TPlayObject;
   svidx: integer;
begin
   hum := TPlayObject (UserEngine.GetPlayObject (whostr));
   if hum <> nil then begin

      if not hum.m_boReadyRun then begin
         SysMsg (whostr + g_sCanotSendmsg, c_Red,t_Hint);
         exit;
      end;
      if not hum.m_boHearWhisper or hum.IsBlockWhisper (m_sCharName) then begin
         SysMsg (whostr + g_sUserDenyWhisperMsg, c_Red,t_Hint);
         exit;
      end;

      hum.SendMsg (self, RM_ME_WHISPER, 0, 0, 0, 0, m_sCharName + #9 + saystr);
   end else begin
         SysMsg (whostr + g_sUserNotOnLine, c_Red,t_Hint);
   end;
end;

//004D199C
function TPlayObject.IsBlockWhisper(sName: String): Boolean;
var
  I: Integer;
begin
  Result:=False;
  for I := 0 to m_BlockWhisperList.Count - 1 do begin
    if CompareText(sName,m_BlockWhisperList.Strings[i]) = 0 then begin
      Result:=True;
      break;
    end;
  end;
end;

function TBaseObject.GetObjectMark(): Byte;     //문파 마크
var
 Guild:TGuild;
begin
  Result := 0;
  if (m_btRaceServer = RC_PLAYOBJECT)  then begin
    if m_btPermission > 9 then begin
      Result := 91;
    end else begin
     Guild:=TGuild(m_MyGuild);
     if m_MyGuild = nil then begin
      Result := 0;
     end else
      Result := Guild.nGuildMark;
    end;
  end;
end;

procedure TBaseObject.GetObjectEffect();     //기퍼짐
begin
   m_btHumEffect := 0;
   if m_boHighLevelEffect then begin
     if (m_Abil.Level >= g_Config.sLevel50Effect) then
        m_btHumEffect := 1;
     if (m_Abil.Level >= g_Config.sLevel60Effect) then
        m_btHumEffect := 2;
     if (m_btJob in [5..9]) then   //직업변경
        m_btHumEffect := 3;
     if (m_btJob in [5..9]) and (m_Abil.Level >= g_Config.sLevel70Effect) then       //직업변경
        m_btHumEffect := 4;
     if (m_Abil.Level >= g_Config.sLevelComEffect) then
        m_btHumEffect := 5;
   end else begin
     m_btHumEffect := 0;
   end;
end;

procedure TBaseObject.GetObjectEventEffect();     //빼빼로
var
 i : integer;
 StdItem:TItem;
 lovername:String;
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
   m_btEventEffect := 0;
   if m_UseItems[U_RIGHTHAND].wIndex > 0 then begin
     StdItem:=UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
     if StdItem <> nil then begin
       if StdItem.StdMode = 30 then begin
         if StdItem.Shape = 3 then begin     //빼빼로
          if m_btGender = 0 then
             m_btEventEffect := 2
          else
             m_btEventEffect := 3
         end else
         if StdItem.Shape = 4 then  //호박
           m_btEventEffect := 4;

         lovername := TPlayObject(self).fLover.GetLoverName;
         if (UserEngine.GetPlayObject(lovername) <> nil) and (StdItem.Shape = 3) then      //하트
           m_btEventEffect := 1;  

       end;
     end;
   end else begin
     m_btEventEffect := 0;
   end;
   FeatureChanged();
  end;
end;


function TBaseObject.PKLevel(): Integer;//004BF0A0
begin
  Result:=m_nPkPoint div 100;
end;

procedure TBaseObject.HealthSpellChanged;//004C4A24
begin
  if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
    SendUpdateMsg(Self,RM_HEALTHSPELLCHANGED,0,0,0,0,'');
    if (m_GroupOwner <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin
      TPlayObject(Self).SendGroupMsg(TPlayObject(Self), SM_GROUPINFO1,
          Integer(Self), m_WAbil.HP, m_WAbil.MP, m_WAbil.MaxHP, IntToStr(m_WAbil.MaxMP));
    end;
  end;
  if m_boShowHP then begin
    SendRefMsg(RM_HEALTHSPELLCHANGED,0,0,0,0,'');
    if (m_btRaceServer = RC_PLAYOBJECT) and (m_GroupOwner <> nil) then begin
      TPlayObject(Self).SendRefGroupMsg(TPlayObject(Self), SM_GROUPINFO1,
        Integer(Self), m_WAbil.HP, m_WAbil.MP, m_WAbil.MaxHP, IntToStr(m_WAbil.MaxMP));
    end;
  end;
end;

procedure TBaseObject.GainExp(dwExp: LongWord);
begin

end;

procedure TBaseObject.GetExp(dwExp: LongWord);
begin

end;

procedure TBaseObject.WinExp(dwExp: LongWord);
begin

end;

function TBaseObject.CalcGetExp(nLevel:Integer;nExp:Integer):Integer;   //004BE59F
begin

  if g_Config.boHighLevelKillMonFixExp or (m_Abil.Level < (nLevel + 10)) then begin
    Result:=nExp;
  end else begin
    Result := nExp - ROUND((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
  end;
  if Result <= 0 then Result:=1;
end;

procedure TBaseObject.RefNameColor();//004BF124
begin
  SendRefMsg(RM_CHANGENAMECOLOR,0,0,0,0,'');
end;

procedure TBaseObject.GainSlaveExp(nLevel:Integer); //004BE8BC
  function GetUpKillCount ():Integer;  //004BE864
  var
    tCount:Integer;
  begin
    if m_btSlaveExpLevel < SLAVEMAXLEVEL -2 then begin
      tCount:=g_Config.MonUpLvNeedKillCount[m_btSlaveExpLevel];
    end else begin
      tCount:=0;
    end;
    Result:=((m_Abil.Level * g_Config.nMonUpLvRate{16}) - m_Abil.Level) + g_Config.nMonUpLvNeedKillBase{100} + tCount
  end;
begin
  if ( m_btRaceServer = RC_CLONE) or ( m_btRaceServer = MONSTER_DARKANGEL) or
      ( m_btRaceServer = MONSTER_ANGEL) or ( m_btRaceServer = RC_DARKCLONE) or ( m_btRaceServer = RC_BONZECLONE) then Exit;

  Inc(n294,nLevel);
  if GetUpKillCount() < n294 then begin
    Dec(n294,GetUpKillCount);
    if m_btSlaveExpLevel < (m_btSlaveMakeLevel * 2 + 1) then begin
      Inc(m_btSlaveExpLevel);
      RecalcAbilitys();
      RefNameColor();
    end;
  end;//004BE92F
end;

function TBaseObject.DropGoldDown(nGold:Integer;boFalg:Boolean;GoldOfCreat,DropGoldCreat:TBaseObject): Boolean; //004C5794
var
  MapItem,MapItemA:PTMapItem;
  nX,nY:Integer;
  s20:String;
  MapItemN:string;
begin
  Result:=False;
  New(MapItem);
  FillChar(MapItem^,SizeOf(TMapItem),#0);
  MapItem.Name:=sSTRING_GOLDNAME;
  MapItem.Count:=nGold;
  MapItem.Grade:= 0;
  MapItem.Looks:=GetGoldShape(nGold);
  MapItem.OfBaseObject:=GoldOfCreat;
  MapItem.dwCanPickUpTick:=GetTickCount();
  MapItem.DropBaseObject:=DropGoldCreat;
  GetDropPosition (m_nCurrX, m_nCurrY, 3, nX,nY);
  MapItemA:=m_PEnvir.AddToMap (nX, nY, OS_ITEMOBJECT, TObject (MapItem));
  if MapItemA <> nil then begin
    if MapItemA <> MapItem then begin
      Dispose(MapItem);
      MapItem:=MapItemA;
    end;
    SendRefMsg (RM_ITEMSHOW, MapItem.Looks, integer(MapItem), nX, nY, MapItem.Name + '/' + '0' + '/' + '0');
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if boFalg then s20:='15'
      else s20:='7';
           //004C5995
          if g_boGameLogGold then
           if s20 = '7' then
            AddGameDataLog(s20 + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        sSTRING_GOLDNAME + #9 +
                        IntToStr(nGold) + #9 +
                        BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                        '0' + #9 + '[땔폴]');
          if s20 = '15' then
           AddGameDataLog(s20 + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        sSTRING_GOLDNAME + #9 +
                        IntToStr(nGold) + #9 +
                        BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                        '0' + #9 + '[숄혤]');
    end; //004C599A
    Result:=True;
  end else Dispose(MapItem);    
end;

function TBaseObject.GetGuildRelation(cert1, cert2: TBaseObject): Integer; //004BF380
begin
  Result:=0;
  m_boGuildWarArea:=False;
  if (cert1.m_MyGuild= nil) or (cert2.m_MyGuild = nil) then exit;
  if cert1.InSafeArea or (cert2.InSafeArea) then exit;        //문파전 금지 구역
  if TGuild(cert1.m_MyGuild).GuildWarList.Count <= 0 then exit;
  m_boGuildWarArea:=True;
  if TGuild(cert1.m_MyGuild).IsWarGuild(TGuild(cert2.m_MyGuild)) and
     TGuild(cert2.m_MyGuild).IsWarGuild(TGuild(cert1.m_MyGuild)) then Result:=2;         //주황색계열, 적

  if cert1.m_MyGuild = cert2.m_MyGuild then Result:=1;  //푸른계열 (우리편)
  if TGuild(cert1.m_MyGuild).IsAllyGuild(TGuild(cert2.m_MyGuild)) and
     TGuild(cert2.m_MyGuild).IsAllyGuild(TGuild(cert1.m_MyGuild)) then Result:=3;      //동맹관계
end;

procedure TBaseObject.IncPkPoint(nPoint: Integer); //피케이
var
  nOldPKLevel:Integer;
begin
  nOldPKLevel:=PKLevel;
  Inc(m_nPkPoint,nPoint);
  if PKLevel <> nOldPKLevel then begin
    if PKLevel <= 2 then RefNameColor;
  end;
end;


function TBaseObject.IncKillPoint(point : integer; onlyFameCur : Boolean) : Boolean;  //킬/데스
var
   hum : TPlayObject;
   FameGrade: integer;
begin
   Result := FALSE;

   //-----------------------------------------
   //명성치가 쌓인다.(현재값, 누적값)
   //-----------------------------------------

   //음수는 취급 안함.
   if point <= 0 then exit;
   //변동치 한계
   if point > 1 then point := 1;

   //Overflow Check
   if m_Abil.KillPointCurr > m_Abil.KillPointCurr + point then exit;
   if m_Abil.KillPoint > m_Abil.KillPoint + point then exit;

   //한계치 적용(최대명성치 3만 제한)
   if m_Abil.KillPointCurr + point > 30000 then exit;
   if m_Abil.KillPoint + point > 30000 then exit;

   //-----------------------
   //포인트 계산
   m_Abil.KillPointCurr := m_Abil.KillPointCurr + point;

   if m_Abil.KillPointCurr > m_Abil.KillPoint then begin
      //FameBase는 안오르고 FameCur값만 오르는 옵션
      if onlyFameCur then
         m_Abil.KillPointCurr := m_Abil.KillPoint
      else
         m_Abil.KillPoint := m_Abil.KillPointCurr;
   end;
   //-----------------------

   if m_btRaceServer = RC_PLAYOBJECT then begin
      hum := TPlayObject(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, hum.GetFameName(FameGrade));
        // SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
   end;

   Result := TRUE;
end;

function TBaseObject.IncDeathPoint(point : integer; onlyFameCur : Boolean) : Boolean;        //킬/데스
var
   hum : TPlayObject;
   FameGrade: integer;
begin
   Result := FALSE;

   //-----------------------------------------
   //명성치가 쌓인다.(현재값, 누적값)
   //-----------------------------------------

   //음수는 취급 안함.
   if point <= 0 then exit;
   //변동치 한계
   if point > 1 then point := 1;

   //Overflow Check
   if m_Abil.DeathPointCurr > m_Abil.DeathPointCurr + point then exit;
   if m_Abil.DeathPoint > m_Abil.DeathPoint + point then exit;

   //한계치 적용(최대명성치 3만 제한)
   if m_Abil.DeathPointCurr + point > 30000 then exit;
   if m_Abil.DeathPoint + point > 30000 then exit;

   //-----------------------
   //포인트 계산
   m_Abil.DeathPointCurr := m_Abil.DeathPointCurr + point;

   if m_Abil.DeathPointCurr > m_Abil.DeathPoint then begin
      //FameBase는 안오르고 FameCur값만 오르는 옵션
      if onlyFameCur then
         m_Abil.DeathPointCurr := m_Abil.DeathPoint
      else
         m_Abil.DeathPoint := m_Abil.DeathPointCurr;
   end;
   //-----------------------

   if m_btRaceServer = RC_PLAYOBJECT then begin
      hum := TPlayObject(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, hum.GetFameName(FameGrade));
        // SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
   end;

   Result := TRUE;
end;

procedure TBaseObject.ZeroFamePoint;      //킬/데스 초기화
var
  hum : TPlayObject;
  FameGrade: integer;
begin
   //명성치를 모두 0으로 만든다.
   m_Abil.KillPointCurr := 0;
   m_Abil.KillPoint := 0;
   m_Abil.DeathPointCurr := 0;
   m_Abil.DeathPoint := 0;

   if m_btRaceServer = RC_PLAYOBJECT then begin
      hum := TPlayObject(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, hum.GetFameName(FameGrade));
         SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, hum.GetFameName(FameGrade));
         hum.SysMsg('콱賈痰츰뵀令求헌죄콱돨鯉띳。',c_Green,t_Hint);
        // SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
   end;
end;

function TBaseObject.UseCurrentFamePoint(usepoint : integer) : Boolean;    //킬 포인트 사용
var
   hum : TPlayObject;
   FameGrade: integer;
begin
   Result := FALSE;

   //-----------------------------------------
   //명성치를 사용한다.(현재값)
   //-----------------------------------------

   //음수는 취급 안함.
   if usepoint <= 0 then exit;

   if m_Abil.KillPointCurr <= usepoint then m_Abil.KillPointCurr := 0
   else m_Abil.KillPointCurr := m_Abil.KillPointCurr - usepoint;

   if m_btRaceServer = RC_PLAYOBJECT then begin
      hum := TPlayObject(self);
      if hum <> nil then
         SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, hum.GetFameName(FameGrade));
         SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, hum.GetFameName(FameGrade));
        // SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
   end;

   Result := TRUE;
end;

procedure TBaseObject.AddBodyLuck(dLuck:Double); //004BF580
var
  n:Integer;
begin
  if (dLuck > 0) and (m_dBodyLuck < 5 * BODYLUCKUNIT) then begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;
  if (dLuck < 0) and (m_dBodyLuck > -(5 * BODYLUCKUNIT)) then begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;

  n := Trunc (m_dBodyLuck / BODYLUCKUNIT);
  if n > 5 then n := 5;
  if n < -10 then n := -10;
  m_nBodyLuckLevel := n;
end;

procedure TBaseObject.MakeWeaponUnlock; //004C1198    //저주표시
var
 PlayObject:TPlayObject;
begin
  if (m_UseItems[U_WEAPON].wIndex <= 0) or (m_UseItems[U_WEAPON].btValue[19] = 1) then exit;  //대여무기 저주
  if m_UseItems[U_WEAPON].btValue[3] > 0 then begin
    Dec(m_UseItems[U_WEAPON].btValue[3]);
    SysMsg(g_sTheWeaponIsCursed,c_Red,t_Hint);
  end else begin
    if m_UseItems[U_WEAPON].btValue[4] < 10 then begin
      Inc(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sTheWeaponIsCursed,c_Red,t_Hint);
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    RecalcAbilitys();
    PlayObject:=TPlayObject(Self);
    PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);  //저주 표시
    SendMsg(Self,RM_ABILITY,0,0,0,0,'');
    SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  end;
end;

function TBaseObject.GetAttackPower(nBasePower,nPower:Integer):Integer;
var
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
begin
  if nPower < 0 then nPower := 0;
  if m_nLuck > 0 then begin
    if Random(10 - _MIN(9,m_nLuck)) = 0 then Result := nBasePower + nPower
    else Result := nBasePower + Random(nPower + 1);
  end else begin
    Result := nBasePower + Random(nPower + 1);
    if m_nLuck < 0 then begin
      if Random(10 - _MAX(0,-m_nLuck)) = 0 then Result := nBasePower;
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    PlayObject:=TPlayObject(Self);
    Result:=ROUND(Result * (PlayObject.m_nPowerRate / 100));
    Result:=ROUND(Result * (PlayObject.m_nPowerRate2 / 100));
    Result:=ROUND(Result * (PlayObject.m_nPowerRate3 / 100));
    Result:=ROUND(Result * (PlayObject.m_nPowerRate4 / 100)); //문파성장 공력
    Result:=ROUND(Result * (PlayObject.m_nPowerRate6 / 100));  //그룹버프 공력
    Result:=ROUND(Result * (PlayObject.m_nPowerRate7 / 100));  //세트 공격력상승
    if PlayObject.m_boPowerItem then
      Result:=ROUND(m_rPowerItem * Result);
  end;

  if m_btRaceServer = RC_HEROOBJECT then begin
    HeroObject := THeroObject(Self);
    Result := Round(Result * (HeroObject.m_nPowerRate / 100));
    Result := Round(Result * (HeroObject.m_nPowerRate3 / 100));
    Result := Round(Result * (HeroObject.m_nPowerRate5 / 100));
    Result := Round(Result * (HeroObject.m_nPowerRate7 / 100));
    if HeroObject.m_boPowerItem then
      Result := Round(m_rPowerItem * Result);
  end;
end;
procedure TBaseObject.DamageHealth(nDamage: Integer); //004BE3FC
var
  nSpdam:Integer;
begin
  if ((m_LastHiter = nil) or not m_LastHiter.m_boUnMagicShield) and m_boMagicShield and (nDamage > 0) and (m_WAbil.MP > 0) then begin
    nSpdam := Round (nDamage * 1.5);
    if integer(m_WAbil.MP) >= nSpdam then begin
      m_WAbil.MP := m_WAbil.MP - nSpdam;
      nSpdam := 0;
    end else begin
      nSpdam := nSpdam - m_WAbil.MP;
      m_WAbil.MP := 0;
    end;
    nDamage := Round (nSpdam / 1.5);
    HealthSpellChanged();
  end;
  if nDamage > 0 then begin
    if (m_WAbil.HP - nDamage) > 0 then begin
      m_WAbil.HP:=m_WAbil.HP - nDamage;
    end else begin
      m_WAbil.HP:=0;
    end;
    if m_boAbilCelestialDefence then begin      //선천기공
      if Random(7) < m_btCelestialDefenceLevel then begin
        m_nIncHealth := (nDamage div 3) + 4 * m_btCelestialDefenceLevel;
      end;
    end;
  end else begin
    if (m_WAbil.HP - nDamage) < m_WAbil.MaxHP then begin
      m_WAbil.HP:=m_WAbil.HP - nDamage;
    end else begin
      m_WAbil.HP:= m_WAbil.MaxHP;
    end;
  end;
end;

procedure TBaseObject.IncHealth(nPlus:Integer);
begin
  if m_WAbil.HP < m_WAbil.MaxHP then begin
    if nPlus > 0 then begin
      if (m_WAbil.HP + nPlus) < m_WAbil.MaxHP then begin
        m_WAbil.HP:=m_WAbil.HP + nPlus;
      end else begin
        m_WAbil.HP:= m_WAbil.MaxHP;
      end;
    end;
  end;
end;

function  TBaseObject.GetBackDir(nDir:integer):Integer;//004B2708
begin
  Result:=0;
  case nDir of
    DR_UP:Result:= DR_DOWN;
    DR_DOWN:Result:= DR_UP;
    DR_LEFT:Result:= DR_RIGHT;
    DR_RIGHT:Result:= DR_LEFT;
    DR_UPLEFT:Result:= DR_DOWNRIGHT;
    DR_UPRIGHT:Result:= DR_DOWNLEFT;
    DR_DOWNLEFT:Result:= DR_UPRIGHT;
    DR_DOWNRIGHT:Result:= DR_UPLEFT;
  end;
end;

procedure  TBaseObject.HitHit2 (target: TBaseObject; hitpwr, magpwr: integer; all: Boolean);
begin
   HitHitEx2 (target, RM_HIT, hitpwr, magpwr, all );
end;

procedure  TBaseObject.HitHitEx2 (target: TBaseObject; rmmsg, hitpwr, magpwr: integer; all: Boolean );
var
   i, dam: integer;
   list: TList;
   cret: TBaseObject;
begin
   m_btDirection := GetNextDirection (m_nCurrX, m_nCurrY, target.m_nCurrX, target.m_nCurrY);
   list := TList.Create;
   m_PEnvir.GetBaseObjects (target.m_nCurrX, target.m_nCurrY, TRUE, list);
   for i:=0 to list.Count-1 do begin
      cret := TBaseObject(list[i]);
      if IsProperTarget (cret) then begin
         dam := 0;
         dam := dam + cret.GetHitStruckDamage (self, hitpwr);
         dam := dam + cret.GetMagStruckDamage (self, magpwr);
         if dam > 0 then begin
            cret.StruckDamage (dam);
            cret.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, dam{wparam},
                     cret.m_WAbil.HP{lparam1}, cret.m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 200);
         end;
      end;
   end;
   FreeAndNil(list);
   SendRefMsg (rmmsg, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;


function  TBaseObject.CharPushed (nDir,nPushCount:Integer): integer; //004C2F90  //무태보
var
   i, nx, ny, olddir, oldx, oldy, nBackDir: integer;
begin
   Result := 0;
   olddir := m_btDirection;
   oldx := m_nCurrX;
   oldy := m_nCurrY;
   m_btDirection := ndir;
   nBackDir:=GetBackDir(ndir);
   for i:=0 to nPushCount - 1 do begin
     GetFrontPosition(nx, ny);
     if m_PEnvir.CanWalk (nX,nY,False) then begin
       if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nX,nY,False) > 0 then begin
         m_nCurrX := nX;
         m_nCurrY := nY;
            //SendRefMsg(RM_PUSH, GetBackDir(ndir), m_nCurrX, m_nCurrY, 0, '');
         SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');
         Inc(Result);
         if m_btRaceServer >= RC_ANIMAL then
            m_dwWalkTick := m_dwWalkTick + 800;
       end else break;
     end else break;
   end;

   m_btDirection:=nBackDir;
   if Result = 0 then m_btDirection:=olddir;
end;

function  TBaseObject.CharDrawingRush (ndir, rushlevel: integer ; isHumanSkill : Boolean): Boolean;  //끌어당김
   function CanPush (cret: TBaseObject): Boolean;
   var
      levelgap: integer;
   begin
      Result := FALSE;
      if (m_Abil.Level > cret.m_Abil.Level) and (not cret.m_boStickMode) then begin
         levelgap := m_Abil.Level - cret.m_Abil.Level;
         if (Random(20) < 6+rushlevel*3+levelgap) then begin  //수련정도에 따라서
            if IsProperTarget(cret) then begin
               Result := TRUE;
            end;
         end;
      end;
   end;
var
   i, nx, ny, damage, damagelevel, mydamagelevel: integer;
   cret, cret2, attackcret: TBaseObject;
   crash: Boolean;
begin
   Result := FALSE;
   crash := TRUE;
   m_btDirection := ndir;
   attackcret := nil;
   damagelevel := rushlevel + 1;
   mydamagelevel := damagelevel;
   cret := GetPoseCreate;

   if cret <> nil then begin
   end else begin
      crash := FALSE;
      for i:=0 to _MAX(2,rushlevel+1) do
      begin
         GetFrontPosition (nx, ny);
         if m_PEnvir.MoveToMovingObject (m_nCurrX,m_nCurrY,Self,nx,ny, FALSE) > 0 then
         begin
            m_nCurrX := nx;
            m_nCurrY := ny;
            SendRefMsg (RM_RUSH, ndir, m_nCurrX, m_nCurrY, 0, '');
            Dec (mydamagelevel);
         end
         else
         begin  //벽에 부L힌 경우
            if m_PEnvir.CanWalk (nx, ny, FALSE) then
               mydamagelevel := 0  //사람때문에 못감
            else crash := TRUE; //벽에 부L힘
            break;
         end;
      end;
   end;

   if ( attackcret <> nil ) and isHumanSkill then
   begin
      if damagelevel < 0 then damagelevel := 0;
      damage := (1+damagelevel)*4 + Random((1+damagelevel) * 5);
      with attackcret do
      begin
         damage := GetHitStruckDamage (self, damage);
         StruckDamage (damage);
         SendRefMsg (RM_STRUCK, damage{wparam}, m_WAbil.HP{lparam1}, m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '');
         //몬스터한테는 직접전달해야 함..
         if m_btRaceServer <> RC_PLAYOBJECT then
            SendMsg (attackcret, RM_STRUCK, damage, m_WAbil.HP, m_WAbil.MaxHP, Longint(self), '');
      end;
   end;

   if crash then begin
      //움직이는 시늉한다.
      GetFrontPosition ( nx, ny);
      SendRefMsg (RM_RUSHKUNG, m_btDirection, nx, ny, 0, '');
      //SendRefMsg (RM_TURN, Dir, CX, CY, 0, '');
      if isHumanSkill then SysMsg ('콱홧랩녑旒제좆。',c_Red,t_Hint);
   end;

   if ( mydamagelevel > 0 )and ( isHumanSkill )then
   begin
      if damagelevel < 0 then damagelevel := 0;
      damage := (1+damagelevel)*5 + Random((1+damagelevel) * 5);
      damage := GetHitStruckDamage (self, damage);
      StruckDamage (damage);
      if(crash) and (m_LastHiter <> nil) then m_LastHiter := nil;
      SendRefMsg (RM_STRUCK, damage{wparam}, m_WAbil.HP{lparam1}, m_WAbil.MaxHP{lparam2}, 0{hiter}, '');
   end;
end;


function  TBaseObject.MagPassThroughMagic (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer; //004C69F4
var                          //염사장
   i, tcount: integer;
   BaseObject:TBaseObject;
begin
   tcount := 0;
   for i:=0 to 12 do begin
     BaseObject:=TBaseObject(m_PEnvir.GetMovingObject(sx,sy,True));
     if BaseObject <> nil then begin
       if IsProperTarget (BaseObject) then begin
         if Random(50) >= BaseObject.m_nAntiMagic then begin
           if undeadattack then
             magpwr := Round (magpwr * 1.5);

           BaseObject.SendDelayMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '', 600);
           Inc (tcount);
         end;
       end;
     end;
     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
       ndir := GetNextDirection (sx, sy, tx, ty);
       if not m_PEnvir.GetNextPosition (sx, sy, ndir, 1, sx, sy) then
         break;
     end else
       break;
   end;
   Result := tcount;
end;

function  TBaseObject.MagPassThroughMagic2 (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer; //004C69F4
var                          //천이검
   i, tcount: integer;
   BaseObject:TBaseObject;
begin
   if m_wStatusTimeArr[STATE_ASSTRANSPARENT] > 0 then  //월영술 및 열화신 공격시.. 풀림
   m_wStatusTimeArr[STATE_ASSTRANSPARENT]:=1;

   if m_wStatusTimeArr[STATE_YEONGMU] > 0 then  //월영무 공격시.. 풀림
   m_wStatusTimeArr[STATE_YEONGMU]:=1;

   tcount := 0;
   for i:=0 to 12 do begin
     BaseObject:=TBaseObject(m_PEnvir.GetMovingObject(sx,sy,True));
     if BaseObject <> nil then begin
       if IsProperTarget (BaseObject) then begin
         if Random(50) >= BaseObject.m_nAntiMagic then begin
           BaseObject.SendDelayMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '', 600);
           Inc (tcount);
         end;
       end;
     end;
     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
       ndir := GetNextDirection (sx, sy, tx, ty);
       if not m_PEnvir.GetNextPosition (sx, sy, ndir, 1, sx, sy) then
         break;
     end else
       break;
   end;
   Result := tcount;
end;

function  TBaseObject.MagPassThroughMagic3 (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer; //맹독검기
var
   i, tcount: integer;
   BaseObject:TBaseObject;
begin
   if m_wStatusTimeArr[STATE_ASSTRANSPARENT] > 0 then  //월영술 및 열화신 공격시.. 풀림
   m_wStatusTimeArr[STATE_ASSTRANSPARENT]:=1;

   if m_wStatusTimeArr[STATE_YEONGMU] > 0 then  //월영무 공격시.. 풀림
   m_wStatusTimeArr[STATE_YEONGMU]:=1;

   tcount := 0;
   for i:=0 to 12 do begin
     BaseObject:=TBaseObject(m_PEnvir.GetMovingObject(sx,sy,True));
     if BaseObject <> nil then begin
       if IsProperTarget (BaseObject) then begin
       if Random(2+BaseObject.m_btAntiPoison) = 0 then begin
        BaseObject.MakePosion(POISON_DECHEALTH, (magpwr div 10) , (magpwr div 5));
       end;
         BaseObject.SendDelayMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '', 600);
         Inc (tcount);
       end;
     end;
     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
       ndir := GetNextDirection (sx, sy, tx, ty);
       if not m_PEnvir.GetNextPosition (sx, sy, ndir, 1, sx, sy) then
         break;
     end else
       break;
   end;
   Result := tcount;
end;



function  TBaseObject.MagPosionThroughMagic (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean; mode: integer): integer; //004C69F4
var
   i, tcount: integer;
   BaseObject:TBaseObject;
begin
   tcount := 0;
   for i:=0 to 12 do begin
     BaseObject:=TBaseObject(m_PEnvir.GetMovingObject(sx,sy,True));
     if BaseObject <> nil then begin
       if IsProperTarget (BaseObject) then begin
         if Random(50) >= BaseObject.m_nAntiMagic then begin
           if undeadattack then
             magpwr := Round (magpwr * 1.5);

           BaseObject.SendDelayMsg (self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '', 600);
           Inc (tcount);

           case mode of
            0: begin       //녹독
              if Random(25 + BaseObject.m_btAntiPoison) = 0 then begin
                BaseObject.MakePosion(POISON_DECHEALTH, 30 , 10);
              end;
            end;
            1: begin       //둔화
              if Random(35 + BaseObject.m_btAntiPoison) = 0 then begin
                BaseObject.MakePosion(POISON_SLOWDOWN,15,0);
              end;
            end;
            2: begin      //빨독
              if (Random(BaseObject.m_btAntiPoison + 15) <= 2)  then begin
                 BaseObject.MakePosion(POISON_DAMAGEARMOR,30,0);
              end;
            end;
           end;

         end;
       end;
     end;
     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
       ndir := GetNextDirection (sx, sy, tx, ty);
       if not m_PEnvir.GetNextPosition (sx, sy, ndir, 1, sx, sy) then
         break;
     end else
       break;
   end;
   Result := tcount;
end;

function  TBaseObject.MagPassIlSum (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer; //004C69F4      //일섬
var
   i, tcount: integer;
   BaseObject:TBaseObject;
begin
   tcount := 0;
   for i:=0 to 12 do begin
     BaseObject:=TBaseObject(m_PEnvir.GetMovingObject(sx,sy,True));
     if BaseObject <> nil then begin
       if IsProperTarget (BaseObject) then begin
            if BaseObject.m_btRaceServer in [RC_ANIMAL,RC_MONSTER, RC_DARKCLONE, RC_BONZECLONE] then begin
             if BaseObject.m_Abil.Level >= 100 then  //왕급 레벨 조절
              magpwr := Round (magpwr * 3)
             else
              magpwr := Round (magpwr * 3.4);
            end else
            magpwr := Round (magpwr * 3);
            magpwr := BaseObject.GetHitStruckDamage (self, magpwr);
            if magpwr > 0 then begin
               BaseObject.SetLastHiter(self);
               BaseObject.StruckDamage (magpwr);
               BaseObject.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, magpwr{wparam},
                                  BaseObject.m_WAbil.HP{lparam1}, BaseObject.m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 800);
            end;
           Inc (tcount);
       end;
     end;
     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
       ndir := GetNextDirection (sx, sy, tx, ty);
       if not m_PEnvir.GetNextPosition (sx, sy, ndir, 1, sx, sy) then
         break;
     end else
       break;
   end;
   Result := tcount;
end;

function  TBaseObject.MagMaPassIlSum (sx, sy, tx, ty, ndir, magpwr: integer; undeadattack: Boolean): integer; //004C69F4      //마혈광섬
var
   i, tcount: integer;
   BaseObject:TBaseObject;
begin
   tcount := 0;
   for i:=0 to 12 do begin
     BaseObject:=TBaseObject(m_PEnvir.GetMovingObject(sx,sy,True));
     if BaseObject <> nil then begin
       if IsProperTarget (BaseObject) then begin
            if BaseObject.m_btRaceServer in [RC_ANIMAL,RC_MONSTER, RC_DARKCLONE, RC_BONZECLONE] then begin
             if BaseObject.m_Abil.Level >= 100 then  //왕급 레벨 조절
              magpwr := Round (magpwr * 3)
             else
              magpwr := Round (magpwr * 3.4);
            end else
            magpwr := Round (magpwr * 3);
            magpwr := BaseObject.GetHitStruckDamage (self, magpwr);
            if magpwr > 0 then begin
               BaseObject.SetLastHiter(self);
               BaseObject.StruckDamage (magpwr);
               BaseObject.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, magpwr{wparam},
                                  BaseObject.m_WAbil.HP{lparam1}, BaseObject.m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 800);
               BaseObject.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, magpwr{wparam},
                                  BaseObject.m_WAbil.HP{lparam1}, BaseObject.m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 1200);
            end;
           Inc (tcount);
       end;
     end;
     if not ((abs(sx-tx) <= 0) and (abs(sy-ty) <= 0)) then begin
       ndir := GetNextDirection (sx, sy, tx, ty);
       if not m_PEnvir.GetNextPosition (sx, sy, ndir, 1, sx, sy) then
         break;
     end else
       break;
   end;
   Result := tcount;
end;

procedure TPlayObject.SendSocket(DefMsg:pTDefaultMessage;sMsg:String);//004CAB38
var
  MsgHdr:TMsgHeader;
  nSendBytes:Integer;
  tBuff:PChar;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::SendSocket..';
begin
  tBuff:=nil;
  try
    MsgHdr.dwCode         := RUNGATECODE;
    MsgHdr.nSocket        := m_nSocket;
    MsgHdr.wGSocketIdx    := m_nGSocketIdx;
    MsgHdr.wIdent         := GM_DATA;

//    MsgHdr.nUserListIndex := 0;
    //004CAB9A
    if DefMsg <> nil then begin
      if sMsg <> '' then begin
        MsgHdr.nLength:=Length(sMsg) + SizeOf(TDefaultMessage) + 1;
        nSendBytes:=MsgHdr.nLength + SizeOf(TMsgHeader);
        GetMem(tBuff,nSendBytes + SizeOf(Integer));
        Move(nSendBytes,tBuff^,SizeOf(Integer));
        Move(MsgHdr,tBuff[SizeOf(Integer)],SizeOf(TMsgHeader));
        Move(DefMsg^,tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],SizeOf(TDefaultMessage));
        Move(sMsg[1],tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) + SizeOf(Integer)],Length(sMsg) + 1);
      end else begin//004CAC29
        MsgHdr.nLength:=SizeOf(TDefaultMessage);
        nSendBytes:=MsgHdr.nLength + SizeOf(TMsgHeader);
        GetMem(tBuff,nSendBytes + SizeOf(Integer));
        Move(nSendBytes,tBuff^,SizeOf(Integer));
        Move(MsgHdr,tBuff[SizeOf(Integer)],SizeOf(TMsgHeader));
        Move(DefMsg^,tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],SizeOf(TDefaultMessage));
      end;
    end else begin//004CAC7F
      if sMsg <> '' then begin
        MsgHdr.nLength:= - (Length(sMsg) + 1);
        nSendBytes:=abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
        GetMem(tBuff,nSendBytes + SizeOf(Integer));
        Move(nSendBytes,tBuff^,SizeOf(Integer));
        Move(MsgHdr,tBuff[SizeOf(Integer)],SizeOf(TMsgHeader));
        Move(sMsg[1],tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],Length(sMsg) + 1);
      end;//004CACF0
    end;//004CACF0
    if not RunSocket.AddGateBuffer(m_nGateIdx,tBuff) then begin
      FreeMem(tBuff);
      //MainOutMessage('SendSocket Buffer Fail ' + IntToStr(m_nGateIdx));
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

procedure TPlayObject.SendDefMessage(wIdent:Word;nRecog:Integer;nParam,nTag,nSeries:Word;sMsg:String); //004CAD6C
begin
  m_DefMsg:=MakeDefaultMsg(wIdent,nRecog,nParam,nTag,nSeries);
  if sMsg <> '' then SendSocket(@m_DefMsg,EncodeString(sMsg))
  else SendSocket(@m_DefMsg,'');
end;

procedure TPlayObject.ClientQueryUserName (target: TBaseObject; x, y: integer); //004DA8E8
var
  uname: string;
  TagColor:Integer;
  Def:TDefaultMessage;
  FameGrade: integer;
begin
   if CretInNearXY (target, x, y) then begin
      tagcolor := GetCharColor (target);
      Def := MakeDefaultMsg (SM_USERNAME, Integer(target), tagcolor, TPlayObject(target).GetRankColor, 0);
      uname := target.GetShowName + '/' + TPlayObject(target).GetFameName(FameGrade) + '/' + TPlayObject(target).GetColumnName + '/' + TPlayObject(target).GetNameRank;         //킬/데스 호칭
      SendSocket (@Def, EncodeString (uname));
   end else
      SendDefMessage (SM_GHOST, integer(target), x, y, 0, '');
end;

function TBaseObject.GetShowName: String; //004C129C
var
  sShowName:String;
begin
  sShowName:=m_sCharName;
  if (m_btRaceServer <> RC_HEROOBJECT) then begin
    Result := FilterShowName(sShowName);
  end else begin
    Result := sShowName + '\' + m_Master.m_sCharName + '돨亶衿';
  end;
  if (m_Master <> nil) and not m_Master.m_boObMode and (m_btRaceServer <> RC_PET) and (m_btRaceServer <> RC_HEROOBJECT) then begin
    if (m_btRaceServer = RC_CLONE) or (m_btRaceServer = RC_DARKCLONE) or (m_btRaceServer = RC_BONZECLONE) then begin
      if m_Master.m_btRaceServer = RC_PLAYOBJECT then
        Result := m_Master.m_sCharName;
    end else begin
      Result:=Result + '(' + m_Master.m_sCharName + ')';
    end;
  end;

end;

procedure TBaseObject.AddMapCount;   //관리자시스템
begin
  if not m_boAddToMaped then begin
    m_boDelFormMaped := False;
    m_boAddToMaped := True;

    if m_PEnvir <> nil then begin
      m_PEnvir.AddObjectCount(Self);
    end;
  end;
end;

procedure TBaseObject.DelMapCount;        //관리자시스템
begin
  if not m_boDelFormMaped then begin
    m_boDelFormMaped := True;
    m_boAddToMaped := False;
    if m_PEnvir <> nil then m_PEnvir.DelObjectCount(Self);
  end;
end;

function TBaseObject.MessageCount(): Integer;           //관리자시스템
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    Result := m_MsgList.Count;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;


procedure TAnimalObject.Attack(TargeTBaseObject: TBaseObject; nDir: Integer); //004C9380
begin
  inherited AttackDir(TargeTBaseObject,0,nDir);
end;

constructor TAnimalObject.Create;//004C9190
begin
  inherited;
  m_nTargetX:= -1;
  dwTick3F0:=Random(4) * 500 + 1000;
  dwTick3F4:=GetTickCount();
  m_btRaceServer:=RC_ANIMAL;
  m_dwHitTick:=GetCurrentTime - LongWord(Random(3000));
  m_dwWalkTick:=GetCurrentTime - LongWord(Random(3000));
  m_dwSearchEnemyTick:=GetTickCount();
  m_boRunAwayMode:=False;
  m_dwRunAwayStart:=GetTickCount();
  m_dwRunAwayTime:=0;
end;
procedure TAnimalObject.GotoTargetXY; //004C9694
var
  I     :Integer;
  nDir  :Integer;
  n10   :Integer;
  n14   :Integer;
  n20   :Integer;
  nOldX :Integer;
  nOldY :Integer;
begin
  if BoDontMove then exit;

  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    n10:=m_nTargetX;
    n14:=m_nTargetY;
    dwTick3F4:=GetTickCount();
    nDir:=DR_DOWN;
    if n10 > m_nCurrX then begin
      nDir:=DR_RIGHT;
      if n14 > m_nCurrY then
        nDir:=DR_DOWNRIGHT;
      if n14 < m_nCurrY then
        nDir:=DR_UPRIGHT;
    end else begin //004C9728
      if n10 < m_nCurrX then begin
          nDir:=DR_LEFT;
        if n14 > m_nCurrY then
          nDir:=DR_DOWNLEFT;
        if n14 < m_nCurrY then
          nDir:=DR_UPLEFT;
      end else begin //004C9760
        if n14 > m_nCurrY then
          nDir:=DR_DOWN
        else if n14 < m_nCurrY then
          nDir:=DR_UP;
      end;
   end;
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    WalkTo(nDir,False);
    n20:=Random(3);
    for I := DR_UP to DR_UPLEFT do begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
        if n20 <> 0 then Inc(nDir)
        else if nDir > 0 then Dec(nDir)
        else nDir:=DR_UPLEFT;
        if (nDir > DR_UPLEFT) then nDir:=DR_UP;
        WalkTo(nDir,False);
      end;
    end;
  end; //004C980B
end;

procedure TAnimalObject.GotoTargetAssXY; //004C9694
var
  I     :Integer;
  nDir  :Integer;
  n10   :Integer;
  n14   :Integer;
  n20   :Integer;
  nOldX :Integer;
  nOldY :Integer;
begin
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
    n10:=m_nTargetX;
    n14:=m_nTargetY;
    dwTick3F4:=GetTickCount();
    nDir:=DR_DOWN;
    if n10 > m_nCurrX then begin
      nDir:=DR_RIGHT;
      if n14 > m_nCurrY then
       nDir:=DR_DOWNRIGHT;
      if n14 < m_nCurrY then
       nDir:=DR_UPRIGHT;
    end else begin //004C9728
      if n10 < m_nCurrX then begin
        nDir:=DR_LEFT;
        if n14 > m_nCurrY then
         nDir:=DR_DOWNLEFT;
        if n14 < m_nCurrY then
         nDir:=DR_UPLEFT;
      end else begin //004C9760
        if n14 > m_nCurrY then
         nDir:=DR_DOWN
        else if n14 < m_nCurrY then
         nDir:=DR_UP;
      end;
   end;
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    AssWalkTo(nDir,True);
    n20:=Random(3);
    for I := DR_UP to DR_UPLEFT do begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
        if n20 <> 0 then
          Inc(nDir)
        else if nDir > 0 then
          Dec(nDir)
        else
          nDir:=DR_UPLEFT;
        if (nDir > DR_UPLEFT) then
          nDir:=DR_UP;
        AssWalkTo(nDir,True);
      end;
    end;
  end; //004C980B
end;

function TAnimalObject.Operate(ProcessMsg:pTProcessMessage):Boolean; //004C9280
begin
//  Result:=False;
  if ProcessMsg.wIdent = RM_STRUCK then begin
    if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3{AttackBaseObject}) <> nil) then begin
      SetLastHiter(TBaseObject(ProcessMsg.nParam3{AttackBaseObject}));
      Struck(TBaseObject(ProcessMsg.nParam3{AttackBaseObject}));{0FFEC}
      BreakHolySeizeMode();
      BreakPobakSeizeMode();
      if (m_Master <> nil) and
         (TBaseObject(ProcessMsg.nParam3) <> m_Master) and
         (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) then begin

        m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
      end;
      if g_Config.boMonSayMsg then MonsterSayMsg(TBaseObject(ProcessMsg.nParam3),s_UnderFire);
    end;
    Result:=True;
  end else begin //004C932C
    Result:=inherited Operate(ProcessMsg);
  end;
end;


procedure TAnimalObject.Run;//004C936C
begin
  inherited;
end;

procedure TAnimalObject.Struck (Hiter: TBaseObject);//004C93A8
var
  btDir:Byte;
begin
  m_dwStruckTick := GetTickCount;
  if Hiter <> nil then begin
    if (m_TargetCret = nil) or GetAttackDir(m_TargetCret,btDir) or (Random(6) = 0) then begin
      if IsProperTarget (Hiter) then
        SetTargetCreat (Hiter);
    end;
  end; //004C941D
  if m_boAnimal then begin
     m_nMeatQuality := m_nMeatQuality - Random (300);
     if m_nMeatQuality < 0 then m_nMeatQuality := 0;
  end;
  //if m_Abil.Level < 50 then
     m_dwHitTick  := m_dwHitTick + LongWord(150 - _MIN(130, m_Abil.Level * 4));
  //WalkTime := WalkTime + (300 - _MIN(200, (Abil.Level div 5) * 20));
end;

procedure TBaseObject.RecalcAbilitys;//004C03B0
var
  wOldHP,wOldMP  :Word;
  boOldPenetrateMode  :Boolean;
  boOldHideMode  :Boolean;  //월영술
  nOldLight      :Integer;
  nItemLight     :Integer;
  I,k, nIndex    :Integer;
  StdItem        :TItem;
  hum            :TPlayObject;

  hum1           :TPlayObject;
  hum2           :TPlayObject;
  cret           :TBaseObject;
  tempvalue, tempcount : integer;

  fastmoveflag   :Boolean;  //질주기능

  boRecallSuite  :Array[0..3] of Boolean;

  UserMagic      :pTUserMagic;
  boHongMoSuite1 :Boolean;
  boHongMoSuite2 :Boolean;
  boHongMoSuite3 :Boolean;
  boSpirit       :Array[0..3] of Boolean;

  boSmash1,boSmash2,boSmash3:Boolean;
  boHwanDevil1,boHwanDevil2,boHwanDevil3:Boolean;
  boPurity1,boPurity2,boPurity3:Boolean;
  boMundane1,boMundane2:Boolean;
  boNokChi1,boNokChi2:Boolean;
  boTaoBu1,boTaoBu2:Boolean;

  boFiveString1,boFiveString2,boFiveString3:Boolean;
  boBone1,boBone2,boBone3: Boolean; //bone set(wpn,helm,robe)
  boBug1,boBug2,boBug3: Boolean; //bug set (neck, ring, brace
  boWhiteGold1,boWhiteGold2,boWhiteGold3,boWhiteGold4,boWhiteGold5: Boolean; // white gold set (belt, shoes, neck, brace, ring)
  boRedJade1,boRedJade2,boRedJade3,boRedJade4,boRedJade5: Boolean; // red jade set (belt, shoes, neck, brace, ring)
  boNephrite1,boNephrite2,boNephrite3,boNephrite4,boNephrite5: Boolean; // nephrite set (belt, shoes, neck, brace, ring)
  boWhiteGoldH1,boWhiteGoldH2,boWhiteGoldH3,boWhiteGoldH4,boWhiteGoldH5: Boolean;// white gold H set (belt, soes, neck, brace ring)
  boRedJadeH1,boRedJadeH2,boRedJadeH3,boRedJadeH4,boRedJadeH5: Boolean; // red jade H set (belt, shoes, neck, brace, ring)
  boNephriteH1,boNephriteH2,boNephriteH3,boNephriteH4,boNephriteH5: Boolean; // nephrite H set (belt, shoes, neck, brace, ring)

  boSetItem: Boolean;
  SetItems: pTSetItems;
  sItemNameL, sItemNameR: string;
begin
  FillChar(m_AddAbil,SizeOf(TAddAbility),#0);
  wOldHP             := m_WAbil.HP;
  wOldMP             := m_WAbil.MP;
  m_WAbil            := m_Abil;
  m_WAbil.HP         := wOldHP;
  m_WAbil.MP         := wOldMP;
  m_WAbil.Weight     := 0;
  m_WAbil.WearWeight := 0;
  m_WAbil.HandWeight := 0;
  m_btAntiPoison     := 0;
  m_nPoisonRecover   := 0;
  m_nHealthRecover   := 0;
  m_nSpellRecover    := 0;
  m_nAntiMagic       := 1;
  m_nLuck            := 0;
  m_nHitSpeed        := 0;
  nPowerDefen        := 0;
  nPowerMagDefen     := 0;
  nPowerDefen2       := 0;
  nPowerMagDefen2    := 0;
  m_boExpItem        := False;
  m_rExpItem         := 0;
  m_boPowerItem      := False;
  m_rPowerItem       := 0;
  boOldHideMode      := m_boHideMode;     //oldhmode := BoHumHideMode;
  m_boHideMode       := False;            //월영술
  boOldPenetrateMode := m_boPenetrateMode;
  m_boPenetrateMode  := False;
  m_boTeleport       := False;
  m_boParalysis      := False;
  m_boAllParalysis   := False;
  m_boRevival        := False;
  m_boUnRevival      := False;
  m_boFlameRing      := False;
  m_boRecoveryRing   := False;
  m_boMagicShield    := False;
  m_boUnMagicShield  := False;
  m_boMuscleRing     := False;
  m_boFastTrain      := False;
  m_boFastTrain2     := False;
  m_boCounterAttack  := False;

  m_nPowerRate7      := 100;
  m_nKillMonExpRate11:= 100;

  m_boProbeNecklace  := False;
  m_boSupermanItem   := False;
  m_boGuildMove      := False;
  m_boUnParalysis    := False;
  m_boExpItem        := False;
  m_boPowerItem      := False;
  m_boNoDropBagItem  := False;
  m_boNoDropUseItem  := False;
  m_boDropDurg       := False;      //환템 드랍
  m_bopirit          := False;
 // m_btHorseType      := -1;
  m_btDressEffType   := 0;
  m_WEffect          := 0;

  m_nPowerRate7      := 100;
  m_nKillMonExpRate11:= 100;
  m_db3B0            := 0;
  m_nHongMoSuite     := 0;
  SuckupEnemyHealthRate := 0; //체력 흡수
  SuckupEnemyHealth  := 0;
  SuckupEnemyManaRate:= 0;    //마나 흡수
  SuckupEnemyMana    := 0;
  boHongMoSuite1     := False;
  boHongMoSuite2     := False;
  boHongMoSuite3     := False;
  boSpirit[0]        := False;
  boSpirit[1]        := False;
  boSpirit[2]        := False;
  boSpirit[3]        := False;
  m_boRecallSuite    := False;
  boRecallSuite[0]   := False;
  boRecallSuite[1]   := False;
  boRecallSuite[2]   := False;
  boRecallSuite[3]   := False;
  boSmash1            := False;
  boSmash2            := False;
  boSmash3            := False;
  boHwanDevil1        := False;
  boHwanDevil2        := False;
  boHwanDevil3        := False;
  boPurity1           := False;
  boPurity2           := False;
  boPurity3           := False;
  boMundane1          := False;
  boMundane2          := False;
  boNokChi1           := False;
  boNokChi2           := False;
  boTaoBu1            := False;
  boTaoBu2            := False;
  boFiveString1       := False;
  boFiveString2       := False;
  boFiveString3       := False;

  boBone1             := False;
  boBone2             := False;
  boBone3             := False;
  boBug1              := False;
  boBug2              := False;
  boBug3              := False;
  boWhiteGold1        := False;
  boWhiteGold2        := False;
  boWhiteGold3        := False;
  boWhiteGold4        := False;
  boWhiteGold5        := False;
  boWhiteGoldH1       := False;
  boWhiteGoldH2       := False;
  boWhiteGoldH3       := False;
  boWhiteGoldH4       := False;
  boWhiteGoldH5       := False;
  boRedJade1          := False;
  boRedJade2          := False;
  boRedJade3          := False;
  boRedJade4          := False;
  boRedJade5          := False;
  boRedJadeH1         := False;
  boRedJadeH2         := False;
  boRedJadeH3         := False;
  boRedJadeH4         := False;
  boRedJadeH5         := False;
  boNephrite1         := False;
  boNephrite2         := False;
  boNephrite3         := False;
  boNephrite4         := False;
  boNephrite5         := False;
  boNephriteH1        := False;
  boNephriteH2        := False;
  boNephriteH3        := False;
  boNephriteH4        := False;
  boNephriteH5        := False;
  fastmoveflag        := false; //질주기능
{end of sets}
  m_dwPKDieLostExp   := 0;
  m_nPKDieLostLevel  := 0;
  nItemLight         := 0;
  m_boCanLooseDura    := True;
 // if (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] ) then begin
  if g_SetItemsArr <> nil then //敬陋溝固
    FillChar(g_SetItemsArr[0], Length(g_SetItemsArr), False);
  boSetItem := False;
  for I:=Low(THumanUseItems) to High(THumanUseItems) do begin
    if (m_UseItems[U_WEAPON].wIndex > 0) then begin    //무기를 착용했다
      StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if StdItem = nil then Continue;
      if StdItem.StdMode <> 7 then begin   //낚싯대가 아니면
         if i in [U_FISH1..U_FISH5] then Continue;        //낚싯대 장신구 옵션 미적용
      end;
    end;
    if (m_UseItems[U_WEAPON].wIndex <= 0) or (m_UseItems[U_WEAPON].Dura <= 0) then begin  //무기의 내구가 0이다... 낚싯대 장신구 옵션 미적용
      if i in [U_FISH1..U_FISH5] then Continue;
    end;

    if (m_UseItems[U_TIGER].wIndex <= 0) or (m_UseItems[U_TIGER].Dura <= 0) then begin    //탈것의 내구가 0이다 .. 탈것 장신구 옵션 미적용
       if i in [U_PETS1..U_PETS5] then Continue;
    end;
    if (m_UseItems[I].wIndex <= 0) or (m_UseItems[I].Dura <= 0) then Continue;

    GetAccessory(m_UseItems[I],m_AddAbil);
    StdItem:=UserEngine.GetStdItem(m_UseItems[I].wIndex);
    if StdItem = nil then Continue;
//==============================세트아이템=====================================
    if (StdItem.SetItemList <> nil) and (g_SetItemsArr <> nil) then begin
      for k := 0 to StdItem.SetItemList.Count - 1 do begin
        nIndex := Integer(StdItem.SetItemList[K]);
        if (nIndex >= Low(g_SetItemsArr)) and (nIndex <= High(g_SetItemsArr)) then begin
          g_SetItemsArr[nIndex] := True;
          boSetItem := True;
        end;
      end;
    end;

    if nItemLight < StdItem.Light then nItemLight := StdItem.Light;

//============================무게============================================
    if (i = U_WEAPON) or (i = U_RIGHTHAND) then begin
      Inc(m_WAbil.HandWeight,StdItem.Weight);        //손에 들고 있는 무게
    end else begin
      Inc(m_WAbil.WearWeight,StdItem.Weight);       //입고 있거나 착용한 무게.
    end;

//============================무기============================
    if (i = U_WEAPON) then begin
      if (StdItem.Source - 1 - 10) < 0 then begin
        m_AddAbil.btWeaponStrong:=StdItem.Source
      end;
      if (StdItem.Source <= -1) and (StdItem.Source >= -50) then begin // -1 to -50       //언데드 공격 효과 상승
        m_AddAbil.UndeadPower:=m_AddAbil.UndeadPower + (-StdItem.Source);//Holy+
      end;
      if (StdItem.Source <= -51) and (StdItem.Source >= -100) then begin // -51 to -100       //언데드 공격 효과 감소
        m_AddAbil.UndeadPower:=m_AddAbil.UndeadPower + (StdItem.Source + 50);//Holy-
      end;

      if (StdItem.WEffect > 0) then begin
        m_WEffect := StdItem.WEffect;
      end;

      Continue;
    end;
//===========================횟불=================================
    if (i = U_RIGHTHAND) then begin
      GetObjectEventEffect;  //빼빼로

      if (StdItem.Source = 0) and (StdItem.Reserved = 1) then
        m_boCanLooseDura := False;

      Continue;
    end;
//=============================옷 ================================
    if (I = U_DRESS) then begin
      if StdItem.HumRun then fastmoveflag := true;  //질주 기능

      if m_UseItems[I].btValue[5] > 0 then m_btDressEffType:=m_UseItems[I].btValue[5];

      if (StdItem.AniCount > 0) and (StdItem.AniCount <> 220) then m_btDressEffType:=StdItem.AniCount;

      if StdItem.AniCount = 110 then begin      //망자의옷
        if not m_PEnvir.Flag.boNOPENETRATE then begin
          if (GetTickCount - m_PenetrateLastTick) > 20 * 1000 then begin
             m_wStatusTimeArr[STATE_PENETRATE]:=6 * 10 * 1000;
             m_boPenetrateMode:=True;              //망자의옷 착용
          end;
        end;
      end;

      if StdItem.AniCount = 111 then begin      //투명옷
        m_wStatusTimeArr[STATE_TRANSPARENT]:=6 * 10 * 1000;
        m_boHideMode:=True;
      end;

       { if StdItem.StdMode in [10,11,12] then begin  //영정갑주 특수기능
        if StdItem.Shape = 12 then
          m_boCounterAttack := True;
      end;    }


      Continue;
    end;

//==============================기타===============================

    if StdItem.Shape = 139 then m_boUnParalysis  := True;    //마비의반지 불가
    if StdItem.Shape = 140 then m_boSupermanItem := True;   //슈퍼맨반지
    if StdItem.Shape = 141 then begin
      m_boExpItem:=True;
      m_rExpItem:=m_rExpItem + (m_UseItems[i].Dura / g_Config.nItemExpRate);
    end;
    if StdItem.Shape = 142 then begin
      m_boPowerItem:=True;
      m_rPowerItem:=m_rPowerItem + (m_UseItems[i].Dura / g_Config.nItemPowerRate);
    end;
    if StdItem.Shape = 182 then begin
      m_boExpItem:=True;
      m_rExpItem:=m_rExpItem + (m_UseItems[i].DuraMax / g_Config.nItemExpRate);
    end;
    if StdItem.Shape = 183 then begin
      m_boPowerItem:=True;
      m_rPowerItem:=m_rPowerItem + (m_UseItems[i].DuraMax / g_Config.nItemPowerRate);
    end;

    if StdItem.Shape = 143 then m_boUnMagicShield := True;    //보호의반지 불가
    if StdItem.Shape = 144 then m_boUnRevival     := True;   //소생불가

    if StdItem.Shape = 180 then begin //PK
      m_dwPKDieLostExp:=StdItem.DuraMax * g_Config.dwPKDieLostExpRate;
    end;
    if StdItem.Shape = 181 then begin //PK
      m_nPKDieLostLevel:=StdItem.DuraMax div g_Config.nPKDieLostLevelRate;
    end;

//=======================목걸이======================================
    if (i = U_NECKLACE) then begin
      if StdItem.Shape = 120 then m_boFastTrain:=True;          //수련의목걸이
      if StdItem.Shape = 121 then m_boProbeNecklace:=True;      //탐색의목걸이
      if StdItem.Shape = 123 then boRecallSuite[0]:=True;       //천지합일
      if StdItem.Shape = 145 then m_boGuildMove:=True;          //문주 문파소환
      if StdItem.Shape = 127 then boSpirit[0]:=True;            //초혼셋트

    end;
//==========================반지===========================
    if (i = U_RINGR) or (i = U_RINGL) then begin
      if StdItem.Shape = 111 then begin       //투명반지
        m_wStatusTimeArr[STATE_TRANSPARENT]:=6 * 10 * 1000;
        m_boHideMode:=True;              //BoHumHideMode
      end;
      if StdItem.Shape = 112 then m_boTeleport     := True;    //순반
      if StdItem.Shape = 113 then m_boParalysis    := True;    //마비의반지
      if StdItem.Shape = 114 then m_boRevival      := True;    //소생의반지
      if StdItem.Shape = 115 then m_boFlameRing    := True;    //화염의반지
      if StdItem.Shape = 116 then m_boRecoveryRing := True;    //회복의반지
      if StdItem.Shape = 118 then m_boMagicShield  := True;    //보호의반지
      if StdItem.Shape = 119 then m_boMuscleRing   := True;    //완력의반지
      if StdItem.Shape = 122 then boRecallSuite[1] := True;      //천지합일
      if StdItem.Shape = 128 then boSpirit[1]      := True;       //초혼셋트
      if StdItem.Shape = 201 then begin
        m_boTeleport     := True;
        m_boAllParalysis    := True;    //마비의반지
      end;

      if StdItem.Shape = 999 then begin
        m_boParalysis:=True;
        m_boMagicShield:=True;
        m_boTeleport:=True;
        m_boRevival:=True;
        m_boFlameRing:=True;
        m_boRecoveryRing:=True;
        m_boMuscleRing:=True;
        m_wStatusTimeArr[STATE_TRANSPARENT{8 0x70}]:=6 * 10 * 1000;
        m_boHideMode:=True;
        m_boProbeNecklace:=True;
      end;
    end;
//===================================팔찌==================================
    if (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
      if (StdItem.Source <= -1) and (StdItem.Source >= -50) then begin // -1 to -50
        m_AddAbil.UndeadPower:=m_AddAbil.UndeadPower + -StdItem.Source;//Holy+
      end;
      if (StdItem.Source <= -51) and (StdItem.Source >= -100) then begin // -51 to -100
        m_AddAbil.UndeadPower:=m_AddAbil.UndeadPower + (StdItem.Source + 50);//Holy-
      end;

      if StdItem.Shape = 124 then boRecallSuite[2] := True;          //천지합일
      if StdItem.Shape = 126 then boSpirit[2]      := True;          //초혼셋트
      if StdItem.Shape = 145 then m_boGuildMove  := True;            //문주 문파소환

    end;
//=============================투구====================================
    if (i = U_HELMET) then begin
      if StdItem.Shape = 125 then boRecallSuite[3] := True;         //천지합일
      if StdItem.Shape = 129 then boSpirit[3]      := True;         //초혼셋트
    end;
//==============================벨트======================================
    if (i = U_BELT) then begin

    end;
//==============================신발====================================
    if (i = U_BOOTS) then begin
      if StdItem.HumRun then fastmoveflag := true;

    end;
//============================수호석===============================
    if (i = U_CHARM) then begin
      if StdItem.Shape = 1 then m_boNoDropUseItem := True;
    end;
//===========================탈것====================================
    if (i = U_TIGER) then begin      //호랑이
      m_btHorseType:=StdItem.Shape;
    end;
    if (i in [U_PETS1..U_PETS5]) then begin   //호랑이
    end;
    
//===================낚시=============================
    if (i in [U_FISH1..U_FISH5]) then begin       //낚시
    end;

    if fastmoveflag then   //질주기능
       SendMsg(Self,RM_ToSendMsg,0,89,1,0,'')
    else  SendMsg(Self,RM_ToSendMsg,0,89,0,0,'');
  end;
//=========================================================================================================
  if boSetItem and (g_SetItemsArr <> nil) then begin
      for I := Low(g_SetItemsArr) to High(g_SetItemsArr) do begin
        if g_SetItemsArr[I] and (I >= 0) and (I < g_SetItemsList.Count) then begin
          SetItems := g_SetItemsList[I];
          boSetItem := True;
          for k := Low(SetItems.Items) to High(SetItems.Items) do begin
            if not boSetItem then Break;
            if (SetItems.Items[k] <> '') then begin
              if (k = U_DRESS) or (k = U_BUJUK) then begin
                if (k = U_DRESS) and (m_btGender = 1) then Continue;
                if (k = U_BUJUK) and (m_btGender = 0) then Continue;
                if (m_UseItems[U_DRESS].wIndex <= 0) or (m_UseItems[U_DRESS].Dura <= 0) or (UserEngine.GetStdItemName(m_UseItems[U_DRESS].wIndex) <> SetItems.Items[k]) then begin
                  boSetItem := False;
                  Break;
                end;
              end else
              if (k = U_ARMRINGL) then begin
                sItemNameL := '';
                sItemNameR := '';
                if (m_UseItems[U_ARMRINGL].wIndex > 0) and (m_UseItems[U_ARMRINGL].Dura > 0) then
                  sItemNameL := UserEngine.GetStdItemName(m_UseItems[U_ARMRINGL].wIndex);
                if (m_UseItems[U_ARMRINGR].wIndex > 0) and (m_UseItems[U_ARMRINGR].Dura > 0) then
                  sItemNameR := UserEngine.GetStdItemName(m_UseItems[U_ARMRINGR].wIndex);

                if (sItemNameL <> SetItems.Items[k]) and (sItemNameR <> SetItems.Items[k]) then begin
                  boSetItem := False;
                  Break;
                end;
                
                if boSetItem and (SetItems.Items[U_ARMRINGR] <> '') then begin
                  if (sItemNameL = SetItems.Items[k]) and (sItemNameR <> SetItems.Items[U_ARMRINGR]) then begin
                    boSetItem := False;
                    Break;
                  end else
                  if (sItemNameR = SetItems.Items[k]) and (sItemNameL <> SetItems.Items[U_ARMRINGR]) then begin
                    boSetItem := False;
                    Break;
                  end;
                end;
              end else
              if (k = U_ARMRINGR) then begin
                sItemNameL := '';
                sItemNameR := '';
                if (m_UseItems[U_ARMRINGL].wIndex > 0) and (m_UseItems[U_ARMRINGL].Dura > 0) then
                  sItemNameL := UserEngine.GetStdItemName(m_UseItems[U_ARMRINGL].wIndex);
                if (m_UseItems[U_ARMRINGR].wIndex > 0) and (m_UseItems[U_ARMRINGR].Dura > 0) then
                  sItemNameR := UserEngine.GetStdItemName(m_UseItems[U_ARMRINGR].wIndex);

                if (sItemNameL <> SetItems.Items[k]) and (sItemNameR <> SetItems.Items[k]) then begin
                  boSetItem := False;
                  Break;
                end;
              end else
              if (k = U_RINGL) then begin
                sItemNameL := '';
                sItemNameR := '';
                if (m_UseItems[U_RINGL].wIndex > 0) and (m_UseItems[U_RINGL].Dura > 0) then
                  sItemNameL := UserEngine.GetStdItemName(m_UseItems[U_RINGL].wIndex);
                if (m_UseItems[U_RINGR].wIndex > 0) and (m_UseItems[U_RINGR].Dura > 0) then
                  sItemNameR := UserEngine.GetStdItemName(m_UseItems[U_RINGR].wIndex);

                if (sItemNameL <> SetItems.Items[k]) and (sItemNameR <> SetItems.Items[k]) then begin
                  boSetItem := False;
                  Break;
                end;
                
                if boSetItem and (SetItems.Items[U_RINGR] <> '') then begin
                  if (sItemNameL = SetItems.Items[k]) and (sItemNameR <> SetItems.Items[U_RINGR]) then begin
                    boSetItem := False;
                    Break;
                  end else
                  if (sItemNameR = SetItems.Items[k]) and (sItemNameL <> SetItems.Items[U_RINGR]) then begin
                    boSetItem := False;
                    Break;
                  end;
                end;
              end else
              if (k = U_RINGR) then begin
                sItemNameL := '';
                sItemNameR := '';
                if (m_UseItems[U_RINGL].wIndex > 0) and (m_UseItems[U_RINGL].Dura > 0) then
                  sItemNameL := UserEngine.GetStdItemName(m_UseItems[U_RINGL].wIndex);
                if (m_UseItems[U_RINGR].wIndex > 0) and (m_UseItems[U_RINGR].Dura > 0) then
                  sItemNameR := UserEngine.GetStdItemName(m_UseItems[U_RINGR].wIndex);

                if (sItemNameL <> SetItems.Items[k]) and (sItemNameR <> SetItems.Items[k]) then begin
                  boSetItem := False;
                  Break;
                end;
              end else begin
                if (m_UseItems[k].wIndex <= 0) or (m_UseItems[k].Dura <= 0) or (UserEngine.GetStdItemName(m_UseItems[k].wIndex) <> SetItems.Items[k]) then begin
                  boSetItem := False;
                  Break;
                end;
              end;
            end;
          end; // end for
          if boSetItem then begin       //세트능력
            for K := Low(SetItems.Value) to High(SetItems.Value) do begin
              if SetItems.Value[K] <= 0 then Continue;
              Try
                case K of
                  0: ;
                  1: m_AddAbil.wDC := MakeLong(LoWord(m_AddAbil.wDC) + SetItems.Value[1], HiWord(m_AddAbil.wDC));   //최소파괴
                  2: m_AddAbil.wMC := MakeLong(LoWord(m_AddAbil.wMC) + SetItems.Value[2], HiWord(m_AddAbil.wMC));   //최대마법
                  3: m_AddAbil.wSC := MakeLong(LoWord(m_AddAbil.wSC) + SetItems.Value[3], HiWord(m_AddAbil.wSC));   //최대도력
                  4: m_AddAbil.wDC := MakeLong(LoWord(m_AddAbil.wDC), HiWord(m_AddAbil.wDC) + SetItems.Value[4]);  //최대파괴
                  5: m_AddAbil.wMC := MakeLong(LoWord(m_AddAbil.wMC), HiWord(m_AddAbil.wMC) + SetItems.Value[5]);  //최대마법
                  6: m_AddAbil.wSC := MakeLong(LoWord(m_AddAbil.wSC), HiWord(m_AddAbil.wSC) + SetItems.Value[6]);  //최대도력
                  7: m_AddAbil.wAC := MakeLong(LoWord(m_AddAbil.wAC) + SetItems.Value[7], HiWord(m_AddAbil.wAC));    //최소방어
                  8: m_AddAbil.wMAC := MakeLong(LoWord(m_AddAbil.wMAC) + SetItems.Value[8], HiWord(m_AddAbil.wMAC));//최소마법방어
                  9: m_AddAbil.wAC := MakeLong(LoWord(m_AddAbil.wAC), HiWord(m_AddAbil.wAC) + SetItems.Value[9]); //최대방어
                  10: m_AddAbil.wMAC := MakeLong(LoWord(m_AddAbil.wMAC), HiWord(m_AddAbil.wMAC) + SetItems.Value[10]); //최대마법방어
                  11: Inc(m_AddAbil.wHitPoint, SetItems.Value[11]);           //정확
                  12: Inc(m_AddAbil.wSpeedPoint, SetItems.Value[12]);         //민첩
                  13: Inc(m_AddAbil.wHP, SetItems.Value[13]);                 //체력
                  14: Inc(m_AddAbil.wMP, SetItems.Value[14]);                 //마력
                  15: Inc(m_AddAbil.wHealthRecover, SetItems.Value[15]);     //체력회복
                  16: Inc(m_AddAbil.wSpellRecover, SetItems.Value[16]);      //마력회복
                  17: Inc(m_AddAbil.wPoisonRecover, SetItems.Value[17]);     //중독회복
                  18: Inc(m_AddAbil.wAntiMagic, SetItems.Value[18]);         //마법저항
                  19: Inc(m_AddAbil.wAntiPoison, SetItems.Value[19]);        //중독저항
                  20: Inc(m_AddAbil.btLuck, SetItems.Value[20]);             //행운
                  21: Inc(m_AddAbil.WearWeight, SetItems.Value[21]);         //착용무게
                  22: Inc(m_AddAbil.Weight, SetItems.Value[22]);             //가방무게
                  23: Inc(m_AddAbil.HandWeight, SetItems.Value[23]);         //양손무게
                  24: Inc(m_AddAbil.nHitSpeed, SetItems.Value[24]);          //공격속도
                  25: begin   //MP = > HP 전환
                    inc(m_nHongMoSuite, SetItems.Value[25]);
                    Inc(m_AddAbil.wHP, SetItems.Value[25]);
                  end;
                  26: SendMsg(Self,RM_ToSendMsg,0,89,1,0,'');               //질주
                  27: Inc(SuckupEnemyHealthRate, SetItems.Value[27]);        //체력흡수
                  28: Inc(SuckupEnemyManaRate, SetItems.Value[28]);          //마력흡수
                  29: Inc(m_AddAbil.UndeadPower, SetItems.Value[29]);        //신성(언데드 공격)
                  30: Inc(m_AddAbil.wHP, (m_WAbil.MaxHP * SetItems.Value[30]) div 100); //체력상승률
                  31: m_boTeleport     := True; //순간이동
                  32: m_boParalysis    := True;   //마비
                  33: m_boMagicShield  := True; //보호
                  34: m_nPowerRate7 := m_nPowerRate7 + SetItems.Value[34]; //공격력상승
                  35: m_nKillMonExpRate11 := m_nKillMonExpRate11 +  + SetItems.Value[35]; //경험치상승
                  else begin
                     //
                  end;
                end;
              Except
              End;
            end;
          end;
        end;
      end;
  end;
//=========================================================================================================
  m_WAbil.Weight:=RecalcBagWeight();
 // end;
  if boRecallSuite[0] and
     boRecallSuite[1] and
     boRecallSuite[2] and
     boRecallSuite[3] then m_boRecallSuite:=True;       //천지합일

  if boSpirit[0] and
     boSpirit[1] and
     boSpirit[2] and
     boSpirit[3] then m_bopirit:=True;               //초혼의셋트


  if m_boTransparent and (m_wStatusTimeArr[STATE_TRANSPARENT] > 0) then //은신술
    m_boHideMode:=True;         //BoHumHideMode

  if m_boHideMode then begin //BoHumHideMode
    if not boOldHideMode then begin    //oldhmode
      m_nCharStatus:=GetCharStatus();
      StatusChanged();
    end;
  end else begin
    if boOldHideMode then begin      //oldhmode
      m_wStatusTimeArr[STATE_TRANSPARENT]:=0;
      m_nCharStatus:=GetCharStatus();
      StatusChanged();
    end;
  end;
  if m_boPenetrateMode then begin
    if not boOldPenetrateMode then begin
      m_nCharStatus:=GetCharStatus();
      StatusChanged();
    end;
  end else begin
    if boOldPenetrateMode then begin
      m_wStatusTimeArr[STATE_PENETRATE]:=0;
      m_nCharStatus:=GetCharStatus();
      StatusChanged();
      SendMsg (Self, RM_COOLBUFF, 93, 0, 79, 1, '[ 价俊쌀 ]\돕퍅珂쇌: ' );  //망자의눈 쿨타임 버프
    end;
  end;

  if (m_btRaceServer = RC_PLAYOBJECT ) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_DARKCLONE) or (m_btRaceServer = RC_BONZECLONE) then begin
    RecalcHitSpeed();
  end;
  nOldLight := m_nLight;
  m_nLight := nItemLight;
  if nOldLight <> m_nLight then
    SendRefMsg(RM_CHANGELIGHT,0,0,0,0,'');

  Inc(m_btSpeedPoint,m_AddAbil.wSpeedPoint);
  Inc(m_btHitPoint,m_AddAbil.wHitPoint);
  Inc(m_btAntiPoison,m_AddAbil.wAntiPoison);
  Inc(m_nPoisonRecover,m_AddAbil.wPoisonRecover);
  Inc(m_nHealthRecover,m_AddAbil.wHealthRecover);
  Inc(m_nSpellRecover,m_AddAbil.wSpellRecover);
  Inc(m_nAntiMagic,m_AddAbil.wAntiMagic);
  Inc(m_nLuck,m_AddAbil.btLuck);
  Dec(m_nLuck,m_AddAbil.btUnLuck);
  m_nHitSpeed:=m_AddAbil.nHitSpeed;//004C0A53
  Inc(m_nPoisonIncrease, m_AddAbil.wTox);
  Inc(m_nFreezingIncrease, m_AddAbil.wSlowDown);

  Inc(m_WAbil.MaxWeight,m_AddAbil.Weight);
  Inc(m_WAbil.MaxWearWeight,m_AddAbil.WearWeight);
  Inc(m_WAbil.MaxHandWeight,m_AddAbil.HandWeight);

  m_WAbil.MaxHP:=_MIN(High(Word),m_Abil.MaxHP + m_AddAbil.wHP);
  m_WAbil.MaxMP:=_MIN(High(Word),m_Abil.MaxMP + m_AddAbil.wMP);

  m_WAbil.AC  := MakeLong(LoWord(m_AddAbil.wAC)  + LoWord(m_Abil.AC),  HiWord(m_AddAbil.wAC)  + HiWord(m_Abil.AC));
  m_WAbil.MAC := MakeLong(LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC), HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC));
  m_WAbil.DC  := MakeLong(LoWord(m_AddAbil.wDC)  + LoWord(m_Abil.DC),  HiWord(m_AddAbil.wDC)  + HiWord(m_Abil.DC));
  m_WAbil.MC  := MakeLong(LoWord(m_AddAbil.wMC)  + LoWord(m_Abil.MC),  HiWord(m_AddAbil.wMC)  + HiWord(m_Abil.MC));
  m_WAbil.SC  := MakeLong(LoWord(m_AddAbil.wSC)  + LoWord(m_Abil.SC),  HiWord(m_AddAbil.wSC)  + HiWord(m_Abil.SC));
  if m_nHongMoSuite > 0 then begin
    m_WAbil.MaxMP:=_MIN(High(Word),m_Abil.MaxMP - m_nHongMoSuite);
  end;

  if m_wStatusTimeArr[STATE_DEFENCEUP] > 0 then begin //항마진법
    if m_wStatusTimeArr[STATE_WINDMOON] > 0 then begin  //항마진법 강화
      m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + 6 + (m_Abil.Level div 7));
      nPowerDefen :=  6 + (m_Abil.Level div 7);
    end else begin
      m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + 2 + (m_Abil.Level div 7));
      nPowerDefen :=  2 + (m_Abil.Level div 7);
    end;
  end;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0 then begin //대지원호
    if m_wStatusTimeArr[STATE_WINDMOON] > 0 then begin  //대지원호 강화
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + 6 + (m_Abil.Level div 7));
      nPowerMagDefen :=  6 + (m_Abil.Level div 7);
    end else begin
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + 2 + (m_Abil.Level div 7));
      nPowerMagDefen :=  2 + (m_Abil.Level div 7);
    end;
  end;
  if m_wStatusTimeArr[STATE_BLOODSWORD] > 0 then begin    //혈룡검법
    Inc(m_nHitSpeed,m_btStatusValue[STATE_BLOODSWORD]); //공격속도
  end;

  if m_wStatusTimeArr[STATE_MAGICUP] > 0 then begin //심연술
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC) + m_btStatusValue[STATE_MAGICUP] , HiWord(m_WAbil.MC) + m_btStatusValue[STATE_MAGICUP]);
  end;


  if m_wStatusArrValue[0] > 0 then begin  //파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[0]);
  end;

  if m_wStatusArrValue[1] > 0 then begin   //마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC) + m_wStatusArrValue[1]);
  end;

  if m_wStatusArrValue[2] > 0 then begin   //도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[2]);
  end;

  if m_wStatusArrValue[3] > 0 then begin  //공속
    Inc(m_nHitSpeed,m_wStatusArrValue[3]{n21B}); //공격속도
  end;

  if m_wStatusArrValue[4] > 0 then begin    //체력
    m_WAbil.MaxHP:=_MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[4]);
  end;


  if m_wStatusArrValue[5] > 0 then begin    //마력
    m_WAbil.MaxMP:=_MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[5]);
  end;

  if m_wStatusArrValue[6] > 0 then begin
    if HiWord(m_WAbil.DC) > (2 + m_wStatusArrValue[6]) then
      m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) - 2 - m_wStatusArrValue[6])
    else
      m_WAbil.DC :=MakeLong(LoWord(m_WAbil.DC),0);
  end;

  if m_wStatusArrValue[7] > 0 then begin //최소,최대 파괴 상승   //첨기폭
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC) + 2 + m_wStatusArrValue[7],HiWord(m_WAbil.DC) + 2 + m_wStatusArrValue[7]);
  end;

  if m_wStatusArrValue[8] > 0 then begin //최소,최대 방어 상승   //호신기막
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC) + 2 + m_wStatusArrValue[8],HiWord(m_WAbil.AC) + 2 + m_wStatusArrValue[8]);
  end;

  if m_wStatusArrValue[9] > 0 then
    Inc(m_nHitSpeed,m_wStatusArrValue[9]{n21B}); //공격속도

  if m_wStatusArrValue[10] > 0 then           //풍신술 민첩
    Inc(m_btSpeedPoint,m_WStatusArrValue[10] );

  if m_wStatusArrValue[11] > 0 then begin          //천무 반격
      m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC) + m_wStatusArrValue[11],HiWord(m_WAbil.AC) + m_wStatusArrValue[11]);
      m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC) + m_wStatusArrValue[11],HiWord(m_WAbil.MAC) + m_wStatusArrValue[11]);
  end;

  if m_wStatusArrValue[12] > 0 then begin
      Inc(m_nHealthRecover, m_wStatusArrValue[12])
  end;

  if m_wStatusArrValue[13] > 0 then begin
      Inc(m_nSpellRecover, m_wStatusArrValue[13])
  end;

  if m_wStatusArrValue[14] > 0 then begin    //환템 드랍
    m_boDropDurg := True;
  end;

  if m_wStatusArrValue[15] > 0 then begin   //무극진기
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[15]);
    if m_btJob = 4 then begin         //직업변경
      m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[15]);
    end;
  end;

  if m_wStatusArrValue[16] > 0 then begin //변신탈 방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + m_wStatusArrValue[16]);
  end;

  if m_wStatusArrValue[17] > 0 then begin    //천령수 행운
    Inc(m_nLuck,m_WStatusArrValue[17]);
  end;

  if m_wStatusArrValue[18] > 0 then begin     //정확의물약
    Inc(m_btHitPoint,m_WStatusArrValue[18]);
  end;

  if m_wStatusArrValue[19] > 0 then begin     //천령수 민첩
    Inc(m_btSpeedPoint,m_WStatusArrValue[19] );
  end;

  if m_wStatusArrValue[20] > 0 then begin     //천령수 정확
    Inc(m_btHitPoint,m_WStatusArrValue[20]);
  end;

  if m_wStatusArrValue[21] > 0 then begin     //천령수 체력
    m_WAbil.MaxHP:=_MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[21]);
  end;

  if m_wStatusArrValue[22] > 0 then begin    //옥청수 방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + m_wStatusArrValue[22]);
  end;

  if m_wStatusArrValue[23] > 0 then begin    //옥청수 파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[23]{n218});
  end;

  if m_wStatusArrValue[24] > 0 then begin    //옥청수 마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC) + m_wStatusArrValue[24]{n218});
  end;

  if m_wStatusArrValue[25] > 0 then begin    //옥청수 도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[25]{n218});
  end;

  if m_wStatusArrValue[26] > 0 then begin     //옥청수 행운
    Inc(m_nLuck,m_WStatusArrValue[26]);
  end;

  if m_wStatusArrValue[27] > 0 then begin //변신탈 마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + m_wStatusArrValue[27]);
  end;

  if m_wStatusArrValue[28] > 0 then begin   //수련의물약
    m_boFastTrain2 := True;
  end;

  if m_wStatusArrValue[29] > 0 then begin         //수라강림 마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC) + m_wStatusArrValue[29] ,HiWord(m_WAbil.MAC) + m_wStatusArrValue[29]);
  end;

  if m_wStatusArrValue[30] > 0 then begin
  end;
  if m_wStatusArrValue[31] > 0 then begin
  end;
  if m_wStatusArrValue[32] > 0 then begin
  end;
  if m_wStatusArrValue[33] > 0 then begin
  end;
  if m_wStatusArrValue[34] > 0 then begin
  end;
  if m_wStatusArrValue[35] > 0 then begin
  end;
  if m_wStatusArrValue[36] > 0 then begin
  end;

  if m_wStatusArrValue[37] > 0 then begin //변신탈 파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[37]);
  end;
  if m_wStatusArrValue[38] > 0 then begin //변신탈 마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC) + m_wStatusArrValue[38]);
  end;
  if m_wStatusArrValue[39] > 0 then begin //변신탈 도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[39]);
  end;

  if m_wStatusArrValue[40] > 0 then begin //문파성장 체력
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[40]);
  end;
  if m_wStatusArrValue[41] > 0 then begin //문파성장 마력
    m_WAbil.MaxMP := _MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[41]);
  end;
  if m_wStatusArrValue[42] > 0 then begin //문파성장 방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + m_wStatusArrValue[42]);
  end;
  if m_wStatusArrValue[43] > 0 then begin //문파성장 마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + m_wStatusArrValue[43]);
  end;
  if m_wStatusArrValue[44] > 0 then begin //문파성장 행운
    Inc(m_nLuck,m_WStatusArrValue[44]);
  end;


  if m_wStatusArrValue[45] > 0 then begin //제자 체력
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[45]);
  end;
  if m_wStatusArrValue[46] > 0 then begin //제자 마력
    m_WAbil.MaxMP := _MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[46]);
  end;
  if m_wStatusArrValue[47] > 0 then begin //제자 파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[47]);
  end;
  if m_wStatusArrValue[48] > 0 then begin //제자 파괴 자객
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC) + m_wStatusArrValue[48] ,HiWord(m_WAbil.DC) + m_wStatusArrValue[48]);
  end;
  if m_wStatusArrValue[49] > 0 then begin //제자 마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC) + m_wStatusArrValue[49]);
  end;
  if m_wStatusArrValue[50] > 0 then begin //제자 도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[50]);
  end;
  if m_wStatusArrValue[51] > 0 then begin //제자 행운
    Inc(m_nLuck,m_WStatusArrValue[51]);
  end;


  if m_wStatusArrValue[52] > 0 then begin //GM 파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC) + m_wStatusArrValue[52],HiWord(m_WAbil.DC) + m_wStatusArrValue[52]);
  end;
  if m_wStatusArrValue[53] > 0 then begin //GM 마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC) + m_wStatusArrValue[53],HiWord(m_WAbil.MC) + m_wStatusArrValue[53]);
  end;
  if m_wStatusArrValue[54] > 0 then begin //GM 도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC) + m_wStatusArrValue[54],HiWord(m_WAbil.SC) + m_wStatusArrValue[54]);
  end;
  if m_wStatusArrValue[55] > 0 then begin //GM 방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC) + m_wStatusArrValue[55],HiWord(m_WAbil.AC) + m_wStatusArrValue[55]);
  end;
  if m_wStatusArrValue[56] > 0 then begin //GM 마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC) + m_wStatusArrValue[56],HiWord(m_WAbil.MAC) + m_wStatusArrValue[56]);
  end;
  if m_wStatusArrValue[57] > 0 then begin //GM 체력
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[57]);
  end;
  if m_wStatusArrValue[58] > 0 then begin //GM 마력
    m_WAbil.MaxMP := _MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[58]);
  end;
  if m_wStatusArrValue[59] > 0 then begin //GM 행운
    Inc(m_nLuck,m_WStatusArrValue[59]);
  end;

  if m_wStatusArrValue[60] > 0 then begin  //망자의눈 쿨타임
  end;
  if m_wStatusArrValue[61] > 0 then begin  //금강불괴 쿨타임
  end;
  if m_wStatusArrValue[62] > 0 then begin  //일섬 쿨타임 버프
  end;
  if m_wStatusArrValue[63] > 0 then begin  //뢰선풍 쿨타임 버프
  end;
  if m_wStatusArrValue[64] > 0 then begin  //뢰선풍 체력
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[64]);
  end;
  if m_wStatusArrValue[65] > 0 then begin  //음양오행진 쿨타임 버프
  end;
  if m_wStatusArrValue[66] > 0 then begin  //월영무 쿨타임 버프
  end;
  if m_wStatusArrValue[67] > 0 then begin  //영적추 쿨타임 버프
  end;

  if m_wStatusArrValue[68] > 0 then begin  //백호강타 쿨타임 버프
  end;
  if m_wStatusArrValue[69] > 0 then begin  //교악 쿨타임 버프
  end;
  if m_wStatusArrValue[70] > 0 then begin  //신기묘산 쿨타임 버프
  end;
  if m_wStatusArrValue[71] > 0 then begin  //운중뢰격 쿨타임 버프
  end;
  if m_wStatusArrValue[72] > 0 then begin  //암독만계 쿨타임 버프
  end;
  if m_wStatusArrValue[73] > 0 then begin  //은형술 쿨타임 버프
  end;
  if m_wStatusArrValue[75] > 0 then begin  //격공장 쿨타임 버프
  end;
  if m_wStatusArrValue[76] > 0 then begin  //지속물약 - 개인 버프
  end;
  if m_wStatusArrValue[77] > 0 then begin  //지속물약 - 그룹 버프
  end;

  if m_wStatusArrValue[80] > 0 then begin  //변신탈
  end;

  if m_wStatusArrValue[81] > 0 then begin  //선천진기 - 승려
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[81]);
  end;

  if m_wStatusArrValue[82] > 0 then begin  //강호술 - 승려
  end;

  if m_wStatusArrValue[83] > 0 then begin  //양용왕
  end;

  if m_wStatusArrValue[84] > 0 then begin         //선천
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC) + m_wStatusArrValue[84],HiWord(m_WAbil.DC) + m_wStatusArrValue[84]);
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC) + m_wStatusArrValue[84],HiWord(m_WAbil.MC) + m_wStatusArrValue[84]);
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC) + m_wStatusArrValue[84],HiWord(m_WAbil.SC) + m_wStatusArrValue[84]);
    Inc(m_btHitPoint, (m_WStatusArrValue[84] div 4));
    Inc(m_btSpeedPoint, (m_WStatusArrValue[84] div 4));
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[84] * 10);
    m_WAbil.MaxMP := _MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[84] * 10);
  end;
//===========================영웅버프=======================
  if (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) then begin
    if (TPlayObject(Self).m_MyHero <> nil) or (m_btRaceServer = RC_HEROOBJECT) then begin
      if m_wStatusArrValue[85] > 0 then begin
         m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[85]);
      end;
      if m_wStatusArrValue[86] > 0 then begin
         m_WAbil.MaxMP := _MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[86]);
      end;
      if m_wStatusArrValue[87] > 0 then begin
         Inc(m_nHealthRecover, Round(m_wStatusArrValue[87] / 10));
      end;
      if m_wStatusArrValue[88] > 0 then begin
         Inc(m_btHitPoint,m_WStatusArrValue[88]);
      end;
      if m_wStatusArrValue[89] > 0 then begin
         Inc(m_nSpellRecover, Round(m_wStatusArrValue[89] / 10));
      end;
    end;
  end;

//===========================이벤트물약=======================
  if m_wStatusArrValue[90] > 0 then begin //파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[90]);
  end;
  if m_wStatusArrValue[91] > 0 then begin //마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC) + m_wStatusArrValue[91]);
  end;
  if m_wStatusArrValue[92] > 0 then begin //도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[92]);
  end;
  if m_wStatusArrValue[93] > 0 then begin //방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + m_wStatusArrValue[93]);
  end;
  if m_wStatusArrValue[94] > 0 then begin //마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + m_wStatusArrValue[94]);
  end;
  if m_wStatusArrValue[95] > 0 then begin //체력
    m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[95]);
  end;
  if m_wStatusArrValue[96] > 0 then begin //마력
    m_WAbil.MaxMP := _MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[96]);
  end;
  if m_wStatusArrValue[97] > 0 then begin    //공격속도
    Inc(m_nHitSpeed,m_wStatusArrValue[97]);
  end;
  if m_wStatusArrValue[98] > 0 then begin     //정확
    Inc(m_btHitPoint,m_WStatusArrValue[98]);
  end;
  if m_wStatusArrValue[99] > 0 then begin     //민첩
    Inc(m_btSpeedPoint,m_WStatusArrValue[99]);
  end;
  if m_wStatusArrValue[100] > 0 then begin     //마법저항
    Inc(m_nAntiMagic,m_WStatusArrValue[100]);
  end;
  if m_wStatusArrValue[101] > 0 then begin     //중독저항
    Inc(m_btAntiPoison,m_WStatusArrValue[101]);
  end;
//=======================그룹버프==================
  if m_wStatusArrValue[102] > 0 then begin    //MAXHP 증가
     m_WAbil.MaxHP := _MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[102]);
  end;
  if m_wStatusArrValue[103] > 0 then begin    //체력회복 증가
    Inc(m_nHealthRecover, Round(m_wStatusArrValue[103] / 10));
  end;
//=========================================================================

  if m_wStatusArrValue[104] > 0 then begin    //흡성 방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + 10 + (m_Abil.Level div 7));
    nPowerDefen2 := 10 + (m_Abil.Level div 7);
  end;
  if m_wStatusArrValue[105] > 0 then begin    //강마 마항
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + 10 + (m_Abil.Level div 7));
    nPowerMagDefen2 := 10 + (m_Abil.Level div 7);
  end;


//=======================영물버프==========================
  if m_wStatusArrValue[110] > 0 then begin //방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC) + m_wStatusArrValue[110],HiWord(m_WAbil.AC));
  end;
  if m_wStatusArrValue[111] > 0 then begin //방어
    m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC) + m_wStatusArrValue[111]);
  end;
  if m_wStatusArrValue[112] > 0 then begin //마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC) + m_wStatusArrValue[112],HiWord(m_WAbil.MAC));
  end;
  if m_wStatusArrValue[113] > 0 then begin //마항
    m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC) + m_wStatusArrValue[113]);
  end;
  if m_wStatusArrValue[114] > 0 then begin  //파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC) + m_wStatusArrValue[114],HiWord(m_WAbil.DC));
  end;
  if m_wStatusArrValue[115] > 0 then begin  //파괴
    m_WAbil.DC  := MakeLong(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC) + m_wStatusArrValue[115]);
  end;
  if m_wStatusArrValue[116] > 0 then begin   //마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC) + m_wStatusArrValue[116],HiWord(m_WAbil.MC));
  end;
  if m_wStatusArrValue[117] > 0 then begin   //마법
    m_WAbil.MC  := MakeLong(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC) + m_wStatusArrValue[117]);
  end;
  if m_wStatusArrValue[118] > 0 then begin   //도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC) + m_wStatusArrValue[118],HiWord(m_WAbil.SC));
  end;
  if m_wStatusArrValue[119] > 0 then begin   //도력
    m_WAbil.SC  := MakeLong(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC) + m_wStatusArrValue[119]);
  end;

  if m_wStatusArrValue[120] > 0 then begin   //음양오행진
  end;
//==============================================================
  if ExtraAbil[EABIL_PWRRATE] > 0 then begin     //저주술 파괴 마력 도력 감소
      m_WAbil.DC := MakeLong(
                     ( LoWord(m_WAbil.DC) * ExtraAbil[EABIL_PWRRATE] ) div 100,
                     ( HiWord(m_WAbil.DC) * ExtraAbil[EABIL_PWRRATE] ) div 100
                  );
      m_WAbil.MC := MakeLong(
                     ( LoWord(m_WAbil.MC) * ExtraAbil[EABIL_PWRRATE] ) div 100,
                     ( HiWord(m_WAbil.MC) * ExtraAbil[EABIL_PWRRATE] ) div 100
                  );
      m_WAbil.SC := MakeLong(
                     ( LoWord(m_WAbil.SC) * ExtraAbil[EABIL_PWRRATE] ) div 100,
                     ( HiWord(m_WAbil.SC) * ExtraAbil[EABIL_PWRRATE] ) div 100
                  );
  end;

  if ExtraAbil[EABIL_DCRATE] > 0 then begin     //금강불괴
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), ( HiWord(m_WAbil.DC) * ExtraAbil[EABIL_DCRATE] ) div 100 );
  end;

  if m_boFlameRing then AddItemSkill(1)           //화염의반지
  else DelItemSkill(1);

  if m_boRecoveryRing then AddItemSkill(2)         //회복의반지
  else DelItemSkill(2);

  if m_boMuscleRing then begin                     //완력의반지
    Inc(m_WAbil.MaxWeight,m_WAbil.MaxWeight);
    Inc(m_WAbil.MaxWearWeight,m_WAbil.MaxWearWeight);
    Inc(m_WAbil.MaxHandWeight,m_WAbil.MaxHandWeight);
  end;

  if m_nHitSpeed > 19 then m_nHitSpeed := 20;
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) or (m_btRaceServer = RC_DARKCLONE) or  (m_btRaceServer = RC_BONZECLONE)  then begin
    SendUpdateMsg(Self,RM_CHARSTATUSCHANGED,m_nHitSpeed,m_nCharStatus,0,0,'');
  end;
  if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_HEROOBJECT) and (m_btRaceServer <> RC_DARKCLONE) and (m_btRaceServer <> RC_BONZECLONE) then begin
    MonsterRecalcAbilitys();
    MonsterRecalcAbilitys2;
  end;

end;

procedure TBaseObject.BreakOpenHealth();//004BDCD0
begin
  if m_boShowHP then begin
    m_boShowHP:=False;
    m_nCharStatusEx:= m_nCharStatusEx xor STATE_OPENHEATH;
    m_nCharStatus:=GetCharStatus();
    SendRefMsg(RM_CLOSEHEALTH,0,0,0,0,'');
  end;
end;

procedure TBaseObject.MakeOpenHealth(); //004BDC7C
begin
  m_boShowHP:=True;
  m_nCharStatusEx:= m_nCharStatusEx or STATE_OPENHEATH;
  m_nCharStatus:=GetCharStatus();
  SendRefMsg(RM_OPENHEALTH,0,m_WAbil.HP,m_WAbil.MaxHP,0,'');
end;


procedure TBaseObject.IncHealthSpell(nHP,nMP:Integer);//004BCAA4
begin
  if (nHP < 0) or (nMP < 0) then exit;
  if (m_WAbil.HP + nHP) >= m_WAbil.MaxHP then m_WAbil.HP:=m_WAbil.MaxHP
  else Inc(m_WAbil.HP,nHP);
  if (m_WAbil.MP + nMP) >= m_WAbil.MaxMP then m_WAbil.MP:=m_WAbil.MaxMP
  else Inc(m_WAbil.MP,nMP);
  HealthSpellChanged();
end;

procedure TBaseObject.ItemDamageRevivalRing();//004C022C
var
  i:integer;
  pSItem: TItem;
  nDura,tDura :Integer;
begin
  for i:=Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[i].wIndex > 0 then begin
      pSItem:=UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if pSItem <> nil then begin
//        if (i = U_RINGR) or (i = U_RINGL) then begin
          if (pSItem.Shape in [114,160,161,162]) or (((i = U_WEAPON) or (i = U_RIGHTHAND)) and (pSItem.AniCount in [114,160,161,162])) then begin
            nDura:=m_UseItems[i].Dura;
            tDura:=Round(nDura / 1000);
            Dec(nDura,1000);
            if nDura <= 0 then begin
              nDura:=0;
              m_UseItems[i].Dura:= nDura;
              SendMsg(Self,RM_DURACHANGE,i,nDura,m_UseItems[i].DuraMax,0,'');
             {   //Nicky no breaking
              if m_btRaceServer = RC_PLAYOBJECT then begin
                PlayObject:=TPlayObject(Self);
                PlayObject.SendDelItems(@m_UseItems[i]);
              end;//004C0310
              m_UseItems[i].wIndex:=0;
              }
              RecalcAbilitys();

            end else begin//004C0331
              m_UseItems[i].Dura:= nDura;
            end;
            if tDura <> Round(nDura / 1000{1.03}) then begin
              SendMsg(Self,RM_DURACHANGE,i,nDura,m_UseItems[i].DuraMax,0,'');
            end;
            //break;
          end;//004C0397
//        end;//004C0397
      end;//004C0397 if pSItem <> nil then begin
    end;//if UseItems[i].wIndex > 0 then begin
  end;// for i:=Low(UseItems) to High(UseItems) do begin
end;

procedure TBaseObject.Run; //004C7720
var
  i,nMagLevel, nRate:Integer;
  boChg:Boolean;
  boNeedRecalc:Boolean;
  nHP, nMP, nPlus:Integer; //
  dwC,dwInChsTime:LongWord;
  ProcessMsg:TProcessMessage;
  BaseObject:TBaseObject;
  nCheckCode:Integer;
  dwRunTick:LongWord;
  nInteger:Integer;
  PlayObject:TPlayObject;
  UserMagic: pTUserMagic;
ResourceString
  sExceptionMsg0 = '[Exception] TBaseObject::Run 0 code: %d';
  sExceptionMsg1 = '[Exception] TBaseObject::Run 1 Code:%d Who:%s';
  sExceptionMsg2 = '[Exception] TBaseObject::Run 2';
  sExceptionMsg3 = '[Exception] TBaseObject::Run 3';
  sExceptionMsg4 = '[Exception] TBaseObject::Run 4 Code:%d Who:%s';
  sExceptionMsg5 = '[Exception] TBaseObject::Run 5 Code:%d Who:%s';
  sExceptionMsg6 = '[Exception] TBaseObject::Run 6';
begin
  nCheckCode:=0;
  dwRunTick:=GetTickCount();
  try
    while GetMessage(@ProcessMsg) do begin
      nCheckCode:=1000;
      Operate(@ProcessMsg);
      nCheckCode:=1001;
    end;
  except
    on e: Exception do begin
      MainOutMessage(format(sExceptionMsg0,[nCheckCode]));
      MainOutMessage(E.Message);
    end;
  end;
  //SetProcessName('TBaseObject.Run 1');
  //004C7798
  nCheckCode:=0;
  try
    nCheckCode := 1;
    if m_boSuperMan then begin
      m_WAbil.HP:=m_WAbil.MaxHP;
      m_WAbil.MP:=m_WAbil.MaxMP;
    end;
    //004C77DA
    nCheckCode := 2;
    dwC:=(GetTickCount() - m_dwHPMPTick) div 20; //초당 50 //체력, 마력 회복 속도
    m_dwHPMPTick:=GetTickCount();
    nCheckCode := 3;
    nPlus := dwC*(1+ m_nHealthRecover);
    Inc(m_nHealthTick,nPlus);
    nCheckCode := 4;
    nPlus := dwC*(1+ m_nSpellRecover);
    Inc(m_nSpellTick,nPlus);

    //004C781D
    nCheckCode := 5;
    if not m_boDeath then begin
      nCheckCode := 6;
      if (m_WAbil.HP < m_WAbil.MaxHP) and (m_nHealthTick >= g_Config.nHealthFillTime) then begin
        nPlus:= (m_WAbil.MaxHP div 75) + 1;
        nCheckCode := 7;
        if (m_WAbil.HP + nPlus) < m_WAbil.MaxHP then begin
          Inc(m_WAbil.HP,nPlus);
        end else begin
          m_WAbil.HP:=m_WAbil.MaxHP;
        end;
        HealthSpellChanged;
      end;
      nCheckCode := 8;
      //004C78AF
      if (m_WAbil.MP < m_WAbil.MaxMP) and (m_nSpellTick >= g_Config.nSpellFillTime) then begin
        nPlus:= (m_WAbil.MaxMP div 18) + 1;
        nCheckCode := 9;
        if (m_WAbil.MP + nPlus) < m_WAbil.MaxMP then begin
          Inc(m_WAbil.MP,nPlus);
        end else begin
          m_WAbil.MP:=m_WAbil.MaxMP;
        end;
        HealthSpellChanged;
      end;
      nCheckCode := 10;
      //004C7934
      if m_WAbil.HP = 0 then begin
        nCheckCode := 11;
        if ((m_LastHiter = nil) or not m_LastHiter.m_boUnRevival{렝릿삶}) and m_boRevival and (GetTickCount - m_dwRevivalTick > g_Config.dwRevivalTime{60 * 1000}) then begin
           m_dwRevivalTick:= GetTickCount();
           ItemDamageRevivalRing;
           m_WAbil.HP := m_WAbil.MaxHP;
           HealthSpellChanged;
           SysMsg (g_sRevivalRecoverMsg, c_Green,t_Hint);
        end;
        if m_WAbil.HP = 0 then Die;
      end;
      nCheckCode := 12;
      if m_nHealthTick >= g_Config.nHealthFillTime then m_nHealthTick:=0;
      if m_nSpellTick >= g_Config.nSpellFillTime then m_nSpellTick:=0;
    end else begin
      nCheckCode := 13;
      if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostTime {3 * 60 * 1000}) then begin
        nCheckCode := 14;
        MakeGhost();
      end;
    end;
  except
    on e: Exception do begin
      MainOutMessage(Format(sExceptionMsg1,[nCheckCode, m_sCharName]));
      MainOutMessage(E.Message);
    end;
  end;
  nCheckCode := 0;
  //004C7A34
  try
    if not m_boDeath and (m_nIncStaySpell > 0) then begin    //지속물약-개인
      if GetTickCount() < m_dwStayMPTime then begin
        if ((GetTickCount - m_dwIncStaySpellTick) >= m_dwStayMPTick) then begin
          m_dwIncStaySpellTick:=GetTickCount();
          if (m_nIncStaySpell > 0) and (m_WAbil.MP <> m_WAbil.MaxMP) then begin
            nHP := 0;
            Inc(nMP,m_nIncStaySpell);
          end;
          IncHealthSpell(nHP,nMP);
        end;
      end else begin
        m_nIncStaySpell := 0;
        m_dwStayMPTime := 0;
        m_dwIncStaySpellTick:=GetTickCount();
        m_dwStatusArrTimeOutTick[76] := 0;
      end;
    end else begin
      m_dwIncStaySpellTick:=GetTickCount();
    end;

    if not m_boDeath and (m_nIncStayHealth > 0) then begin    //지속물약-개인
      if GetTickCount() < m_dwStayHPTime then begin
        if ((GetTickCount - m_dwIncStayHealthTick) >= m_dwStayHPTick) then begin
          m_dwIncStayHealthTick:=GetTickCount();
          if (m_nIncStayHealth > 0) then begin
            if (m_nIncStayHealth > 0) and (m_WAbil.HP <> m_WAbil.MaxHP) then begin
              Inc(nHP,m_nIncStayHealth);
              nMP := 0;
            end;
            IncHealthSpell(nHP,nMP);
          end;
        end;
      end else begin
        m_nIncStayHealth := 0;
        m_dwStayHPTime := 0;
        m_dwIncStayHealthTick:=GetTickCount();
        m_dwStatusArrTimeOutTick[76] := 0;
      end;
    end else begin //004C7CEA
      m_dwIncStayHealthTick:=GetTickCount();
    end;


    if not m_boDeath and (m_nGrIncStaySpell > 0) then begin    //지속물약-그룹
      if (GetTickCount() < m_dwGrStayMPTime) and (m_GroupOwner <> nil) then begin
        if ((GetTickCount - m_dwGrIncStaySpellTick) >= m_dwGrStayMPTick) then begin
          m_dwGrIncStaySpellTick:=GetTickCount();
          if (m_nGrIncStaySpell > 0) and (m_WAbil.MP <> m_WAbil.MaxMP) then begin
            nHP := 0;
            Inc(nMP,m_nGrIncStaySpell);
          end;
          IncHealthSpell(nHP,nMP);
        end;
      end else begin
        m_nGrIncStaySpell := 0;
        m_dwGrStayMPTime := 0;
        m_dwGrIncStaySpellTick:=GetTickCount();
        m_dwStatusArrTimeOutTick[77] := 0;
      end;
    end else begin
      m_dwGrIncStaySpellTick:=GetTickCount();
    end;

    if not m_boDeath and (m_nGrIncStayHealth > 0) then begin    //지속물약-그룹
      if (GetTickCount() < m_dwGrStayHPTime) and (m_GroupOwner <> nil) then begin
        if ((GetTickCount - m_dwGrIncStayHealthTick) >= m_dwGrStayHPTick) then begin
          m_dwGrIncStayHealthTick:=GetTickCount();
          if (m_nGrIncStayHealth > 0) and (m_WAbil.HP <> m_WAbil.MaxHP) then begin
            Inc(nHP,m_nGrIncStayHealth);
            nMP := 0;
          end;
          IncHealthSpell(nHP,nMP);
        end;
      end else begin
        m_nGrIncStayHealth := 0;
        m_dwGrStayHPTime := 0;
        m_dwGrIncStayHealthTick:=GetTickCount();
        m_dwStatusArrTimeOutTick[77] := 0;
      end;
    end else begin
      m_dwGrIncStayHealthTick:=GetTickCount();
    end;

    if not m_boDeath and ((m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nIncHealing > 0)) then begin
      dwInChsTime:=600 - _MIN(400,m_Abil.Level * 10);
      if ((GetTickCount - m_dwIncHealthSpellTick) >= dwInChsTime) and not m_boDeath then begin     //체약,마약을 먹으면 천천히 찬다.
        dwC:=_MIN(200,(GetTickCount - m_dwIncHealthSpellTick - dwInChsTime));
        m_dwIncHealthSpellTick:=GetTickCount() + dwC;
        if (m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nPerHealing > 0) then begin
          if (m_nPerHealth <= 0) then m_nPerHealth:= 1;
          if (m_nPerSpell <= 0) then m_nPerSpell:= 1;
          if (m_nPerHealing <= 0) then m_nPerHealing:= 1;
          if m_nIncHealth < m_nPerHealth then begin
            nHP:=m_nIncHealth;
            m_nIncHealth:=0;
          end else begin
            nHP:=m_nPerHealth;
            Dec(m_nIncHealth,m_nPerHealth);
          end;
          if m_nIncSpell < m_nPerSpell then begin
            nMP:=m_nIncSpell;
            m_nIncSpell:=0;
          end else begin
            nMP:=m_nPerSpell;
            Dec(m_nIncSpell,m_nPerSpell);
          end;
          
          //004C7BFD
          if m_nIncHealing < m_nPerHealing then begin
            Inc(nHP,m_nIncHealing);
            m_nIncHealing:=0;
          end else begin
            //004C7C2A
            Inc(nHP,m_nPerHealing);
            Dec(m_nIncHealing,m_nPerHealing);
          end;
          m_nPerHealth:=(m_Abil.Level div 10 + 5);
          m_nPerSpell:=(m_Abil.Level div 10 + 5);
          m_nPerHealing:=5;
          IncHealthSpell(nHP,nMP);

          //004C7C9B
          if m_WAbil.HP = m_WAbil.MaxHP then begin
            m_nIncHealth:=0;
            m_nIncHealing:=0;
          end;
          if m_WAbil.MP = m_WAbil.MaxMP then begin
            m_nIncSpell:=0;
          end;
        end;
      end;
    end else begin //004C7CEA
      m_dwIncHealthSpellTick:=GetTickCount();
    end;
    //004C7CF8
    if (m_nHealthTick < - g_Config.nHealthFillTime) and (m_WAbil.HP > 1) then begin //Jacky ????
      dec(m_WAbil.HP);
      Inc(m_nHealthTick,g_Config.nHealthFillTime);
      HealthSpellChanged();
    end;
    //쇱꿴HP/MP令角뤠댕黨離댕令，댕黨橙슉됴돕攣끽댕鬼
    boNeedRecalc:=False;
    if m_WAbil.HP > m_WAbil.MaxHP then begin
      boNeedRecalc:=True;
      m_WAbil.HP:=m_WAbil.MaxHP -1;
    end;
    if m_WAbil.MP > m_WAbil.MaxMP then begin
      boNeedRecalc:=True;
      m_WAbil.MP:=m_WAbil.MaxMP -1;
    end;
    if boNeedRecalc then HealthSpellChanged();

  except
    MainOutMessage(sExceptionMsg2);
  end;

  //004C7D59
  //TBaseObject.Run 3 헌잿커깃뚤蹶
  try
    if (m_TargetCret <> nil) then begin
      if ((GetTickCount() - m_dwTargetFocusTick) > 30000) or
         m_TargetCret.m_boDeath or
         m_TargetCret.m_boGhost or
         (m_TargetCret.m_PEnvir <> m_PEnvir) or // 08/06 藤속，묶숫括却瞳훙膠쏵흙렛쇌빈疼놔윱，뻘삔묑샌훙膠(훙膠돨묑샌커깃청헌뇜)
         (abs(m_TargetCret.m_nCurrX - m_nCurrX) > 15) or
         (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 15) then begin
          //004C7DE4
          m_TargetCret:=nil;
      end;
    end;
    //004C7DEF
    if (m_LastHiter <> nil) then begin
      if ((GetTickCount() - m_LastHiterTick) > 30000) or
         m_LastHiter.m_boDeath or
         m_LastHiter.m_boGhost then begin
          //004C7E34
        m_LastHiter:=nil;
      end;
    end;
    //004C7E3F
    //
    if (m_ExpHitter <> nil) then begin
      if ((GetTickCount() - m_ExpHitterTick) > 6000) or
         m_ExpHitter.m_boDeath or
         m_ExpHitter.m_boGhost then begin
          //004C7E84
        m_ExpHitter:=nil;
      end;
    end;
    //004C7E8F
    if (m_Master <> nil) then begin
      if (m_btRaceServer <> RC_HEROOBJECT) then m_boNoItem := True;
      if m_btRaceServer <> RC_HEROOBJECT then begin
        if (m_Master.m_boDeath and ((GetTickCount - m_Master.m_dwDeathTick) > 1000)) then begin
          if g_Config.boMasterDieMutiny and (m_Master.m_LastHiter <> nil) and (Random(g_Config.nMasterDieMutinyRate) = 0) then begin
            m_Master:=nil;
            m_btSlaveExpLevel:=High(g_Config.SlaveColor);
            RecalcAbilitys();
            m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower,HiWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower);
            m_nWalkSpeed:=m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
            RefNameColor;
            RefShowName;
          end else begin
            //004C7EFF
            m_WAbil.HP:=0;
          end;
        end;
        if m_Master.m_boGhost and ((GetTickCount - m_Master.m_dwGhostTick) > 1000) then begin
          MakeGhost;
        end;
      end;
    end;
    for i:=m_SlaveList.Count -1 downto 0 do begin
      if TBaseObject(m_SlaveList.Items[i]).m_boDeath or
         TBaseObject(m_SlaveList.Items[i]).m_boGhost or
         (TBaseObject(m_SlaveList.Items[i]).m_Master <> Self) then

      m_SlaveList.Delete(i);
    end;
    for i:=m_PetList.Count -1 downto 0 do begin
      if TBaseObject(m_PetList.Items[i]).m_boDeath or
         TBaseObject(m_PetList.Items[i]).m_boGhost or
         (TBaseObject(m_PetList.Items[i]).m_Master <> Self) then

      m_PetList.Delete(i);
    end;


    if m_boPobakSeize and ((GetTickCount() - m_dwPobakSeizeTick) > m_dwPobakSeizeInterval) then begin
      BreakPobakSeizeMode();
    end;
    if m_boHolySeize and ((GetTickCount() - m_dwHolySeizeTick) > m_dwHolySeizeInterval) then begin
      BreakHolySeizeMode();
    end;
    if m_boCrazyMode and ((GetTickCount() - m_dwCrazyModeTick) > m_dwCrazyModeInterval) then begin
      BreakCrazyMode();
    end;
    if m_boHallucMode and ((GetTickCount - m_dwHallucModeTick) > m_dwHallucModeInterval) then begin
      BreakHallucMode(); //미혼술
    end;
    if m_boShowHP and ((GetTickCount() - m_dwShowHPTick) > m_dwShowHPInterval) then begin
      BreakOpenHealth();
    end;
  except
    MainOutMessage(sExceptionMsg3);
  end;

  //SetProcessName('TBaseObject.Run ');
  //004C802F
  try
    nCheckCode:=4;
    // 숑PK令역迦
    if (GetTickCount() - m_dwDecPkPointTick) > g_Config.dwDecPkPointTime{120000} then begin
      m_dwDecPkPointTick:=GetTickCount();
      if m_nPkPoint > 0 then begin
        DecPKPoint(g_Config.nDecPkPointCount{1});
      end;
    end;
    // 숑PK令써監

    //쇱꿴亮츠膠틔섟PK榴檄 역迦
    nCheckCode:=41;
    if (GetTickCount - m_DecLightItemDrugTick) > g_Config.dwDecLightItemDrugTime{500} then begin
      Inc(m_DecLightItemDrugTick,g_Config.dwDecLightItemDrugTime{500});
      if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
        UseLamp();
        CheckPKStatus();
      end;
    end;
    //쇱꿴亮츠膠틔섟PK榴檄 써監

    nCheckCode:=42;
    if ((GetTickCount - m_dwCheckRoyaltyTick) > 10000) and (m_btRaceServer <> RC_HEROOBJECT) then begin
      m_dwCheckRoyaltyTick:=GetTickCount();
      nCheckCode:=477;
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if (m_GroupOwner <> nil) then begin
          nCheckCode := 431;
          if m_GroupOwner.m_boGhost then begin
            m_GroupOwner.DelMember(m_GroupOwner);
            m_GroupOwner := nil;
            nCheckCode := 432;
          end;

          nCheckCode := 433;
        end;
        nCheckCode := 44;
        if m_GroupOwner = Self then begin
          for i := m_GroupMembers.Count - 1 downto 0 do begin
            if m_GroupMembers.Count <= 0 then break;
            BaseObject := TBaseObject(m_GroupMembers.Objects[i]);
            if (BaseObject <> nil) and ((BaseObject.m_boGhost) or (BaseObject.m_GroupOwner <> self)) then begin
              BaseObject.LeaveGroup();
              m_GroupMembers.Delete(i);
            end;
          end;
          nCheckCode := 45;
          if not TPlayObject(Self).CancelGroup then begin
            SendDefMsg(Self, SM_GROUPCANCEL, 1, 0, 0, 0, '');
          end;
        end;
        nCheckCode := 46;
      end;
      nCheckCode:=479;
      if m_Master <> nil then begin
        if (m_btRaceServer <> RC_PET) then begin
          if (g_dwSpiritMutinyTick > GetTickCount) and (m_btSlaveExpLevel < 5) then begin
            m_dwMasterRoyaltyTick:=0;
          end;
          nCheckCode:=423;
          if (GetTickCount > m_dwMasterRoyaltyTick) then begin
            for I := 0 to m_Master.m_SlaveList.Count - 1 do begin
              nCheckCode:=424;
              if m_Master.m_SlaveList.Items[i] = Self then begin
                nCheckCode:=425;
                m_Master.m_SlaveList.Delete(i);
                break;
              end;
            end;
            m_Master:=nil;
            m_WAbil.HP:=m_WAbil.HP div 10;
            nCheckCode:=426;
            RefShowName();
          end;

          nCheckCode:=427;
          if m_dwMasterTick <> 0 then begin
            if (GetTickCount -  m_dwMasterTick) > 12 * 60 * 60 * 1000 then begin
              m_WAbil.HP:=0;
              BoDisapear := True;
            end;
          end;
        end else begin
          if (GetTickCount - m_dwCheckStatiey) > 60 * 60 * 1000 then begin
             m_dwCheckStatiey:=GetTickCount();
          end;
          if (GetTickCount > m_dwMasterRoyaltyTick) then begin
             RefShowName();
          end;
        end;
      end; //004C81DB
    end;

    if m_GroupOwner <> nil then begin
      for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
         BaseObject := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
         if (BaseObject.m_PEnvir.Flag.nMAPGROUP <> m_PEnvir.Flag.nMAPGROUP) then begin
            m_GroupOwner.DelMember(Self);
            m_GroupOwner := nil;
         end;
         if (BaseObject.m_PEnvir.Flag.boDEATHMATCH) or (m_PEnvir.Flag.boDEATHMATCH) then begin   //데스매치 그룹 해제
            m_GroupOwner.DelMember(Self);
            m_GroupOwner := nil;
         end;
         if (BaseObject.m_PEnvir.Flag.boNotGroup) or (m_PEnvir.Flag.boNotGroup) then begin   //그룹 해제
            m_GroupOwner.DelMember(Self);
            m_GroupOwner := nil;
         end;
      end;
    end;

    nCheckCode:=43;
    if (GetTickCount -  m_dwVerifyTick) > 30 * 1000 then begin
      m_dwVerifyTick:=GetTickCount();
      nCheckCode:=45;
      if (m_DealCreat <> nil) and (m_DealCreat.m_boGhost) then
        m_DealCreat:=nil;
      if (m_RentalCreat <> nil) and (m_RentalCreat.m_boGhost) then
         m_RentalCreat :=nil;
      nCheckCode:=46;
      if not m_boDenyRefStatus then
        m_PEnvir.VerifyMapTime(m_nCurrX,m_nCurrY,Self);  //岬劤瞳뒈暠鷗뿟천켁굴
    end;
  except
    on e: Exception do begin
      MainOutMessage(format(sExceptionMsg4,[nCheckCode,m_sCharName]));
      MainOutMessage(E.Message);
    end;
  end;

  //SetProcessName('TBaseObject.Run 5');
  try
    nCheckCode:=501;
    boChg:=False;
    boNeedRecalc:=False;
    //004C832E
    nCheckCode:=502;
    for i:=Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin  //004C832E
      nCheckCode:=503;
      if (m_wStatusTimeArr[i] > 0) and (m_wStatusTimeArr[i] < 60000) then begin
        nCheckCode:=504;
        if (GetTickCount() - m_dwStatusArrTick[i]) > 1000 then begin
          Dec(m_wStatusTimeArr[i]);
          Inc(m_dwStatusArrTick[i],1000);
          nCheckCode:=505;
          if (m_wStatusTimeArr[i] = 0) then begin
            boChg:=True;
            case i of
              POISON_DECHEALTH: begin   //녹독
                 SendMsg (Self,RM_COOLBUFF, 85, 0, 83, 0, '');
              end;
              POISON_DAMAGEARMOR: begin   //빨독
                 SendMsg (Self,RM_COOLBUFF, 86, 0, 84, 0, '');
              end;
              POISON_FREEZE: begin   //둔화
                 SendMsg (Self,RM_COOLBUFF, 87, 0, 85, 0, '');
              end;
              POISON_STUN: begin   //상태이상 스턴
                 SendMsg (Self,RM_COOLBUFF, 88, 0, 86, 0, '');
              end;
              POISON_SLOWDOWN: begin   //느리게 둔화
                 SendMsg (Self,RM_COOLBUFF, 89, 0, 87, 0, '');
              end;
              POISON_STONE: begin   //마비
                 SendMsg (Self,RM_COOLBUFF, 90, 0, 88, 0, '');
              end;
              POISON_HEMORRHAGE: begin   //혈풍격
                 SendMsg (Self,RM_COOLBUFF, 91, 0, 92, 0, '');
              end;
              POISON_THUNDER: begin   //복호장
                 SendMsg (Self,RM_COOLBUFF, 112, 0, 95, 0, '');
              end;


              STATE_TRANSPARENT: begin   //은신
                  m_boHideMode:=False;
              end;
              STATE_DEFENCEUP: begin
                boNeedRecalc:=True;
                if m_btRaceServer = RC_HEROOBJECT then begin
                  THeroObject(Self).SysMsg('亶衿돨렝徒제뿟릿攣끽。',c_Green,t_Hint);
                end else
                SysMsg('렝徒제뿟릿攣끽。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 12, 0, 10, 0, '');   //대지 버프
              end;
              STATE_MAGDEFENCEUP :begin
                boNeedRecalc:=True;
                if m_btRaceServer = RC_HEROOBJECT then begin
                  THeroObject(Self).SysMsg('亶衿돨침랬렝徒제뿟릿攣끽。',c_Green,t_Hint);
                end else
                SysMsg('침랬렝徒제뿟릿攣끽。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 13, 0, 11, 0, '');  //항마 버프
              end;
              STATE_BUBBLEDEFENCEUP :begin
                m_boAbilMagBubbleDefence:=False;
              end;
              STATE_PROTECTSHIELD  :begin  //호신강기
                m_boAbilMagProtectDefence:=False;
              end;
              STATE_KUMGANG :begin   //금강불괴
                m_boAbilMagKumGangDefence:=False;
                SendMsg (Self, RM_BUFF, 70, 0, 52, 0, ''); //금강불괴 버프
              end;
              STATE_SUNCHENDEFENCEUP :begin    //선천기공
                m_boAbilCelestialDefence:=False;
              end;
              STATE_BLOODSWORD :begin  //혈룡검법
                boNeedRecalc:=True;
                SysMsg('沂질숲랬槻벎綠句呵。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 58, 0, 46, 0, ''); //혈룡검법 버프
              end;
              STATE_MAGICUP :begin     //심연술
                boNeedRecalc:=True;
                SysMsg('雎錟椎㏏瓠拮滸㎕',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 56, 0, 37, 0, ''); //심연술 버프
              end;
              STATE_SPEEDRUN :begin   //경신보
                SysMsg('햐滋싻㏏瓠拮滸㎕',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 23, 0, 21, 0, ''); //경신보 버프
              end;
              STATE_ASSTRANSPARENT :begin   //월영술
                m_boHideMode:=False;
                m_wStatusTimeArr[STATE_TRANSPARENT]:=1;
                SysMsg('墩緞減槻벎綠句呵。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 26, 0, 24, 0, ''); //월영술 버프
              end;
              STATE_WINDMOON: begin      //청풍명월
                SysMsg('헌루츠墩槻벎綠句呵。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 16, 0, 14, 0, '');  //청풍명월 버프
              end;
              STATE_BLOODMOON: begin      //적혈무영
                SysMsg('븐질緞校槻벎綠句呵。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 64, 0, 120, 0, '');  //적혈무영 버프
              end;

              STATE_SKYSWORD :begin //천상비술
                SysMsg('莖衢襪椎㏏瓠拮滸㎕',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 60, 0, 48, 0, '');   //천상비술 버프
              end;
              STATE_PENETRATE :begin   //망자의옷
                m_boPenetrateMode:=False;
                m_PenetrateLastTick := GetTickCount();
                SendMsg (Self, RM_COOLBUFF, 93, 0, 79, 20, '[ 价俊쌀 ]\돕퍅珂쇌: ' );  //망자의눈 쿨타임 버프
                SysMsg('价俊쌀쨍슈便켕㏏瓠拮滸㎕',c_Green,t_Hint);
              end;
              STATE_YEONGMU :begin   //월영무
                m_boYeongMu:=False;
                SysMsg('墩緞絞槻벎綠句呵。',c_Green,t_Hint);
                SendMsg (Self,RM_BUFF, 75, 0, 57, 0, '');   //월영무 버프
              end;
              STATE_THUNDERWAVE :begin  //복호장
                m_btThunderPower := 0;
                SysMsg('륨빪벅랬槻벎綠句呵。',c_Green,t_Hint);
             //   SendMsg (Self,RM_BUFF, 109, 0, 74, 0, '');  //복호장 해제
                SendRefMsg(RM_SHOWEFFECT, EFFECT_THUNDERWAVE, Integer(Self), m_nCurrX, m_nCurrY, '');
              end;

            end;
          end else
          if (m_wStatusTimeArr[i]) = 10 then begin //10초전 메시지
            case i of
              STATE_DEFENCEUP: begin
                if m_btRaceServer = RC_HEROOBJECT then begin
                  THeroObject(Self).SysMsg('亶衿돨렝徒제瞳'+ IntToStr(m_wStatusTimeArr[i]) +'취빈뿟릿攣끽。', c_Green,t_Hint);
                end else
                SysMsg ('렝徒제瞳'+ IntToStr(m_wStatusTimeArr[i]) +'취빈뿟릿攣끽。', c_Green,t_Hint);
              end;
              STATE_MAGDEFENCEUP: begin
                if m_btRaceServer = RC_HEROOBJECT then begin
                  THeroObject(Self).SysMsg('亶衿돨침랬렝徒제'+ IntToStr(m_wStatusTimeArr[i]) +'취빈뿟릿攣끽。', c_Green,t_Hint);
                end else
                SysMsg ('침랬렝徒제瞳'+ IntToStr(m_wStatusTimeArr[i]) +'취빈뿟릿攣끽。', c_Green,t_Hint);
              end;
            end;
          end;
        end;
      end;
    end;
    nCheckCode:=506;
    //004C8409
    for i:=Low(m_wStatusArrValue) to High(m_wStatusArrValue) do begin
      nCheckCode:=507;
      if (m_wStatusArrValue[i] > 0) and not (i in [40..59,85..89,102,103,110..119]) then begin      //스승의가호 버프 //영물버프
        nCheckCode:=508;
        if GetTickCount() > m_dwStatusArrTimeOutTick[i] then begin
          m_wStatusArrValue[i]:=0;
          m_wStatusArrFlag[i]:=0;
          m_dwStatusArrTimeOutTick[i] := 0;
          boNeedRecalc:=True;
          case i of
            0: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨疆珂묑샌제뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('疆珂묑샌제뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 3, 0, 307, 0, '');    //파괴의물약 버프
            end;
            1: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨疆珂침랬제뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('疆珂침랬제뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 5, 0, 308, 0, '');   //마력의물약 버프
            end;
            2: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨疆珂돛減뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('疆珂돛減뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 6, 0, 309, 0, '');   //도력의물약 버프
            end;
            3: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨疆珂묑샌醵똑뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('疆珂묑샌醵똑뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 7, 0, 312, 0, '');   //광풍물약 버프
            end;
            4: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨疆珂餉篁돐寧닙勳！',c_Green,t_Hint);
              end else
              SysMsg('疆珂餉篁돐寧닙勳！',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 10, 0, 310, 0, '');   //육체 버프
            end;
            5: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨疆珂침랬令뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('疆珂침랬令뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 11, 0, 311, 0, '');  //정신 버프
            end;
            6: begin  //New
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨굳罹麓槻벎句呵죄。',c_Green,t_Hint);
              end else
              SysMsg('罹麓槻벎句呵죄。',c_Green,t_Hint);
            end;
            7: begin  //New
              SysMsg('숲폭괵맒속돨묑샌제뿟릿죄攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 1, 0, 0, 0, '');  //첨기폭 버프
            end;
            8: begin  //New
              SysMsg('빱昨評뻗슨撻캠임河┿寧늑坑勳！',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 2, 0, 1, 0, '');  //호신기막 버프
            end;
            9: begin
              if m_btRaceServer = RC_HEROOBJECT then
                THeroObject(Self).SysMsg('亶衿돨竟祺루槻벎綠句呵。',c_Green,t_Hint)
              else
              SysMsg('竟祺루槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 22, 0, 20, 0, '');  //체신풍 버프
            end;
            10: begin
              if m_btRaceServer = RC_HEROOBJECT then
                THeroObject(Self).SysMsg('亶衿돨루綽椎㏏瓠拮滸㎕',c_Green,t_Hint)
              else
              SysMsg('루綽椎㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 24, 0, 22, 0, '');  //풍신술 버프
            end;
            11: begin
              m_boChunMuSkill := 0;
              SysMsg('莖蛟槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 54, 0, 39, 0, '');  //천무 버프
            end;
            12: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨餉環寧닐綺寧닙勳！',c_Green,t_Hint);
              end else
              SysMsg('餉環寧닐綺寧닙勳！',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 34, 0, 31, 0, '');  //흡성대법 버프
            end;
            13: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨침랬뿟릿綠뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('침랬뿟릿綠뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 35, 0, 32, 0, '');  //강마진법 버프
            end;
            14: begin
              m_boDropDurg := False; //환템 드랍
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨괵쪽綠뿟릿攣끽。',c_Green,t_Hint)
              end else begin
                SysMsg('괵쪽綠뿟릿攣끽。',c_Green,t_Hint);
                SendMsg(Self,RM_ToSendMsg,0,86,0,0,'');
              end;
            end;
            15: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨묑샌제綠뿟릿攣끽。',c_Green,t_Hint)
              end else begin
                if m_btJob = 4 then begin    //직업변경
                 SysMsg('묑샌제、돛減綠뿟릿攣끽。',c_Green,t_Hint);
                end else begin
                  SysMsg('묑샌제綠뿟릿攣끽。',c_Green,t_Hint);
                end;
              end;
              SendMsg (Self,RM_BUFF, 4, 0, 2, 0, '');  //무극진기 버프
            end;
            17: begin
              SysMsg('莖쥣彊槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 52, 0, 317, 0, '');  //천령수 버프
            end;
            18: begin
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨硫횅浪彊槻벎綠句呵。',c_Green,t_Hint);
              end else
              SysMsg('硫횅浪彊槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 17, 0, 320, 0, '');  //정확의물약 버프
            end;
            26: begin
              SysMsg('圖헌彊槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 44, 0, 305, 0, '');  //옥청수 버프
            end;
            28: begin
              m_boFastTrain2 := False;
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨세콘坎족똑綠뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('세콘坎족똑綠뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 53, 0, 318, 0, '');  //수련의물약 버프
            end;
            29: begin
              SysMsg('莖洲돝鶩㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 63, 0, 508, 0, '');  //수라강림 버프
            end;
            30: begin
              SysMsg('햐滋싻㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 25, 0, 23, 0, '');  //경신보 쿨타임 버프
            end;
            31: begin
              SysMsg('죠삽棧㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 27, 0, 25, 0, '');  //열화신 쿨타임 버프
            end;
            32: begin
              SysMsg('莖蛟槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 55, 0, 40, 0, '');  //천무 쿨타임 버프
            end;
            33: begin
              SysMsg('雎錟椎㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 57, 0, 38, 0, '');  //심연술 쿨타임 버프
            end;
            34: begin
              SysMsg('沂질숲랬槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 59, 0, 47, 0, '');  //혈룡검법 쿨타임 버프
            end;
            35: begin
              SysMsg('莖衢襪椎㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 61, 0, 49, 0, '');  //천상비술 쿨타임 버프
            end;
            36: begin
              SysMsg('챔敾셸㏏瓠拮滸㎕',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 62, 0, 50, 0, '');  //묘설란 쿨타임 버프
            end;
            60: begin
              SysMsg('价空裂癩槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 68, 0, 16, 0, '');  //망자의눈 쿨타임 버프
            end;
            61: begin
              SysMsg('쏜먼꼇뻐槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 71, 0, 53, 0, '');  //금강불괴 쿨타임 버프
            end;

            63: begin
              SysMsg('잉鉤루槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 73, 0, 55, 0, '');  //뢰선풍 쿨타임 버프
            end;
            65: begin
              SysMsg('綾捺巧契黎槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 74, 0, 56, 0, '');  //음양오행진 쿨타임 버프
            end;
            66: begin
              SysMsg('墩緞絞槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 76, 0, 58, 0, '');  //월영무 쿨타임 버프
            end;
            67: begin
              SysMsg('緞沂瑠槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 77, 0, 49, 0, ''); //영적추 쿨타임 버프
            end;
            68: begin
              SysMsg('겜빪퓻쭝槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 78, 0, 26, 0, '');  //백호강타 쿨타임 버프
            end;
            69: begin
              SysMsg('懦띳槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 79, 0, 27, 0, '');  //교악 쿨타임 버프
            end;
            70: begin
              SysMsg('逞퓻寧샌槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 80, 0, 50, 0, '');  //신기묘산 쿨타임 버프
            end;
            71: begin
              SysMsg('暾櫓쭝잉槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 81, 0, 59, 0, '');  //운중뢰격 쿨타임 버프
            end;
            72: begin
              SysMsg('갠뗀맙썹槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 82, 0, 60, 0, '');  //암독만계 쿨타임 버프
            end;
            73: begin
              SysMsg('盡緞減槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 108, 0, 67, 0, '');  //은형술 쿨타임 버프
            end;

            75: begin
              SysMsg('샌왕벅랬槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 111, 0, 76, 0, '');  //격공장 쿨타임 버프
            end;

            76: begin //지속물약 - 개인 버프해제
              SysMsg('몸훙넣崎浪彊槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 118, 0, 467, 0, '');
            end;
            77: begin //지속물약 - 그룹 버프해제
              SysMsg('莉뚠넣崎浪彊槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 119, 0, 468, 0, '');
            end;

            80: begin   //변신탈
               m_btMask := 0;
               SendMsg (Self,RM_BUFF, 33, 0, 19, 0, '');    //변신탈 버프
               FeatureChanged();
            end;
            81: begin    //선천진기 - 승려
              SysMsg('邱莖廬폭돨槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 94, 0, 409, 0, '');  //선천진기 버프
            end;
            82: begin
              SysMsg('퓻빱減돨槻벎綠句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_COOLBUFF, 113, 0, 71, 0, ''); //강호술 쿨타임 버프
            end;
            83: begin //양용왕 사라짐
              m_boAdminMode:=False;
            end;
            84: begin //선천
              SysMsg('到뺏되鉤돨槻벎綠쒔句呵。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 120, 0, 98, 0, '');
            end;
          //=========================이벤트물약========================
            90: begin
              SysMsg('疆珂묑샌제뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 96, 0, 307, 0, '');
            end;
            91: begin
              SysMsg('疆珂침랬뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 97, 0, 308, 0, '');
            end;
            92: begin
              SysMsg('疆珂돛減뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 98, 0, 309, 0, '');
            end;
            93: begin
              SysMsg('疆珂렝徒제뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 99, 0, 870, 0, '');
            end;
            94: begin
              SysMsg('疆珂침랬렝徒제뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 100, 0, 871, 0, '');
            end;
            95: begin
              SysMsg('疆珂餉篁돐寧닙勳！',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 101, 0, 310, 0, '');
            end;
            96: begin
              SysMsg('疆珂침랬令뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 102, 0, 311, 0, '');
            end;
            97: begin
              SysMsg('疆珂묑샌醵똑뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 103, 0, 312, 0, '');
            end;
            98: begin
              SysMsg('疆珂硫횅뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 104, 0, 320, 0, '');
            end;
            99: begin
              SysMsg('疆珂츌쌥뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 105, 0, 319, 0, '');
            end;
            100: begin
              SysMsg('疆珂침랬뜰긁뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 106, 0, 332, 0, '');
            end;
            101: begin
              SysMsg('疆珂뗀膠뜰긁뿟릿攣끽。',c_Green,t_Hint);
              SendMsg (Self,RM_BUFF, 107, 0, 333, 0, '');
            end;
            //============================================================
            104: begin   //흡성 방어
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨렝徒제綠뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('렝徒제綠뿟릿攣끽。',c_Green,t_Hint);
            end;
            105: begin   //강마 마방
              if m_btRaceServer = RC_HEROOBJECT then begin
                THeroObject(Self).SysMsg('亶衿돨침랬렝徒제綠뿟릿攣끽。',c_Green,t_Hint);
              end else
              SysMsg('침랬렝徒제綠뿟릿攣끽。',c_Green,t_Hint);
            end;

            120: begin   //음양오행진
               m_boOhaeng := False;
            end;
          end;
          nCheckCode:=509;
        end else  if (m_wStatusArrFlag[i] = 0) and (GetTickCount() > m_dwStatusArrTimeOutTick[i] - 10000) then begin
          m_wStatusArrFlag[i]:=1;
          nCheckCode:=510;
          case i of
           0  :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂묑샌제瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('파괴력 순간 상승 해제 10초 전', c_Green,t_Hint);
           1  :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂침랬瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('마법력 순간 상승 해제 10초 전', c_Green,t_Hint);
           2  :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂돛減瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('도력 순간 상승 해제 10초 전', c_Green,t_Hint);
           3  :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂묑샌醵똑瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('공격속도 순간 상승 해제 10초 전', c_Green,t_Hint);
           4  :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂餉篁둣10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('체력 순간 상승 해제 10초 전', c_Green,t_Hint);
           5  :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂침랬令瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('마력 순간 상승 해제 10초 전', c_Green,t_Hint);
           12 :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂餉環寧님10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('체력 회복률 순간 상승 해제 10초 전', c_Green,t_Hint);
           13 :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨疆珂침랬뿟릿瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else SysMsg ('마력 회복률 순간 상승 해제 10초 전', c_Green,t_Hint);
           15 :  if m_btRaceServer = RC_HEROOBJECT then THeroObject(Self).SysMsg ('亶衿돨묑샌제瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint) else  SysMsg ('파괴력 상승 해제 10초 전', c_Green,t_Hint);

           90       :  SysMsg ('疆珂묑샌제瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           91       :  SysMsg ('疆珂침랬瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           92       :  SysMsg ('疆珂돛減瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           93       :  SysMsg ('疆珂렝徒제瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           94       :  SysMsg ('疆珂침랬렝徒제瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           95       :  SysMsg ('疆珂餉篁둣10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           96       :  SysMsg ('疆珂침랬令瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           97       :  SysMsg ('疆珂묑샌醵똑瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           98       :  SysMsg ('疆珂硫횅瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           99       :  SysMsg ('疆珂츌쌥瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           100      :  SysMsg ('疆珂침랬뜰긁瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
           101      :  SysMsg ('疆珂뗀膠뜰긁瞳10취爐빈뿟릿攣끽。', c_Green,t_Hint);
          end;
        end;
      end;
    end;
    nCheckCode:=511;
    for i:=0 to EXTRAABIL_SIZE -1 do begin
         if ExtraAbil[i] > 0 then begin
            if GetTickCount > ExtraAbilTimes[i] then begin
               ExtraAbil[i] := 0;
               ExtraAbilFlag[i] := 0;
               boNeedRecalc := TRUE;
               case i of
                  EABIL_DCUP        :  SysMsg ('疆珂묑샌제뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_MCUP        :  SysMsg ('疆珂침랬뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_SCUP        :  SysMsg ('疆珂돛減뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_HITSPEEDUP  :  SysMsg ('疆珂묑샌醵똑뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_HPUP        :  SysMsg ('疆珂餉篁돐寧닙勳！',c_Green,t_Hint);
                  EABIL_MPUP        :  SysMsg ('疆珂침랬令뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_PWRRATE     :  if m_btRaceServer = RC_HEROOBJECT then  THeroObject(Self).SysMsg ('亶衿돨묑샌퓻똑綠뿟릿攣끽。',c_Green,t_Hint); else SysMsg ('공격력 저하 해제',c_Green,t_Hint);
               end;
            end else if (ExtraAbilFlag[i] = 0) and (GetTickCount > ExtraAbilTimes[i] - 10000) then begin
               ExtraAbilFlag[i] := 1;
               case i of
                  EABIL_DCUP        :  SysMsg ('疆珂묑샌제瞳10취爐빈뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_MCUP        :  SysMsg ('疆珂침랬瞳10취爐빈뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_SCUP        :  SysMsg ('疆珂돛減瞳10취爐빈뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_HITSPEEDUP  :  SysMsg ('疆珂묑샌醵똑瞳10취爐빈뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_HPUP        :  SysMsg ('疆珂餉篁둣10취爐빈뿟릿攣끽。',c_Green,t_Hint);
                  EABIL_MPUP        :  SysMsg ('疆珂침랬令瞳10취爐빈뿟릿攣끽。',c_Green,t_Hint);
               end;
            end;
         end;
      end;
      nCheckCode:=512;

    //004C84F5
    if boChg then begin
      nCheckCode:=513;
      m_nCharStatus:=GetCharStatus();
      nCheckCode:=514;
      StatusChanged();
      nCheckCode:=515;
      FeatureChanged();
    end;
    //004C8511
    nCheckCode:=516;
    if boNeedRecalc then begin
      nCheckCode:=517;
      RecalcAbilitys();
      nCheckCode:=518;
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0 ,0, 0, 0, '');
    end;
  except
    MainOutMessage(format(sExceptionMsg5,[nCheckCode,m_sCharName]));
  end;

  //SetProcessName('TBaseObject.Run 6');
  //004C855A
  try
    if (GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime{2500} then begin
      m_dwPoisoningTick:=GetTickCount();
      if m_wStatusTimeArr[POISON_DECHEALTH] > 0 then begin
        if m_boAnimal then
        Dec(m_nMeatQuality,1000);
        DamageHealth(m_btGreenPoisoningPoint + 1);
        m_nHealthTick:=0;
        m_nSpellTick:=0;
        HealthSpellChanged();
      end;
      if m_wStatusTimeArr[STATE_THUNDERWAVE] <> 0 then begin   //복호장 마력 소모
        DamageSpell(m_btThunderWavePoint);
        m_nHealthTick:=0;
        m_nSpellTick:=0;
        HealthSpellChanged();
      end;

      if (m_wStatusArrValue[81] > 0) and m_boSunchunUse then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          UserMagic := GetMagicInfo(SKILL_SUNCHUNJIN);  //선천진기
          if Assigned(UserMagic) then begin
            case UserMagic.btLevel of
            1: begin
                nMagLevel := 20;
                nRate := 20;
              end;
            2: begin
                nMagLevel := 30;
                nRate := 30;
              end;
            3: begin
                nMagLevel := 40;
                nRate := 40;
              end;
              else begin
                nMagLevel := 10;
                nRate := 10;
              end;
            end;
            if Random(100) < nMagLevel then begin
              if m_WAbil.HP <> m_WAbil.MaxHP then begin
                if m_wStatusTimeArr[STATE_WINDMOON] > 0 then
                  nRate := Round(nRate * 1.3);
                Inc(m_nIncHealth, nRate);
                SendRefMsg(RM_SHOWEFFECT, EFFECT_MEDITATION, Integer(Self), m_nCurrX, m_nCurrY, '');
              end;
            end;
          end;
        end;
      end;
    end;
    if GetTickCount - m_dwHemorrHageTick > 3000 then begin   //혈풍격 3초마다
      m_dwHemorrHageTick := GetTickCount;
      if (not m_boDeath) and (m_wStatusTimeArr[POISON_HEMORRHAGE] > 0) then begin
        SendRefMsg (RM_10205, 0, m_nCurrX, m_nCurrY, NE_TICKHEMORRHAGE, '0');  //혈풍격 이팩트
        SendMsg(m_LastHiter, RM_HEMORRHAGE_STRUCK, 0, HemorrhageLevel, 0, 0, '');
        m_nHealthTick := 0;  //체력 회복 안됨
        m_nSpellTick := 0;   //마력 회복 안됨
        HealthSpellChanged;
      end;

      if (not m_boDeath) then begin
        if (m_wStatusTimeArr[POISON_THUNDER] > 0) then begin
          SendRefMsg (RM_10205, 0, m_nCurrX, m_nCurrY, NE_THUNDERHAGE, '0');  //복호장 이팩트
          SendMsg(m_LastHiter, RM_THUNDER_STRUCK, 0, ThunderLevel, 0, 0, '');
          m_nHealthTick := 0;  //체력 회복 안됨
          m_nSpellTick := 0;   //마력 회복 안됨
          HealthSpellChanged;
        end;
      end else begin
        m_wStatusTimeArr[POISON_THUNDER] := 1;
      end;
    end;
    if GetTickCount - m_dwOhaengTick > 1000 then begin //음양오행진
      m_dwOhaengTick := GetTickCount;
      if (not m_boDeath) and (m_wStatusArrValue[120] > 0) and (m_boOhaeng) then begin
        IncHealth(m_wStatusArrValue[120]);
        SendRefMsg(RM_10205, 0, m_nCurrX, m_nCurrY, 122, '0');
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;
    end;

  {
  if boOpenHealth then begin
    if (GetTickCount() - dwOpenHealthStart) > dwOpenHealthTime then begin
      BreakOpenHealth();
    end;
  end;
  }
  g_nBaseObjTimeMin:=GetTickCount - dwRunTick;
  if g_nBaseObjTimeMax < g_nBaseObjTimeMin then g_nBaseObjTimeMax:=g_nBaseObjTimeMin;

  except
    MainOutMessage(sExceptionMsg6);
  end;
end;

function TPlayObject.DayBright: Byte;
begin
  if m_PEnvir.Flag.boDarkness then Result := 1
  else if (m_btBright = 1) then
    Result := 0
  else if (m_btBright = 3) then
    Result := 1
  else
    Result := 2;

  if m_PEnvir.Flag.boDayLight then Result := 0;
end;



function TBaseObject.GetFrontPosition(var nX:Integer;var nY:Integer):Boolean;//004B2790
var
  Envir:TEnvirnoment;
begin
  Envir:=m_PEnvir;
  nX:=m_nCurrX;
  nY:=m_nCurrY;
  case m_btDirection of    //
    DR_UP: begin
      if nY > 0 then Dec(nY);
    end;
    DR_UPRIGHT: begin
      if (nX < (Envir.m_nWidth -1)) and (nY > 0) then begin
       Inc(nX);
       Dec(nY);
      end;
    end;
    DR_RIGHT: begin
     if nX < (Envir.m_nWidth -1) then Inc(nX);
    end;
    DR_DOWNRIGHT: begin
      if (nX < (Envir.m_nWidth -1)) and (nY < (Envir.m_nHeight -1)) then begin
       Inc(nX);
       Inc(nY);
      end;
    end;
    DR_DOWN: begin
     if nY < (Envir.m_nHeight -1) then Inc(nY);
    end;
    DR_DOWNLEFT: begin
      if (nX > 0) and (nY < (Envir.m_nHeight -1)) then begin
       Dec(nX);
       Inc(nY);
      end;
    end;
    DR_LEFT: begin
      if nX > 0 then Dec(nX);
    end;
    DR_UPLEFT: begin
      if (nX > 0) and (nY > 0) then begin
        Dec(nX);
        Dec(nY);
      end;
    end;
  end;
  Result:=True;
end;


function TBaseObject.GetFrontSecPosition(var nX:Integer;var nY:Integer):Boolean;//004B2790
var
  Envir:TEnvirnoment;
begin
  Envir:=m_PEnvir;
  nX:=m_nCurrX;
  nY:=m_nCurrY;
  case m_btDirection of    //
    DR_UP: begin
      if nY > 0 then Dec(nY, 2);
    end;
    DR_UPRIGHT: begin
      if (nX < (Envir.m_nWidth -1)) and (nY > 0) then begin
       Inc(nX, 2);
       Dec(nY, 2);
      end;
    end;
    DR_RIGHT: begin
     if nX < (Envir.m_nWidth -1) then Inc(nX, 2);
    end;
    DR_DOWNRIGHT: begin
      if (nX < (Envir.m_nWidth -1)) and (nY < (Envir.m_nHeight -1)) then begin
       Inc(nX, 2);
       Inc(nY, 2);
      end;
    end;
    DR_DOWN: begin
     if nY < (Envir.m_nHeight -1) then Inc(nY, 2);
    end;
    DR_DOWNLEFT: begin
      if (nX > 0) and (nY < (Envir.m_nHeight -1)) then begin
       Dec(nX, 2);
       Inc(nY, 2);
      end;
    end;
    DR_LEFT: begin
      if nX > 0 then Dec(nX, 2);
    end;
    DR_UPLEFT: begin
      if (nX > 0) and (nY > 0) then begin
        Dec(nX, 2);
        Dec(nY, 2);
      end;
    end;
  end;
  Result:=True;
end;

function TBaseObject.GetFrontPositionEx(var nX: Integer; var nY: Integer;n:byte = 3): Boolean;
var
  Envir: TEnvirnoment;
  i:integer;
begin
  Envir := m_PEnvir;
  i:=0;
  while true do begin
    nX := m_nCurrX - n + Random(n*2);
    nY := m_nCurrY - n + Random(n*2);
    if Envir.CanWalk(nX, nY, false) then begin
      Result := True;
      break;
    end else  begin
      i:=i+1;
      if i > 20 then
      begin
        Result := false;
        break;
      end;
    end;
  end;
end;

function TBaseObject.GetRecallPosition(x, y, wide: integer; var dx, dy: integer): boolean;
var
  i, j, k: integer;

begin
  Result := False;
  if m_PEnvir.GetMovingObject(x, y, True) = nil then begin
    Result := True;
    dx     := x;
    dy     := y;
  end;
  if not Result then begin
    for k := 1 to wide do begin
      for j := -k to k do begin
        for i := -k to k do begin
          dx := x + i;
          dy := y + j;
          if m_PEnvir.GetMovingObject(dx, dy, True) = nil then begin
            Result := True;
            break;
          end;
        end;
        if Result then
          break;
      end;
      if Result then
        break;
    end;
  end;
  if not Result then begin //아니면 자기 자리...
    dx := x;// - wide + Random(wide*2+1);
    dy := y;// - wide + Random(wide*2+1);
  end;
end;

//mapname의 맵은 항상 0번맵 혹은 아마나 갈 수 있는 바탕맵이다.
procedure TBaseObject.RandomSpaceMove (mname: string; mtype: integer);
var
   nx, ny, egdey: integer;
   nenvir, oldenvir: TEnvirnoment;
 //  hum: TUserHuman;
begin
   oldenvir := m_PEnvir;
   nenvir := g_MapManager.FindMap (mname);
   if nenvir <> nil then begin
      if nenvir.m_nHeight < 150 then begin
         if nenvir.m_nHeight < 30 then egdey := 2
         else egdey := 20;
      end else egdey := 50;
      nx := egdey + Random(nenvir.m_nWidth-egdey-1);
      ny := egdey + Random(nenvir.m_nHeight-egdey-1);
      SpaceMove (mname, nx, ny, mtype);

   end;
end;
//mapname의 맵은 항상 0번맵 혹은 아마나 갈 수 있는 바탕맵이다.
//현재 맵에서 반경이 InRange보다 크고 OutRange보다 작은 범위로 랜덤하게 이동.
procedure TBaseObject.RandomSpaceMoveInRange (mtype, InRange, OutRange: integer);
var
   ran, signX, signY, nx, ny: integer;
   moverange : integer;
begin
   //초기화.
   signX := 1;
   signY := 1;

   if m_PEnvir <> nil then begin
      ran := Random(100);
      ran := ran mod 4;

      case ran of
      0:
         begin
            signX := 1;
            signY := 1;
         end;
      1:
         begin
            signX := -1;
            signY := 1;
         end;
      2:
         begin
            signX := -1;
            signY := -1;
         end;
      3:
         begin
            signX := 1;
            signY := -1;
         end;
      end;

      nx := m_nCurrX + signX * (InRange + Random(OutRange - InRange) + 1);
      // 지도의 사이즈보다 클 경우에 넘어가지 않도록 수정...
      // 넘어가면 SpaceMove 함수 안에서 랜덤하게 튕길 수 있다.
      if nx >= m_PEnvir.m_nWidth then begin
         nx := m_PEnvir.m_nWidth -1;
      end else if nx < 0 then begin
         nx := 0;
      end;

      ny := m_nCurrY + signY * (InRange + Random(OutRange - InRange) + 1);
      // 지도의 사이즈보다 클 경우에 넘어가지 않도록 수정...
      // 넘어가면 SpaceMove 함수 안에서 랜덤하게 튕길 수 있다.
      if ny >= m_PEnvir.m_nHeight then begin
         ny := m_PEnvir.m_nHeight -1;
      end else if ny < 0 then begin
         ny := 0;
      end;

      SpaceMove (m_PEnvir.sMapName, nx, ny, mtype);
   end;
end;

procedure TBaseObject.SpaceMove(sMap:String;nX,nY:Integer;nInt:Integer);//004BCD1C   //맵 이동     //nomove작업
  function GetRandXY(Envir:TEnvirnoment;var nX:Integer;var nY:Integer):Boolean;
  var
    n14,n18,n1C:Integer;
  begin
    Result:=False;
    if Envir.m_nWidth < 80 then n18:=3
    else n18:=10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C:=2
      else n1C:=15;
    end else n1C:=50;
    n14:=0;
    while (True) do begin
      if Envir.CanWalk(nX,nY,True) then begin
        Result:=True;
        break;
      end;
      if nX < (Envir.m_nWidth - n1C -1) then Inc(nX,n18)
      else begin
        nX:=Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C -1) then Inc(nY,n18)
        else nY:=Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then break;
    end;
  end;
var
  I: Integer;
  Envir,OldEnvir:TEnvirnoment;
  nOldX,nOldY:Integer;
  bo21:Boolean;
  PlayObject:TPlayObject;
begin
  if m_boStore then Exit;
  if m_PEnvir.Flag.boNOMOVE then begin        //nomove작업
    SysMsg('뎠품혐堵쐐岺盧땡。',c_RedWhite,t_Hint);
    Exit;
  end;
  Envir:=g_MapManager.FindMap(sMap);
  if Envir <> nil then begin
    if nServerIndex = Envir.nServerIndex then begin
      OldEnvir := m_PEnvir;
      nOldX    := m_nCurrX;
      nOldY    := m_nCurrY;
      bo21     := False;

      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then DelMapCount;  //관리자시스템

      m_VisibleHumanList.Clear;
      for I := 0 to m_VisibleItems.Count - 1 do begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end;
      m_VisibleItems.Clear;
      for I := 0 to m_VisibleActors.Count - 1 do begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
      m_VisibleActors.Clear;
      m_VisibleEvents.Clear; //01/21 盧땡珂헌뇜죗깊
      m_PEnvir:=Envir;
      m_sMapName:=Envir.sMapName;
      m_nCurrX:=nX;
      m_nCurrY:=nY;
      if GetRandXY(m_PEnvir,m_nCurrX,m_nCurrY) then begin
        m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
        if (m_btRaceServer = RC_PLAYOBJECT) then begin
          SendMsg(Self,RM_CLEAROBJECTS,0,0,0,0,'');
          SendMsg(Self,RM_CHANGEMAP,0,0,0,0,m_sMapName);         //맵이동
        end;
        if nInt = 1 then begin
          SendRefMsg(RM_SPACEMOVE_SHOW2,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        end else SendRefMsg(RM_SPACEMOVE_SHOW,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        m_dwMapMoveTick:=GetTickCount();
        m_bo316:=True;
        bo21:=True;
      end; //004BCFA9
      if not bo21 then begin
        m_PEnvir := OldEnvir;
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
      end;
      AddMapCount;           //관리자시스템
    end else begin //004BCFF6
      if GetRandXY(Envir,nX,nY) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          DisappearA();
          m_bo316:=True;
          PlayObject:=TPlayObject(Self);
          PlayObject.m_sSwitchMapName:=Envir.sMapName;
          PlayObject.m_nSwitchMapX:=nX;
          PlayObject.m_nSwitchMapY:=nY;
          PlayObject.m_boSwitchData:=True;
          PlayObject.m_nServerIndex:=Envir.nServerIndex;
          PlayObject.m_boEmergencyClose:=True;
          PlayObject.m_boReconnection:=True;
        end else KickException();
      end;
    end;
  end;
end;

procedure TBaseObject.NoSpaceMove(sMap:String;nX,nY:Integer;nInt:Integer);//004BCD1C   //맵 이동     //nomove작업
  function GetRandXY(Envir:TEnvirnoment;var nX:Integer;var nY:Integer):Boolean;
  var
    n14,n18,n1C:Integer;
  begin
    Result:=False;
    if Envir.m_nWidth < 80 then n18:=3
    else n18:=10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C:=2
      else n1C:=15;
    end else n1C:=50;
    n14:=0;
    while (True) do begin
      if Envir.CanWalk(nX,nY,True) then begin
        Result:=True;
        break;
      end;
      if nX < (Envir.m_nWidth - n1C -1) then Inc(nX,n18)
      else begin
        nX:=Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C -1) then Inc(nY,n18)
        else nY:=Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then break;
    end;
  end;
var
  I: Integer;
  Envir,OldEnvir:TEnvirnoment;
  nOldX,nOldY:Integer;
  bo21:Boolean;
  PlayObject:TPlayObject;
begin
  if m_boStore then Exit;
  Envir:=g_MapManager.FindMap(sMap);
  if Envir <> nil then begin
    if nServerIndex = Envir.nServerIndex then begin
      OldEnvir := m_PEnvir;
      nOldX    := m_nCurrX;
      nOldY    := m_nCurrY;
      bo21     := False;

      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then DelMapCount;     //관리자시스템
      m_VisibleHumanList.Clear;
      for I := 0 to m_VisibleItems.Count - 1 do begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end;
      m_VisibleItems.Clear;
      for I := 0 to m_VisibleActors.Count - 1 do begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
      m_VisibleActors.Clear;
      m_VisibleEvents.Clear; //01/21 盧땡珂헌뇜죗깊
      m_PEnvir:=Envir;
      m_sMapName:=Envir.sMapName;
      m_nCurrX:=nX;
      m_nCurrY:=nY;
      if GetRandXY(m_PEnvir,m_nCurrX,m_nCurrY) then begin
        m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
        if m_btRaceServer = RC_PLAYOBJECT then begin
          SendMsg(Self,RM_CLEAROBJECTS,0,0,0,0,'');
          SendMsg(Self,RM_CHANGEMAP,0,0,0,0,m_sMapName);         //맵이동
        end;
        if nInt = 1 then begin
          SendRefMsg(RM_SPACEMOVE_SHOW2,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        end else SendRefMsg(RM_SPACEMOVE_SHOW,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        m_dwMapMoveTick:=GetTickCount();
        m_bo316:=True;
        bo21:=True;
      end; //004BCFA9
      if not bo21 then begin
        m_PEnvir := OldEnvir;
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
      end;
      AddMapCount;                 //관리자시스템
    end else begin //004BCFF6
      if GetRandXY(Envir,nX,nY) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          DisappearA();
          m_bo316:=True;
          PlayObject:=TPlayObject(Self);
          PlayObject.m_sSwitchMapName:=Envir.sMapName;
          PlayObject.m_nSwitchMapX:=nX;
          PlayObject.m_nSwitchMapY:=nY;
          PlayObject.m_boSwitchData:=True;
          PlayObject.m_nServerIndex:=Envir.nServerIndex;
          PlayObject.m_boEmergencyClose:=True;
          PlayObject.m_boReconnection:=True;
        end else KickException();
      end;
    end;
  end;
end;

procedure TBaseObject.SpaceMagMove(nX, nY: Integer; nInt: Integer);  //일섬
  function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
  var
    n14, n18, n1C: Integer;
  begin
    Result := False;
    if Envir.m_nWidth < 80 then n18 := 3
    else n18 := 10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C := 2
      else n1C := 15;
    end else n1C := 50;
    n14 := 0;
    while (True) do begin
      if Envir.CanWalk(nX, nY, True) then begin
        Result := True;
        Break;
      end;
      if nX < (Envir.m_nWidth - n1C - 1) then Inc(nX, n18)
      else begin
        nX := Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C - 1) then Inc(nY, n18)
        else nY := Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then Break;
    end;
  end;
var
  I: Integer;
  nOldX, nOldY: Integer;
  bo21: Boolean;
  PlayObject: TPlayObject;
begin
  if m_boStore then Exit;
  nOldX := m_nCurrX;
  nOldY := m_nCurrY;
  bo21 := False;

  if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then DelMapCount;   //관리자시스템
  m_nCurrX := nX;
  m_nCurrY := nY;
  if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then begin
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);

    if nInt = 1 then begin
      SendRefMsg(RM_SPACEMOVE_SHOW4, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    end else SendRefMsg(RM_SPACEMOVE_SHOW4, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //일섬 이펙트
    m_dwMapMoveTick2 := GetTickCount();
    m_bo316 := True;
    bo21 := True;
  end;
  if not bo21 then begin
    m_nCurrX := nOldX;
    m_nCurrY := nOldY;
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  end;
  AddMapCount;        //관리자시스템
end;

procedure TBaseObject.SpaceMaMagMove(nX, nY: Integer; nInt: Integer);  //마혈광섬
  function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
  var
    n14, n18, n1C: Integer;
  begin
    Result := False;
    if Envir.m_nWidth < 80 then n18 := 3
    else n18 := 10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C := 2
      else n1C := 15;
    end else n1C := 50;
    n14 := 0;
    while (True) do begin
      if Envir.CanWalk(nX, nY, True) then begin
        Result := True;
        Break;
      end;
      if nX < (Envir.m_nWidth - n1C - 1) then Inc(nX, n18)
      else begin
        nX := Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C - 1) then Inc(nY, n18)
        else nY := Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then Break;
    end;
  end;
  function directionDir(dir: integer): integer;
  begin
    if dir in [0..3] then begin
      Result := dir + 4;
    end else begin
      Result := dir - 4;
    end;
  end;
var
  I: Integer;
  nOldX, nOldY: Integer;
  bo21: Boolean;
  PlayObject: TPlayObject;
begin
  if m_boStore then Exit;
  nOldX := m_nCurrX;
  nOldY := m_nCurrY;
  bo21 := False;
  if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then DelMapCount;  //관리자시스템
  m_nCurrX := nX;
  m_nCurrY := nY;
  if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then begin
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);

    if nInt = 1 then begin
      SendRefMsg(RM_SPACEMOVE_SHOW4, directionDir(m_btDirection), m_nCurrX, m_nCurrY, 0, '');
    end else SendRefMsg(RM_SPACEMOVE_SHOW4, directionDir(m_btDirection), m_nCurrX, m_nCurrY, 0, ''); //일섬 이펙트
    m_dwMapMoveTick2 := GetTickCount();
    m_bo316 := True;
    bo21 := True;
  end;
  if not bo21 then begin
    m_nCurrX := nOldX;
    m_nCurrY := nOldY;
    m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  end;
  AddMapCount;       //관리자시스템
end;


procedure TBaseObject.SpaceGTMoveEX(sMap:String;nX,nY:Integer;nInt,GTNumber:Integer);//004BCD1C
  function GetRandXY(Envir:TEnvirnoment;var nX:Integer;var nY:Integer):Boolean;
  var
    n14,n18,n1C:Integer;
  begin
    Result:=False;
    if Envir.m_nWidth < 80 then n18:=3
    else n18:=10;
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 50 then n1C:=2
      else n1C:=15;
    end else n1C:=50;
    n14:=0;
    while (True) do begin
      if Envir.CanWalk(nX,nY,True) then begin
        Result:=True;
        break;
      end;
      if nX < (Envir.m_nWidth - n1C -1) then Inc(nX,n18)
      else begin
        nX:=Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C -1) then Inc(nY,n18)
        else nY:=Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then break;
    end;
  end;
var
  I: Integer;
  Envir,OldEnvir:TEnvirnoment;
  nOldX,nOldY:Integer;
  bo21:Boolean;
  PlayObject:TPlayObject;
begin
  Envir:=g_MapManager.FindMapEx(sMap,GTNumber);
  if Envir <> nil then begin
    if nServerIndex = Envir.nServerIndex then begin
      OldEnvir := m_PEnvir;
      nOldX    := m_nCurrX;
      nOldY    := m_nCurrY;
      bo21     := False;

      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then DelMapCount;   //관리자시스템
      m_VisibleHumanList.Clear;
      for I := 0 to m_VisibleItems.Count - 1 do begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end;
      m_VisibleItems.Clear;
      for I := 0 to m_VisibleActors.Count - 1 do begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
      m_VisibleActors.Clear;
      m_VisibleEvents.Clear; //01/21 盧땡珂헌뇜죗깊
      m_PEnvir:=Envir;
      m_sMapName:=Envir.sMapName;
      m_nCurrX:=nX;
      m_nCurrY:=nY;
      if GetRandXY(m_PEnvir,m_nCurrX,m_nCurrY) then begin
        m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
        if m_btRaceServer = RC_PLAYOBJECT then begin
          SendMsg(Self,RM_CLEAROBJECTS,0,0,0,0,'');
          SendMsg(Self,RM_CHANGEMAP,0,0,0,0,m_sMapName);            //맵이동
        end;
        if nInt = 1 then begin
          SendRefMsg(RM_SPACEMOVE_SHOW2,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        end else SendRefMsg(RM_SPACEMOVE_SHOW,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        m_dwMapMoveTick:=GetTickCount();
        m_bo316:=True;
        bo21:=True;
      end; //004BCFA9
      if not bo21 then begin
        m_PEnvir := OldEnvir;
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
      end;
      AddMapCount;               //관리자시스템
    end else begin //004BCFF6
      if GetRandXY(Envir,nX,nY) then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          DisappearA();
          m_bo316:=True;
          PlayObject:=TPlayObject(Self);
          PlayObject.m_sSwitchMapName:=Envir.sMapName;
          PlayObject.m_nSwitchMapX:=nX;
          PlayObject.m_nSwitchMapY:=nY;
          PlayObject.m_boSwitchData:=True;
          PlayObject.m_nServerIndex:=Envir.nServerIndex;
          PlayObject.m_boEmergencyClose:=True;
          PlayObject.m_boReconnection:=True;
        end else KickException();
      end;
    end;
  end;
end;

procedure TPlayObject.RefUserState(); //10-07-29
var
  n8:Integer;
  PlayObject :TPlayObject;
begin
  n8:=0;
  if m_PEnvir.Flag.boFightZone then n8:=n8 or 1;  //대련
  if m_PEnvir.Flag.boSAFE then n8:=n8 or 2;   //안전
  if m_boInFreePKArea then n8:=n8 or 4;     //공성
  if m_PEnvir.Flag.VailantZone then n8:=n8 or 8; //용맹의전장
  SendDefMessage(SM_AREASTATE,n8,0,0,0,'');
end;

procedure TBaseObject.RefShowName();//004BF0C4
var
   FameGrade: integer;
begin
  SendRefMsg(RM_USERNAME,0,0,TPlayObject(Self).GetRankColor,0,GetShowName+'/'+ TPlayObject(self).GetFameName(FameGrade) + '/' + TPlayObject(Self).GetColumnName + '/' + TPlayObject(Self).GetNameRank);       //킬/데스 호칭
  SendRefMsg(RM_SHOWRANKNAME, 0, TPlayObject(Self).GetRankColor, 0, 0, TPlayObject(Self).GetNameRank);
end;

function TBaseObject.Operate(ProcessMsg:pTProcessMessage):Boolean;//004C716C
  function MINXY(AObject, BObject: TBaseObject): TBaseObject;
  var
    nA, nB: Integer;
  begin
    nA := abs(m_nCurrX - AObject.m_nCurrX) + abs(m_nCurrY - AObject.m_nCurrY);
    nB := abs(m_nCurrX - BObject.m_nCurrX) + abs(m_nCurrY - BObject.m_nCurrY);
    if nA > nB then Result := BObject else Result := AObject;
  end;
var
  nDamage          :Integer;
  nTargetX         :Integer;
  nTargetY         :Integer;
  nPower           :Integer;
  nRage            :Integer;
  TargetBaseObject, AttackBaseObject :TBaseObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::Operate ';
begin
  Result:=False;
try
  case ProcessMsg.wIdent of
    RM_MAGSTRUCK,
    RM_MAGSTRUCK_MINE: begin //10025
      if (ProcessMsg.wIdent = RM_MAGSTRUCK) and
         (m_btRaceServer >= RC_ANIMAL) and
         (not bo2BF) and (m_Abil.Level < g_Config.nLightFlowerStruckLevel) then begin      //뢰설화 관련
        m_dwWalkTick:=m_dwWalkTick + 800 + LongWord(Random(1000));
      end;
      if ProcessMsg.nParam2 <> 1 then begin //if 1 then hit through mshield and amc :p
        nDamage:=GetMagStruckDamage(nil,ProcessMsg.nParam1);
      end else
        nDamage:= ProcessMsg.nParam1;

      AttackBaseObject := TBaseObject(ProcessMsg.BaseObject);
      if nDamage > 0 then begin

        if AttackBaseObject <> nil then begin
          if (not AttackBaseObject.m_boDeath) and (not AttackBaseObject.m_boGhost) then begin
            if (m_btRaceServer in [RC_HEROOBJECT]) then begin
              if (AttackBaseObject.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) or ((AttackBaseObject.m_Master <> nil) and (AttackBaseObject.m_Master.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT])) then begin
                if (m_TargetCret <> nil) and ((m_TargetCret.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) or ((m_TargetCret.m_Master <> nil) and (m_TargetCret.m_Master.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]))) then begin
                  if ((MINXY(m_TargetCret, AttackBaseObject) = AttackBaseObject) or (Random(6) = 0)) and (GetTickCount() - m_dwTargetFocusTick > 1000 * 3) then begin
                    SetTargetCreat(AttackBaseObject);
                  end;
                end else begin
                  SetTargetCreat(AttackBaseObject);
                end;
              end else begin
                if (m_TargetCret = nil) and IsProperTarget(AttackBaseObject) then begin
                  SetTargetCreat(AttackBaseObject);
                end else begin
                  if ((m_TargetCret <> nil) and (MINXY(m_TargetCret, AttackBaseObject) = AttackBaseObject)) or (Random(6) = 0) then begin
                    if (m_btJob in [1,2]) or ((m_TargetCret <> nil) and (GetTickCount() - m_dwTargetFocusTick > 1000 * 3)) then
                    if IsProperTarget(AttackBaseObject) then begin
                      SetTargetCreat(AttackBaseObject);
                    end;
                  end;
                end;
              end;
            end;
          end;
        end; //if AttackBaseObject <> nil then begin

        StruckDamage(nDamage);
        HealthSpellChanged();
        SendRefMsg(RM_STRUCK_MAG,nDamage,m_WAbil.HP,m_WAbil.MaxHP,Integer(ProcessMsg.BaseObject),'');
        if m_btRaceServer <> RC_PLAYOBJECT then begin
          if m_boAnimal then Dec(m_nMeatQuality,nDamage * 1000);
          SendMsg(Self,RM_STRUCK,nDamage,m_WAbil.HP,m_WAbil.MaxHP,Integer(ProcessMsg.BaseObject){AttackBaseObject},'');
        end;          
      end;
      if m_boFastParalysis then begin
        m_wStatusTimeArr[POISON_STONE]:=1;
        m_boFastParalysis:=False;
      end;
    end;
    RM_MAGHEALING: begin //10026
      if (m_nIncHealing + ProcessMsg.nParam1) < 300 then begin
        if m_btRaceServer = RC_PLAYOBJECT then begin
          Inc(m_nIncHealing,ProcessMsg.nParam1);
          m_nPerHealing:=5;
        end else begin
          Inc(m_nIncHealing,ProcessMsg.nParam1);
          m_nPerHealing:=5;
        end;
      end else m_nIncHealing:=300;
    end;
    RM_10101: begin //10101
      SendRefMsg(Integer(ProcessMsg.BaseObject),
                 ProcessMsg.wParam{nPower},
                 ProcessMsg.nParam1{HP},
                 ProcessMsg.nParam2{MaxHP},
                 ProcessMsg.nParam3{AttackSrc},
                 ProcessMsg.sMsg);
      if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) and (m_btRaceServer <> RC_PLAYOBJECT) then begin
        SendMsg(Self,Integer(ProcessMsg.BaseObject),
                ProcessMsg.wParam,
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                ProcessMsg.nParam3{AttackBaseObject},
                ProcessMsg.sMsg);
      end;
      if m_boFastParalysis then begin
        m_wStatusTimeArr[POISON_STONE]:=1;
        m_boFastParalysis:=False;
      end;
    end;

    RM_HEMORRHAGE_STRUCK, RM_THUNDER_STRUCK:    //혈풍격
         begin
            nDamage := ProcessMsg.nParam1;
            if nDamage > 0 then begin
               TargetBaseObject := TBaseObject(ProcessMsg.BaseObject);
               if (TargetBaseObject <> nil) and IsProperTarget(TargetBaseObject) then begin
                 SetTargetCreat(TargetBaseObject);
                 SetLastHiter(TargetBaseObject);
               end;
               StruckDamage (nDamage);
               HealthSpellChanged;
               SendRefMsg (RM_STRUCK_MAG, nDamage, m_WAbil.HP, m_WAbil.MaxHP, integer(ProcessMsg.BaseObject), '');
               if m_btRaceServer <> RC_PLAYOBJECT then begin
                  if m_boAnimal then Dec(m_nMeatQuality,nDamage * 1000);
                  SendMsg (self, RM_STRUCK, nDamage, m_WAbil.HP, m_WAbil.MaxHP, integer(ProcessMsg.BaseObject), '');
               end;
            end;
         end;

    RM_DELAYMAGIC: begin //10154 004C726E
      nPower:=ProcessMsg.wParam;
      nTargetX:=LoWord(ProcessMsg.nParam1);
      nTargetY:=HiWord(ProcessMsg.nParam1);
      nRage:=ProcessMsg.nParam2;
      TargetBaseObject:=TBaseObject(ProcessMsg.nParam3);
      if (TargetBaseObject <> nil) and
         (TargetBaseObject.GetMagStruckDamage(Self,nPower) > 0) then begin

        if (TargetBaseObject.m_btRaceServer = 138) or (TargetBaseObject.m_btRaceServer = 140) then begin
          if ( ABS( self.m_nCurrX - TargetBaseObject.m_nCurrX ) <= 8) and ( ABS ( self.m_nCurrY - TargetBaseObject.m_nCurrY ) <= 8) then begin
            TargetBaseObject.SendMsg (self, RM_DRAGON_EXP, 0, random(3)+1, 0, 0, '');     //마룡
          end;
        end;

        SetTargetCreat{0FFF2}(TargetBaseObject);
        if TargetBaseObject.m_btRaceServer >= RC_ANIMAL then
          nPower:=ROUND(nPower / 1.2);
        if (abs(nTargetX - TargetBaseObject.m_nCurrX) <= nRage) and (abs(nTargetY - TargetBaseObject.m_nCurrY) <= nRage )then
          TargetBaseObject.SendMsg(Self,RM_MAGSTRUCK,0,nPower,0,0,'');
      end;         
    end;
    RM_10155: begin //10155
      MapRandomMove(ProcessMsg.sMsg,ProcessMsg.wParam);
    end;
    RM_DELAYPUSHED: begin
      nPower:=ProcessMsg.wParam;
      nTargetX:=LoWord(ProcessMsg.nParam1);
      nTargetY:=HiWord(ProcessMsg.nParam1);
      nRage:=ProcessMsg.nParam2;
      TargetBaseObject:=TBaseObject(ProcessMsg.nParam3);
      if (TargetBaseObject <> nil) then begin
        TargetBaseObject.CharPushed (nPower, nRage);
      end;
    end;
    RM_POISON: begin //10300 중독
      TargetBaseObject:=TBaseObject(ProcessMsg.nParam2);
      if TargetBaseObject <> nil then begin
        if IsProperTarget(TargetBaseObject) then begin
          SetTargetCreat(TargetBaseObject);
          SetLastHiter(TargetBaseObject);
        end;

        if (m_btRaceServer = RC_PLAYOBJECT) and (TargetBaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin  //20101214
          SetPKFlag (TargetBaseObject);          //정당방어 해주기
          SetLastHiter(TargetBaseObject);
        end else
        if (m_Master <> nil) then begin   //사람이 아니며 주인이 있다.
           if m_Master <> TargetBaseObject then begin    //중독된 꼬봉의 주인이 공격자가 아니면
             SetPKFlag (TargetBaseObject);       //정당방어 해주기
             SetLastHiter (TargetBaseObject);
           end;
        end;

        MakePosion(ProcessMsg.wParam,ProcessMsg.nParam1{nPower},ProcessMsg.nParam3{});
      end else begin
        MakePosion(ProcessMsg.wParam,ProcessMsg.nParam1{nPower},ProcessMsg.nParam3);
      end;
    end;

    RM_DRAGON_EXP: begin    //마룡
      if gFireDragon <> nil then begin
        gFireDragon.ChangeExp( ProcessMsg.nParam1 );
      end;
    end;

    RM_TRANSPARENT: begin //은신,대은
      MagicManager.MagMakePrivateTransparent(Self,ProcessMsg.nParam1);
    end;
    RM_DOOPENHEALTH: begin //10412
      MakeOpenHealth();
    end;
    RM_CURSE:
         begin
            MagCurse (ProcessMsg.wParam, ProcessMsg.nParam1);
         end;
{$IF CHECKNEWMSG = 1}
    else begin
      MainOutMessage(format('훙膠: %s 句口: Ident %d Param %d P1 %d P2 %d P3 %d Msg %s',
                            [m_sCharName,
                            ProcessMsg.wIdent,
                            ProcessMsg.wParam,
                            ProcessMsg.nParam1,
                            ProcessMsg.nParam2,
                            ProcessMsg.nParam3,
                            ProcessMsg.sMsg]));
    end;
{$IFEND}    
  end;
except
  on e: Exception do begin
    MainOutMessage(sExceptionMsg);
    MainOutMessage(E.Message);
  end;
end;
end;
function TPlayObject.Operate(ProcessMsg: pTProcessMessage):Boolean;
var
  CharDesc:TCharDesc;
  nObjCount:integer;
  s1C:String;
  MessageBodyWL:TMessageBodyWL;
  MessageBodyW:TMessageBodyW;
  ShortMessage:TShortMessage;
  nMsgCount:Integer;
  tmp2, i:Integer;
  strupgrade: string;
  dwDelayTime: LongWord;
  UserOpenInfo: pTUserOpenInfo;
begin
  Result:=True;
      case ProcessMsg.wIdent of
        CM_HEROLOGON: begin //영웅소환
          ClientHeroLogOn(2);
        end;
        CM_HEROLOGOUT: begin //영웅 소환해제
          ClientHeroLogOut(TBaseObject(ProcessMsg.nParam1));
        end;
        CM_MASTERBAGTOHEROBAG: begin //주인 > 영웅 가방으로
          ClientMasterBagToHeroBag(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
        CM_HEROBAGTOMASTERBAG: begin //영웅 > 주인 가방으로
          ClientHeroBagToMasterBag(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
        CM_HEROSTORAGEITEM: begin //주인 > 영웅창고로
          ClientHeroStorageItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
        CM_HEROTAKEBACKSTORAGEITEM: begin   //영웅창고 > 주인가방
          ClientHeroTakeBackStorageItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
        CM_NEWHERO: begin
          ClientNewHeroCreate(ProcessMsg.nParam1, DecodeString(ProcessMsg.sMsg));
        end;

        CM_HEROPROTECT: begin //磵빱
          if GetTickCount() - g_dwLastHeroMoveTick > 3000 then begin
            g_dwLastHeroMoveTick:= GetTickCount();
            ClientHeroProtect(ProcessMsg.nParam2, ProcessMsg.nParam3);
          end;
        end;
        CM_HEROTARGET: begin
          if GetTickCount() - g_dwLastHeroMoveTick > 3000 then begin
            g_dwLastHeroMoveTick:= GetTickCount();
            ClientHeroTarget(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3); //傑땍
          end;
        end;
        CM_HEROSPELL:begin
          ClientHeroSpell( TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam);   //영웅무공
        end;
        CM_HEROTURN: begin
          if GetTickCount() - g_dwLastHeroTurnTick > 1000 then begin
            g_dwLastHeroTurnTick:= GetTickCount();
            ClientHeroTurn(ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.nParam1);
          end;
        end;
        CM_HEROAI: ClientHeroAI(ProcessMsg.nParam1);
        CM_HEROCALL: begin      //소환
          ClientHeroCall;
        end;
        CM_HEROBACKCALL: begin  //퇴각
          ClientHeroBackCall;
        end;
        CM_MASTERDEFEN: begin
          ClientHeroMasterDefen();
        end;
        CM_AUTOADDITEM: begin
          ClientAddAutoItem(MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        end;
        CM_AUTODELITEM: begin
          ClientDelAutoItem(MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        end;


        CM_QUERYUSERNAME: begin //80
          ClientQueryUserName(TPlayObject(ProcessMsg.nParam1),ProcessMsg.nParam2,ProcessMsg.nParam3);//004D7931
        end;
        CM_QUERYBAGITEMS: begin //0x81
        if GetTickCount - m_dwQueryBagItemsTick > 30 * 1000 then begin
          m_dwQueryBagItemsTick := GetTickCount;
          ClientQueryBagItems(DecodeString(ProcessMsg.sMsg));
        end else
          SysMsg(IntToStr(30 - (GetTickCount - m_dwQueryBagItemsTick) div 1000) + '취鹿빈옵鹿疼늴賈痰。',c_RedWhite,t_Hint);
        end;

        CM_QUERYSTORAGEITEMS: begin    //여관   //창고
          m_sHDDCode := (DecodeString(Processmsg.sMsg));     //수정되었습니다.
          CheckHDDLogon(DecodeString(Processmsg.sMsg));      //수정되었습니다.
          ClientQueryStorageItems(0);
        end;

        CM_GETRENTAL: begin     //대여
          if TestUpServer then Exit;
          FrmDB.GetRentalItems(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_GETRENTAL2: begin     //대여
          if TestUpServer then Exit;
          FrmDB.GetOwnerItems(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_RRENTALITEM: begin   //대여
          if TestUpServer then Exit;
          FrmDB.RRentalItem(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;
        CM_ENDRENTALITEM: begin    //대여
          FrmDB.EndOfRental(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;

        CM_GETPETINFO: begin     //영물 정보보내기
          FrmDB.GetPetInfo(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_DELETEPET: begin   //영물 놓아주기
          FrmDB.DeletePet(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;
        CM_SUMMONPET: begin   //영물 부르기
          PetSummon(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
          PetOption(DecodeString(ProcessMsg.sMsg));
        end;
        CM_NOTSUMMONPET: begin   //영물 부르기
          NotPetSummon();
          PetAbility('','',False);
          PetOption(DecodeString(ProcessMsg.sMsg));
        end;
        CM_CHANGPETNAME: begin   //영물 이름변경
           FrmDB.ChangPetName(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),DecodeString(ProcessMsg.sMsg));
        end;

        CM_GETSTORAGE: begin   //이동여관
          ClientGetStorage(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_GETAUCTION: begin     //위탁
          if TestUpServer then Exit;
          FrmDB.GetAuctionItems(DecodeString(ProcessMsg.sMsg),TPlayObject(ProcessMsg.nParam1));
        end;
        CM_BUYAUCTIONITEM: begin   //위탁
          if TestUpServer then Exit;
          FrmDB.BuyAuctionItem(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;
        CM_GETGOLDITEM: begin    //위탁
          if TestUpServer then Exit;
          FrmDB.EndOfAuction(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;

        CM_GETCOMSTORAGE: begin    //공용창고
          if TestUpServer then Exit;
          FrmDB.GetComStorageItems(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_ENDCOMSTORAGEITEM: begin    //공용창고
          if TestUpServer then Exit;
          FrmDB.EndOfComStorage(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;

        CM_GETGUILDSTORAGE: begin    //문파창고
          if TestUpServer then Exit;
          FrmDB.GetGuildStorageItems(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_ENDGUILDSTORAGEITEM: begin     //문파창고
          if TestUpServer then Exit;
          FrmDB.EndOfGuildStorage(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;

        CM_SENDWAKEUPITEM : begin
          ClientGetWakeUpItems(ProcessMsg.nParam1, ProcessMsg.nParam2, DecodeString(ProcessMsg.sMsg));
        end;
        CM_SENDWAKEUP : begin
          ClientGetWakeUp(ProcessMsg.nParam1, ProcessMsg.nParam2,  DecodeString(ProcessMsg.sMsg));
        end;

        CM_QUERYUSERSTATE: begin //82
          ClientQueryUserState(TPlayObject(ProcessMsg.nParam1),ProcessMsg.nParam2,ProcessMsg.nParam3);
        end;
        CM_QUERYGUILDGROW: begin //84문파성장
          ClientQueryGuildGrow(TPlayObject(ProcessMsg.nParam1));
        end;
        CM_DROPITEM: begin //1000
          if ClientDropItem(ProcessMsg.sMsg,ProcessMsg.nParam1) then     //아이템 버림
            SendDefMessage(SM_DROPITEM_SUCCESS,ProcessMsg.nParam1,0,0,0,ProcessMsg.sMsg)
          else SendDefMessage(SM_DROPITEM_FAIL,ProcessMsg.nParam1,0,0,0,ProcessMsg.sMsg);
        end;
        CM_PICKUP: begin //1001  004D78F9
          if (m_nCurrX = ProcessMsg.nParam2) and (m_nCurrY = ProcessMsg.nParam3) then
            ClientPickUpItem();
        end;
        CM_PETBANAUTO: begin
          if m_PetList.Count > 0 then begin
            for i:=m_PetList.Count -1 downto 0 do begin
              if g_boItemAuto = 2 then begin
                TPetObject(m_PetList.Items[i]).StartPickUpItem(m_nPetEatRage);
                Break;
              end;
            end;
          end;
        end;

        CM_PETMOUSE: begin
          if m_PetList.Count > 0 then begin
            for i:=m_PetList.Count -1 downto 0 do begin
                TPetObject(m_PetList.Items[i]).MousePickUpItem(m_nPetEatRage,ProcessMsg.nParam2,ProcessMsg.nParam3);
                Break;
            end;
          end;
        end;

        CM_OPENDOOR: begin //1002
          ClientOpenDoor(ProcessMsg.nParam2,ProcessMsg.nParam3);
        end;

        CM_TAKEONITEM: begin //1003
          ClientTakeOnItems(ProcessMsg.nParam2,ProcessMsg.nParam1,ProcessMsg.sMsg,0);
        end;
        CM_TAKEOFFITEM: begin //1004
          ClientTakeOffItems(ProcessMsg.nParam2,ProcessMsg.nParam1,ProcessMsg.sMsg,0);
        end;
        CM_EAT: begin //1006
          ClientUseItems(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;
        CM_BUNDLEITEM:begin   //물약
          ClientaddBundleItems(ProcessMsg.nParam2,ProcessMsg.nParam1,ProcessMsg.sMsg);  //물약
        end;
        CM_BUNDLESTORAGEITEM:begin   //물약 창고
          ClientaddBundleStorageItems(ProcessMsg.nParam2,ProcessMsg.nParam1,ProcessMsg.sMsg);  //물약2
        end;
        CM_SEPARITEM: begin //물약
           ClientSeparateItems(ProcessMsg.nParam1,ProcessMsg.nParam2) //물약
        end;
        CM_GOTOITEMID:begin                                                      //재련
           ClientUpwaoinItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        end;

        CM_BUTCH: begin //1007
          ClientGetButchItem(TBaseObject(ProcessMsg.nParam1),ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.wParam);
        end;
        CM_MAGICKEYCHANGE: begin //1008
          ClientChangeMagicKey(ProcessMsg.nParam1,ProcessMsg.nParam2);
        end;
        CM_SOFTCLOSE: begin //1009  004D79CB
          m_boReconnection:=True;
          m_boSoftClose:=True;
        end;
        CM_CANCLOSE: begin //꼬봉몹의 공격대상이 있을 경우는 로그아웃 할 수 없도록 함.
          if ExistAttackSlaves then begin
             SendMsg(self, RM_CANCLOSE_FAIL, 0, 0, 0, 0, '');
          end else begin
             SendMsg(self, RM_CANCLOSE_OK, 0, 0, 0, 0, '');
          end;
        end;
        CM_CLICKNPC: //1010  004D79E4
          ClientClickNPC(ProcessMsg.nParam1);
        CM_MERCHANTDLGSELECT: //1011
          ClientMerchantDlgSelect(ProcessMsg.nParam1,ProcessMsg.sMsg);
        CM_MERCHANTQUERYSELLPRICE: //1012
          ClientMerchantQuerySellPrice(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        CM_COMPOUNDITEM:
          ClientCompoundItem(ProcessMsg);
        CM_USERSELLITEM: //1013
          ClientUserSellItem(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        CM_USERITEMLOCK:   //봉인
          ClientUserItemLock(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        CM_PRICEDISASSEMBLE:  //각성분해
          ClientPriceDisassemble(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);

        CM_USERITEMWAKE:
          ClientUserItemWake(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);  //각성취소

        CM_USERITEMRESTORE:
          ClientUserItemReStore(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);


        CM_DISASSEMBLE: //각성분해
          ClientDisassemble(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);

        CM_ITEMWAKEUP:
          ClientWakeUpItem(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));

        CM_PRICEDISMANTLEBLE: //일반분해
          ClientPriceDismantle(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        CM_DISMANTLE:    //일반분해
          ClientDismantle(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);

        CM_USERBUYITEM:  //1014 상인
          ClientUserBuyItem(ProcessMsg.wIdent,ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),0,ProcessMsg.wParam,ProcessMsg.sMsg);
        CM_USERPBUYITEM :  //1015 상인
          ClientUserPBuyItem(ProcessMsg.wIdent,ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),0,ProcessMsg.wParam,ProcessMsg.sMsg);
        CM_DROPGOLD:  //1016  004D7AFC
          if ProcessMsg.nParam1 > 0 then ClientDropGold(ProcessMsg.nParam1);
          
        CM_1017: //1017
          SendDefMessage(1,0,0,0,0,'');

        CM_GROUPMODE: begin //1019
          if ProcessMsg.nParam1 = 0 then ClientGroupClose()
          else m_boAllowGroup := True;  //그룹
          m_boCheckGroup := ByteToBool(ProcessMsg.nParam2);
          m_boCheckHero := ByteToBool(ProcessMsg.nParam3);
          m_GroupClass := ByteToBool(ProcessMsg.wParam);
          SendDefMessage(SM_GROUPMODECHANGED,Integer(m_boAllowGroup),Integer(m_boCheckGroup),integer(m_boCheckHero),Integer(m_GroupClass),'');
        end;
        // 아이템 업그레이드 by sonmg...
        CM_UPGRADEITEM: begin   //스쳐
          strupgrade := GetValidStr3(ProcessMsg.sMsg , ProcessMsg.sMsg, ['/']);
          CmdUpgradeItem (ProcessMsg.sMsg, strupgrade, ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0);
        end;
        CM_CREATEGROUP: begin //1020
          ClientCreateGroup(ProcessMsg);
        end;
        CM_ADDGROUPMEMBER: begin //1021
          ClientAddGroupMember(Trim(ProcessMsg.sMsg));
        end;
        CM_DELGROUPMEMBER: begin //1022
          ClientDelGroupMember(Trim(ProcessMsg.sMsg));
        end;
        CM_USERREPAIRITEM: begin //1023 004D7A70
          ClientRepairItem(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        end;
        CM_USERCHWEAPONITEM: begin //제련 확인
          ClientCheckWeapon(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        end;
        CM_MERCHANTQUERYWAKECOST: begin //1024 004D7A2A
          ClientQueryWakeCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
        CM_MERCHANTQUERYRESTORECOST: begin //1024 004D7A2A
          ClientQueryReStoreCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
        CM_TIGERSET: begin //호랑이
          if ProcessMsg.nParam2 = 1 then begin
            if not m_PEnvir.Flag.boNOTIGER then begin
              m_boOnHorse := True;
              SendDefMessage(SM_TIGERSETCHANGED,0,1,0,0,'');
              FeatureChanged();
            end else begin
            if (m_UseItems[U_PETS1].wIndex > 0) and (m_UseItems[U_PETS1].Dura > 0) then begin  //고삐 착용
              m_boOnHorse := True;
              SendDefMessage(SM_TIGERSETCHANGED,0,1,0,0,'');
              FeatureChanged();
            end else begin
              m_boOnHorse := False;
              SysMsg('뎠품뒈暠쐐岺賈痰麟폄。',c_Red,t_Hint);
              SendDefMessage(SM_TIGERSETCHANGED,0,0,0,0,'');
              FeatureChanged();
            end;
            end;
          end else begin
            m_boOnHorse := False;
            SendDefMessage(SM_TIGERSETCHANGED,0,0,0,0,'');
            FeatureChanged();
          end;
        end;
        CM_GUILDSET :begin   //문파 마크
           ClientGuildMark(ProcessMsg.nParam2);
        end;
        CM_GUILDGROWUP :begin  //문파성장
          ClientGuildGrowUp(ProcessMsg.nParam2,1);
        end;
        CM_TRADEGT : begin
          ClientTradeGT(ProcessMsg.nParam1);
        end;
        CM_MERCHANTQUERYREPAIRCOST: begin //1024 004D7A2A
          ClientQueryRepairCost(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg);
        end;

        CM_RENTALTRY: begin     //대여
          if TestUpServer then Exit;
          ClientRentalTry(Trim(ProcessMsg.sMsg));
        end;
        CM_RENTALADDITEM: begin   //대여
          if TestUpServer then Exit;
          ClientAddRentalItem(ProcessMsg.nParam1,ProcessMsg.sMsg,ProcessMsg.nParam2,ProcessMsg.nParam3);
        end;
        CM_RENTALDELITEM: begin    //대여
          if TestUpServer then Exit;
          ClientDelRentalItem(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;
        CM_RENTALCANCEL: begin    //대여
          if TestUpServer then Exit;
          ClientCancelRental();
        end;
        CM_RENTALCHGGOLD: begin   //대여
          if TestUpServer then Exit;
          ClientChangeRentalGold(ProcessMsg.nParam1);
        end;
        CM_RENTALEND: begin     //대여
          if TestUpServer then Exit;
          ClientRentalEnd();
        end;




        CM_DEALTRY: begin //1025    //거래
          if TestUpServer then Exit;
          ClientDealTry(Trim(ProcessMsg.sMsg));
        end;
        CM_DEALADDITEM: begin //1026    //거래
          if TestUpServer then Exit;
          ClientAddDealItem(ProcessMsg.nParam1,ProcessMsg.sMsg,ProcessMsg.nParam2);
        end;
        CM_DEALDELITEM: begin //1027     //거래
          if TestUpServer then Exit;
          ClientDelDealItem(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;
        CM_DEALDELITEM2: begin //1027   //거래
          ClientDelDealItem2(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;
        CM_DEALCANCEL: begin //1028     //거래
          ClientCancelDeal();
        end;
        CM_DEALCHGGOLD: begin //1029        //거래
          ClientChangeDealGold(ProcessMsg.nParam1);
        end;
        CM_DEALEND: begin //1030     //거래
          if TestUpServer then Exit;
          ClientDealEnd();
        end;




        CM_EXCHGGOLD: begin   //환전 (금전 - 밀환)
          ClientChangeExGold(ProcessMsg.nParam1);
        end;
        CM_EXCHGAMEGGOLD: begin //환전 (밀환 - 금전)
          ClientChangeExGameGold(ProcessMsg.nParam1);
        end;
        CM_EXCANCEL: begin    //환전 취소
          ClientCancelEx();
        end;
        CM_EXCHANGEEND: begin //환전 완료
          ClientExEnd();
        end;
        CM_EXCHGAMERATE: begin  //환전 시세
          ClientChangeExRate();
        end;

        CM_AUCADDITEM: begin
          if TestUpServer then Exit;
          AddAucItem(ProcessMsg.nParam1,DecodeString(ProcessMsg.sMsg));     //경매
        end;
        CM_AUCGET: begin         //경매
          if TestUpServer then Exit;
          FrmDB.OfAucEnd(DecodeString(ProcessMsg.sMsg),ProcessMsg.nParam1);
        end;
        CM_BUYAUCITEM: begin      //경매
          if TestUpServer then Exit;
          FrmDB.OfAucCost(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),DecodeString(ProcessMsg.sMsg));
        end;


        CM_STOPSTORE: begin  //개인상점
          if TestUpServer then Exit;
          ClientCancelStore;
        end;
        CM_STARTSTORE: begin //개인상점
          if TestUpServer then Exit;
          ClientStartStore(ProcessMsg.sMsg, ProcessMsg.nParam1);
        end;
        CM_QUERYSTORE: begin     //개인상점
          ClientQueryUserStoreState(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
        CM_BUYSTOREITEM: begin      //개인상점
          if TestUpServer then Exit;
          ClientBuySroreItem(TPlayObject(ProcessMsg.nParam1), ProcessMsg.sMsg);
        end;

        CM_STORAGEPASSWORD: begin       //창고암호
          ClientStorageSetPassWord(TPlayObject(ProcessMsg.nParam1), ProcessMsg.sMsg , ProcessMsg.nParam2);
        end;
        CM_CHECKSTORAGEPW: begin      //창고암호
          ClientCheckStoragePw(TPlayObject(ProcessMsg.nParam1));
        end;


        RM_SENDSTORE: begin    //개인상점
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg := MakeDefaultMsg(SM_SENDSTORE, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam3, 0, 0);
            SendSocket(@m_DefMsg, '');
          end;
        end;

        CM_USERSTORAGEITEM: begin  //여관      //창고
          if TestUpServer then Exit;
          ClientStorageItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
        CM_USERTAKEBACKSTORAGEITEM: begin //여관    //창고
          if TestUpServer then Exit;
          ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
        CM_CONSIGNITEM: begin  //10311   //위탁
          if TestUpServer then Exit;
          ConsignItem(MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),DecodeString(ProcessMsg.sMsg));
        end;

        CM_COMSTORAGEITEM: begin  //10311   //공용창고
          if TestUpServer then Exit;
          ComStorageItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3){,ProcessMsg.wParam});
        end;

        CM_GUILDSTORAGEITEM: begin  //10311   //문파창고
          if TestUpServer then Exit;
          GuildStorageItem(TObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3){,ProcessMsg.wParam});
        end;

        CM_USERMAKEITEMSEL: ServerGetMakeItemSel (TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);       //제조스쳐
        CM_USERMAKEITEM: ServerGetMakeItem (TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);        //제조스쳐

        CM_OPENGUILDDLG: begin //1035
          if TestUpServer then Exit;
          ClientOpenGuildDlg();
        end;
        CM_GUILDHOME: begin //1036
          if TestUpServer then Exit;
          ClientGuildHome();
        end;
        CM_GUILDMEMBERLIST: begin
          if TestUpServer then Exit;
          ClientGuildMemberList();
        end;
        CM_GUILDADDMEMBER: begin
          if TestUpServer then Exit;
          ClientGuildAddMember(ProcessMsg.sMsg);
        end;
        CM_GUILDDELMEMBER: begin
          ClientGuildDelMember(ProcessMsg.sMsg);
        end;
        CM_GUILDUPDATENOTICE: begin
          ClientGuildUpdateNotice(ProcessMsg.sMsg);
        end;
        CM_GUILDUPDATERANKINFO: begin //1041
          ClientGuildUpdateRankInfo(ProcessMsg.sMsg);
        end;
        CM_SPEEDHACKUSER: begin
          if TestUpServer then Exit;
          if ProcessMsg.sMsg <> '' then begin
            MainOutMessage ('[賈痰렷랬넋埼] <' + IntToStr(ProcessMsg.nParam1) + '> ' + m_sCharName + ' : ' + DecodeString(ProcessMsg.sMsg)); //speedhack 유저 로그를 남긴다.
          end else begin
            MainOutMessage ('[賈痰렷랬넋埼] <' + IntToStr(ProcessMsg.nParam1) + '> ' + m_sCharName);
          end;
          m_boEmergencyClose := True;
        end;
        CM_ADJUST_BONUS: begin
          ClientAdjustBonus(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;

        CM_FRIEND_CHENGE: begin     //새로운친구
          ClientFriendChange(ProcessMsg);
        end;
        CM_REQUESTFRIENDLIST: begin
          if GetTickCount - m_dwQueryFriendItemsTick > 60 * 1000 then begin
            m_dwQueryFriendItemsTick := GetTickCount;
            ClientSendFriendsList(Self);
          end else
          SysMsg(IntToStr(60 - (GetTickCount - m_dwQueryFriendItemsTick) div 1000) + '취鹿빈옵鹿疼늴賈痰。',c_RedWhite,t_Hint);
        end;

        CM_MAIL_LIST: Begin
          ClientRequestMailList(Self);
        end;
        CM_MAIL_ADD: Begin
          ClientSendMail(ProcessMsg);
        end;
        CM_MAIL_SETINFO: Begin
          ClientMailStatus(ProcessMsg);
        end;
        CM_MAIL_DELETE: Begin
          ClientDeleteMail(ProcessMsg);
        end;

        CM_REJECT_LIST: Begin
          ClientRejectList(Self);
        end;
        CM_REJECT_ADD: Begin
          ClientAddReject(ProcessMsg);
        end;
        CM_REJECT_DELETE: Begin
          ClientDelReject(ProcessMsg);
        end;

        {-------------------------------------------------------------}
        //연인 스쳐
        CM_LM_REQUEST: ServerGetRelationRequest(ProcessMsg.nParam1, ProcessMsg.nParam2);
        CM_LM_OPTION: ServerGetRelationOptionChange(ProcessMsg.nParam1, ProcessMsg.nParam2);  //사제 스쳐
        CM_LM_DELETE: ServerGetRelationDelete(ProcessMsg.nParam1, ProcessMsg.sMsg);
        CM_LM_DELETE_REQ_OK: ServerGetRelationDeleteRequestOk(
            ProcessMsg.nParam1, ProcessMsg.sMsg);
        CM_LM_DELETE_REQ_FAIL: ServerGetRelationDeleteRequestFail(
            ProcessMsg.nParam1, ProcessMsg.sMsg);
        RM_LM_DBDELETE  :ServerSetRelationDBDelete  ( ProcessMsg.sMsg );
        RM_LM_DBGETLIST :ServerGetRelationDBGetList();
        RM_LM_LOGOUT    :ServerGetLoverLogout;
       {-------------------------------------------------------------}

       {-------------------------------------------------------------}
        //사제 스쳐
        CM_ME_REQUEST: ServerGetMentorRequest(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, DecodeString(ProcessMsg.sMsg));
        CM_ME_DELETE: ServerGetMentorDelete(ProcessMsg.nParam1, ProcessMsg.sMsg);

        RM_ME_DBDELETE  :ServerSetMentorDBDelete  ( ProcessMsg.sMsg );
        RM_ME_DBGETLIST :ServerGetMentorDBGetList;
        RM_ME_LOGOUT    :ServerGetMentorLogout;
       {-------------------------------------------------------------}

        CM_PETOPTION: begin  //영물옵션
          PetOption(DecodeString(ProcessMsg.sMsg));
        end;
        CM_PETAUTO: begin
          g_boItemAuto := ProcessMsg.nParam2;
        end;

        CM_CHANGESYSTEM: begin  //변환
          ChangeItem(DecodeString(ProcessMsg.sMsg));
        end;

        CM_GUILDALLY: begin  //1044
          ClientGuildAlly();
        end;
        CM_GUILDBREAKALLY: begin //1045
          ClientGuildBreakAlly(ProcessMsg.sMsg);
        end;
        CM_REQUESTGTLIST: begin
          if (gettickcount - m_dwBBSDelayTime) > 1000 then begin
            m_dwBBSDelayTime := gettickcount();
            ClientRequestGTList(ProcessMsg);
          end;
        end;
        CM_REQUESTDECOLIST: begin
          ClientRequestDecoList(ProcessMsg);
        end;
        CM_BUYGT: begin
          //ClientBuyGT(ProcessMsg);
        end;
        CM_BUYDECOITEM: begin
          ClientBuyDecoItem(ProcessMsg);
        end;
        CM_BBSLIST: begin          //장원게시판
          if (gettickcount - m_dwBBSDelayTime) > 1000 then begin
            m_dwBBSDelayTime := gettickcount();
            ClientRequestBBSList(ProcessMsg);
          end;
        end;
        CM_BBSMSG: begin         //장원게시판
          if (gettickcount - m_dwBBSDelayTime) > 1000 then begin
            m_dwBBSDelayTime := gettickcount();
            ClientRequestBBSMsg(ProcessMsg);
          end;
        end;
        CM_BBSPOST: begin      //장원게시판
          if (gettickcount - m_dwBBSPostDelay) > 10000 then begin
            m_dwBBSPostDelay := gettickcount();
            ClientPostBBSMsg(ProcessMsg,ProcessMsg.sMsg);
          end else
            SysMsg( IntToStr(10 - (GetTickCount - m_dwBBSPostDelay) div 1000) +'취裂빈옵鹿疼늴輕畇。',c_Red,t_Hint);

        end;
        CM_BBSDELETE: begin   //장원게시판
          if (gettickcount - m_dwBBSPostDelay) > 10000 then begin
            m_dwBBSPostDelay := gettickcount();
            ClientDeleteBBSMsg(ProcessMsg);
          end else
            SysMsg( IntToStr(10 - (GetTickCount - m_dwBBSPostDelay) div 1000) +'취裂빈옵鹿疼늴輕畇。',c_Red,t_Hint);
        end;

        CM_LOADSHOPITEM: begin   //환상점
          if TestUpServer then Exit;
          FrmDB.GetShopItems(TPlayObject(ProcessMsg.nParam1), DecodeString(ProcessMsg.sMsg) );
        end;
        CM_OPSHOPCART: begin    //환상점
         ClientShopCardItem();
        end;
        CM_LIPEITEMSTR: begin           //환상점 선물
         savelipiitemnamestr(ProcessMsg);
        end;
        CM_MYSHOPCART: begin      //환상점  관심
         saveMyShopCartstr(ProcessMsg);
        end;
        CM_DELSHOPCART: begin       //환상점 관심
         DEllMyShopCartstr(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;
        CM_GIFTSITEMS: begin   //환상점 선물
         Giftstlisopen(self);
        end;
        CM_GIFTITEMTYPE: begin    //환상점 선물
         FrmDB.GiftsAuction(TPlayObject(ProcessMsg.nParam1),MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3));
        end;
        CM_SHOPBUYOK: begin     //환상점
          ClientShopBuyItem(ProcessMsg.sMsg);
        end;

        CM_DICEITEM: begin     //혈룡상자
          if TestUpServer then Exit;
          FrmDB.ClientDiceItem(TPlayObject(ProcessMsg.nParam1),ProcessMsg.nParam2,DecodeString(ProcessMsg.sMsg));
        end;

        CM_UPONFISH2: begin   //낚시
         if (m_PEnvir.Flag.boFISHEVENT ) then begin
          ClientUponfish4;
         end else begin
          ClientUponfish2;
         end;
        end;

        CM_UPONFISH: begin   //낚시
         if (m_PEnvir.Flag.boFISHEVENT ) then begin
          ClientUponfish3;
         end else begin
          ClientUponfish;
         end;

        end;

{$IF CHECKNEWMSG = 1}
        CM_1046: begin
          MainOutMessage(format('%s/%d/%d/%d/%d/%d/%s',
                               [m_sCharName,
                                ProcessMsg.wIdent,
                                ProcessMsg.wParam,
                                ProcessMsg.nParam1,
                                ProcessMsg.nParam2,
                                ProcessMsg.nParam3,
                                DecodeString(ProcessMsg.sMsg)]));
        end;
        CM_1056: begin
          MainOutMessage(format('%s/%d/%d/%d/%d/%d/%s',
                               [m_sCharName,
                                ProcessMsg.wIdent,
                                ProcessMsg.wParam,
                                ProcessMsg.nParam1,
                                ProcessMsg.nParam2,
                                ProcessMsg.nParam3,
                                DecodeString(ProcessMsg.sMsg)]));
        end;
{$IFEND}
        CM_TURN: begin //3010    004D73DD
           if ClientChangeDir(ProcessMsg.wIdent,ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam) then
             SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount))
           else SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;

        CM_WALK: begin //3011
          if m_boStore then Exit;
          if ClientWalkXY(ProcessMsg.wIdent,ProcessMsg.nParam1{x},ProcessMsg.nParam2{y}) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;
         CM_DOWN: begin //월영술
          if m_boStore then Exit;
          if ClientDownWalkXY(ProcessMsg.wIdent,ProcessMsg.nParam1{x},ProcessMsg.nParam2{y}) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;
        CM_HORSERUN: begin //3009
          if m_boStore then Exit;
          if ClientHorseRunXY(ProcessMsg.wIdent,ProcessMsg.nParam1{x},ProcessMsg.nParam2{y}) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;
        CM_RUN: begin
          if m_boStore then Exit;
          if ClientRunXY(ProcessMsg.wIdent,ProcessMsg.nParam1{x},ProcessMsg.nParam2{y}) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else begin
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
          end;
        end;
        CM_SPEEDRUN: begin
          if m_boStore then Exit;
          if ClientSpeedRunXY(ProcessMsg.wIdent,ProcessMsg.nParam1{x},ProcessMsg.nParam2{y},ProcessMsg.nParam3) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;

        CM_DOWNRUN: begin
          if m_boStore then Exit;
          if ClientDownRunXY(ProcessMsg.wIdent,ProcessMsg.nParam1{x},ProcessMsg.nParam2{y},ProcessMsg.nParam3) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;

        CM_HIT, //3014
        CM_HEAVYHIT,//3015
        CM_BIGHIT, //3016
        CM_HITLEFT,
        CM_POWERHIT, //3018
        CM_WBHIT,      //풍검술
        CM_WBHIT2,      //풍검술
        CM_LONGHIT, //3019
        CM_TAGUHIT,
        CM_WIDEHIT, //3024
        CM_CRSHIT,          //광풍참
        CM_NANCRSHIT,      //난화혈풍참
        CM_TWINHIT,
        CM_THUNDERHIT,
        CM_FIRESHAOLIN,
        CM_CRBHIT,
        CM_CPOWERHIT,
        CM_CFIREHIT,
        CM_BALDO, //발도술
        CM_BALDO2, //발도술
        CM_FIREHIT,
        CM_DEATHHIT,
        CM_FISHING1,      //낚시
        CM_FISHING2: begin  //낚시 끝
          if m_boStore then Exit;
          if ClientHitXY(ProcessMsg.wIdent, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam, TBaseObject(ProcessMsg.nParam3)) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else begin
            SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
          end;
        end;

        CM_SITDOWN: begin //3012
          if m_boStore then Exit;
          if ClientSitDownHit(ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam) then begin
            SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else
             SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
        end;
        CM_BOW: begin
          if m_boStore then Exit;
          if ClientBowXY(ProcessMsg.wIdent,ProcessMsg.wParam,ProcessMsg.nParam1,ProcessMsg.nParam2,TBaseObject(ProcessMsg.nParam3)) then begin
             SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else begin
             SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
          end;
        end;

        CM_SPELL: begin //3017  004D76FD
          if m_boStore then Exit;
          if ClientSpellXY(ProcessMsg.wIdent,ProcessMsg.wParam,ProcessMsg.nParam1,ProcessMsg.nParam2,TBaseObject(ProcessMsg.nParam3)) then begin
             SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          end else begin
             SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount));
          end;
        end;
        CM_CHECKMSG: begin
          ClientGetCheckMsg(ProcessMsg);
        end;
        CM_GETSAYITEM: begin
          ClientGetSayItem(ProcessMsg);
        end;
        CM_GETTOPINFO: begin
          ClientGetTopInfo(ProcessMsg);
        end;
        CM_ROCKPAPERS: begin   //가위바위보
          ClientGetRockPapers(ProcessMsg);
        end;
        CM_ALIVE: begin
           ClientAlive(ProcessMsg);
        end;

        CM_ALIVE_OK :begin   //소생 확인
          Alive;
        end;
        CM_SAY: begin //3030
          if ProcessMsg.sMsg <> '' then begin
            ProcessUserLineMsg(ProcessMsg.sMsg);
          end;
        end;
        CM_PASSWORD: begin
          ProcessClientPassword(ProcessMsg);
        end;
        CM_GEMITEM:begin             //보옥(구 시스템)
          tmp2:=MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3);
          GemItem(ProcessMsg.nParam1,tmp2);
        end;


        RM_HEROCREATE: begin //10146  004D9B5B
          SendDefMessage(SM_HEROCREATE, ProcessMsg.nParam1, ProcessMsg.nParam2, 0, 0, '');
        end;

        RM_HEROLOGON: begin //삿혤亶衿 TMessageBodyWL 끓赫☜滂픈싻㏏
          m_DefMsg := MakeDefaultMsg(SM_HEROLOGON, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam);

          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong();
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          MessageBodyWL.lTag1 := TBaseObject(ProcessMsg.BaseObject).GetFeatureEx;
          MessageBodyWL.lTag2 := Integer(TBaseObject(ProcessMsg.BaseObject).m_Master);

          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
        RM_HEROLOGOUT: begin //삿혤亶衿 TMessageBodyWL 끓赫☜盃糠飭㏏
          m_DefMsg := MakeDefaultMsg(SM_HEROLOGOUT, ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
          SendSocket(@m_DefMsg, '');
        end;

        RM_WALK: begin //10002   //걷기
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_WALK,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;

            CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
            CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
            CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_HORSERUN: begin//10003 004D860A
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_HORSERUN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;

            CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
            CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
            CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_DOWN: begin //10002   //월영술
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_DOWN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_RUN: begin//10003 004D860A    달리기
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_RUN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_SPEEDRUN: begin//10003 004D860A   경신보
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPEEDRUN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;

            CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
            CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
            CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_DOWNRUN: begin//10003 004D860A   월영술 달리기
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_DOWNRUN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_HIT: begin //10004 004D871D    //오른쪽
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_HIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_HITLEFT: begin //10004 004D871D    //왼쪽
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_HITLEFT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_81: begin //10054
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_81,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;
        end;
        RM_82: begin //10055
         if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_82,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;
        end;
        RM_83: begin //10056
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_83,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;
        end;

        RM_84: begin //10054
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_84,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;
        end;
        RM_85: begin //10055
         if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_85,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;
        end;
        RM_86: begin //10056
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_86,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;
        end;

        RM_HEAVYHIT: begin
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_HEAVYHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,ProcessMsg.sMsg);
          end;
        end;

        RM_FISHING1: begin     //낚시 시작
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_FISHING1,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,ProcessMsg.sMsg);
          end;
        end;
        RM_FISHING2: begin   //낚시 끝
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_FISHING2,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,ProcessMsg.sMsg);
          end;
        end;
        RM_BIGHIT: begin//004D893A
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_BIGHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_BOW: begin//004D893A
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_BOW,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_SPELL: begin // 10007 004D8A12
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPELL,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,IntToStr(ProcessMsg.nParam3));
          end;
        end;

        RM_POWERHIT: begin
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_POWERHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_MOVEFAIL: begin //10010 004D8289
          m_DefMsg:=MakeDefaultMsg(SM_MOVEFAIL,Integer(Self),m_nCurrX,m_nCurrY,m_btDirection);
          CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong;
          CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;

          CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
          CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
          CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

          CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
          CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
          SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(CharDesc)));
        end;
        RM_LONGHIT: begin //10011 004D87F5
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_LONGHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_TAGUHIT: begin //타구봉법 - 승려
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_TAGUHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_WIDEHIT: begin//10012 004D8861
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_WIDEHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_FIREHIT: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_FIREHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_WBHIT: begin//풍검술
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_WBHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_WBHIT2: begin//풍검술
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_WBHIT2,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_CRSHIT: begin //10014 004D89A6     //광풍참
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_CRSHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_NANCRSHIT: begin //10014 004D89A6     //난화혈풍참
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_NANCRSHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_TWINHIT: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_TWINHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_THUNDERHIT: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_THUNDERHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_FIRESHAOLIN: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_FIRESHAOLIN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_CRBHIT: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_CRBHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;

        RM_BALDO: begin //10014 004D89A6  //발도술
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_BALDO,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_BALDO2: begin //10014 004D89A6  //발도술
           if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_BALDO2,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_CPOWERHIT: begin //10008 004D8789
           if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
              m_DefMsg := MakeDefaultMsg(SM_CPOWERHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
              SendSocket(@m_DefMsg, '');
           end;
        end;
        RM_CFIREHIT: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
             m_DefMsg := MakeDefaultMsg(SM_CFIREHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
             SendSocket(@m_DefMsg, '');
          end;
        end;
        RM_DEATHHIT: begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_DEATHHIT,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;
        end;
        RM_BLASTHIT: begin        //참진격
          m_DefMsg := MakeDefaultMsg(SM_BLASTHIT, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;

        RM_TURN,
        RM_PUSH,
        RM_RUSH,
        RM_MAGICMOVE,
        RM_RUSHKUNG: begin//004D831D
          if (TBaseObject(ProcessMsg.BaseObject) <> Self) or (ProcessMsg.wIdent = RM_PUSH) or (ProcessMsg.wIdent = RM_RUSH) or (ProcessMsg.wIdent = RM_RUSHKUNG) or (ProcessMsg.wIdent = RM_MAGICMOVE) then begin
            case ProcessMsg.wIdent of
              RM_PUSH://004D835F
                m_DefMsg:=MakeDefaultMsg(SM_BACKSTEP,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1{x},ProcessMsg.nParam2{y},MakeWord(ProcessMsg.wParam{dir}, TBaseObject(ProcessMsg.BaseObject).m_nLight{light}));
              RM_RUSH://004D83B9
                m_DefMsg:=MakeDefaultMsg(SM_RUSH,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
              RM_RUSHKUNG://004D8413
                m_DefMsg:=MakeDefaultMsg(SM_RUSHKUNG,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
              RM_MAGICMOVE:
                m_DefMsg:=MakeDefaultMsg(SM_MAGICMOVE,Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);

              else begin //004D846A
                m_DefMsg:=MakeDefaultMsg(SM_TURN,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_nLight));
              end;
            end;
            CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;

            CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
            CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
            CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            s1C:=EncodeBuffer(@CharDesc,SizeOf(CharDesc));
            nObjCount:=GetCharColor(TBaseObject(ProcessMsg.BaseObject));
            if ProcessMsg.sMsg <> '' then
              s1C:=s1C + ( EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount)));
            SendSocket(@m_DefMsg,s1C);
            if ProcessMsg.wIdent = RM_TURN then begin
              nObjCount:=TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong();
              SendDefMessage(SM_FEATURECHANGED,
                             Integer(ProcessMsg.BaseObject),
                             LoWord(nObjCount),
                             HiWord(nObjCount),
                             TBaseObject(ProcessMsg.BaseObject).GetFeatureEx,
                             '');
            end;
          end;
        end;

        RM_FOXSTATE:
               begin
                  if ProcessMsg.BaseObject <> self then begin
                     m_DefMsg := MakeDefaultMsg (SM_FOXSTATE, integer(ProcessMsg.BaseObject),
                                              ProcessMsg.nParam1{x},
                                              ProcessMsg.nParam2{y},
                                              MakeWord(ProcessMsg.wParam{dir}, ProcessMsg.nParam3{bodystate}));
                     CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(self);
                     CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
                     CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
                     CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
                     s1C:=EncodeBuffer(@CharDesc,SizeOf(CharDesc));
                     nObjCount:=GetCharColor(TBaseObject(ProcessMsg.BaseObject));
                     if ProcessMsg.sMsg <> '' then begin
                       s1C:=s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
                     end;
                     SendSocket (@m_DefMsg, s1C);
                  end;
               end;

        RM_STRUCK,
        RM_STRUCK_MAG: begin
          if ProcessMsg.wParam{nPower} > 0 then begin
            if ProcessMsg.BaseObject = Self then begin
              if TBaseObject(ProcessMsg.nParam3){AttackBaseObject} <> nil then begin
                if TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT then begin
                  SetPKFlag(TBaseObject(ProcessMsg.nParam3){AttackBaseObject});
                end;
                SetLastHiter(TBaseObject(ProcessMsg.nParam3){AttackBaseObject});
                if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) then begin
                  if (TPlayObject(Self).m_MyHero <> nil) and (TPlayObject(Self).m_MyHero.m_btAiMode = 1) and (TPlayObject(Self).m_MyHero.m_TargetCret = nil) then begin
                    TPlayObject(Self).m_MyHero.SetTargetCreat(TBaseObject(ProcessMsg.nParam3));
                  end;
                end;
              end; //004D8B67
              if PKLevel >= 2 then m_dw5D4:=GetTickCount();
              if (g_CastleManager.IsCastleMember(Self) <> nil) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
                TBaseObject(ProcessMsg.nParam3).BoCrimeforCastle:=True;      //성의 문원을 때린 경우, 궁병이 공격함
                TBaseObject(ProcessMsg.nParam3).CrimeforCastleTime:=GetTickCount();
              end;
              m_nHealthTick:=0;       //맞으면 회복이 안된다.
              m_nSpellTick:=0;
              Dec(m_nPerHealth);
              Dec(m_nPerSpell);
              m_dwStruckTick:=GetTickCount();//09/10
              if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and
                   (TBaseObject(ProcessMsg.BaseObject).m_GroupOwner <> nil) then begin
                 TPlayObject(Self).SendRefGroupMsg(
                    Self,
                    SM_GROUPINFO1,
                    Integer(Self),
                    m_WAbil.HP,
                    m_WAbil.MP,
                    m_WAbil.MaxHP,
                    IntToStr(m_WAbil.MaxMP));
              end;
            end; //4D8BE1                             SM_STRUCK
            if ProcessMsg.BaseObject <> nil then begin
              m_DefMsg:=MakeDefaultMsg(SM_STRUCK,
                                       Integer(ProcessMsg.BaseObject),
                                       TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                                       TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                                       ProcessMsg.wParam);
              MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
              MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
              MessageBodyWL.lTag1:=ProcessMsg.nParam3;
              if ProcessMsg.wIdent = RM_STRUCK_MAG then MessageBodyWL.lTag2:=1      //마법으로 맞는 사운드 효과
              else MessageBodyWL.lTag2:=0;
              SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
            end;
          end;
        end;
        RM_DEATH: begin //10021 004D8C9D
          if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer <> RC_CLONE)
           and (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer <> RC_DARKCLONE)
           and (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer <> RC_BONZECLONE) then begin
          if ProcessMsg.nParam3 = 1 then begin
              m_DefMsg:=MakeDefaultMsg(SM_NOWDEATH,
                                       Integer(ProcessMsg.BaseObject),
                                       ProcessMsg.nParam1,
                                       ProcessMsg.nParam2,
                                       ProcessMsg.wParam);

          if (ProcessMsg.BaseObject = Self) then begin
            if (g_FunctionNPC <> nil) then
              g_FunctionNPC.GotoLable(Self,'@OnDeath',False);
          end;

          end else begin
              m_DefMsg:=MakeDefaultMsg(SM_DEATH,
                                       Integer(ProcessMsg.BaseObject),
                                       ProcessMsg.nParam1,
                                       ProcessMsg.nParam2,
                                       ProcessMsg.wParam);
          end;
          CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
          CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
          CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

          CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
          CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
          SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_DISAPPEAR: begin //10022 004D915C
          m_DefMsg:=MakeDefaultMsg(SM_DISAPPEAR,
                                   Integer(ProcessMsg.BaseObject),
                                   0,0,0);
          SendSocket(@m_DefMsg,'');
        end;
        RM_SKELETON: begin //10024 004D8D7B
              m_DefMsg:=MakeDefaultMsg(SM_SKELETON,
                                       Integer(ProcessMsg.BaseObject),
                                       ProcessMsg.nParam1,
                                       ProcessMsg.nParam2,
                                       ProcessMsg.wParam);
          CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
          CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
          CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

          CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
          CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
          SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
        end;
        RM_USERNAME: begin //10043 004D9587
          m_DefMsg:=MakeDefaultMsg(SM_USERNAME,
                                   Integer(ProcessMsg.BaseObject),
                                   GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
                                   ProcessMsg.nParam3,
                                   0);
          SendSocket(@m_DefMsg,EncodeString(ProcessMsg.sMsg));
        end;
        RM_BUFF : begin       //버프
          SendDefMessage(SM_BUFF,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,   //이미지
                         ProcessMsg.wParam,   //시간
                         ProcessMsg.sMsg);
        end;

        RM_COOLBUFF : begin       //버프
          SendDefMessage(SM_COOLBUFF,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,   //이미지
                         ProcessMsg.wParam,   //시간
                         ProcessMsg.sMsg);
        end;

        RM_AUCBUFF : begin       //경매버프
          SendDefMessage(SM_AUCBUFF,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam2,     //makeindex
                         ProcessMsg.nParam3,    //가격
                         ProcessMsg.wParam,     //가격
                         ProcessMsg.sMsg);      //입찰자
        end;
        RM_COOLTIME: begin      //리콜
          SendDefMessage(SM_COOLTIME,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         ProcessMsg.wParam,
                         ProcessMsg.sMsg);
        end;

        RM_ROCKPAPERS: begin      //가위바위보
          SendDefMessage(SM_ROCKPAPERS,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         ProcessMsg.wParam,
                         ProcessMsg.sMsg);
        end;

        RM_WINEXP: begin //10044 004D95FE
          m_DefMsg:=MakeDefaultMsg(SM_WINEXP,m_Abil.Exp,LoWord(ProcessMsg.nParam1),HiWord(ProcessMsg.nParam1),0);
          SendSocket(@m_DefMsg,'');
        end;

        RM_CHANGEFAMEPOINT: begin //킬/데스 변화
          m_DefMsg:=MakeDefaultMsg(SM_CHANGEFAMEPOINT,m_Abil.KillPointCurr,0,0,0);
          SendSocket(@m_DefMsg,EncodeString(ProcessMsg.sMsg));
        end;
        RM_CHANGEFAMEPOINT2: begin //킬/데스 변화
          m_DefMsg:=MakeDefaultMsg(SM_CHANGEFAMEPOINT2,m_Abil.DeathPointCurr,0,0,0);
          SendSocket(@m_DefMsg,EncodeString(ProcessMsg.sMsg));
        end;
        RM_LEVELUP: begin
          nObjCount := Integer(ProcessMsg.BaseObject);

          m_DefMsg:=MakeDefaultMsg(SM_LEVELUP,m_Abil.Exp,m_Abil.Level,LoWord(nObjCount),HiWord(nObjCount));
          SendSocket(@m_DefMsg,'');

          if ProcessMsg.BaseObject = Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_ABILITY,m_nGold,MakeWord(m_btJob,99),LoWord(m_nGameGold),HiWord(m_nGameGold));
            //0806
            SendSocket(@m_DefMsg,EncodeBuffer(@m_WAbil,SizeOf(TAbility)));

            SendDefMessage(SM_SUBABILITY,
                         MakeLong(MakeWord(m_nAntiMagic,m_nLuck),0), //행운표시
                         MakeWord(m_btHitPoint,m_btSpeedPoint),
                         MakeWord(m_btAntiPoison,m_nPoisonRecover),
                         MakeWord(m_nHealthRecover,m_nSpellRecover),
                         '');
          end;
        end;
        RM_LEVELUP2: begin //등선변환
          nObjCount := Integer(ProcessMsg.BaseObject);

          m_DefMsg:=MakeDefaultMsg(SM_LEVELUP2,m_Abil.Exp,m_Abil.Level,LoWord(nObjCount),HiWord(nObjCount));
          SendSocket(@m_DefMsg,'');

          if ProcessMsg.BaseObject = Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_ABILITY,m_nGold,MakeWord(m_btJob,99),LoWord(m_nGameGold),HiWord(m_nGameGold));
            //0806
            SendSocket(@m_DefMsg,EncodeBuffer(@m_WAbil,SizeOf(TAbility)));

            SendDefMessage(SM_SUBABILITY,
                         MakeLong(MakeWord(m_nAntiMagic,m_nLuck),0), //행운표시
                         MakeWord(m_btHitPoint,m_btSpeedPoint),
                         MakeWord(m_btAntiPoison,m_nPoisonRecover),
                         MakeWord(m_nHealthRecover,m_nSpellRecover),
                         '');
          end;
        end;

        RM_LEVELUP3: begin //보너스 포인트
          nObjCount := Integer(ProcessMsg.BaseObject);

          m_DefMsg:=MakeDefaultMsg(SM_LEVELUP3,m_Abil.Exp,m_Abil.Level,LoWord(nObjCount),HiWord(nObjCount));
          SendSocket(@m_DefMsg,'');

          if ProcessMsg.BaseObject = Self then begin
            m_DefMsg:=MakeDefaultMsg(SM_ABILITY,m_nGold,MakeWord(m_btJob,99),LoWord(m_nGameGold),HiWord(m_nGameGold));
            //0806
            SendSocket(@m_DefMsg,EncodeBuffer(@m_WAbil,SizeOf(TAbility)));

            SendDefMessage(SM_SUBABILITY,
                         MakeLong(MakeWord(m_nAntiMagic,m_nLuck),0), //행운표시
                         MakeWord(m_btHitPoint,m_btSpeedPoint),
                         MakeWord(m_btAntiPoison,m_nPoisonRecover),
                         MakeWord(m_nHealthRecover,m_nSpellRecover),
                         '');
          end;
        end;
        RM_CHANGENAMECOLOR: begin  //네임칼라
          SendDefMessage(SM_CHANGENAMECOLOR,
                         Integer(ProcessMsg.BaseObject),
                         GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
                         0,
                         0,
                         '');
        end;
        RM_DEFSOCKET : begin
           m_DefMsg := MakeDefaultMsg(ProcessMsg.wParam,
                        ProcessMsg.nParam1,
                        ProcessMsg.nParam2,
                        LoWord(ProcessMsg.nParam3),
                        HiWord(ProcessMsg.nParam3));
           SendSocket(@m_DefMsg, ProcessMsg.sMsg);
         end;
        RM_DEFMESSAGE : begin
           SendDefMessage(ProcessMsg.wParam,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         LoWord(ProcessMsg.nParam3),
                         HiWord(ProcessMsg.nParam3),
                         ProcessMsg.sMsg);
         end;
        RM_LOGON: begin //10050
          m_DefMsg:=MakeDefaultMsg(SM_NEWMAP,Integer(Self),m_nCurrX,m_nCurrY,MakeWord( LOBYTE( DayBright() ), LOBYTE( m_PEnvir.Flag.AutoAttack ) ) );
          SendSocket(@m_DefMsg,EncodeString(m_sMapName));
          SendMsg(Self,RM_CHANGELIGHT,0,0,0,0,'');
          SendLogon();
          SendServerConfig();
          ClientQueryUserName(Self,m_nCurrX,m_nCurrY);
          RefUserState();
          SendMapDescription();
          SendGoldInfo(True);
          m_DefMsg:=MakeDefaultMsg(SM_VERSION_FAIL,g_Config.nClientFile1_CRC,LoWord(g_Config.nClientFile2_CRC),HiWord(g_Config.nClientFile2_CRC),0);
          SendSocket(@m_DefMsg,EncodeBuffer(@g_Config.nClientFile3_CRC,SizeOf(Integer)));
        end;
        RM_HEAR,
        RM_WHISPER,
        RM_CRY,
        RM_LM_WHISPER,
        RM_ME_WHISPER,
        RM_SYSMESSAGE,
        RM_GROUPMESSAGE,
        RM_SYSMESSAGE2,
        RM_GUILDMESSAGE,
        RM_GUILDAILLY,
        RM_MOVEMESSAGE,     //화면공지
        RM_SYSMESSAGE3,
        RM_MERCHANTSAY: begin
          case ProcessMsg.wIdent of    //004D97B3
            RM_HEAR: m_DefMsg:=MakeDefaultMsg(SM_HEAR,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1);//10030
            RM_WHISPER: m_DefMsg:=MakeDefaultMsg(SM_WHISPER,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1);//10031
            RM_LM_WHISPER: m_DefMsg:=MakeDefaultMsg(LM_WHISPER,integer(ProcessMsg.BaseObject),MakeWord(253, 255), 0, 1); //연인 스쳐
            RM_ME_WHISPER: m_DefMsg:=MakeDefaultMsg(ME_WHISPER,integer(ProcessMsg.BaseObject),MakeWord(219, 255), 0, 1); //사제 스쳐
            RM_CRY: m_DefMsg:=MakeDefaultMsg(SM_CRY,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1);//10032
            RM_SYSMESSAGE: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1);//10100
            RM_MOVEMESSAGE: m_DefMsg := MakeDefaultMsg(SM_MOVEMESSAGE, ProcessMsg.nParam3, ProcessMsg.wParam, ProcessMsg.nParam1, ProcessMsg.nParam2); //10140      //화면공지
            RM_GROUPMESSAGE: m_DefMsg:=MakeDefaultMsg(SM_GROUPMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1);//10102
            RM_GUILDMESSAGE: m_DefMsg:=MakeDefaultMsg(SM_GUILDMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1); //10104
            RM_GUILDAILLY: m_DefMsg:=MakeDefaultMsg(SM_GUILDAILLY,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1); //10104
            RM_MERCHANTSAY: m_DefMsg:=MakeDefaultMsg(SM_MERCHANTSAY,Integer(ProcessMsg.BaseObject),MakeWord(ProcessMsg.nParam1,ProcessMsg.nParam2),0,1);//10126
          end;
          SendSocket(@m_DefMsg,EncodeString(ProcessMsg.sMsg));
        end;

        RM_ABILITY: begin //10051
          m_DefMsg:=MakeDefaultMsg(SM_ABILITY,
                                 m_nGold,
                                 MakeWord(m_btJob,99),
                                 LoWord(m_nGameGold),
                                 HiWord(m_nGameGold));
            SendSocket(@m_DefMsg,EncodeBuffer(@m_WAbil,SizeOf(TAbility)));

        end;
        RM_USERMARK: begin       //문파 마크
          m_DefMsg := MakeDefaultMsg(SM_USERMARK,
                 Integer(ProcessMsg.BaseObject),
                 ProcessMsg.nParam1,
                 ProcessMsg.nParam2,
                 ProcessMsg.nParam3);
               SendSocket(@m_DefMsg, '');
        end;

        RM_USERMASK: begin       //문파 마크
          m_DefMsg := MakeDefaultMsg(SM_USERMASK,
                 Integer(ProcessMsg.BaseObject),
                 ProcessMsg.nParam1,
                 ProcessMsg.nParam2,
                 ProcessMsg.nParam3);
               SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;

        RM_HEALTHSPELLCHANGED: begin //10052
          m_DefMsg:=MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
                                 Integer(ProcessMsg.BaseObject),
                                 TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                                 TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
                                 TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
          SendSocket(@m_DefMsg,'');
        end;
        RM_DAYCHANGING: begin //10053
          m_DefMsg:=MakeDefaultMsg(SM_DAYCHANGING,0,m_btBright,DayBright(),0);
          SendSocket(@m_DefMsg,'');
        end;

        RM_ITEMSHOW: begin //10110 004D9D01
          SendDefMessage(SM_ITEMSHOW,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         ProcessMsg.wParam,
                         ProcessMsg.sMsg);
        end;
        RM_ITEMHIDE: begin //10111 004D9D27
          SendDefMessage(SM_ITEMHIDE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         0,
                         '');
        end;
        RM_DOOROPEN: begin //10112 004D9D6A
          SendDefMessage(SM_OPENDOOR_OK,
                         0,
                         ProcessMsg.nParam1,{x}
                         ProcessMsg.nParam2,{y}
                         0,
                         '');
        end;
        RM_DOORCLOSE: begin //10113 004D9D8A
          SendDefMessage(SM_CLOSEDOOR,
                         0,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         '');
        end;
        RM_SENDUSEITEMS: SendUseitems();
        RM_WEIGHTCHANGED: begin //10115 004D9DC4
          SendDefMessage(SM_WEIGHTCHANGED,
                         m_WAbil.Weight,
                         m_WAbil.WearWeight,
                         m_WAbil.HandWeight,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_FEATURECHANGED: begin //10116 004D9E1A
          SendDefMessage(SM_FEATURECHANGED,
                         Integer(ProcessMsg.BaseObject),
                         LoWord(ProcessMsg.nParam1),
                         HiWord(ProcessMsg.nParam1),
                         ProcessMsg.wParam,
                         '');
        end;
        RM_CLEAROBJECTS: begin //10117 오브젝트 클리어 그리고 캐릭 이름색
          if ProcessMsg.BaseObject <> nil then begin
            SendDefMessage(SM_CLEAROBJECTS,
                           Integer(ProcessMsg.BaseObject),
                           GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
                           0,
                           0,
                           '');
          end else begin
            SendDefMessage(SM_CLEAROBJECTS,
                           0,
                           0,
                           0,
                           0,
                           '');
          end;
        end;

        RM_CHANGEMAP: begin      //맵이동
          SendDefMessage(SM_CHANGEMAP,Integer(Self),m_nCurrX,m_nCurrY,MakeWord( LOBYTE( DayBright() ), LOBYTE( m_PEnvir.Flag.AutoAttack ) ) ,ProcessMsg.sMsg);   //마룡번개
          SendMapDescription();
          SendServerConfig();
          RefUserState();
        end;

        RM_BUTCH: begin //10119 004D86B1
          if ProcessMsg.BaseObject <> nil then begin
            m_DefMsg:=MakeDefaultMsg(SM_BUTCH,
                                 Integer(ProcessMsg.BaseObject),
                                 ProcessMsg.nParam1,
                                 ProcessMsg.nParam2,
                                 ProcessMsg.wParam);
            SendSocket(@m_DefMsg,'');
          end;

        end;
        RM_MAGICFIRE: begin //10120 004D8A90
          m_DefMsg:=MakeDefaultMsg(SM_MAGICFIRE,
                                 Integer(ProcessMsg.BaseObject),
                                 LoWord(ProcessMsg.nParam2),
                                 HiWord(ProcessMsg.nParam2),
                                 ProcessMsg.nParam1);
          SendSocket(@m_DefMsg,EncodeBuffer(@ProcessMsg.nParam3,SizeOf(Integer)));
        end;
        RM_MAGICFIREFAIL: begin //10121
          SendDefMessage(SM_MAGICFIRE_FAIL,Integer(ProcessMsg.BaseObject),0,0,0,'');
        end;
        RM_SENDMYMAGIC: SendUseMagic;//10122
        RM_MAGIC_LVEXP: begin //10123 004D9E8D
          if (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_HEROOBJECT) then begin
            SendDefMessage(SM_HEROMAGIC_LVEXP,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         LoWord(ProcessMsg.nParam3),
                         HiWord(ProcessMsg.nParam3),
                         '');
          end else begin
            SendDefMessage(SM_MAGIC_LVEXP,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         LoWord(ProcessMsg.nParam3),
                         HiWord(ProcessMsg.nParam3),
                          '');
          end;
        end;
        RM_SOUND:
               begin
                  SendDefMessage (SM_SOUND, 0,ProcessMsg.nParam1, 0,0, '');
               end;
        RM_DURACHANGE: begin //10125 004D9EB9
          SendDefMessage(SM_DURACHANGE,
                         ProcessMsg.nParam1,
                         ProcessMsg.wParam,
                         LoWord(ProcessMsg.nParam2),
                         HiWord(ProcessMsg.nParam2),
                          '');
        end;
        RM_SETPASSWORD : begin //10127 004D9ADF     //창고암호
           SendDefMessage(SM_SETPASSWORD,
                          ProcessMsg.nParam1,
                          0,
                          0,
                          0,
                          '');
        end;
        RM_INPUTPASSWORD : begin //10127 004D9ADF    //창고암호
           SendDefMessage(SM_INPUTPASSWORD,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                         '');
        end;
        RM_MERCHANTDLGCLOSE: begin  //10127 004D9ADF
          SendDefMessage(SM_MERCHANTDLGCLOSE,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_OPWWAPONMG: begin  //10127 004D9ADF //재련
          SendDefMessage(SM_OPWWAPONMG,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_CHECKWEAPON: begin  //10127 004D9ADF //제련 확인
          SendDefMessage(SM_CHECKWEAPON,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_CORWAPONMG: begin  //10127 004D9ADF   //재련
          SendDefMessage(SM_CORWAPONMG,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_SENDGOODSLIST: begin  //10128 004D9AFC
          SendDefMessage(SM_SENDGOODSLIST,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_SENDGOODAPPR: begin  //상인
          SendDefMessage(SM_SENDGOODAPPR,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         0,
                         ProcessMsg.sMsg);
        end;

        RM_SENDUSERSELL: begin  //10129 004D9B1D
          SendDefMessage(SM_SENDUSERSELL,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_SENDWAKEUPITEM: begin
           SendDefMessage(SM_SENDWAKEUPITEM,
                     ProcessMsg.nParam1,
                     ProcessMsg.nParam2,
                     ProcessMsg.nParam3,
                     ProcessMsg.wParam,
                     ProcessMsg.sMsg);
        end;

        RM_SENDBUYPRICE: begin //10130  004D9BAB
          SendDefMessage(SM_SENDBUYPRICE,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_USERSELLITEM_OK: begin //10131  004D9BC8
          SendDefMessage(SM_USERSELLITEM_OK,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_USERSELLITEM_FAIL: begin //10132  004D9BC8
          SendDefMessage(SM_USERSELLITEM_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;

        RM_SENDUSERMAKEITEMLIST:    //제조스쳐
               begin
                  SendDefMessage (SM_SENDUSERMAKEITEMLIST,
                           ProcessMsg.nParam1{merchant id},
                           ProcessMsg.nParam2{count}, 0, 0,
                           ProcessMsg.sMsg);
               end;

        RM_BUYITEM_SUCCESS: begin //10133  004D9C02
          SendDefMessage(SM_BUYITEM_SUCCESS,
                         ProcessMsg.nParam1,
                         LoWord(ProcessMsg.nParam2),
                         HiWord(ProcessMsg.nParam2),
                         0,
                          '');
        end;
        
        RM_BUYITEM_SUCCESS2: begin //10133  004D9C02
          SendDefMessage(SM_BUYITEM_SUCCESS2,
                         ProcessMsg.nParam1,
                         LoWord(ProcessMsg.nParam2),
                         HiWord(ProcessMsg.nParam2),
                         0,
                          '');
        end;

        RM_PRICEDISASSEMBLE: begin //10130  004D9BAB
          SendDefMessage(SM_PRICEDISASSEMBLE,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_SENDUSERDISASSEMBLE: begin
          SendDefMessage(SM_SENDUSERDISASSEMBLE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_SENDUSERWAKEUP: begin
          SendDefMessage(SM_SENDUSERWAKEUP,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;

        RM_SENDUSERWAKE: begin //각성취소
           SendDefMessage(SM_SENDUSERWAKE,
                   ProcessMsg.nParam1,
                   ProcessMsg.nParam2,
                   0,
                   0,
                   '');
        end;
        RM_SENDWAKECOST: begin //10142  004D9CE4
                 SendDefMessage(SM_SENDWAKECOST,
                   ProcessMsg.nParam1,
                   0,
                   0,
                   0,
                   '');
        end;
        RM_USERITEMWAKE_OK: begin //10131  004D9BC8
                 SendDefMessage(SM_USERITEMWAKE_OK,
                   ProcessMsg.nParam1,
                   0,
                   0,
                   0,
                   ProcessMsg.sMsg);
        end;
        RM_USERITEMWAKE_FAIL: begin //10132  004D9BC8
                 SendDefMessage(SM_USERITEMWAKE_FAIL,
                   ProcessMsg.nParam1,
                   0,
                   0,
                   0,
                   '');
        end;


        RM_SENDUSERRESTORE: begin //각성취소
                 SendDefMessage(SM_SENDUSERRESTORE,
                   ProcessMsg.nParam1,
                   ProcessMsg.nParam2,
                   0,
                   0,
                   '');
        end;
        RM_SENDRESTORECOST: begin //10142  004D9CE4
        SendDefMessage(SM_SENDRESTORECOST,
                   ProcessMsg.nParam1,
                   0,
                   0,
                   0,
                  '');
        end;
        RM_USERITEMRESTORE_FAIL: begin //10132  004D9BC8
                 SendDefMessage(SM_USERITEMRESTORE_FAIL,
                   ProcessMsg.nParam1,
                   0,
                   0,
                   0,
                   '');
        end;

        RM_DISASSEMBLE_OK: begin
          SendDefMessage(SM_DISASSEMBLE_OK,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                          '');
        end;
        RM_DISASSEMBLE_FAIL: begin
          SendDefMessage(SM_DISASSEMBLE_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_PRICEDISMANTLE: begin //10130  004D9BAB
          SendDefMessage(SM_PRICEDISMANTLE,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_SENDUSERDISMANTLE: begin
          SendDefMessage(SM_SENDUSERDISMANTLE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_DISMANTLE_OK: begin
          SendDefMessage(SM_DISMANTLE_OK,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                          '');
        end;
        RM_ToSendMsg: begin    //발도술
          SendDefMessage(SM_ToSendMsg,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2, 
                         ProcessMsg.nParam3, 
                         ProcessMsg.wParam, 
                         ProcessMsg.sMsg);
        end;
        RM_KMSendMsg: begin    //케이엠메시지
          SendDefMessage(SM_KMSendMsg,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         ProcessMsg.wParam,
                         ProcessMsg.sMsg);
        end;
        RM_RENTALGIVE: begin   //대여
          SendDefMessage(SM_RENTALGIVE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                          '');
        end;

        RM_AUCTIONGIVE: begin
          SendDefMessage(SM_AUCTIONGIVE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                          '');
        end;
        RM_COMSTORAGEGIVE : begin  //공용창고
          SendDefMessage(SM_COMSTORAGEGIVE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                          '');
        end;
        RM_GUILDTORAGEGIVE : begin  //문파창고
          SendDefMessage(SM_GUILDSTORAGEGIVE,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                          '');
        end;
        RM_BUYITEM_FAIL: begin //10134  004D9C2C
          SendDefMessage(SM_BUYITEM_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_GOLDCHANGED: begin //10136  004D9DFA
          SendDefMessage(SM_GOLDCHANGED,
                         m_nGold,
                         LoWord(m_nGameGold),
                         HiWord(m_nGameGold),
                         0,
                          '');
        end;
        RM_POINTCHANGED: begin //10136  004D9DFA
          SendDefMessage(SM_POINTCHANGED,
                         m_nPCPoint,
                         LoWord(m_nGameGold),
                         HiWord(m_nGameGold),
                         0,
                          '');
        end;
        RM_GAMEGOLDCHANGED: begin
          SendGoldInfo(False);
        end;
        RM_CHANGELIGHT: begin //10137  004D9EE6
          SendDefMessage(SM_CHANGELIGHT,
                         Integer(ProcessMsg.BaseObject),
                         TBaseObject(ProcessMsg.BaseObject).m_nLight,
                         g_Config.nClientKey,
                         0,
                          '');
        end;
        RM_LAMPCHANGEDURA: begin //10138 004D9F0B
          SendDefMessage(SM_LAMPCHANGEDURA,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_CHARSTATUSCHANGED: begin //10139 004D9E44
          SendDefMessage(SM_CHARSTATUSCHANGED,
                         Integer(ProcessMsg.BaseObject),
                         LoWord(ProcessMsg.nParam1),
                         HiWord(ProcessMsg.nParam1),
                         ProcessMsg.wParam,
                          '');
        end;
        // 카운트 아이템
        RM_COUNTERITEMCHANGE: begin
          ServerSendItemCountChanged (ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg);
        end;
        RM_GROUPCANCEL: begin //10140 004D9F28
          SendDefMessage(SM_GROUPCANCEL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_SENDITEMLOCK: begin //10129 004D9B1D
           SendDefMessage(SM_SENDITEMLOCK,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_USERITEMLOCK_OK: begin //10131  004D9BC8
            SendDefMessage(SM_USERITEMLOCK_OK,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_USERITEMLOCK_FAIL: begin //10132  004D9BC8
            SendDefMessage(SM_USERITEMLOCK_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                         '');
        end;
        RM_SENDUSERREPAIR,
        RM_SENDUSERSREPAIR: begin //10141 004D9B3C
          SendDefMessage(SM_SENDUSERREPAIR,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         '');
        end;
        RM_USERREPAIRITEM_OK: begin //10143  004D9CA6
          SendDefMessage(SM_USERREPAIRITEM_OK,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         0,
                         '');
        end;
        RM_SENDREPAIRCOST: begin //10142  004D9CE4
          SendDefMessage(SM_SENDREPAIRCOST,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_USERREPAIRITEM_FAIL: begin //10144  004D9CC7
          SendDefMessage(SM_USERREPAIRITEM_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;

        RM_USERCHECKWEAPON_OK: begin //제련 확인
          SendDefMessage(SM_USERCHECKWEAPON_OK,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         0,
                         '');
        end;

        RM_USERCHECKWEAPON_UPFAIL: begin //제련 확인
          SendDefMessage(SM_USERCHECKWEAPON_UPFAIL,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         0,
                         '');
        end;

        RM_USERCHECKWEAPON_FAIL: begin //제련 확인
          SendDefMessage(SM_USERCHECKWEAPON_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;

        RM_USERSTORAGEITEM: begin //10146  004D9B5B      //창고
          SendDefMessage(SM_SENDUSERSTORAGEITEM,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         '');
        end;
        RM_USERCOMSTORAGE : begin         //공용창고
          SendDefMessage(SM_SENDUCOMSTORAGEITEM,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         '');
        end;
        RM_USERGUILDSTORAGE: begin         //문파창고
          SendDefMessage(SM_SENDUGUILDSTORAGEITEM,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         '');
        end;
        RM_SENDDELITEMLIST: begin //10148  004D9D48  //SM_DELITEMS
          SendDelItemList(TStringList(ProcessMsg.nParam1));
          TStringList(ProcessMsg.nParam1).Free;
        end;

        RM_CANCLOSE_OK:   SendDefMessage (SM_CANCLOSE_OK, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
        RM_CANCLOSE_FAIL: SendDefMessage (SM_CANCLOSE_FAIL, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);

        RM_GETMAKEGEMLIST: begin //10149  004D9B8A
          SendDefMessage(SM_GETMAKEGEMLIST,
                         ProcessMsg.nParam1,
                         ProcessMsg.nParam2,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_MAKEDRUG_SUCCESS: begin //10150 004D9C49
          SendDefMessage(SM_MAKEDRUG_SUCCESS,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_MAKEDRUG_FAIL: begin //10151 004D9C66
          SendDefMessage(SM_MAKEDRUG_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;

        RM_ALIVE: begin //10153 004D8E09
          m_DefMsg:=MakeDefaultMsg(SM_ALIVE,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   ProcessMsg.wParam);
          CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
          CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
          CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

          CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
          CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
          SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
        end;
        RM_DIGUP: begin //10200 004D91B4
          m_DefMsg:=MakeDefaultMsg(SM_DIGUP,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   MakeWord(ProcessMsg.wParam,TBaseObject(ProcessMsg.BaseObject).m_nLight));
          MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          MessageBodyWL.lTag1:=ProcessMsg.nParam3;
          MessageBodyWL.lTag1:=0;
          s1C:=EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL));
          SendSocket(@m_DefMsg,s1C);
        end;
        RM_DIGDOWN: begin //10201 004D9254
          m_DefMsg:=MakeDefaultMsg(SM_DIGDOWN,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   ProcessMsg.wParam);
          SendSocket(@m_DefMsg,'');
        end;
        RM_FLYAXE: begin  //10202 004D9358
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyW.Param1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1:=LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2:=HiWord(ProcessMsg.nParam3);
            m_DefMsg:=MakeDefaultMsg(SM_FLYAXE,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     ProcessMsg.wParam);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyW,SizeOf(TMessageBodyW)));
          end;


        end;
        RM_LIGHTING: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;
        RM_LIGHTING_1: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_1,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;
        RM_LIGHTING_2: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_2,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;
        RM_LIGHTING_3: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_3,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;

        RM_LIGHTING_4: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_4,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;

        RM_LIGHTING_5: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_5,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;

        RM_LIGHTING_6: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_6,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;

        RM_LIGHTING_7: begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then begin
            MessageBodyWL.lParam1:=TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2:=TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1:=ProcessMsg.nParam3;
            MessageBodyWL.lTag2:=ProcessMsg.wParam;
            m_DefMsg:=MakeDefaultMsg(SM_LIGHTING_7,
                                     Integer(ProcessMsg.BaseObject),
                                     ProcessMsg.nParam1,
                                     ProcessMsg.nParam2,
                                     TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));
          end;
        end;
        RM_SHOWRANKNAME: begin //10205 004D949A
          SendDefMessage(SM_SHOWRANKNAME,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam1{x},
                         ProcessMsg.nParam2{y},
                         ProcessMsg.nParam3{type},
                         ProcessMsg.sMsg);
        end;


        RM_10205: begin //10205 004D949A
          SendDefMessage(SM_716,
                         Integer(ProcessMsg.BaseObject),
                         ProcessMsg.nParam1{x},
                         ProcessMsg.nParam2{y},
                         ProcessMsg.nParam3{type},
                         ProcessMsg.sMsg);
        end;
        RM_CHANGEGUILDNAME: begin //10301 004D9F44  SM_CHANGEGUILDNAME
          SendChangeGuildName();
        end;
        RM_SUBABILITY: begin //10302
          SendDefMessage(SM_SUBABILITY,
                       MakeLong(MakeWord(m_nAntiMagic,m_nLuck),0), //행운표시
                       MakeWord(m_btHitPoint,m_btSpeedPoint),
                       MakeWord(m_btAntiPoison,m_nPoisonRecover),
                       MakeWord(m_nHealthRecover,m_nSpellRecover),
                       '');

        end;
        RM_BUILDGUILD_OK: begin //10303 004D9F51
          SendDefMessage(SM_BUILDGUILD_OK,
                         0,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_BUILDGUILD_FAIL: begin //10304 004D9F6D
          SendDefMessage(SM_BUILDGUILD_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;

        RM_DONATE_OK: begin //10305 004D9FA7
          SendDefMessage(SM_DONATE_OK,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;
        RM_DONATE_FAIL: begin //10306 004D9F8A
          SendDefMessage(SM_DONATE_FAIL,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                          '');
        end;

        RM_ATTATCKMODE: begin     //공격모드 표시
          SendDefMessage(SM_ATTATCKMODE, m_btAttatckMode,0,0,0,'');
        end;

        RM_GROUPCALL: begin     //공격모드 표시
          SendDefMessage(SM_GROUPCALL,0,GetAllowGroupReCall,0,0,'');
        end;
        RM_ALIVEREQ : begin //10309  004D9FC4
          SendDefMessage(SM_ALIVEREQ,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_HOMEMOVE : begin
          SendDefMessage(SM_HOMEMOVE,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_MENU_OK: begin //10309  004D9FC4
          SendDefMessage(SM_MENU_OK,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_SIMPLE_OK: begin //10309  004D9FC4
          SendDefMessage(SM_SIMPLE_OK,
                         ProcessMsg.nParam1,
                         0,
                         0,
                         0,
                         ProcessMsg.sMsg);
        end;
        RM_SPACEMOVE_FIRE,
        RM_SPACEMOVE_FIRE2: begin //10330 004D90BA
          if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_HIDE,
                                   Integer(ProcessMsg.BaseObject),
                                   0,
                                   0,
                                   0);


          end else begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_HIDE2,
                                   Integer(ProcessMsg.BaseObject),
                                   0,
                                   0,
                                   0);


          end;
          SendSocket(@m_DefMsg,'');
        end;
        RM_SPACEMOVE_FIRE3: begin //10330 004D90BA          //일섬
          if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE3 then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_HIDE3,
                                   Integer(ProcessMsg.BaseObject),
                                   0,
                                   0,
                                   0);


          end else begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_HIDE3,
                                   Integer(ProcessMsg.BaseObject),
                                   0,
                                   0,
                                   0);


          end;
          SendSocket(@m_DefMsg,'');
        end;
        RM_SPACEMOVE_SHOW4:Begin             //일섬
          if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW4 then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_SHOW4,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   MakeWord(ProcessMsg.wParam,TBaseObject(ProcessMsg.BaseObject).m_nLight));

          end;
          if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW3 then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_SHOW3,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   MakeWord(ProcessMsg.wParam,TBaseObject(ProcessMsg.BaseObject).m_nLight));

          end;
          CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
          CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
          CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

          CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
          CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
          s1C:=EncodeBuffer(@CharDesc,SizeOf(TCharDesc));
          nObjCount:=GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then begin
            s1C:=s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
          end;
          SendSocket(@m_DefMsg,s1C);
        end;
        RM_SPACEMOVE_SHOW,
        RM_SPACEMOVE_SHOW2: begin  //004D8F62
          if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW then begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_SHOW,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   MakeWord(ProcessMsg.wParam,TBaseObject(ProcessMsg.BaseObject).m_nLight));

          end else begin
            m_DefMsg:=MakeDefaultMsg(SM_SPACEMOVE_SHOW2,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.nParam1,
                                   ProcessMsg.nParam2,
                                   MakeWord(ProcessMsg.wParam,TBaseObject(ProcessMsg.BaseObject).m_nLight));

          end;
          CharDesc.feature:=TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status:=TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;      //문파 마크
          CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
          s1C:=EncodeBuffer(@CharDesc,SizeOf(TCharDesc));
          nObjCount:=GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then begin
            s1C:=s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
          end;
          SendSocket(@m_DefMsg,s1C);
        end;
        RM_RECONNECTION: begin //10332 004D8F3A
          m_boReconnection:=True;
          SendDefMessage(SM_RECONNECT,0,0,0,0,ProcessMsg.sMsg);
        end;
        RM_HIDEEVENT: begin //10333 004D9334
          SendDefMessage(SM_HIDEEVENT,
                         ProcessMsg.nParam1,
                         ProcessMsg.wParam,                         
                         ProcessMsg.nParam2,
                         ProcessMsg.nParam3,
                         '');
        end;
        RM_SHOWEVENT: begin //10334 004D92B1
          ShortMessage.Ident:=HiWord(ProcessMsg.nParam2);
          ShortMessage.wMsg:=0;
          m_DefMsg:=MakeDefaultMsg(SM_SHOWEVENT,
                                   ProcessMsg.nParam1,
                                   ProcessMsg.wParam,
                                   ProcessMsg.nParam2,
                                   ProcessMsg.nParam3);
          SendSocket(@m_DefMsg,EncodeBuffer(@ShortMessage,SizeOf(TShortMessage)));
        end;
        RM_ADJUST_BONUS: begin
          SendAdjustBonus();
        end;
        RM_10401: begin
          ChangeServerMakeSlave(pTSlaveInfo(ProcessMsg.nParam1));
          Dispose(pTSlaveInfo(ProcessMsg.nParam1));
        end;
        RM_LOOPNORMALEFFECT: begin  //소생 이팩트
          SendDefMessage(SM_LOOPNORMALEFFECT,
            integer(ProcessMsg.BaseObject),  //recog
            ProcessMsg.nparam1, //시간(초)
            ProcessMsg.nparam2, //사용안함.
            ProcessMsg.nparam3, //효과 종류
            '');
        end;
        RM_OPENHEALTH: begin //10410 004D94BD
          m_DefMsg := MakeDefaultMsg(SM_OPENHEALTH, Integer(ProcessMsg.BaseObject),
               TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
               TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 0);
          SendSocket(@m_DefMsg, '');
        end;

        RM_CLOSEHEALTH: begin //10411 004D94EC
          SendDefMessage(SM_CLOSEHEALTH,
                         Integer(ProcessMsg.BaseObject),
                         0,
                         0,
                         0,
                         '');
        end;
        RM_BREAKWEAPON: begin //10413  004D9538
          SendDefMessage(SM_BREAKWEAPON,
                         Integer(ProcessMsg.BaseObject),
                         0,
                         0,
                         0,
                         '');
        end;
        RM_GROUPPOS:    // gadget
               begin
                  m_DefMsg := MakeDefaultMsg(SM_GROUPPOS, integer(ProcessMsg.BaseObject),
                                          ProcessMsg.nParam1 {x},
                                          ProcessMsg.nParam2 {y},
                                          ProcessMsg.nParam3 );
                  SendSocket(@m_DefMsg, '');
               end;
        RM_CHANGEFACE: begin //10415 004D8E97
          if (ProcessMsg.nParam1 <> 0) and (ProcessMsg.nParam2 <> 0) then begin
            m_DefMsg:=MakeDefaultMsg(SM_CHANGEFACE,
                                     ProcessMsg.nParam1,
                                     LoWord(ProcessMsg.nParam2),
                                     HiWord(ProcessMsg.nParam2),
                                     0);
            CharDesc.feature := TBaseObject(ProcessMsg.nParam2).GetFeature(Self);
            CharDesc.Status  := TBaseObject(ProcessMsg.nParam2).m_nCharStatus;

            CharDesc.Level := TBaseObject(ProcessMsg.BaseObject).m_WAbil.Level;
            CharDesc.HP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP;
            CharDesc.MaxHP := TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP;

            CharDesc.AddStatus := TBaseObject(ProcessMsg.BaseObject).GetAddStatus;   //문파 마크
            CharDesc.AddStatus2 := TBaseObject(ProcessMsg.BaseObject).GetAddStatus2;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,SizeOf(TCharDesc)));
          end;
        end;
        RM_PASSWORD: begin //10416 004D9FE3
          SendDefMessage(SM_PASSWORD,
                         0,
                         0,
                         0,
                         0,
                         '');
        end;
        RM_PLAYDICE: begin //10500 004D9FFF
          MessageBodyWL.lParam1 := ProcessMsg.nParam1;
          MessageBodyWL.lParam2 := ProcessMsg.nParam2;
          MessageBodyWL.lTag1   := ProcessMsg.nParam3;

          m_DefMsg:=MakeDefaultMsg(SM_PLAYDICE,
                                   Integer(ProcessMsg.BaseObject),
                                   ProcessMsg.wParam,
                                   0,
                                   0);
            SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)) + EncodeString(ProcessMsg.sMsg));
        end;

        RM_SHOWEFFECT: begin
            SendDefMessage(SM_SHOWEFFECT,
              ProcessMsg.nParam1,
              ProcessMsg.wParam,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3,
              '');
        end;

        else begin  //004DA0A0
          //inherited;//  Operate(@ProcessMsg);
          Result:=inherited Operate(ProcessMsg);
        end;
      end;
  //inherited;

end;
procedure TPlayObject.Run();//004D68D0    //그룹 체력
var
  tObjCount, nCheck  :Integer;
  tObjCount2     :Integer;
  tObjCount3     :Integer;
  nInteger     :Integer;
  nTotlePoint  :Integer;
  wHour        :Word;
  wMin         :Word;
  wSec         :Word;
  wMSec        :Word;
  ProcessMsg   :TProcessMessage;
  boInSafeArea :Boolean;
  boInSafezone :Boolean;
  I,II, K      :Integer;
  StdItem      :TItem;
  UserItem     :pTUserItem;
  PlayObject, hum   :TPlayObject;
  boTakeItem   :Boolean;
  Castle       :TUserCastle;
  Cret: TBaseObject;
  boot:Boolean;
  lovername, MentorName : string;
  TimeLabel: pTTimeLabel;
  CheckMsg: pTCheckMsg;
  msgstr  : string;
  ListCnt : integer;
  FireBurnEvent:TThunderBurnEvent;
ResourceString
  sPayMentExpire = '퀭돨琅빵념令珂쇌綠돕퍅！！！';
  sDisConnectMsg = '踏狗굳퓻契櫓뙤！！！';
  sExceptionMsg1 = '[Exception] TPlayObject::Run -> Operate 1 Code=%d';
  sExceptionMsg2 = '[Exception] TPlayObject::Run -> Operate 2 # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s Check:%d';
  sExceptionMsg3 = '[Exception] TPlayObject::Run -> GetHighHuman';
  sExceptionMsg4 = '[Exception] TPlayObject::Run -> ClearObj';
  sExceptionMsg6 = '[Exception] TUserEngine::ProcessHumans Human.Finalize Code: %d';
  sExceptionMsg7 = '[Exception] TPlayObject::Run [check] :: Who %s - check %d';
begin
  if g_boExitServer then
    m_boEmergencyClose:=True;
  //004D6901
  try
    ItemTimeRun;      //여관
    if m_boDealing then begin
      if (GetPoseCreate <> m_DealCreat) or (m_DealCreat = Self) or (m_DealCreat = nil)then
        DealCancel();
    end;//004D6950

    if m_boRentaling then begin    //대여
      if (GetPoseCreate <> m_RentalCreat) or (m_RentalCreat = Self) or (m_RentalCreat = nil)then
        RentalCancel();
    end;
    
    if m_boExpire then begin
      SysMsg(sPayMentExpire,c_Red,t_Hint);
      SysMsg(sDisConnectMsg,c_Red,t_Hint);
      m_boEmergencyClose:=True;
      m_boExpire:=False;
    end;//004D698E

    if m_boFireHitSkill then begin //염화결 해제..
      if GetTickCount - m_dwLatestFireHitTick > 20 * 1000 then begin
         m_boFireHitSkill:=False;
         SysMsg(sSpiritsGone,c_Red,t_Hint);
         SendSocket(nil,'+UFIR');
      end;
    end;

    if m_boDeathHitSkill then begin //살생도 해제..
      if GetTickCount - m_dwLatestDeathHitTick > 20 * 1000 then begin
         m_boDeathHitSkill:=False;
         SysMsg('궜骸떫켕㏏瓠耭句呵죄。',c_Red,t_Hint);
         SendSocket(nil,'+UDEA');
      end;
    end;

    if m_boTwinHitSkill = 2 then begin  //쌍룡참 해제
      m_boTwinHitSkill := 0;
      SendSocket(nil,'+UTWN');
    end;

    if m_boThunderHitSkill = 2 then begin  //뇌룡봉법 해제
      m_boThunderHitSkill := 0;
      SendSocket(nil,'+UTHWN');
    end;

    if m_boFireShaolinSkill = 2 then begin  //천화봉법 해제
      m_boFireShaolinSkill := 0;
      SendSocket(nil,'+UFIWN');
    end;

    if m_boTimeRecallGroup then begin     //리콜 초기화
      if (GetTickCount > m_dwTimeRecallTick) then begin
        m_boTimeRecall:=False;
        m_boTimeRecallGroup :=False;
        SpaceMove(m_sMoveMap,m_nMoveX,m_nMoveY,0);
        SendMsg(Self,RM_COOLTIME,0,0,0, 0 , m_sMoveMap); //리콜 버프
      end;
    end else if m_boTimeRecall then begin      //리콜 초기화
      if (GetTickCount > m_dwTimeRecallTick) then begin
        m_boTimeRecall:=False;
        SpaceMove(m_sMoveMap,m_nMoveX,m_nMoveY,0);
        SendMsg(Self,RM_COOLTIME,0,0,0, 0 , m_sMoveMap); //리콜 버프
      end;//004D6A23
    end;

    if m_boCastleRecall then begin      //리콜 초기화
      if (GetTickCount > m_dwCastleRecallTick) then begin
        m_boCastleRecall:=False;
      end;//004D6A23
    end;

    if (m_wStatusTimeArr[STATE_THUNDERWAVE] <> 0) and ((GetTickCount - m_dwThunderWaveTick) > 3000) then begin //복호장
       m_dwThunderWaveTick := GetTickCount;
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX, m_nCurrY - 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX, m_nCurrY - 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 1, m_nCurrY - 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 1, m_nCurrY + 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 2, m_nCurrY - 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 1, m_nCurrY - 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 2, m_nCurrY - 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX, m_nCurrY, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 1, m_nCurrY, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 2, m_nCurrY, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 1, m_nCurrY, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 2, m_nCurrY, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX, m_nCurrY + 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX, m_nCurrY + 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 1, m_nCurrY + 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 2, m_nCurrY + 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 1, m_nCurrY + 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 2, m_nCurrY + 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 2, m_nCurrY + 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 2, m_nCurrY - 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX - 1, m_nCurrY - 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 1, m_nCurrY + 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 2, m_nCurrY + 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 2, m_nCurrY - 1, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
       FireBurnEvent:=TThunderBurnEvent.Create(Self, m_nCurrX + 1, m_nCurrY - 2, ET_NONE, 500, m_btThunderPower);
       g_EventManager.AddEvent(FireBurnEvent);
    end;

    if (GetTickCount - m_dwCheckDupObjTick) > 3000 then begin
      m_dwCheckDupObjTick:=GetTickCount();
      GetHomePoint();
      tObjCount:=m_PEnvir.GetXYObjCount(m_nCurrX,m_nCurrY);
      if tObjCount >= 2 then begin
        if not bo2F0 then begin
          bo2F0:=True;
          m_dwDupObjTick:=GetTickCount();
        end;
      end else begin
        bo2F0:=False;
      end;
      if (((tObjCount >= 3) and ((GetTickCount() - m_dwDupObjTick) > 3000))
      or (((tObjCount = 2) and ((GetTickCount() - m_dwDupObjTick) > 10000)))) and ((GetTickCount() - m_dwDupObjTick) < 20000) then begin
        CharPushed(Random(8),1);
      end;

    end;//004D6B09

    Castle:=g_CastleManager.InCastleWarArea(Self);

    if (Castle <> nil) and Castle.m_boUnderWar then begin
      ChangePKStatus(True);
    end;

    if (GetTickCount - dwTick578) > 1000 then begin
      dwTick578:=GetTickCount();
      //접속 로그를 남김
      //할인 시간의 경계에는 로그를 남김.
      DecodeTime(Now,wHour, wMin, wSec, wMSec);
      //할인 시간 시작 혹은 끝
      if g_Config.boDiscountForNightTime and ((wHour = g_Config.nHalfFeeStart) or (wHour = g_Config.nHalfFeeEnd)) then begin
        //할인 시간이 시작되는 때
        if (wMin = 0) and (wSec <= 30 ) and ((GetTickCount - m_dwLogonTick) > 60000) then begin  //할인시간시작때 기록을 하지 않은 경우
          LogonTimcCost(); //할인 시간 이전에 접속한 경우임
          m_dwLogonTick:=GetTickCount();
          m_dLogonTime:=Now();
        end;
      end;//004D6BF5

      //최소 2시간 마다 재접속 기록(sonmg 2005/03/28)   2 * 60 * 60 * 1000
      if g_Config.boTimeEventUse then begin
        if g_Config.nHourEvent > 0 then begin
          if dwTick578 - m_dwLoginTick > g_Config.nHourEvent * 60 * 60 * 1000 then begin        //시간마다
            if AddCheckMsg(Format('콱綠쒔瞳窟%d롸爐，\콱狼쌈澗쉽쟨膠틔찐？', [ (n_sLoginCount * ((GetTickCount - m_dwLoginTick) div 60000)) ]), tmc_Time, Self, 62) <> nil then begin
            end;
            Inc(n_sLoginCount, 1);
            m_dwLoginTick := GetTickCount;
          end;
        end else begin
          if g_Config.nMinEvent > 0 then begin
            if dwTick578 - m_dwLoginTick > g_Config.nMinEvent * 60 * 1000 then begin        //분마다
              if AddCheckMsg(Format('콱綠쒔瞳窟%d롸爐，\콱狼쌈澗쉽쟨膠틔찐？', [ (n_sLoginCount * ((GetTickCount - m_dwLoginTick) div 60000)) ]), tmc_Time, Self, 62) <> nil then begin
              end;
              Inc(n_sLoginCount, 1);
              m_dwLoginTick := GetTickCount;
            end;
          end;
        end;
      end;

      //문파전으로 지역에 따라서 이름이 색깔이 변경될 경우가 있음
      if (m_MyGuild <> nil) then begin
        if TGuild(m_MyGuild).GuildWarList.Count > 0 then begin        //문파전 중임
          boInSafeArea:=InSafeArea();
          if boInSafeArea <> m_boInSafeArea then begin   //지역에 따라서 이름색이 변경됨
            m_boInSafeArea:=boInSafeArea;
            RefNameColor();
          end;
        end;
      end;//004D6C43


       //공성전중인 경우
      if (Castle <> nil) and Castle.m_boUnderWar then begin    //점령깃발을 쓰러트린 문파가 주인이 된다.
        if (m_MyGuild <> nil) then begin   //내가 문파가 있고
          if not Castle.IsMember(Self) then begin     //성문원도 아님
            if Castle.m_WallFlag.BaseObject.m_boWarChack then begin //점령깃발이 파괴됨
             { if Castle.m_WallFlag.BaseObject.m_ExpHitter <> nil then begin
                Castle.GetCastle(TGuild(Castle.m_WallFlag.BaseObject.m_ExpHitter.m_MyGuild));      //점령 성공
              end else begin
                Castle.GetCastle(g_GuildManager.FindGuild(TWallFlag(Castle.m_WallFlag.BaseObject).sLastHiterGuild));
              end;  }
            end;
          end;
        end;//004D6D29
      end else begin//004D6D1F
        ChangePKStatus(False);
      end;//004D6D29

      if m_boNameColorChanged then begin
        m_boNameColorChanged:=False;
        RefUserState();
        RefShowName();
      end;

      if m_CheckMsgList.Count > 0 then begin
        for i := m_CheckMsgList.Count - 1 downto 0 do begin
          CheckMsg := m_CheckMsgList.Items[i];
          if (CheckMsg <> nil) and (GetTickCount > CheckMsg.AddTime) then begin
            ClientCheckMsg(CheckMsg.tClass, CheckMsg.AllPurpose, -1);
            DisPose(CheckMsg);
            m_CheckMsgList.Delete(i);
          end;
        end;
      end;

      // 20003/02/11 그룹원 위치 전달
         if m_GroupOwner <> nil then begin
            for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
                cret := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
                if (cret.m_sMapName = m_sMapName) then begin
                    cret.SendMsg(self, RM_GROUPPOS, m_btDirection, m_nCurrX, m_nCurrY, m_btRaceServer, '');
                    cret.SendMsg(self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
                end;
            end;
         end;
         if m_SlaveList.Count >= 1 then begin
            for i := 0 to m_SlaveList.Count -1 do begin
               cret := TBaseObject(m_SlaveList[i]);
               if (cret <> nil) and (cret.m_sMapName = m_sMapName) then begin
                   SendMsg(cret, RM_GROUPPOS, cret.m_btDirection, cret.m_nCurrX, cret.m_nCurrY, cret.m_btRaceServer, '');
                   SendMsg(cret, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
               end;
            end;
         end;
    end;//004D6D4F

  except
    MainOutMessage(format(sExceptionMsg1,[0]));
  end;

  nCheck := -1;
  try
    m_dwGetMsgTick:=GetTickCount();
    nCheck := -2;
    while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and GetMessage(@ProcessMsg) do begin
      nCheck := -22;
      if not Operate(@ProcessMsg) then break;
    end;
    nCheck := -3;
    if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then begin
      nCheck := -4;
      if m_boSwitchData then begin
        m_sMapName := m_sSwitchMapName;
        m_nCurrX   := m_nSwitchMapX;
        m_nCurrY   := m_nSwitchMapY;
      end;
      nCheck := -5;
      //접속종료시에 연인에게 알려줌.
        lovername := fLover.GetLoverName;
        PlayObject := UserEngine.GetPlayObject(lovername);
        if PlayObject <> nil then begin
          PlayObject.SendMsg( PlayObject, RM_LM_LOGOUT, 0, 0, 0, 0, '' );
        end;
      nCheck := -6;
        MentorName := fMentor.GetMentorName;        //사제 스쳐  접속 종료 알리자
        PlayObject := UserEngine.GetPlayObject(MentorName);
        if PlayObject <> nil then begin
          PlayObject.SendMsg( PlayObject, RM_ME_LOGOUT, 0, 0, 0, 0, '' );
        end;
      nCheck := -7;
      if m_GroupOwner <> nil then m_GroupOwner.DelMember(Self);
      nCheck := -8;
      for K:=Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin  //스테이트 꺼주기
        if K in [0..5,7..13,15..19,20..26] then begin   //스테이트
          if (m_wStatusTimeArr[K] > 0) then
            m_wStatusTimeArr[K]:=0;
        end;
      end;
      nCheck := -9;
      if m_boOnHorse then
        m_boOnHorse := False;    //호랑이 버그
      nCheck := -10;
      ClientFriendChangeState(Self,False);
      MakeGhost();
      nCheck := -11;
      if m_boKickFlag then begin
        SendDefMessage(SM_OUTOFCONNECTION,0,0,0,0,'');
      end;
      nCheck := -12;
      if not m_boReconnection and m_boSoftClose then begin
        FrmIDSoc.SendHumanLogOutmsg(m_sUserID,m_nSessionID);
      end;
      nCheck := -13;
    end;
  except
    on e: Exception do begin
      if ProcessMsg.wIdent = 0 then
        MakeGhost();    // 11.22 속句в촨渼╂ 훙膠嫩끽藁놔，뎃훙膠뻘瞳踏狗櫓狂痙 瓊刻 Ident0  댄轎
      MainOutMessage(format(sExceptionMsg2,[m_sCharName,
                                            ProcessMsg.wIdent,
                                            Integer(ProcessMsg.BaseObject),
                                            ProcessMsg.wParam,
                                            ProcessMsg.nParam1,
                                            ProcessMsg.nParam2,
                                            ProcessMsg.nParam3,
                                            ProcessMsg.sMsg, nCheck]));
      MainOutMessage(E.Message);
    end;
  end;

  nCheck := 0;
try
  boTakeItem:=False;
  nCheck := 1;
  for i:=Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[i].wIndex > 0 then begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if StdItem <> nil then begin

        if (m_UseItems[I].btValue[19] = 2) then begin    //반짝 착용
          if (m_UseItems[I].MaxDate >= DateTimeToUnix(now)) then begin

          end else begin
            SendDelItems(@m_UseItems[I]);
            m_UseItems[I].wIndex := 0;
            RecalcAbilitys();
            SendMsg(Self,RM_ABILITY,0,0,0,0,'');
            SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
            FeatureChanged();
            SysMsg('膠틔 "'+ StdItem.Name +'"凜법퍅랍쓱爻',c_Red,t_Hint);   //착용템
          end;
        end;

        if (m_UseItems[I].btValue[19] > 2) and (m_UseItems[I].MaxDate < DateTimeToUnix(now)) then begin //봉인
          m_UseItems[I].btValue[19] := 0;
          m_UseItems[I].MaxDate := 0;
          RecalcAbilitys();
          SysMsg(StdItem.Name +'돨룐丹珂쇌돕퍅죄。',c_Red,t_Hint);
        end;

        if (m_UseItems[U_WEAPON].wIndex <> 0) and (m_UseItems[U_WEAPON].btValue[19] = 1) then begin    //대여 아이템 공방
          if m_btAttatckMode <> 1 then begin
           m_btAttatckMode := 1;
           SendMsg(Self,RM_ATTATCKMODE,0,0,0,0,''); //공격모드 표시
          end;
        end;

        if (m_UseItems[I].btValue[19] = 1) then begin    //대여 아이템
          if (m_UseItems[I].MaxDate >= DateTimeToUnix(now)) then begin

          end else begin
            SendDelItems(@m_UseItems[I]);
            m_UseItems[I].wIndex := 0;
            RecalcAbilitys();
            SendMsg(Self,RM_ABILITY,0,0,0,0,'');
            SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
            FeatureChanged();
            SysMsg('理줏돨膠틔'+ StdItem.Name +'굳돕퍅藁쀼죄。',c_Green,t_Hint);
          end;
        end;

        if not CheckItemsNeed(StdItem) then begin
          New(UserItem);
          UserItem^:=m_UseItems[i];
          if AddItemToBag(UserItem,boot) then begin
           if boot then
            SendAddItem(UserItem,1);
            WeightChanged();
            boTakeItem:=True;
          end else begin
            if DropItemDown(@m_UseItems[i],1,False,nil,Self) then begin
              boTakeItem:=True;
            end;
          end;
          if boTakeItem then begin
            SendDelItems(@m_UseItems[i]);
            m_UseItems[i].wIndex:=0;
            RecalcAbilitys();
          end;
        end;
      end else m_UseItems[i].wIndex:=0;
    end;
  end;
  nCheck := 2;
  for I := m_ItemList.Count - 1 downto 0 do begin
    UserItem := pTUserItem(m_ItemList.Items[I]);
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.btValue[19] = 2) then begin  //반짝 가방
      if (UserItem.MaxDate >= DateTimeToUnix(now)) then begin

      end else begin
       m_ItemList.Delete(I);
       SendDelItems(UserItem);
       Dispose(UserItem);
       SysMsg('膠틔"'+ StdItem.Name +'"凜법퍅랍굳쓱爻',c_Red,t_Hint);  //가방창
      end;
    end;

    if (UserItem.wIndex > 0) and (UserItem.btValue[19] > 2) and (UserItem.MaxDate < DateTimeToUnix(now)) then begin//봉인
      UserItem.btValue[19] := 0;
      UserItem.MaxDate := 0;
      SysMsg(StdItem.Name +'돨룐丹珂쇌돕퍅죄。',c_Red,t_Hint);
    end;

    if (UserItem.btValue[19] = 1) then begin  //대여 아이템 가방
      if (UserItem.MaxDate >= DateTimeToUnix(now)) then begin

      end else begin
       m_ItemList.Delete(I);
       SendDelItems(UserItem);
       Dispose(UserItem);
       SysMsg('理줏돨膠틔'+ StdItem.Name +'凜돕퍅굳藁쀼죄，',c_Green,t_Hint);
      end;
    end;

  end;
  nCheck := 3;
  {for I := m_StorageItemList.Count - 1 downto 0 do begin
    UserItem := pTUserItem(m_StorageItemList.Items[I]);

    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem.btValue[19] = 2) then begin  //반짝 여관
      if (UserItem.MaxDate >= DateTimeToUnix(now)) then begin

      end else begin
       m_StorageItemList.Delete(I);
       Dispose(UserItem);
       SysMsg('기간이 만료되어 "'+ StdItem.Name +'"이(가) 삭제되었습니다.',c_Red,t_Hint);       //창고
      end;
    end;
    if (UserItem.wIndex > 0) and (UserItem.btValue[19] > 2) and (UserItem.MaxDate < DateTimeToUnix(now)) then begin//봉인
      UserItem.btValue[19] := 0;
      UserItem.MaxDate := 0;
      SysMsg(StdItem.Name +'의 봉인기간이 만료되었습니다.',c_Red,t_Hint);
    end;
  end;    }

  if fMentor <> nil then begin   //사제 스쳐
    hum := UserEngine.GetPlayObject(fMentor.GetMentorName);
    if hum <> nil then begin //제자 접속 해있다
      if hum.fMentor.GetMentorName <> '' then begin
        if (m_Abil.Level <> hum.fMentor.GetLevel) or (m_btJob <> Hum.fMentor.GetJob ) then begin
          hum.FMentor.Change( hum.fMentor.GetMentorName , m_Abil.level , m_btJob , 1);
          msgstr := hum.FMentor.GetListmsg( RsState_Master , ListCnt );
          if ( ListCnt > 0 ) then begin
            hum.SendDefMessage (SM_ME_INFO, 0, ListCnt, 0, 0, msgstr);
          end;
        end;
      end;
    end;

    if fMentor.GetMode = 0 then begin
      if m_Abil.Level >= g_Config.nMasterLevel then begin     //내가 제자일때 지정 레벨보다 높으면 해제
        ServerGetMentorDelete2(RsState_Master, fMentor.GetMentorName );
      end;
    end;

  end;
  nCheck := 4;
  tObjCount2:=m_nPCPoint;
  tObjCount:=m_nGameGold;
  tObjCount3:=m_nGamePoint;
  if m_boDecGameGold and (GetTickCount - m_dwDecGameGoldTick > m_dwDecGameGoldTime) then begin
    m_dwDecGameGoldTick:=GetTickCount();
    if m_nGameGold >= m_nDecGameGold then begin
      Dec(m_nGameGold,m_nDecGameGold);
      nInteger:=m_nDecGameGold;
    end else begin
      nInteger:=m_nGameGold;
      m_nGameGold:=0;
      m_boDecGameGold:=False;
      MoveToHome();
    end;
    if g_boGameLogGameGold then begin
      AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEGOLD,
                                        m_sMapName,
                                        m_nCurrX,
                                        m_nCurrY,
                                        m_sCharName,
                                        g_Config.sGameGoldName,
                                        nInteger,
                                        '-',
                                        'Auto','[뒈暠斤口]']));
    end;
  end;
  nCheck := 5;
  if m_boIncGameGold and (GetTickCount - m_dwIncGameGoldTick > m_dwIncGameGoldTime) then begin
    m_dwIncGameGoldTick:=GetTickCount();
    if m_nGameGold + m_nIncGameGold < 2000000 then begin
      Inc(m_nGameGold,m_nIncGameGold);
      nInteger:=m_nIncGameGold;
    end else begin
      m_nGameGold:=2000000;
      nInteger:=2000000 - m_nGameGold;
      m_boIncGameGold:=False;
    end;
    if g_boGameLogGameGold then begin
      AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEGOLD,
                                        m_sMapName,
                                        m_nCurrX,
                                        m_nCurrY,
                                        m_sCharName,
                                        g_Config.sGameGoldName,
                                        nInteger,
                                        '-',
                                        'Auto','[뒈暠斤口]']));
    end;
  end;

  nCheck := 6;
  if not m_boDecGameGold and m_PEnvir.Flag.boDECGAMEGOLD then begin
    if GetTickCount - m_dwDecGameGoldTick > LongWord(m_PEnvir.Flag.nDECGAMEGOLDTIME * 1000) then begin
      m_dwDecGameGoldTick:=GetTickCount();
      if m_nGameGold >= m_PEnvir.Flag.nDECGAMEGOLD then begin
        Dec(m_nGameGold,m_PEnvir.Flag.nDECGAMEGOLD);
        nInteger:=m_PEnvir.Flag.nDECGAMEGOLD;
      end else begin
        nInteger:=m_nGameGold;
        m_nGameGold:=0;
        m_boDecGameGold:=False;
        MoveToHome();
      end;
      if g_boGameLogGameGold then begin
        AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEGOLD,
                                        m_sMapName,
                                        m_nCurrX,
                                        m_nCurrY,
                                        m_sCharName,
                                        g_Config.sGameGoldName,
                                        nInteger,
                                        '-',
                                        'Map','[뒈暠斤口]']));
      end;
    end;
  end;
  nCheck := 7;
  if not m_boIncGameGold and m_PEnvir.Flag.boINCGAMEGOLD {and not InStartZone} then begin
   if m_Abil.Level >= g_Config.nAllowGameGoldLevel then begin   //환충전 레벨 제한
    if GetTickCount - m_dwIncGameGoldTick > LongWord(m_PEnvir.Flag.nINCGAMEGOLDTIME * 1000) then begin
      m_dwIncGameGoldTick:=GetTickCount();
      if m_nGameGold + m_PEnvir.Flag.nINCGAMEGOLD <= 2000000 then begin
        Inc(m_nGameGold,m_PEnvir.Flag.nINCGAMEGOLD);
        nInteger:=m_PEnvir.Flag.nINCGAMEGOLD;
      end else begin
        nInteger:=2000000 - m_nGameGold;
        m_nGameGold:=2000000;
      end;
      if g_boGameLogGameGold then begin
        AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEGOLD,
                                        m_sMapName,
                                        m_nCurrX,
                                        m_nCurrY,
                                        m_sCharName,
                                        g_Config.sGameGoldName,
                                        nInteger,
                                        '+',
                                        'Map','[뒈暠斤口]']));
      end;
    end;
   end;
  end;

  if tObjCount <> m_nGameGold then
    SendUpdateMsg(Self,RM_GOLDCHANGED,0,0,0,0,'');
  nCheck := 8;
  if m_PEnvir.Flag.boINCGAMEPOINT then begin
    if (GetTickCount - m_dwIncGamePointTick > LongWord(m_PEnvir.Flag.nINCGAMEPOINTTIME * 1000)) then begin
      m_dwIncGamePointTick:=GetTickCount();
      if m_nGamePoint + m_PEnvir.Flag.nINCGAMEPOINT <= 2000000 then begin
        Inc(m_nGamePoint,m_PEnvir.Flag.nINCGAMEPOINT);
        nInteger:=m_PEnvir.Flag.nINCGAMEPOINT;
      end else begin
        m_nGamePoint:=2000000;
        nInteger:=2000000 - m_nGamePoint;
      end;
      if g_boGameLogGamePoint then begin
        AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEPOINT,
                                        m_sMapName,
                                        m_nCurrX,
                                        m_nCurrY,
                                        m_sCharName,
                                        g_Config.sGamePointName,
                                        nInteger,
                                        '+',
                                        'Map','[뒈暠斤口]']));
      end;
    end;
  end;
  if tObjCount3 <> m_nGamePoint then
    SendUpdateMsg(Self,RM_GAMEGOLDCHANGED,0,0,0,0,'');


  nCheck := 9;
  if m_PEnvir.Flag.boINCPCPOINT then begin
    if m_Abil.Level >= g_Config.nAllowPCPointLevel then begin   //환충전 레벨 제한
    if (GetTickCount - m_dwPCPointTick > LongWord(m_PEnvir.Flag.nINCPCPOINTTIME * 1000)) then begin
      m_dwPCPointTick:=GetTickCount();
      if m_nPCPoint + m_PEnvir.Flag.nINCPCPOINT <= 2000000 then begin
        Inc(m_nPCPoint,m_PEnvir.Flag.nINCPCPOINT);
        nInteger:=m_PEnvir.Flag.nINCPCPOINT;
      end else begin
        m_nPCPoint:=2000000;
        nInteger:=2000000 - m_nPCPoint;
      end;
      if g_boGameLogGamePoint then begin
        AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEPOINT,
                                        m_sMapName,
                                        m_nCurrX,
                                        m_nCurrY,
                                        m_sCharName,
                                        g_Config.sPCPointName,
                                        nInteger,
                                        '+',
                                        'Map','[뒈暠斤口]']));
      end;
    end;
    end;
  end;

  if tObjCount2 <> m_nPCPoint then
    SendUpdateMsg(Self,RM_POINTCHANGED,0,0,0,0,'');


  nTotlePoint:=m_BonusAbil.DC +
               m_BonusAbil.MC +
               m_BonusAbil.SC +
               m_BonusAbil.AC +
               m_BonusAbil.MAC +
               m_BonusAbil.HP +
               m_BonusAbil.MP +
               m_BonusAbil.Hit +
               m_BonusAbil.Speed +
               m_BonusAbil.X2;

  nTotlePoint:=nTotlePoint + m_nBonusPoint;

  if (nTotlePoint > g_Config.nBonusPointHack) or (m_nBonusPoint > g_Config.nBonusPointHack) then begin    //보너스포인트 핵
    MainOutMessage('[賈痰렷랬넋埼]쉽쟨생롸: ' + IntToStr(nTotlePoint) + m_sCharName + ' / ' + m_sUserID + '[' + m_sIPaddr + ']');
    FillChar(m_BonusAbil,SizeOf(TNakedAbility),#0);
    m_nBonusPoint := 0;
    m_boEmergencyClose := True;
  end;
  nCheck := 10;
  if m_PEnvir.Flag.boDECHP and (GetTickCount - m_dwDecHPTick > LongWord(m_PEnvir.Flag.nDECHPTIME * 1000)) then begin
    m_dwDecHPTick:=GetTickCount();
    if m_WAbil.HP > m_PEnvir.Flag.nDECHPPOINT then begin
      Dec(m_WAbil.HP,m_PEnvir.Flag.nDECHPPOINT);
    end else begin
      m_WAbil.HP:=0;
    end;
    HealthSpellChanged();
  end;

  if m_PEnvir.Flag.boINCHP and (GetTickCount - m_dwIncHPTick > LongWord(m_PEnvir.Flag.nINCHPTIME * 1000)) then begin
    m_dwIncHPTick:=GetTickCount();
    if m_WAbil.HP + m_PEnvir.Flag.nDECHPPOINT < m_WAbil.MaxHP then begin
      Inc(m_WAbil.HP,m_PEnvir.Flag.nDECHPPOINT);
    end else begin
      m_WAbil.HP:=m_WAbil.MaxHP;
    end;
    HealthSpellChanged();
  end;


  nCheck := 11;
  if GetTickCount - m_dwDropRateTick > 1000 then begin    //드롭율
    m_dwDropRateTick:=GetTickCount();
    if m_dwKillMonDropRateTime > 0 then begin
      Dec(m_dwKillMonDropRateTime);
      if m_dwKillMonDropRateTime = 0 then begin
        m_nKillMonDropRate:=100;
        SysMsg('밍膠괵쪽뿟릿攣끽。',c_Green,t_Hint);
        SendMsg (Self,RM_BUFF, 15, 0, 13, 0, '');    //드롭율 버프
      end;
    end;
   end;

  nCheck := 12;
  if GetTickCount - m_dwRateTick > 1000 then begin
    m_dwRateTick:=GetTickCount();
    if m_dwKillMonExpRateTime > 0 then begin
      Dec(m_dwKillMonExpRateTime);
      if m_dwKillMonExpRateTime = 0 then begin
        m_nKillMonExpRate:=100;
        SysMsg('쒔駱令뿟릿攣끽。',c_Green,t_Hint);
        SendMsg(self, RM_BUFF, 50, 0, 504, 0,''); //NPC 경험치버프
      end;
    end;
   end;
   nCheck := 13;
   if GetTickCount - m_dwRateTick2 > 1000 then begin    //경험치 가산
    m_dwRateTick2:=GetTickCount();
    if m_dwKillMonExpRateTime2 > 0 then begin
      Dec(m_dwKillMonExpRateTime2);
      if m_dwKillMonExpRateTime2 = 0 then begin
        m_nKillMonExpRate2:=100;
        SysMsg('쒔駱令뿟릿攣끽。',c_Green,t_Hint);
        SendMsg(self, RM_BUFF, 8, 0, 300, 0,''); //경험치가산 버프
      end;
    end;
   end;
   nCheck := 14;
   if GetTickCount - m_dwRateTick3 > 1000 then begin      //검성 검후 경치
    m_dwRateTick3:=GetTickCount();
    if m_dwKillMonExpRateTime3 > 0 then begin
      Dec(m_dwKillMonExpRateTime3);
      if m_dwKillMonExpRateTime3 = 0 then begin
        m_nKillMonExpRate3:=100;
        SysMsg('쒔駱令뿟릿攣끽。',c_Green,t_Hint);
      end;
    end;
   end;
   nCheck := 15;
   if GetTickCount - m_dwRateTick4 > 1000 then begin      //사제 경치
    m_dwRateTick4:=GetTickCount();
    if m_dwKillMonExpRateTime4 > 0 then begin
      Dec(m_dwKillMonExpRateTime4);
      Dec(m_nMasterUpExp);
      if m_dwKillMonExpRateTime4 = 0 then begin
        m_nKillMonExpRate4:=100;
        SysMsg('일可쳬돨瓜拮綠쀼릿攣끽。',c_Green,t_Hint);
        SendMsg(self, RM_BUFF, 31, 0, 30, 0, ''); //스승의위엄 버프
      end;
    end;
   end;

   nCheck := 16;
   if GetTickCount - m_dwRateTick8 > 1000 then begin      //솔플 경험치
    m_dwRateTick8:=GetTickCount();
    if m_dwKillMonExpRateTime8 > 0 then begin
      Dec(m_dwKillMonExpRateTime8);
      if m_dwKillMonExpRateTime8 = 0 then begin
        m_nKillMonExpRate8:=100;
        SysMsg('밍膠쒔駱令뿟릿攣끽。',c_Green,t_Hint);
        SendMsg(self, RM_BUFF, 84, 0, 334, 0, ''); //솔플 경험치
      end;
    end;
   end;
  nCheck := 17;
  if GetTickCount - m_dwPowerRateTick > 1000 then begin
    m_dwPowerRateTick:=GetTickCount();
    if m_dwPowerRateTime > 0 then begin
      Dec(m_dwPowerRateTime);
      if m_dwPowerRateTime = 0 then begin
        m_nPowerRate:=100;
        SysMsg('묑샌제뿟릿攣끽。',c_Green,t_Hint);
      end;
    end;
  end;
  nCheck := 18;
  if GetTickCount - m_dwPowerRateTick2 > 1000 then begin    //천령수 공력
    m_dwPowerRateTick2:=GetTickCount();
    if m_dwPowerRateTime2 > 0 then begin
      Dec(m_dwPowerRateTime2);
      if m_dwPowerRateTime2 = 0 then begin
        m_nPowerRate2:=100;
      end;
    end;
  end;
  nCheck := 19;
  if GetTickCount - m_dwPowerRateTick3 > 1000 then begin     //공력수 공력
    m_dwPowerRateTick3:=GetTickCount();
    if m_dwPowerRateTime3 > 0 then begin
      Dec(m_dwPowerRateTime3);
      if m_dwPowerRateTime3 = 0 then begin
        m_nPowerRate3:=100;
        SysMsg('묑샌제뿟릿攣끽。',c_Green,t_Hint);
        SendMsg(self, RM_BUFF, 49, 0, 306, 0, ''); //공력수 버프
      end;
    end;
  end;
  nCheck := 20;
except
  MainOutMessage(format(sExceptionMsg7,[m_sCharName, nCheck]));
end;


  try
    if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then g_HighLevelHuman:=nil;
    if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then g_HighPKPointHuman:=nil;
    if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then g_HighDCHuman:=nil;
    if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then g_HighMCHuman:=nil;
    if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then g_HighSCHuman:=nil;
    if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then g_HighOnlineHuman:=nil;

    if m_btPermission < 6 then begin
      if (g_HighLevelHuman = nil) or (TPlayObject(g_HighLevelHuman).m_boGhost) then begin
        g_HighLevelHuman:=Self;
      end else begin
        if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then
          g_HighLevelHuman:=Self;
      end;

      //離멕PK
      if (g_HighPKPointHuman = nil) or (TPlayObject(g_HighPKPointHuman).m_boGhost) then begin
        if m_nPkPoint > 0 then g_HighPKPointHuman:=Self;
      end else begin
        if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then
          g_HighPKPointHuman:=Self;
      end;
      //離멕묑샌제
      if (g_HighDCHuman = nil) or (TPlayObject(g_HighDCHuman).m_boGhost) then begin
        g_HighDCHuman:=Self;
      end else begin
        if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC) then
          g_HighDCHuman:=Self;
      end;
      //離멕침랬
      if (g_HighMCHuman = nil) or (TPlayObject(g_HighMCHuman).m_boGhost) then begin
        g_HighMCHuman:=Self;
      end else begin
        if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC) then
          g_HighMCHuman:=Self;
      end;
      //離멕돛減
      if (g_HighSCHuman = nil) or (TPlayObject(g_HighSCHuman).m_boGhost) then begin
        g_HighSCHuman:=Self;
      end else begin
        if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC) then
          g_HighSCHuman:=Self;
      end;
      //離낀瞳窟珂쇌
      if (g_HighOnlineHuman = nil) or (TPlayObject(g_HighOnlineHuman).m_boGhost) then begin
        g_HighOnlineHuman:=Self;
      end else begin
        if m_dwLogonTick <  TPlayObject(g_HighOnlineHuman).m_dwLogonTick then
          g_HighOnlineHuman:=Self;
      end;
    end;
  except
    on e: Exception do begin
      MainOutMessage(sExceptionMsg3);
    end;
  end;
  nCheck := 100;
  try
    nCheck := 101;
    if (Not m_PEnvir.Flag.boDEATHMATCH) and (Not m_PEnvir.Flag.boPKZONE)
      and g_Config.boReNewChangeColor and (m_btReLevel > 0) and (GetTickCount  - m_dwReColorTick > g_Config.dwReNewNameColorTime) then begin   //전직
      m_dwReColorTick:=GetTickCount();
      Inc(m_btReColorIdx);
      if m_btReColorIdx > High(g_Config.ReNewNameColor) then m_btReColorIdx:=0;
      m_btNameColor:=g_Config.ReNewNameColor[m_btReColorIdx];
      RefNameColor;
    end;
    nCheck := 102;
    //쇱꿎礪桂降좔뚤獗
    if (m_GetWhisperHuman <> nil) then begin
      if m_GetWhisperHuman.m_boDeath or (m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman:=nil;
    end;
    nCheck := 103;
    ProcessSpiritSuite();    //초혼의세트
  except
    MainOutMessage(format(sExceptionMsg7,[m_sCharName, nCheck]));
  end;


  if (m_nAutoGetExpPoint > 0) and ((m_AutoGetExpEnvir = nil) or (m_AutoGetExpEnvir = m_PEnvir)) and (GetTickCount - m_dwAutoGetExpTick > m_nAutoGetExpTime) then begin
    m_dwAutoGetExpTick:=GetTickCount();
    if not m_boAutoGetExpInSafeZone or (m_boAutoGetExpInSafeZone and InSafeZone) then
      GetExp(m_nAutoGetExpPoint);
  end;

  inherited Run;
end;

procedure TPlayObject.CheckSpeedCount(var nCount: Integer; sHitName: string);   //스피드핵
begin
  if nCount >= g_Config.nOverSpeedKickCount then begin
    SpeedCloseFunc;
    if g_Config.boKickOverSpeed then begin
      SendMsg(g_ManageNPC, RM_MENU_OK,0,Integer(Self),0,0, '[쒸멩]: 콱攣瞳賈痰렷랬넋埼。');
      m_boEmergencyClose := True;
    end;
     MainOutMessage(Format('[醵똑嫩끽]  실ッ:%s IP:%s 蘆잚:%s 圈玖斤口:[頓땡斤口:%d 세콘:%d]',
          [m_sCharName, m_sIPaddr, sHitName, {m_nWalkCount, }m_nRunCount, m_nMagicHitCount]));
  end;
end;

procedure TPlayObject.ProcessSpiritSuite();
var
  I: Integer;
  StdItem:TItem;
  UseItem:pTUserItem;
begin
  if not g_Config.boSpiritMutiny or not m_bopirit then exit;
  m_bopirit:=False;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    UseItem:=@m_UseItems[I];
    if UseItem.wIndex <= 0 then Continue;
    StdItem:=UserEngine.GetStdItem(UseItem.wIndex);
    if StdItem <> nil then begin
      if (StdItem.Shape = 126) or
         (StdItem.Shape = 127) or
         (StdItem.Shape = 128) or
         (StdItem.Shape = 129) then begin

        SendDelItems(UseItem);
        UseItem.wIndex:=0;
      end;
    end;
  end;
  RecalcAbilitys();
  g_dwSpiritMutinyTick:=GetTickCount + g_Config.dwSpiritMutinyTime;
  UserEngine.SendBroadCastMsg('Spirits will revolt soon...',t_System);//no idea what this is exactly so i guessed :p
  SysMsg('You started a spirit revolt',c_Green,t_Hint);

end;
procedure TPlayObject.LogonTimcCost();//004CA994
var
  n08:Integer;
  sC:String;
begin
  if (m_nPayMent = 2) or (g_Config.boTestServer) then begin   //유료사용자 (테스트 서버 테스트용)
    n08:=(GetTickCount - m_dwLogonTick) div 1000;      //초 단위
  end else n08:=0;
  sC:=m_sIPaddr + #9 + m_sUserID + #9 + m_sCharName + #9 + IntToStr(n08) + #9 + FormatDateTime('yyyy-mm-dd hh:mm'{yyyy-mm-dd hh:mm:ss},m_dLogonTime) + #9 + FormatDateTime('yyyy-mm-dd hh:mm'{yyyy-mm-dd hh:mm:ss},Now) + #9 + IntToStr(m_nPayMode);
  AddLogonCostLog(sC);
  if m_nPayMode = 2 then
    FrmIDSoc.SendLogonCostMsg(m_sUserID,n08 div 60);

end;



function TBaseObject.MakeSlave(sMonName:String;nMakeLevel,nExpLevel,nMaxMob:Integer;dwRoyaltySec:LongWord):TBaseObject;//004C37C0
var
  nX,nY:Integer;
  MonObj:TBaseObject;
begin
  Result:=nil;
  if m_SlaveList.Count < nMaxMob then begin
    GetFrontPosition(nX,nY);  // sub_004B2790
    MonObj:=UserEngine.RegenMonsterByName(m_PEnvir,nX,nY,sMonName);
    if MonObj <> nil then begin
      MonObj.m_Master:=Self;
      MonObj.m_dwMasterRoyaltyTick := GetTickCount + dwRoyaltySec * 1000;
      MonObj.m_btSlaveMakeLevel := nMakeLevel;
      MonObj.m_btSlaveExpLevel := nExpLevel;
      MonObj.RecalcAbilitys;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then begin
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP) + (MonObj.m_WAbil.MaxHP - MonObj.m_WAbil.HP);
      end;
      MonObj.RefNameColor;
      m_SlaveList.Add (MonObj);
      Result := MonObj;
    end;
  end;
end;


function TBaseObject.MakeSlaveBonze(sMonName:String; nMakeLevel,dwRoyaltySec:Integer; targ: TBaseObject):TBaseObject;//004C37C0
var
  nX,nY:Integer;
  MonObj:TBaseObject;
begin
  Result:=nil;
    GetFrontPosition(nX,nY);  // sub_004B2790
    MonObj:=UserEngine.RegenMonsterByName(m_PEnvir,nX,nY,sMonName);
    if MonObj <> nil then begin
      MonObj.m_Master:=Self;
      MonObj.m_dwMasterRoyaltyTick := GetTickCount + dwRoyaltySec * 1000;
      MonObj.m_btSlaveMakeLevel := nMakeLevel;
      MonObj.m_btSlaveExpLevel := nMakeLevel;
      MonObj.RecalcAbilitys;
      MonObj.m_TargetCret:= targ;
      MonObj.m_WAbil.DC       := (LoWord(m_WAbil.DC) + HiWord(m_WAbil.DC));
      MonObj.m_WAbil.SC       := (LoWord(m_WAbil.SC) + HiWord(m_WAbil.SC));
      MonObj.m_WAbil.AC       := m_WAbil.AC;
      MonObj.m_WAbil.MAC      := m_WAbil.MAC;
      MonObj.m_WAbil.MaxHP      := m_WAbil.MaxHP;
      case nMakeLevel of
        0: MonObj.m_WAbil.HP := m_WAbil.MaxHP div 4;
        1: MonObj.m_WAbil.HP := m_WAbil.MaxHP div 3;
        2: MonObj.m_WAbil.HP := m_WAbil.MaxHP div 2;
        3: MonObj.m_WAbil.HP := m_WAbil.MaxHP;
      end;
      MonObj.RefNameColor;
      m_SlaveList.Add (MonObj);
      Result := MonObj;
    end;
end;


function   TBaseObject.NewMakeSlave (sname: string; slevel, max_slave, royaltysec: integer): TBaseObject;
var
   nx, ny: integer;
   mon: TBaseObject;
   AddPlus : integer;
begin
   Result := nil;

   AddPlus := 0;
   if (GetExistSlave( g_Config.sAngel ) <> nil) or ( sname = g_Config.sAngel ) then Inc(Addplus);

   if (m_SlaveList.Count < (max_slave + AddPlus))then begin
      GetFrontPosition (nx, ny);
      mon := UserEngine.RegenMonsterByName (m_PEnvir.sMapName, nx, ny, sname);         //RC_CLONE
      if mon <> nil then begin
         mon.m_Master := self;
         mon.m_dwMasterRoyaltyTick := GetTickCount + longword(royaltysec) * 1000;
         mon.m_btSlaveMakeLevel := slevel;
         mon.m_btSlaveExpLevel := slevel;
         mon.m_btDirection      := m_btDirection;
         mon.m_btMask           := m_btMask;
         mon.MasterFeature      := GetFeature(Self); //열화신
         mon.m_UseItems         := m_UseItems;
         mon.m_btGender         := m_btGender;
         mon.m_btHair           := m_btHair;
         mon.m_btJob            := m_btJob;
         mon.m_btMask           := m_btMask;
         mon.m_btHumEffect      := m_btHumEffect;
         mon.m_btDressEffType   := m_btDressEffType;

         mon.m_Abil           := m_Abil;
         mon.m_WAbil          := m_WAbil;
         mon.m_btHitPoint     := m_btHitPoint;
         mon.m_btAntiPoison   := m_btAntiPoison;
         mon.m_nAntiMagic     := m_nAntiMagic;
         mon.m_nPoisonRecover := m_nPoisonRecover;
         mon.m_btSpeedPoint   := m_btSpeedPoint;
         mon.m_btNameColor    := m_btNameColor;
         mon.m_nLuck          := m_nLuck;
         mon.m_WAbil.DC       := (LoWord(m_WAbil.DC) + HiWord(m_WAbil.DC));
         mon.m_WAbil.AC       := m_WAbil.AC;
         mon.m_WAbil.MAC      := m_WAbil.MAC;
         mon.m_AddAbil.wSlowDown := m_AddAbil.wSlowDown;
         mon.m_AddAbil.wTox := m_AddAbil.wTox;



         mon.RecalcAbilitys; //ApplySlaveLevelAbilitys;
         if mon.m_WAbil.HP < mon.m_WAbil.MaxHP then begin
            mon.m_WAbil.HP := mon.m_WAbil.HP + (mon.m_WAbil.MaxHP - mon.m_WAbil.HP) div 2;
         end;
         mon.RefNameColor;
         m_SlaveList.Add (mon);
         Result := mon;
      end;
   end;
end;


function   TBaseObject.DarkBodyMakeSlave (sname: string; slevel, royaltysec: integer; targ: TBaseObject): TBaseObject;
var
   nx, ny: integer;
   mon: TBaseObject;
begin
   Result := nil;
   try
      GetFrontPosition (nx, ny);                                                               //RC_DARKCLONE
      mon := UserEngine.RegenMonsterByName (m_PEnvir, nx, ny, sname);
      if mon <> nil then begin
         mon.m_Master := Self;
         mon.m_dwMasterRoyaltyTick := GetTickCount + longword(royaltysec) * 1000;

         mon.m_btSlaveMakeLevel := slevel;
         mon.m_btSlaveExpLevel  := slevel;

         mon.m_btMask           := m_btMask;
         mon.MasterFeature      := GetFeature(Self); //열화신
         mon.m_UseItems         := m_UseItems;
         mon.m_btGender         := m_btGender;
         mon.m_btHair           := m_btHair;
         mon.m_btJob            := m_btJob;
         mon.m_btMask           := m_btMask;
         mon.m_btHumEffect      := m_btHumEffect;
         mon.m_btDressEffType   := m_btDressEffType;


         mon.m_Abil           := m_Abil;
         mon.m_WAbil          := m_WAbil;
         mon.m_btHitPoint     := m_btHitPoint;
         mon.m_btAntiPoison   := m_btAntiPoison;
         mon.m_nAntiMagic     := m_nAntiMagic;
         mon.m_nPoisonRecover := m_nPoisonRecover;
         mon.m_btSpeedPoint   := m_btSpeedPoint;
         mon.m_btNameColor    := m_btNameColor;
         mon.m_nLuck          := m_nLuck;
         mon.m_WAbil.DC       := (LoWord(m_WAbil.DC) + HiWord(m_WAbil.DC));
         mon.m_WAbil.AC       := m_WAbil.AC;
         mon.m_WAbil.MAC      := m_WAbil.MAC;
         mon.m_AddAbil.wSlowDown := m_AddAbil.wSlowDown;
         mon.m_AddAbil.wTox := m_AddAbil.wTox;


         mon.m_TargetCret       := targ;
         mon.m_WAbil.MaxHP      := m_WAbil.MaxHP;
         case slevel of
           0: mon.m_WAbil.HP := m_WAbil.MaxHP div 8;
           1: mon.m_WAbil.HP := m_WAbil.MaxHP div 6;
           2: mon.m_WAbil.HP := m_WAbil.MaxHP div 4;
           3: mon.m_WAbil.HP := m_WAbil.MaxHP div 2;
         end;
         mon.RecalcAbilitys;
         mon.RefNameColor;
         m_SlaveList.Add (mon);
         Result := mon;
      end;
   except
     MainOutMessage('EXCEPT MAKESLAVE-ASSA');
   end;
end;

function   TBaseObject.BonzeBodyMakeSlave (sname: string; slevel, royaltysec, no: integer): TBaseObject;        //은형술
var
   nx, ny: integer;
   mon: TBaseObject;
begin
   Result := nil;
   try
      GetFrontPosition (nx, ny);
      Case no of
        0: mon := UserEngine.RegenMonsterByName (m_PEnvir, nx + 3, ny - 3, sname);
        1: mon := UserEngine.RegenMonsterByName (m_PEnvir, nx - 3, ny - 3, sname);
        2: mon := UserEngine.RegenMonsterByName (m_PEnvir, nx + 5, ny + 3, sname);
        3: mon := UserEngine.RegenMonsterByName (m_PEnvir, nx, ny + 3, sname);
        else begin
          mon := UserEngine.RegenMonsterByName (m_PEnvir, nx - 5, ny + 3, sname);
        end;
      end;
      if mon <> nil then begin
         mon.m_Master := Self;
         mon.m_dwMasterRoyaltyTick := GetTickCount + longword(royaltysec) * 1000;
         mon.m_btSlaveMakeLevel := slevel;
         mon.m_btSlaveExpLevel  := slevel;

         mon.m_btMask           := m_btMask;
         mon.m_btJob            := m_btJob;
         mon.m_UseItems         := m_UseItems;
         mon.m_btGender         := m_btGender;
         mon.m_btHair           := m_btHair;
         mon.m_btHumEffect      := m_btHumEffect;
         mon.m_btDressEffType   := m_btDressEffType;
         mon.MasterFeature      := GetFeature(Self);

         mon.m_Abil           := m_Abil;
         mon.m_WAbil          := m_WAbil;
         mon.m_btHitPoint     := m_btHitPoint;
         mon.m_btAntiPoison   := m_btAntiPoison;
         mon.m_nAntiMagic     := m_nAntiMagic;
         mon.m_nPoisonRecover := m_nPoisonRecover;
         mon.m_btSpeedPoint   := m_btSpeedPoint;
         mon.m_btNameColor    := m_btNameColor;
         mon.m_nLuck          := m_nLuck;
         mon.m_WAbil.DC       := (LoWord(m_WAbil.DC) + HiWord(m_WAbil.DC));
         mon.m_WAbil.AC       := m_WAbil.AC;
         mon.m_WAbil.MAC      := m_WAbil.MAC;
         mon.m_AddAbil.wSlowDown := m_AddAbil.wSlowDown;
         mon.m_AddAbil.wTox := m_AddAbil.wTox;

         mon.m_WAbil.MaxHP      := m_WAbil.MaxHP;    
         case slevel of
           0: mon.m_WAbil.HP := m_WAbil.MaxHP div 8;
           1: mon.m_WAbil.HP := m_WAbil.MaxHP div 6;
           2: mon.m_WAbil.HP := m_WAbil.MaxHP div 4;
           3: mon.m_WAbil.HP := m_WAbil.MaxHP div 2;
         end;
         mon.RecalcAbilitys;
         mon.RefNameColor;
         m_SlaveList.Add (mon);
         Result := mon;
      end;
   except
     MainOutMessage('EXCEPT MAKESLAVE-BONZE');
   end;
end;


function TBaseObject.MakePet(sMonName:String):TBaseObject;//004C37C0     //영물
var
  i,nX,nY:Integer;
  MonObj:TBaseObject;
  Magic:pTUserMagic;
  UserMagic:pTUserMagic;
  PlayObject:TPlayObject;
begin
  Result:=nil;
  for i := 0 to m_PetList.count -1 do begin
    if TBaseObject(m_PetList.Items[i]) is TPetObject then
      exit;
  end;
  GetBackPosition(nX,nY);
  MonObj:=UserEngine.RegenMonsterByName(m_PEnvir,nX,nY,sMonName);
  if (MonObj <> nil) and (MonObj is TPetObject) then begin
     MonObj.m_Master:=Self;
     MonObj.m_sCharName      := m_sCharName;
     MonObj.m_dwMasterRoyaltyTick := GetTickCount + 10 * 24 * 60 * 1000;
     MonObj.m_Abil           := m_Abil;
     MonObj.m_WAbil          := m_WAbil;
     MonObj.RecalcAbilitys;
     MonObj.m_WAbil.MaxHP := m_WAbil.MaxHP;
     MonObj.RefShowName;
     m_PetList.Add (MonObj);
     Result := MonObj;
  end;
end;

procedure TBaseObject.PetAbility(sMonName,sValues:String; mode:boolean);    //영물버프
var
   sValue, sIndex, sTempStr2: string;
   nIndex: Integer;
begin
  sTempStr2 := '';
  if mode then begin
    while True do begin
      if sValues = '' then break;
        sValues := GetValidStr3(sValues, sValue, [',']);
      if sValue = '' then break;
        sValue := GetValidStr3(sValue, sIndex, ['.']);
        nIndex := StrToIntDef(sIndex, -1);
      if nIndex in [110..119] then begin
        m_wStatusArrValue[nIndex] := StrToIntDef(sValue, 0);
        m_dwStatusArrTimeOutTick[nIndex] := 1;
      end;
    end;
    if (m_wStatusArrValue[110] > 0) or (m_wStatusArrValue[111] > 0) then
      sTempStr2 := sTempStr2 + '렝徒 + ' + IntToStr(m_wStatusArrValue[110]) + '-' + IntToStr(m_wStatusArrValue[111]) + '\';
    if (m_wStatusArrValue[112] > 0) or (m_wStatusArrValue[113] > 0) then
      sTempStr2 := sTempStr2 + '침랬렝徒 + ' + IntToStr(m_wStatusArrValue[112]) + '-' + IntToStr(m_wStatusArrValue[113]) + '\';
    if (m_wStatusArrValue[114] > 0) or (m_wStatusArrValue[115] > 0) then
      sTempStr2 := sTempStr2 + '묑샌 + ' + IntToStr(m_wStatusArrValue[114]) + '-' + IntToStr(m_wStatusArrValue[115]) + '\';
    if (m_wStatusArrValue[116] > 0) or (m_wStatusArrValue[117] > 0) then
      sTempStr2 := sTempStr2 + '침랬 + ' + IntToStr(m_wStatusArrValue[116]) + '-' + IntToStr(m_wStatusArrValue[117]) + '\';
    if (m_wStatusArrValue[118] > 0) or (m_wStatusArrValue[119] > 0) then
      sTempStr2 := sTempStr2 + '돛減 + ' + IntToStr(m_wStatusArrValue[118]) + '-' + IntToStr(m_wStatusArrValue[119]) + '\';
    SendMsg (Self,RM_BUFF, 117, 0, 510, 1 , '[' + sMonName + ']\' + sTempStr2);  //영물버프
    RecalcAbilitys;
    SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  end else begin
    m_wStatusArrValue[110] := 0;
    m_wStatusArrValue[111] := 0;
    m_wStatusArrValue[112] := 0;
    m_wStatusArrValue[113] := 0;
    m_wStatusArrValue[114] := 0;
    m_wStatusArrValue[115] := 0;
    m_wStatusArrValue[116] := 0;
    m_wStatusArrValue[117] := 0;
    m_wStatusArrValue[118] := 0;
    m_wStatusArrValue[119] := 0;
    m_dwStatusArrTimeOutTick[110] := 0;
    m_dwStatusArrTimeOutTick[111] := 0;
    m_dwStatusArrTimeOutTick[112] := 0;
    m_dwStatusArrTimeOutTick[113] := 0;
    m_dwStatusArrTimeOutTick[114] := 0;
    m_dwStatusArrTimeOutTick[115] := 0;
    m_dwStatusArrTimeOutTick[116] := 0;
    m_dwStatusArrTimeOutTick[117] := 0;
    m_dwStatusArrTimeOutTick[118] := 0;
    m_dwStatusArrTimeOutTick[119] := 0;
    SendMsg (Self,RM_BUFF, 117, 0, 510, 0 , '');  //영물버프
    RecalcAbilitys;
    SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  end;
end;

procedure TPlayObject.ProcessUserLineMsg(sData:String);//004D1E54
var
  sC,sCMD,sParam1,sParam2,sParam3,sParam4,sParam5,sParam6,sParam7:String;
  PlayObject:TPlayObject;
  nFlag, nError:Integer;
  nValue:Integer;
  nLen:Integer;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::ProcessUserLineMsg Msg = %s Error [%d]';
begin
  nError := 0;
try
  nLen:=Length(sData);
  nError := 1;
  if sData = '' then exit;
  nError := 2;
  if m_boTestGa then begin
    m_boTestGa:=False;
    if (g_Config.sTestGAPassword <> '') and (g_Config.sTestGAPassword = sData) then begin
      m_btPermission:=4;
      SysMsg('되쩍냥묘...',c_Red,t_Hint);
    end else begin
      SysMsg('쵱쯤댄轎，',c_Red,t_Hint);
    end;
    Exit;
  end;
  nError := 3;
  if m_boGsa then begin
    m_boGsa:=False;
    if sData = '콱攣瞳끼桿賈痰gsa溝固' then begin
//      m_btPermission:=5;  //broke this on purpose i dont want ppl to hack into noob servers so i dont want @gsa to work
      SysMsg('GSA溝固되쩍냥묘。',c_Red,t_Hint);
    end else begin
      SysMsg('GSA溝固되쩌呵겨。',c_Red,t_Hint);
    end;
    Exit;
  end;
  nError := 4;
  if m_boSetStoragePwd then begin
    m_boSetStoragePwd:=False;
    nError := 5;
    if (nLen > 3) and (nLen < 8) then begin
      m_sTempPwd:=sData;
      m_boReConfigPwd:=True;
      SysMsg(g_sReSetPasswordMsg,c_Green,t_Hint);
      SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
    end else begin
      SysMsg(g_sPasswordOverLongMsg,c_Red,t_Hint);
    end;
    exit;
  end;
  nError := 6;
  if m_boReConfigPwd then begin
    m_boReConfigPwd:=False;
    nError := 7;
    if CompareStr(m_sTempPwd,sData) = 0 then begin
      m_sSystemPwd:=sData;
      m_boPasswordLocked:=True;
      m_boCanGetBackItem:=False;
      m_sTempPwd:='';
      SysMsg(g_sReSetPasswordOKMsg,c_Blue,t_Hint);
    end else begin
      m_sTempPwd:='';
      SysMsg(g_sReSetPasswordNotMatchMsg,c_Red,t_Hint);
    end;
    exit;
  end;
  nError := 8;
  if m_boUnLockPwd or m_boUnLockStoragePwd then begin
    if CompareStr(m_sSystemPwd,sData) = 0 then begin
      m_boPasswordLocked:=False;
      if m_boUnLockPwd then begin
        if g_Config.boLockDealAction then m_boCanDeal:=True;
        if g_Config.boLockDropAction then m_boCanDrop:=True;
        if g_Config.boLockWalkAction then m_boCanWalk:=True;
        if g_Config.boLockRunAction then m_boCanRun:=True;
        if g_Config.boLockHitAction then m_boCanHit:=True;
        if g_Config.boLockSpellAction then m_boCanSpell:=True;
        if g_Config.boLockSendMsgAction then m_boCanSendMsg:=True;
        if g_Config.boLockUserItemAction then m_boCanUseItem:=True;
        if g_Config.boLockInObModeAction then begin
          m_boObMode:=False;     //감시자
          m_boAdminMode:=False;
        end;
        m_boLockLogoned:=True;
        SysMsg(g_sPasswordUnLockOKMsg,c_Blue,t_Hint);
      end;
      if m_boUnLockStoragePwd then begin
        if g_Config.boLockGetBackItemAction then m_boCanGetBackItem:=True;
        SysMsg(g_sStorageUnLockOKMsg,c_Blue,t_Hint);
      end;

    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sUnLockPasswordFailMsg,c_Red,t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
      end;
    end;
    m_boUnLockPwd:=False;
    m_boUnLockStoragePwd:=False;
    exit;
  end;
  nError := 9;
  if m_boCheckOldPwd then begin
    m_boCheckOldPwd:=False;
    if m_sSystemPwd = sData then begin
      SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
      SysMsg(g_sSetPasswordMsg,c_Green,t_Hint);
      m_boSetStoragePwd:=True;
    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sOldPasswordIncorrectMsg,c_Red,t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
        m_boPasswordLocked:=True;
      end;
    end;
    exit;
  end;
  nError := 10;

  AddGameDataLog('50' +  #9 +
               m_sMapName + #9 +
               IntToStr(m_nCurrX) + #9 +
               IntToStr(m_nCurrY) + #9 +
               m_sCharName + #9 +
               '0' + #9 +
               '0' + #9 +
               '1' + #9 +
               '0' + #9
               + m_sCharName + ': ' +sData);

  if sData[1] <> '@' then begin
    nError := 11;
    ProcessSayMsg(sData);
    exit;
  end;
  nError := 11;
    sC:=Copy(sData,2,Length(sData) - 1);
    sC:=GetValidStr3(sC, sCMD, [' ', ':', ',',#9]);
    nError := 12;
    if CompareText(sCMD,g_GameCommand.SHOUTGREEN.sCmd) = 0 then begin
      CmdShoutGreen(@g_GameCommand.SHOUTGREEN,sC);
      UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [푤쟁눈稜] ' + m_sCharName + ': ' +sData, 11);   //고성  //좔莖溝固
      exit;
    end;
    nError := 13;
    if CompareText(sCMD,g_GameCommand.SHOUTPURPLE.sCmd) = 0 then begin
      CmdShoutPurple(@g_GameCommand.SHOUTPURPLE,sC);
      UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [푤쟁눈稜] ' + m_sCharName + ': ' +sData, 11);   //고성   //채팅시스템
      exit;
    end;
    nError := 14;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam1, [' ', ':', ',',#9]);
    end;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam2, [' ', ':', ',',#9]);
    end;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam3, [' ', ':', ',',#9]);
    end;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam4, [' ', ':', ',',#9]);
    end;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam5, [' ', ':', ',',#9]);
    end;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam6, [' ', ':', ',',#9]);
    end;
    if sC <> '' then begin
      sC:=GetValidStr3(sC, sParam7, [' ', ':', ',',#9]);
    end;//004D20BF
    nError := 15;

    UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [츱즈] ' + m_sCharName + ': ' +sData, 1);   //명령  //채팅시스템

    if ProcessUserCmd(sCmd) then  Exit;   //유저명령어
    nError := 16;
    if CompareText(sCMD,g_GameCommand.PASSWORDLOCK.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;
      if m_sSystemPwd = '' then begin
        SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
        m_boSetStoragePwd:=True;
        SysMsg(g_sSetPasswordMsg,c_Green,t_Hint);
        exit;
      end;
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
        m_boPasswordLocked:=True;
        exit;
      end;
      if m_sSystemPwd <> '' then begin
        SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
        m_boCheckOldPwd:=True;
        SysMsg(g_sPleaseInputOldPasswordMsg,c_Green,t_Hint);
        exit;
      end;
      exit;
    end;
    
    if CompareText(sCMD,g_GameCommand.SETPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;

      if m_sSystemPwd = '' then begin
        SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
        m_boSetStoragePwd:=True;
        SysMsg(g_sSetPasswordMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sAlreadySetPasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    
    if CompareText(sCMD,g_GameCommand.UNPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;
      if not m_boPasswordLocked then begin
        m_sSystemPwd:='';
        SysMsg(g_sOldPasswordIsClearMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sPleaseUnLockPasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CHGPASSWORD.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
        m_boPasswordLocked:=True;
        exit;
      end;
      if m_sSystemPwd <> '' then begin
        SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
        m_boCheckOldPwd:=True;
        SysMsg(g_sPleaseInputOldPasswordMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sNoPasswordSetMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.UNLOCKSTORAGE.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock{3} then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
        m_boPasswordLocked:=True;
        exit;
      end;
      if m_sSystemPwd <> '' then begin
        if not m_boUnLockStoragePwd then begin
          SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
          SysMsg(g_sPleaseInputUnLockPasswordMsg,c_Green,t_Hint);
          m_boUnLockStoragePwd:=True;
        end else begin
          SysMsg(g_sStorageAlreadyUnLockMsg,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageNoPasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.UNLOCK.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock{3} then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
        m_boPasswordLocked:=True;
        exit;
      end;
      if m_sSystemPwd <> '' then begin
        if not m_boUnLockPwd then begin
          SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
          SysMsg(g_sPleaseInputUnLockPasswordMsg,c_Green,t_Hint);
          m_boUnLockPwd:=True;
        end else begin
          SysMsg(g_sStorageAlreadyUnLockMsg,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageNoPasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
      if not g_Config.boPasswordLockSystem then begin
        SysMsg(g_sNoPasswordLockSystemMsg,c_Red,t_Hint);
        exit;
      end;
      if not m_boPasswordLocked then begin
        if m_sSystemPwd <> '' then begin
          m_boPasswordLocked:=True;
          m_boCanGetBackItem:=False;
          SysMsg(g_sLockStorageSuccessMsg,c_Green,t_Hint);
        end else begin
          SysMsg(g_sStorageNoPasswordMsg,c_Green,t_Hint);
        end;
      end else begin
        SysMsg(g_sStorageAlreadyLockMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    {
    if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
      if not m_boPasswordLocked then begin
        m_sSystemPwd:='';
        SysMsg(g_sStoragePasswordClearMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sPleaseUnloadStoragePasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    }
    if CompareText(sCMD,g_GameCommand.MEMBERFUNCTION.sCmd) = 0 then begin
      CmdMemberFunction(g_GameCommand.MEMBERFUNCTION.sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MEMBERFUNCTIONEX.sCmd) = 0 then begin
      CmdMemberFunctionEx(g_GameCommand.MEMBERFUNCTIONEX.sCmd,sParam1);
      exit;
    end;


    if CompareText(sCMD,g_GameCommand.DEARRECALL.sCmd) = 0 then begin
      CmdDearRecall(g_GameCommand.DEARRECALL.sCmd);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.DEARBREAK.sCmd) = 0 then begin  //연인 스쳐 해제
       CmdBreakLoverRelation;
      exit;
    end;


    if CompareText(sCMD,g_GameCommand.DATA.sCmd) = 0 then begin  //시간
      SysMsg(g_sNowCurrDateTime + FormatDateTime('dddddd, hh:mm:nn', Now),c_Blue,t_Hint);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.PRVMSG.sCmd) = 0 then begin
      CmdPrvMsg(g_GameCommand.PRVMSG.sCmd,g_GameCommand.PRVMSG.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCmd, g_GameCommand.GetUserItem.sCmd) = 0 then begin          //회수
      CmdGetUserItems(@g_GameCommand.GetUserItem, sParam1, sParam2, sParam3, sParam4);
      Exit;
    end;
    if CompareText(sCmd, g_GameCommand.AddUserItem.sCmd) = 0 then begin          //주기
      CmdAddUserItems(@g_GameCommand.AddUserItem, sParam1, sParam2, Str_ToInt(sParam3,0));
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.ALLOWMSG.sCmd) = 0 then begin
      m_boHearWhisper:= not m_boHearWhisper;
      if m_boHearWhisper then SysMsg(g_sEnableHearWhisper{'[Reject Whisper Deactivated]'},c_Green,t_Hint)
      else SysMsg(g_sDisableHearWhisper{'[Reject Whisper Activated]'},c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.BANSTORE.sCmd) = 0 then begin
      m_boBanStoreShout:= not m_boBanStoreShout;
      if m_boBanStoreShout then SysMsg(g_sEnableStoreMsg,c_Green,t_Hint)
      else SysMsg(g_sDisableStoreMsg,c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.LETSHOUT.sCmd) = 0 then begin
      m_boBanShout:= not m_boBanShout;
      if m_boBanShout then SysMsg(g_sEnableShoutMsg,c_Green,t_Hint)
      else SysMsg(g_sDisableShoutMsg,c_Green,t_Hint);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.LETTRADE.sCmd) = 0 then begin
      m_boAllowDeal:= not m_boAllowDeal;
      if m_boAllowDeal then SysMsg(g_sEnableDealMsg{'[Allow Deal]'},c_Green,t_Hint)
      else SysMsg(g_sDisableDealMsg{'[Disallow Deal]'},c_Green,t_Hint);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.BANGUILDCHAT.sCmd) = 0 then begin
      m_boBanGuildChat:= not m_boBanGuildChat;
      if m_boBanGuildChat then SysMsg(g_sEnableGuildChat{'[Show Guild Chat]'},c_Green,t_Hint)
      else SysMsg(g_sDisableGuildChat{'[Hide Guild Chat]'},c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.BANGROUPCHAT.sCmd) = 0 then begin
      m_boBanGroupChat:= not m_boBanGroupChat;
      if m_boBanGroupChat then SysMsg(g_sEnableGroupChat,c_Green,t_Hint)
      else SysMsg(g_sDisableGroupChat,c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.BANSYSMSG.sCmd) = 0 then begin
      m_boBanSysMsg:= not m_boBanSysMsg;
      if m_boBanSysMsg then SysMsg(g_sEnableSysMsg,c_Green,t_Hint)
      else SysMsg(g_sDisableSysMsg,c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.BANHEARMSG.sCmd) = 0 then begin      //일반 대화
      m_boHearMsg:= not m_boHearMsg;
      if m_boHearMsg then SysMsg(g_sEnableHearMsg,c_Green,t_Hint)
      else SysMsg(g_sDisableHearMsg,c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.LETGUILD.sCmd) = 0 then begin
      m_boAllowGuild:= not m_boAllowGuild;
      if m_boAllowGuild then SysMsg(g_sEnableJoinGuild,c_Green,t_Hint)
      else SysMsg(g_sDisableJoinGuild,c_Green,t_Hint);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.ENERGY.sCmd) = 0 then begin
      if (m_Abil.Level >= g_Config.sLevel50Effect) or (m_Abil.Level >= g_Config.sLevel60Effect) or ((m_btJob in [5..9]) and (m_Abil.Level >= g_Config.sLevel70Effect)) then begin        //직업변경
        m_boHighLevelEffect := not m_boHighLevelEffect;
        if m_boHighLevelEffect then begin
          SysMsg ('鞫刻콘좆景槻。',c_Green,t_Hint);
          GetObjectEffect;
          RecalcAbilitys;
          FeatureChanged;
        end else begin
          SysMsg ('밑균콘좆景槻。',c_Green,t_Hint);
          m_btHumEffect := 0;
          RecalcAbilitys;
          FeatureChanged;
        end;
      end else
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.ENDGUILD.sCmd) = 0 then begin
      CmdEndGuild();
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.AUTHALLY.sCmd) = 0 then begin
      if IsGuildMaster then begin
        TGuild(m_MyGuild).m_boEnableAuthAlly:=not TGuild(m_MyGuild).m_boEnableAuthAlly;
        if TGuild(m_MyGuild).m_boEnableAuthAlly then SysMsg(g_sEnableAuthAllyGuild{'[Allow Ally]'},c_Green,t_Hint)
        else SysMsg(g_sDisableAuthAllyGuild{'[Disallow Ally]'},c_Green,t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ALLOWGROUPCALL.sCmd) = 0 then begin
      CmdAllowGroupReCall(sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.GROUPRECALLL.sCmd) = 0 then begin
      CmdGroupRecall(g_GameCommand.GROUPRECALLL.sCmd);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ALLOWGUILDRECALL.sCmd) = 0 then begin
      m_boAllowGuildReCall:= not m_boAllowGuildReCall;
      if m_boAllowGuildReCall then SysMsg(g_sEnableGuildRecall{'[Allow Guild Recall]'},c_Green,t_Hint)
      else SysMsg(g_sDisableGuildRecall{'[Disallow Guild Recall]'},c_Green,t_Hint);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.GUILDRECALLL.sCmd) = 0 then begin
      CmdGuildRecall(g_GameCommand.GUILDRECALLL.sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ALLIANCE.sCmd) = 0 then begin
      if IsGuildMaster then ClientGuildAlly();
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CANCELALLIANCE.sCmd) = 0 then begin
      if IsGuildMaster then ClientGuildBreakAlly(sParam1);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.DIARY.sCmd) = 0 then begin
      CmdViewDiary(g_GameCommand.DIARY.sCmd,Str_ToInt(sParam1,0));
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.ATTACKMODE.sCmd) = 0 then begin
      CmdChangeAttackMode(Str_ToInt(sParam1,-1),sParam1,sParam2,sParam3,sParam4,sParam5,sParam6,sParam7);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.REST.sCmd) = 0 then begin
      CmdChangeSalveStatus();
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.TAKEONHORSE.sCmd) = 0 then begin
      CmdTakeOnHorse(sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.TAKEOFHORSE.sCmd) = 0 then begin
      CmdTakeOffHorse(sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SVNINFO.sCmd) = 0 then begin
      CmdSvnInfo(@g_GameCommand.SVNINFO,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.TRADEGT.sCmd) = 0 then begin
      CmdTradeGT(@g_GameCommand.TRADEGT);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.TESTGA.sCmd) = 0 then begin //004D25C5
      exit;
      SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
      m_boTestGa:=True;
      SysMsg(g_sPleaseInputPassword{'Password: '},c_Green,t_Hint);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MAPINFO.sCmd) = 0 then begin
      ShowMapInfo(sParam1,sParam2,sParam3);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CLEARBAG.sCmd) = 0 then begin     //가방정리
      CmdClearBagItem(@g_GameCommand.CLEARBAG,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWUSEITEMINFO.sCmd) = 0 then begin
      CmdShowUseItemInfo(@g_GameCommand.SHOWUSEITEMINFO,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.BINDUSEITEM.sCmd) = 0 then begin
      CmdBindUseItem(@g_GameCommand.BINDUSEITEM,sParam1,sParam2,sParam3);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SBKDOOR.sCmd) = 0 then begin //004D2610
      CmdSbkDoorControl(g_GameCommand.SBKDOOR.sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.USERMOVE.sCmd) = 0 then begin
      CmdUserMoveXY(g_GameCommand.USERMOVE.sCmd,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SEARCHING.sCmd) = 0 then begin
      CmdSearchHuman(g_GameCommand.SEARCHING.sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.LOCKLOGON.sCmd) = 0 then begin
      CmdLockLogin(@g_GameCommand.LOCKLOGON);
      exit;
    end;
    if (m_btPermission >= 2) and (length(sData) > 2) then begin
      if (m_btPermission >= 6) and (sData[2] = g_GMRedMsgCmd) then begin

        if GetTickCount - m_dwSayMsgTick > 1000 then begin
          m_dwSayMsgTick:=GetTickCount();
          sData:=Copy(sData,3,length(sData) - 2);
          if length(sData) > g_Config.nSayRedMsgMaxLen then begin
            sData:=Copy(sData,1,g_Config.nSayRedMsgMaxLen);
          end;

          if g_Config.boShutRedMsgShowGMName then
            sC:= '(*)'+ #7 + m_sCharName  + #7 + ': ' + GetItemInfo(sData)
          else sC:='(*)'+ GetItemInfo(sData);
          UserEngine.SendBroadCastMsg(sC,t_GM);
        end;
        exit;
      end;
    end;

    if (m_btPermission >= 2) and (length(sData) > 2) then begin
      if (m_btPermission >= 6) and (sData[2] = g_GMRedMsgCmd1) then begin

        if GetTickCount - m_dwSayMsgTick > 1000 then begin
          m_dwSayMsgTick:=GetTickCount();
          sData:=Copy(sData,3,length(sData) - 2);
          if length(sData) > g_Config.nSayRedMsgMaxLen then begin
            sData:=Copy(sData,1,g_Config.nSayRedMsgMaxLen);
          end;

         { if g_Config.boShutRedMsgShowGMName then
            sC:=m_sCharName + ': ' + sData
          else }sC:=sData;
          UserEngine.SendMoveMsg(sC);     //운영자 메시지
        end;
        exit;
      end;
    end;
    //004D2C70
    if CompareText(sCMD,g_GameCommand.HUMANLOCAL.sCmd) = 0 then begin
      CmdHumanLocal(@g_GameCommand.HUMANLOCAL,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.MOVE.sCmd) = 0 then begin
      CmdMapMove(@g_GameCommand.MOVE,sParam1);
      Exit;
    end;//004D2CD0
    if CompareText(sCMD,g_GameCommand.POSITIONMOVE.sCmd) = 0 then begin
      CmdPositionMove(@g_GameCommand.POSITIONMOVE,sParam1,sParam2,sParam3);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.POSITIONGTMOVE.sCmd) = 0 then begin
      CmdPositionGtMove(@g_GameCommand.POSITIONGTMOVE,sParam1,sParam2,sParam3,sParam4);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.HOMEMOVE.sCmd) = 0 then begin    //마을이동
      CmdHomeMove(@g_GameCommand.HOMEMOVE);
      Exit;
    end;

    if CompareText(sCMD,g_GameCommand.MASKCLEAR.sCmd) = 0 then begin    //마을이동
      CmdMaskClear(@g_GameCommand.MASKCLEAR);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.INFO.sCmd) = 0 then begin
      CmdHumanInfo(@g_GameCommand.INFO,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.MOBLEVEL.sCmd) = 0 then begin
      CmdMobLevel(@g_GameCommand.MOBLEVEL,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.MOBCOUNT.sCmd) = 0 then begin
      CmdMobCount(@g_GameCommand.MOBCOUNT,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.HUMANCOUNT.sCmd) = 0 then begin
      CmdHumanCount(@g_GameCommand.HUMANCOUNT,sParam1);
      Exit;
    end;

    if CompareText(sCMD,g_GameCommand.GMEVENT.sCmd) = 0 then begin  //gm 이벤트
      CmdGMEventAbill(@g_GameCommand.GMEVENT,sParam1,sParam2,sParam3,sParam4);
      Exit;
    end;

    if CompareText(sCMD,g_GameCommand.KICK.sCmd) = 0 then begin
      CmdKickHuman(@g_GameCommand.KICK,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.TING.sCmd) = 0 then begin
      CmdTing(@g_GameCommand.TING,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SUPERTING.sCmd) = 0 then begin
      CmdSuperTing(@g_GameCommand.SUPERTING,sParam1,sParam2);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.MAPMOVE.sCmd) = 0 then begin
      CmdMapMoveHuman(@g_GameCommand.MAPMOVE,sParam1,sParam2);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHUTUP.sCmd) = 0 then begin
      CmdShutup(@g_GameCommand.SHUTUP,sParam1,sParam2);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.MAP.sCmd) = 0 then begin
      CmdShowMapInfo(@g_GameCommand.MAP,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.RELEASESHUTUP.sCmd) = 0 then begin
      CmdShutupRelease(@g_GameCommand.RELEASESHUTUP,sParam1,True);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHUTUPLIST.sCmd) = 0 then begin
      CmdShutupList(@g_GameCommand.SHUTUPLIST,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.GAMEMASTER.sCmd) = 0 then begin
      CmdChangeAdminMode(g_GameCommand.GAMEMASTER.sCmd,g_GameCommand.GAMEMASTER.nPermissionMin,sParam1,not m_boAdminMode);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.OBSERVER.sCmd) = 0 then begin
      CmdChangeObMode(g_GameCommand.OBSERVER.sCmd,g_GameCommand.OBSERVER.nPermissionMin,sParam1,not m_boObMode);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SUEPRMAN.sCmd) = 0 then begin
      CmdChangeSuperManMode(g_GameCommand.OBSERVER.sCmd,g_GameCommand.OBSERVER.nPermissionMin,sParam1,not m_boSuperMan);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.LEVEL.sCmd) = 0 then begin
      CmdChangeLevel(@g_GameCommand.LEVEL,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SABUKWALLGOLD.sCmd) = 0 then begin
      CmdShowSbkGold(@g_GameCommand.SABUKWALLGOLD,sParam1,sParam2,sParam3);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.RECALL.sCmd) = 0 then begin
      CmdRecallHuman(@g_GameCommand.RECALL,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.REGOTO.sCmd) = 0 then begin
      CmdReGotoHuman(@g_GameCommand.REGOTO,sParam1);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWFLAG.sCmd) = 0 then begin
      CmdShowHumanFlag(g_GameCommand.SHOWFLAG.sCmd,g_GameCommand.SHOWFLAG.nPermissionMin,sParam1,sParam2);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWOPEN.sCmd) = 0 then begin
      CmdShowHumanUnitOpen(g_GameCommand.SHOWOPEN.sCmd,g_GameCommand.SHOWOPEN.nPermissionMin,sParam1,sParam2);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWUNIT.sCmd) = 0 then begin
      CmdShowHumanUnit(g_GameCommand.SHOWUNIT.sCmd,g_GameCommand.SHOWUNIT.nPermissionMin,sParam1,sParam2);
      Exit;
    end;
    if CompareText(sCMD,g_GameCommand.ATTACK.sCmd) = 0 then begin
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MOB.sCmd) = 0 then begin
      CmdMob(@g_GameCommand.MOB,sParam1,Str_ToInt(sParam2,0),Str_ToInt(sParam3,0), Str_ToInt(sParam4,-1));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MOBNPC.sCmd) = 0 then begin
      CmdMobNpc(g_GameCommand.MOBNPC.sCmd,g_GameCommand.MOBNPC.nPermissionMin,sParam1,sParam2,sParam3,sParam4);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.NPCSCRIPT.sCmd) = 0 then begin
      CmdNpcScript(g_GameCommand.NPCSCRIPT.sCmd,g_GameCommand.NPCSCRIPT.nPermissionMin,sParam1,sParam2,sParam3);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELNPC.sCmd) = 0 then begin
      CmdDelNpc(g_GameCommand.DELNPC.sCmd,g_GameCommand.DELNPC.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ALLLOCK.sCmd) = 0 then begin
      CmdALLLOCK(g_GameCommand.ALLLOCK.sCmd,g_GameCommand.ALLLOCK.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SFC.sCmd) = 0 then begin
      CmdSFC(g_GameCommand.SFC.sCmd,g_GameCommand.SFC.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.RECALLMOB.sCmd) = 0 then begin
      CmdRecallMob(@g_GameCommand.RECALLMOB,sParam1,Str_ToInt(sParam2,0),Str_ToInt(sParam3,0));
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.FIVEGO.sCmd) = 0 then begin
      CmdFiveGo(g_GameCommand.FIVEGO.sCmd,g_GameCommand.FIVEGO.nPermissionMin);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.MAPCLICKMOVE.sCmd) = 0 then begin
      CmdMapClickMove(@g_GameCommand.MAPCLICKMOVE,sParam1,sParam2);
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.LUCKYPOINT.sCmd) = 0 then begin
      CmdLuckPoint(g_GameCommand.LUCKYPOINT.sCmd,g_GameCommand.LUCKYPOINT.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.LOTTERYTICKET.sCmd) = 0 then begin
      CmdLotteryTicket(g_GameCommand.LOTTERYTICKET.sCmd,g_GameCommand.LOTTERYTICKET.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.RELOADGUILD.sCmd) = 0 then begin
      CmdReloadGuild(g_GameCommand.RELOADGUILD.sCmd,g_GameCommand.RELOADGUILD.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.LOADGUILD.sCmd) = 0 then begin  //초보문파
      CmdloadGuild(g_GameCommand.LOADGUILD.sCmd,g_GameCommand.RELOADGUILD.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.RELOADLINENOTICE.sCmd) = 0 then begin
      CmdReloadLineNotice(g_GameCommand.RELOADLINENOTICE.sCmd,g_GameCommand.RELOADLINENOTICE.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.RELOADABUSE.sCmd) = 0 then begin
      CmdReloadAbuse(g_GameCommand.RELOADABUSE.sCmd,g_GameCommand.RELOADABUSE.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.FREEPENALTY.sCmd) = 0 then begin
      CmdFreePenalty(@g_GameCommand.FREEPENALTY,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.KILLDEATHZERO.sCmd) = 0 then begin   //킬/데스 초기화
      CmdKillDeathZero(@g_GameCommand.KILLDEATHZERO,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.PKPOINT.sCmd) = 0 then begin
      CmdPKpoint(@g_GameCommand.PKPOINT,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.INCPKPOINT.sCmd) = 0 then begin
      CmdIncPkPoint(@g_GameCommand.INCPKPOINT,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MAKE.sCmd) = 0 then begin
      CmdMakeItem(@g_GameCommand.MAKE,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.TRACK.sCmd) = 0 then begin
     // CmdTRACK(@g_GameCommand.TRACK,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.VIEWWHISPER.sCmd) = 0 then begin
      CmdViewWhisper(@g_GameCommand.VIEWWHISPER,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.REALIVE.sCmd) = 0 then begin
      CmdReAlive(@g_GameCommand.REALIVE,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.KILL.sCmd) = 0 then begin
      CmdKill(@g_GameCommand.KILL,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SMAKE.sCmd) = 0 then begin
      CmdSmakeItem(@g_GameCommand.SMAKE,Str_ToInt(sParam1,0),Str_ToInt(sParam2,0),Str_ToInt(sParam3,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.YOURMAKE.sCmd) = 0 then begin
      CmdYourmakeItem(@g_GameCommand.YOURMAKE,sParam1,Str_ToInt(sParam2,0),Str_ToInt(sParam3,0),Str_ToInt(sParam4,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CHANGEJOB.sCmd) = 0 then begin
      CMdChangeJob(@g_GameCommand.CHANGEJOB,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CHANGEJOBUP.sCmd) = 0 then begin  //등선변환
      CMdChangeJobUp(@g_GameCommand.CHANGEJOBUP,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CHANGEGENDER.sCmd) = 0 then begin
      CmdChangeGender(@g_GameCommand.CHANGEGENDER,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.HAIR.sCmd) = 0 then begin
      CmdHair(@g_GameCommand.HAIR,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.BONUSPOINT.sCmd) = 0 then begin
      CmdBonuPoint(@g_GameCommand.BONUSPOINT,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELBONUSPOINT.sCmd) = 0 then begin
      CmdDelBonuPoint(@g_GameCommand.DELBONUSPOINT,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.RESTBONUSPOINT.sCmd) = 0 then begin
      CmdRestBonuPoint(@g_GameCommand.RESTBONUSPOINT,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SETPERMISSION.sCmd) = 0 then begin
      CmdSetPermission(@g_GameCommand.SETPERMISSION,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SETCOLUMN.sCmd) = 0 then begin
      CmdSetColumn(@g_GameCommand.SETCOLUMN,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.RENEWLEVEL.sCmd) = 0 then begin
      CmdReNewLevel(@g_GameCommand.RENEWLEVEL,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELGOLD.sCmd) = 0 then begin
      CmdDelGold(@g_GameCommand.DELGOLD,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ADDGOLD.sCmd) = 0 then begin
      CmdAddGold(@g_GameCommand.ADDGOLD,sParam1,Str_ToInt(sParam2,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.GAMEGOLD.sCmd) = 0 then begin
      CmdGameGold(@g_GameCommand.GAMEGOLD,sParam1,sParam2,Str_ToInt(sParam3,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.GAMEPOINT.sCmd) = 0 then begin
      CmdGamePoint(@g_GameCommand.GAMEPOINT,sParam1,sParam2,Str_ToInt(sParam3,0));
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.PCPOINT.sCmd) = 0 then begin
      CmdPCPoint(@g_GameCommand.PCPOINT,sParam1,sParam2,Str_ToInt(sParam3,0));
      exit;
    end;

    if CompareText(sCMD,g_GameCommand.TRAINING.sCmd) = 0 then begin
      CmdTrainingSkill(@g_GameCommand.TRAINING,sParam1,sParam2,Str_ToInt(sParam3,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELETEITEM.sCmd) = 0 then begin
      CmdDeleteItem(@g_GameCommand.DELETEITEM,sParam1,sParam2,Str_ToInt(sParam3,1));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELETESKILL.sCmd) = 0 then begin
      CmdDelSkill(@g_GameCommand.DELETESKILL,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.TRAININGSKILL.sCmd) = 0 then begin
      CmdTrainingMagic(@g_GameCommand.TRAININGSKILL,sParam1,sParam2,Str_ToInt(sParam3,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CLEARMISSION.sCmd) = 0 then begin
      CmdClearMission(@g_GameCommand.CLEARMISSION,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.STARTQUEST.sCmd) = 0 then begin
      CmdStartQuest(@g_GameCommand.STARTQUEST,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DENYIPLOGON.sCmd) = 0 then begin
      CmdDenyIPaddrLogon(@g_GameCommand.DENYIPLOGON,sParam1,sParam2);
      exit;
    end;


    if CompareText(sCMD,g_GameCommand.CLEARMON.sCmd) = 0 then begin
      CmdClearMapMonster(@g_GameCommand.CLEARMON,sParam1,sParam2,sParam3);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdDenyAccountLogon(@g_GameCommand.DENYACCOUNTLOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdDenyCharNameLogon(@g_GameCommand.DENYCHARNAMELOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELDENYIPLOGON.sCmd) = 0 then begin
      CmdDelDenyIPaddrLogon(@g_GameCommand.DELDENYIPLOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELDENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdDelDenyAccountLogon(@g_GameCommand.DELDENYACCOUNTLOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DELDENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdDelDenyCharNameLogon(@g_GameCommand.DELDENYCHARNAMELOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWDENYIPLOGON.sCmd) = 0 then begin
      CmdShowDenyIPaddrLogon(@g_GameCommand.SHOWDENYIPLOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWDENYACCOUNTLOGON.sCmd) = 0 then begin
      CmdShowDenyAccountLogon(@g_GameCommand.SHOWDENYACCOUNTLOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWDENYCHARNAMELOGON.sCmd) = 0 then begin
      CmdShowDenyCharNameLogon(@g_GameCommand.SHOWDENYCHARNAMELOGON,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MISSION.sCmd) = 0 then begin
      CmdMission(@g_GameCommand.MISSION,sParam1,sParam2);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.MOBPLACE.sCmd) = 0 then begin
      CmdMobPlace(@g_GameCommand.MOBPLACE,sParam1,sParam2,sParam3,sParam4);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SETMAPMODE.sCmd) = 0 then begin
      CmdSetMapMode(g_GameCommand.SETMAPMODE.sCmd,sParam1,sParam2,sParam3,sParam4);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.SHOWMAPMODE.sCmd) = 0 then begin
      CmdShowMapMode(g_GameCommand.SHOWMAPMODE.sCmd,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CLRPASSWORD.sCmd) = 0 then begin
      CmdClearHumanPassword(g_GameCommand.CLRPASSWORD.sCmd,g_GameCommand.CLRPASSWORD.nPermissionMin,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.CONTESTPOINT.sCmd) = 0 then begin
      CmdContestPoint(@g_GameCommand.CONTESTPOINT,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.STARTCONTEST.sCmd) = 0 then begin
      CmdStartContest(@g_GameCommand.STARTCONTEST,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ENDCONTEST.sCmd) = 0 then begin
      CmdEndContest(@g_GameCommand.ENDCONTEST,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ANNOUNCEMENT.sCmd) = 0 then begin
      CmdAnnouncement(@g_GameCommand.ANNOUNCEMENT,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DISABLESENDMSG.sCmd) = 0 then begin
      CmdDisableSendMsg(@g_GameCommand.DISABLESENDMSG,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.ENABLESENDMSG.sCmd) = 0 then begin
      CmdEnableSendMsg(@g_GameCommand.ENABLESENDMSG,sParam1);
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.REFINEWEAPON.sCmd) = 0 then begin
      CmdRefineWeapon(@g_GameCommand.REFINEWEAPON,Str_ToInt(sParam1,0),Str_ToInt(sParam2,0),Str_ToInt(sParam3,0),Str_ToInt(sParam4,0));
      exit;
    end;
    if CompareText(sCMD,g_GameCommand.DISABLESENDMSGLIST.sCmd) = 0 then begin
      CmdDisableSendMsgList(@g_GameCommand.DISABLESENDMSGLIST);
      exit;
    end;
    if m_btPermission > 4 then begin
      if CompareText(sCMD,g_GameCommand.BACKSTEP.sCmd) = 0 then begin
        CmdBackStep(sCmd,Str_ToInt(sParam1,0),Str_ToInt(sParam2,1));
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.BALL.sCmd) = 0 then begin //쑹周
        exit;
      end;

      if CompareText(sCMD,g_GameCommand.CHANGELUCK.sCmd) = 0 then begin
        CmdChangeLuckPoint(@g_GameCommand.CHANGELUCK,sParam1,Str_ToInt(sParam2,0));
        exit;
      end;

      if CompareText(sCMD,g_GameCommand.NAMECOLOR.sCmd) = 0 then begin
        exit;
      end;

      if CompareText(sCMD,g_GameCommand.TRANSPARECY.sCmd) = 0 then begin
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.LEVEL0.sCmd) = 0 then begin
        exit;
      end;

      if CompareText(sCMD,g_GameCommand.SETFLAG.sCmd) = 0 then begin //004D3BDD
        PlayObject:=UserEngine.GeTPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag:=Str_ToInt(sParam2,0);
          nValue:=Str_ToInt(sParam3,0);
          PlayObject.SetQuestFlagStatus(nFlag,nValue);
          if PlayObject.GetQuestFalgStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON',c_Green,t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF',c_Green,t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETFLAG.sCmd + ' Username Flag (0 - 1)',c_Red,t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.SETOPEN.sCmd) = 0 then begin
        PlayObject:=UserEngine.GeTPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag:=Str_ToInt(sParam2,0);
          nValue:=Str_ToInt(sParam3,0);
          PlayObject.SetQuestUnitOpenStatus(nFlag,nValue);
          if PlayObject.GetQuestUnitOpenStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON',c_Green,t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF',c_Green,t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETOPEN.sCmd + ' Username Flag On/Off(0 - 1)',c_Red,t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.SETUNIT.sCmd) = 0 then begin
        PlayObject:=UserEngine.GeTPlayObject(sParam1);
        if PlayObject <> nil then begin
          nFlag:=Str_ToInt(sParam2,0);
          nValue:=Str_ToInt(sParam3,0);
          PlayObject.SetQuestUnitStatus(nFlag,nValue);
          if PlayObject.GetQuestUnitStatus(nFlag) = 1 then begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON',c_Green,t_Hint);
          end else begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF',c_Green,t_Hint);
          end;
        end else begin
          SysMsg('@' + g_GameCommand.SETUNIT.sCmd + ' Username Flag On/Off(0 - 1)',c_Red,t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.RECONNECTION.sCmd) = 0 then begin
        CmdReconnection(sCmd,sParam1,sParam2);
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.DISABLEFILTER.sCmd) = 0 then begin
        CmdDisableFilter(sCmd,sParam1);
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.CHGUSERFULL.sCmd) = 0 then begin
        CmdChangeUserFull(sCmd,sParam1);
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.CHGZENFASTSTEP.sCmd) = 0 then begin
        CmdChangeZenFastStep(sCmd,sParam1);
        exit;
      end;

      if CompareText(sCMD,g_GameCommand.OXQUIZROOM.sCmd) = 0 then begin
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.GSA.sCmd) = 0 then begin
        exit;
      end;
      if CompareText(sCMD,g_GameCommand.CHANGEITEMNAME.sCmd) = 0 then begin
        CmdChangeItemName(g_GameCommand.CHANGEITEMNAME.sCmd,sParam1,sParam2,sParam3);
        exit;
      end;
      if (m_btPermission >= 5) or (g_Config.boTestServer)then begin

        if CompareText(sCMD,g_GameCommand.FIREBURN.sCmd) = 0 then begin
          CmdFireBurn(Str_ToInt(sParam1,0),Str_ToInt(sParam2,0),Str_ToInt(sParam3,0));
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.TESTFIRE.sCmd) = 0 then begin
          CmdTestFire(sCmd,Str_ToInt(sParam1,0),Str_ToInt(sParam2,0),Str_ToInt(sParam3,0),Str_ToInt(sParam4,0));
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.TESTSTATUS.sCmd) = 0 then begin
          CmdTestStatus(sCmd,Str_ToInt(sParam1,-1),Str_ToInt(sParam2,0));
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.DELGAMEGOLD.sCmd) = 0 then begin
          CmdDelGameGold(g_GameCommand.DELGAMEGOLD.sCmd,sParam1,Str_ToInt(sParam2,0));
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADDGAMEGOLD.sCmd) = 0 then begin
          CmdAddGameGold(g_GameCommand.ADDGAMEGOLD.sCmd,sParam1,Str_ToInt(sParam2,0));
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.TESTGOLDCHANGE.sCmd) = 0 then begin
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADADMIN.sCmd) = 0 then begin
          CmdReLoadAdmin(g_GameCommand.RELOADADMIN.sCmd);
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADCOLUMN.sCmd) = 0 then begin    //홍보단
          CmdReLoadColumn(g_GameCommand.RELOADCOLUMN.sCmd);
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADNPC.sCmd) = 0 then begin
          CmdReloadNpc(sParam1);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADDKILLPOINT.sCmd) = 0 then begin
          CmdAddKillPoint(sCmd,sParam1,sParam2,sParam3);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADDDEATHPOINT.sCmd) = 0 then begin
          CmdAddDeathPoint(sCmd,sParam1,sParam2,sParam3);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADMANAGE.sCmd) = 0 then begin
          CmdReloadManage(@g_GameCommand.RELOADMANAGE,sParam1);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADROBOTMANAGE.sCmd) = 0 then begin
          CmdReloadRobotManage();
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADROBOT.sCmd) = 0 then begin
          CmdReloadRobot();
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADMONITEMS.sCmd) = 0 then begin
          CmdReLoadMonitems();
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADDIARY.sCmd) = 0 then begin
          if FrmDB.LoadQuestDiary < 0 then
           SysMsg ('路劤속潼QuestDiarys呵겨...',c_Green,t_Hint)
          else
          SysMsg ('路劤속潼QuestDiarys냥묘...',c_Green,t_Hint);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADITEMDB.sCmd) = 0 then begin
          FrmDB.LoadItemsDB();
          SysMsg('路劤속潼膠틔鑒앴욋냥묘...',c_Green,t_Hint);
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADSHOPITEMDB.sCmd) = 0 then begin  //환상점 리로드
          FrmDB.LoadShopItemList();
          SysMsg('路劤속潼鉗勍鮎례暄芙묘...',c_Green,t_Hint);
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADMAKEITEM.sCmd) = 0 then begin  //제조 리로드
          FrmDB.LoadMakeItemList;
          SysMsg('路劤속潼齡芚膠틔鑒앴냥묘...',c_Green,t_Hint);
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADFISHITEMDB.sCmd) = 0 then begin  //낚시 리로드
          FrmDB.LoadFishItemList();
          SysMsg('路劤속潼딥戴膠틔膠틔鑒앴냥묘...',c_Green,t_Hint);
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADMAGICDB.sCmd) = 0 then begin
          FrmDB.LoadMagicDB();
          SysMsg('路劤속潼세콘鑒앴욋냥묘...',c_Green,t_Hint);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADMONSTERDB.sCmd) = 0 then begin
          FrmDB.LoadMonsterDB();
          SysMsg('路劤속潼밍膠鑒앴욋냥묘...',c_Green,t_Hint);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.RELOADMINMAP.sCmd) = 0 then begin
          {$IFDEF UseTXT}
            FrmDB.LoadMinMap();
            g_MapManager.ReSetMinMap();
            SysMsg('路劤속潼鬼뒈暠鑒앴냥묘...',c_Green,t_Hint);
          {$ELSE}
            SysMsg('Minimaps Reloaded. (Not Added Yet)',c_Green,t_Hint);
          {$ENDIF}
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.RELOADBIGMAP.sCmd) = 0 then begin
          {$IFDEF UseTXT}
            FrmDB.LoadBigMap();
            g_MapManager.ReSetBigMap();
            SysMsg('路劤속潼댕뒈暠鑒앴냥묘...',c_Green,t_Hint);
          {$ELSE}
            SysMsg('Bigmaps Reloaded. (Not Added Yet)',c_Green,t_Hint);
          {$ENDIF}
          exit;
        end;

        if CompareText(sCMD,g_GameCommand.ADJUESTLEVEL.sCmd) = 0 then begin
          CmdAdjuestLevel(@g_GameCommand.ADJUESTLEVEL,sParam1,Str_ToInt(sParam2,1));
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADJUESTEXP.sCmd) = 0 then begin
          CmdAdjuestExp(@g_GameCommand.ADJUESTEXP,sParam1,sParam2);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADDGUILD.sCmd) = 0 then begin
          CmdAddGuild(@g_GameCommand.ADDGUILD,sParam1,sParam2);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.DELGUILD.sCmd) = 0 then begin
          CmdDelGuild(@g_GameCommand.DELGUILD,sParam1);
          exit;
        end;
        nError := 17;
        if (CompareText(sCMD,g_GameCommand.CHANGESABUKLORD.sCmd) = 0) then begin
          CmdChangeSabukLord(@g_GameCommand.CHANGESABUKLORD,sParam1,sParam2,True);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.FORCEDWALLCONQUESTWAR.sCmd) = 0 then begin
          CmdForcedWallconquestWar(@g_GameCommand.FORCEDWALLCONQUESTWAR,sParam1);
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADDTOITEMEVENT.sCmd) = 0 then begin
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ADDTOITEMEVENTASPIECES.sCmd) = 0 then begin
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.ITEMEVENTLIST.sCmd) = 0 then begin
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.STARTINGGIFTNO.sCmd) = 0 then begin
          exit;
        end;
        if CompareText(sCMD,g_GameCommand.DELETEALLITEMEVENT.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.STARTITEMEVENT.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.ITEMEVENTTERM.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.ADJUESTTESTLEVEL.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.OPDELETESKILL.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.CHANGEWEAPONDURA.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.RELOADGUILDALL.sCmd) = 0 then begin
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.SPIRIT.sCmd) = 0 then begin
          CmdSpirtStart(g_GameCommand.SPIRIT.sCmd,sParam1);
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.SPIRITSTOP.sCmd) = 0 then begin
          CmdSpirtStop(g_GameCommand.SPIRITSTOP.sCmd,sParam1);
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.TESTSERVERCONFIG.sCmd) = 0 then begin
          SendServerConfig();
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.SERVERSTATUS.sCmd) = 0 then begin
          SendServerStatus();
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.TESTGETBAGITEM.sCmd) = 0 then begin
          CmdTestGetBagItems(@g_GameCommand.TESTGETBAGITEM,sParam1);
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.MOBFIREBURN.sCmd) = 0 then begin
          CmdMobFireBurn(@g_GameCommand.MOBFIREBURN,sParam1,sParam2,sParam3,sParam4,sParam5,sParam6);
          exit;
        end else
        if CompareText(sCMD,g_GameCommand.TESTSPEEDMODE.sCmd) = 0 then begin
          CmdTestSpeedMode(@g_GameCommand.TESTSPEEDMODE);
          exit;
        end;
      end;
    end;
  //  SysMsg('@' + sCMD + '는 없는 명령어 입니다..',c_Red,t_Hint);
except
  on e: Exception do begin
    MainOutMessage(format(sExceptionMsg,[sData, nError]));
    MainOutMessage(E.Message);
  end;
end;
end;
// else begin//004D4D8B


function TPlayObject.GetItemInfo(str: string): string;
var
  nC: Integer;
  s10: string;
  tempstr: string;
  i: integer;
  UserItem: pTUserItem;
  nmode, ItemIndex: Integer;
  ItemIdx: Integer;
  StdItem:TItem;
  ItemStr,mode, sName,sident: string;
begin
  nC := 0;
  tempstr := str;
  nmode := 0;
  Result := str;
  while (True) do begin
    if TagCount(tempstr, '}') < 1 then
      break;
    tempstr := ArrestStringEx(tempstr, '{', '}', s10);
    s10 := GetValidStr3(s10, mode, ['/']);

    nmode := StrToInt(mode);
    ItemIndex := StrToIntDef(s10, -1);

    ItemStr := '';
    if ItemIndex > 0 then begin
      if nmode = 0 then begin
        for i := 0 to m_ItemList.Count - 1 do begin
          UserItem := m_ItemList.Items[i];
          if (UserItem <> nil) and (UserItem.MakeIndex = ItemIndex) then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          ItemIdx := SetSayItem(UserItem);
          ItemStr := '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(ItemIndex) + '}';
          break;
          end;
        end;
      end;
      if nmode = 1 then begin
        for I := Low(THumanUseItems) to High(THumanUseItems) do begin
          UserItem := @m_UseItems[I];
          if (UserItem.wIndex > 0) and (UserItem.MakeIndex = ItemIndex) then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            ItemIdx := SetSayItem(UserItem);
            ItemStr := '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(ItemIndex) + '}';
            Break;
          end;
        end;
      end;
      if nmode = 2 then begin
        for I := 0 to m_StorageItemList.Count - 1 do begin
          UserItem := m_StorageItemList.Items[I];
          if (UserItem.wIndex > 0) and (UserItem.MakeIndex = ItemIndex) then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            ItemIdx := SetSayItem(UserItem);
            ItemStr := '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(ItemIndex) + '}';
            Break;
          end;
        end;
      end;
      if nmode = 3 then begin
        if m_MyHero <> nil then begin
          for I := 0 to m_MyHero.m_StorageItemList.Count - 1 do begin
            UserItem := m_MyHero.m_StorageItemList.Items[I];
            if (UserItem.wIndex > 0) and (UserItem.MakeIndex = ItemIndex) then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              ItemIdx := SetSayItem(UserItem);
              ItemStr := '{' + IntToStr(ItemIdx) + '/' + IntToStr(UserItem.wIndex) + '/' + UserEngine.GetStdItemName(UserItem.wIndex) + '/' + IntToStr(ItemIndex) + '}';
              Break;
            end;
          end;
        end;
      end;
      Result := AnsiReplaceText(Result, '{' + mode + '/' + s10 + '}', ItemStr);
    end;
    Inc(nC);
    if nC >= 4 then break;
  end;
end;
procedure TPlayObject.ProcessSayMsg(sData:String);
var
  boDisableSayMsg:Boolean;
  sC,sCryCryMsg,sParam1:String;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject.ProcessSayMsg Msg = %s';
begin
  try
    if length(sData) > g_Config.nSayMsgMaxLen then begin
      sData:=Copy(sData,1,g_Config.nSayMsgMaxLen);
    end;

    if ((GetTickCount - m_dwSayMsgTick) < g_Config.dwSayMsgTime{3 * 1000}) then begin
      Inc(m_nSayMsgCount);
      if m_nSayMsgCount >= g_Config.nSayMsgCount{2} then begin
        m_boDisableSayMsg:=True;
        m_dwDisableSayMsgTick:=GetTickCount + g_Config.dwDisableSayMsgTime{30 * 1000};
        SysMsg(format(g_sDisableSayMsg,[g_Config.dwDisableSayMsgTime div 1000]),c_Red,t_Hint);
      end;
    end else begin  //004D4DF6
      m_dwSayMsgTick:=GetTickCount();
      m_nSayMsgCount:=0;
    end;


    if GetTickCount >= m_dwDisableSayMsgTick  then m_boDisableSayMsg:=False;
    boDisableSayMsg:=m_boDisableSayMsg;
    g_DenySayMsgList.Lock;
    try
      if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then boDisableSayMsg:=True;
    finally
      g_DenySayMsgList.UnLock;
    end;

    if not (boDisableSayMsg or m_PEnvir.Flag.boNOCHAT) then begin


      m_sOldSayMsg:=sData;
      if sData[1] = '/' then begin
        sC:=Copy(sData,2,length(sData) - 1);
        if CompareText(Trim(sC),Trim(g_GameCommand.WHO.sCmd)) = 0 then begin
          if (m_btPermission < g_GameCommand.WHO.nPermissionMin) then begin
          //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
            exit;
          end;
          HearMsg(format(g_sOnlineCountMsg,[UserEngine.PlayObjectCount, UserEngine.HeroObjectCount]));
          exit;
        end; //004D4F03
        if CompareText(Trim(sC),Trim(g_GameCommand.TOTAL.sCmd)) = 0 then begin
          if (m_btPermission < g_GameCommand.TOTAL.nPermissionMin) then begin
          //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
            exit;
          end;
          HearMsg(format(g_sTotalOnlineCountMsg,[g_nTotalHumCount]));
          exit;
        end ;  //004D4F5B
        sC:=GetValidStr3(sC,sParam1,[' ']);
        if not m_boFilterSendMsg then
          Whisper(sParam1, GetItemInfo(SC)); //降좔
          UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [降좔] ' + m_sCharName + ': ' +sData, 2);  //귓속말  //채팅시스템
         // Whisper(sParam1,sC);        //ProcessSayMsg
        exit;
      end;

      if sData[1] = '!' then begin
        if length(sData) >= 2 then begin
          if (sData[2] = '%') and (sData[3] = '*') and m_boStore then begin   //개인상점 외치기
            sC:=Copy(sData,4,length(sData) - 3);
            sCryCryMsg:='(絹 )' + m_sCharName + ': ' + GetItemInfo(SC) + ' [ 貫零 ' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ' ]';
            UserEngine.StoreCry(RM_CRY,m_PEnvir,m_nCurrX,m_nCurrY,100,0,116,sCryCryMsg);
            UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [絹 ] ' + m_sCharName + ': ' +sData, 3);  //상점  //채팅시스템
            exit;
          end;
          if sData[2] = '!' then begin   //그룹 메세지
            sC:=Copy(sData,3,length(sData) - 2);
            SendGroupText(m_sCharName + #9 + GetItemInfo(SC));
            UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [莉뚠] ' + m_sCharName + ': ' +sData, 4);  //그룹     //채팅시스템
            exit;
          end;
          if sData[2] = '~' then begin        //문파채팅 메세지
            if m_MyGuild <> nil then begin
              sC:=Copy(sData,3,length(sData) - 2);
              TGuild(m_MyGuild).SendGuildMsg(m_sCharName + #9 + GetItemInfo(SC));
              UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [契삔] (' + TGuild(m_MyGuild).sGuildName + ') ' + m_sCharName + ': ' +sData, 5);  //문파    //채팅시스템
              UserEngine.SendServerGroupMsg(SS_208,nServerIndex,TGuild(m_MyGuild).sGuildName + '/' + m_sCharName + '/' +sC);
            end;
            exit;
          end;
          if sData[2] = '@' then begin        //문파채팅 동맹 메세지
            if m_MyGuild <> nil then begin
              sC:=Copy(sData,3,length(sData) - 2);
              TGuild(m_MyGuild).SendAillyGuildMsg(m_sCharName + #9 +'('+ TGuild(m_MyGuild).sGuildName + ')' + ': ' + GetItemInfo(SC));
              UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [젬촉] ('+ TGuild(m_MyGuild).sGuildName + ')' + m_sCharName + ': ' +sData, 6);  //동맹   //채팅시스템
            end;
            exit;
          end;
        end; //004D512C
        if not m_PEnvir.Flag.boQUIZ then begin   //외치기
          if (GetTickCount - m_dwShoutMsgTick) > 10 * 1000 then begin   //외치기 딜레이
            if m_Abil.Level <= g_Config.nCanShoutMsgLevel then begin
              SysMsg(format(g_sYouNeedLevelMsg,[g_Config.nCanShoutMsgLevel + 1]),c_Red,t_Hint);
              exit;
            end else begin
              // 문주 장원내 공지(sonmg)
              UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [별뺐] ' + m_sCharName + ': ' +sData, 7);  //외치기   //채팅시스템
              if IsMyGuildMaster then begin     //장원 외치기
                sC:=Copy(sData,2,length(sData) -1);
                sCryCryMsg:={'(!)' +} m_sCharName + #9 + GetItemInfo(SC);
                UserEngine.GuildAgitCry (RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50, sCryCryMsg);   //장원 외치기
                exit;
              end else begin
                m_dwShoutMsgTick:=GetTickCount();        //외치기 딜레이
                sC:=Copy(sData,2,length(sData) -1);
                if m_PEnvir.Flag.boDEATHMATCH then
                  sCryCryMsg:={'(!)' + }'엄떱' + ': ' + GetItemInfo(SC)
                else
                if m_PEnvir.Flag.boPKZONE then
                  sCryCryMsg:={'(!)' + }'PKZONE' + ': ' + GetItemInfo(SC)
                else
                sCryCryMsg:={'(!)' +} m_sCharName + #9 + GetItemInfo(SC);
                if m_boFilterSendMsg then begin
                  SendMsg(nil,RM_CRY,0,0,$FFFF,0,sCryCryMsg);
                end else begin
                  UserEngine.CryCry(RM_CRY,m_PEnvir,m_nCurrX,m_nCurrY,50,g_Config.btCryMsgFColor,g_Config.btCryMsgBColor,sCryCryMsg);
                end;
                exit;
              end;
            end;
          end else begin
            SysMsg(format(g_sYouCanSendCyCyLaterMsg,[10 - (GetTickCount - m_dwShoutMsgTick) div 1000]),c_Red,t_Hint);
          end;
        end else
        SysMsg(g_sThisMapDisableSendCyCyMsg,c_Red,t_Hint);
        exit;
      end else begin
        if CompareLStr(sData, '♡', 2) then begin  //연인 메세지
               //연인이 있는 사람만...
           if fLover.GetLoverName <> '' then begin
              sC:=Copy(sData,3,length(sData) -2);
              LoverWhisper (fLover.GetLoverName, GetItemInfo(SC));  //연인 귓속말
              UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [뤼펄] ' + m_sCharName + ': ' +sData, 8);  //연인   //채팅시스템
              exit;
           end;
        end;

        if CompareLStr(sData, '◎', 2) then begin  //사제 메세지
               //연인이 있는 사람만...
           if fMentor.GetMentorName <> '' then begin
              sC:=Copy(sData,3,length(sData) -2);
              MasterWhisper (fMentor.GetMentorName, GetItemInfo(SC));  //사제 귓속말
              UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [可] ' + m_sCharName + ': ' +sData, 9);  //사제  //채팅시스템
              exit;
           end;
        end;
      end;
      UserEngine.AddUserChat('['+DateTimeToStr(Now)+'] ' + ' [寧겹] ' + m_sCharName + ': ' +sData, 0);  //일반    //채팅시스템
      if m_boFilterSendMsg then begin
        SendMsg(Self,RM_HEAR,0,g_Config.btHearMsgFColor,g_Config.btHearMsgBColor,0,m_sCharName + #9 + GetItemInfo(sData));
      end else begin
        inherited ProcessSayMsg (GetItemInfo(sData));  //20110713
      end;
      exit;
    end;
    SysMsg(g_sYouIsDisableSendMsg{'Chat ban'},c_Red,t_Hint);
except
  on e: Exception do begin
    MainOutMessage(format(sExceptionMsg,[sData]));
    MainOutMessage(E.Message);
  end;
end;
end;

function TPlayObject.ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; TargeTBaseObject: TBaseObject): Boolean; //004CB7F8
var
  n14,n18:Integer;
  StdItem:TItem;
begin
  Result:=False;
  if not m_boCanHit then exit;      //공격 딜레이
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_Config.ClientConf.boParalyCanHit) then exit;//렝쮸

    if (nX = m_nCurrX) and (nY = m_nCurrY) then begin
      Result:=True;
      if (wIdent = CM_HEAVYHIT) and (m_UseItems[U_WEAPON].Dura > 0) then begin//광산 곡괭이 모션
        if GetFrontPosition(n14,n18) and not m_PEnvir.CanWalk(n14,n18,False) then begin   //앞이 막혔음
          StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
          if (StdItem <> nil) and (StdItem.Shape = 19)then begin       //곡괭이 광산
            if PileStones(n14,n18) then SendSocket(nil,'=DIG');   //광산
            Dec(m_nHealthTick,30);
            Dec(m_nSpellTick,50);
            m_nSpellTick:=_MAX(0,m_nSpellTick);
            Dec(m_nPerHealth,2);
            Dec(m_nPerSpell,2);
            exit;
          end;
        end;
      end;

      if wIdent = CM_FISHING1 then begin
        m_wStatusTimeArr[STATE_FISHING]:=60000;   //낚시 중
        m_nCharStatus:=GetCharStatus();
        StatusChanged();
        ClienFishItemDuraChange;
        FeatureChanged();
        if not ClienFishItemCheck then begin
          SysMsg('戴窟뵨戴뭄돨넣씹槨0，콱꼇콘賈痰딥戴묘콘。',c_Red,t_Hint);
          SendDefMessage(SM_FISHCANCEL,0,0,0,0,'');
        end;
      end;
      if wIdent = CM_FISHING2 then begin
        m_wStatusTimeArr[STATE_FISHING]:= 0;   //낚시 중 끝냄
        m_nCharStatus:=GetCharStatus();
        StatusChanged();
        FeatureChanged();
      end;


      if wIdent = CM_HITLEFT  then AttackDir(nil,0,nDir);    //왼쪽
      if wIdent = CM_HIT      then AttackDir(nil,1,nDir);
      if wIdent = CM_HEAVYHIT then AttackDir(nil,2,nDir);
      if wIdent = CM_BIGHIT   then AttackDir(nil,3,nDir);
      if wIdent = CM_LONGHIT  then AttackDir(nil,4,nDir);
      if wIdent = CM_WIDEHIT  then AttackDir(nil,5,nDir);
      if wIdent = CM_POWERHIT then AttackDir(nil,6,nDir);    //예도검법
      if wIdent = CM_FIREHIT  then AttackDir(nil,7,nDir);
      if wIdent = CM_CRSHIT   then AttackDir(nil,8,nDir);    //광풍참
      if wIdent = CM_TWINHIT  then AttackDir(nil,9,nDir);
      if wIdent = CM_DEATHHIT then AttackDir(nil,10,nDir);   //살생도
      if wIdent = CM_BALDO2   then AttackDir(nil,13,nDir);   //발도술
      if wIdent = CM_WBHIT    then AttackDir(nil,15,nDir);   //풍검술
      if wIdent = CM_BALDO    then AttackDir(nil,17,nDir);   //발도술
      if wIdent = CM_WBHIT2   then AttackDir(nil,18,nDir);   //풍검술
      if wIdent = CM_FISHING1 then AttackDir(nil,20,nDir);   //낚시 시작
      if wIdent = CM_FISHING2 then AttackDir(nil,21,nDir);   //낚시 끝
      if wIdent = CM_CPOWERHIT then AttackDir(nil, 22, nDir);
      if wIdent = CM_CFIREHIT  then AttackDir(nil, 23, nDir);
      if wIdent = CM_TAGUHIT  then AttackDir(nil,25,nDir);    //타구봉법 - 승려
      if wIdent = CM_THUNDERHIT  then AttackDir(nil,26,nDir);    //뇌룡봉법 - 승려
      if wIdent = CM_FIRESHAOLIN  then AttackDir(nil,27,nDir);   //천화봉법 - 승려
      if wIdent = CM_CRBHIT  then AttackDir(nil,28,nDir);   //회풍천봉법 - 승려
      if wIdent = CM_NANCRSHIT  then AttackDir(nil,29,nDir);   //난화혈풍참 - 전사

      if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0) then begin
        Dec(m_btAttackSkillCount);
        if m_btAttackSkillPointCount = m_btAttackSkillCount then begin
          m_boPowerHit:=True;
          SendSocket(nil,'+PWR');
        end;
        if m_btAttackSkillCount <= 0 then begin
          m_btAttackSkillCount:=7 - m_MagicPowerHitSkill.btLevel;
          m_btAttackSkillPointCount:=Random(m_btAttackSkillCount);
        end;
      end;
      if (m_AssassinHitSkill <> nil) then begin
        Dec(m_btAssassinHitCount);
        if m_btAssassinHitPointCount = m_btAssassinHitCount then m_boAssassinHit := True;
        if m_btAssassinHitCount <= 0 then begin
          m_btAssassinHitCount := 7 + Random(11) - m_AssassinHitSkill.btLevel;
          m_btAssassinHitPointCount := Random(m_btAssassinHitCount);
        end;
      end;
      if (m_MagicVampSkill <> nil) then begin
        Dec(m_btManaEaterCount);
        if m_btManaEaterPointCount = m_btManaEaterCount then m_boManaEater := True;
        if m_btManaEaterCount <= 0 then begin
          m_btManaEaterCount := 9  + Random(15) - m_MagicVampSkill.btLevel;
          m_btManaEaterPointCount := Random(m_btManaEaterCount);
        end;
      end;
      if (m_MagicHemorrhageSkill <> nil) then begin
        Dec(m_btHemorrhageCount);
        if m_btHemorrhagePointCount = m_btHemorrhageCount then m_boHemorrhage := True;
        if m_btHemorrhageCount <= 0 then begin
          m_btHemorrhageCount := 7 + Random(15) - m_MagicHemorrhageSkill.btLevel;
          m_btHemorrhagePointCount := Random(m_btHemorrhageCount);
        end;
      end;

      Dec(m_nHealthTick,30);
      Dec(m_nSpellTick,100);
      m_nSpellTick:=_MAX(0,m_nSpellTick);
      Dec(m_nPerHealth,2);
      Dec(m_nPerSpell,2);  //004CBB62
      m_boSunchunUse := False;
   end;

end;




function TPlayObject.ClientHorseRunXY(wIdent: Word; nX, nY: Integer): Boolean;
var
  n14:Integer;
  allowdup: Boolean;
  Castle:TUserCastle;
begin
  Result:=False;


  if not m_boCanRun then exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) and not g_Config.ClientConf.boParalyCanRun) then exit;//렝쮸

    m_bo316:=False;
    n14:=GetNextDirection(m_nCurrX,m_nCurrY,nX,nY);

    allowdup := TRUE;  //평상시에는 뛸때 겹칠 수 있음
    Castle:=g_CastleManager.InCastleWarArea(Self);
    if ((Castle <> nil) and Castle.m_boUnderWar)  then begin  //공성전 중인 경우
       if m_boInFreePKArea then //프리피케이존(전쟁터)에 있음, 공성 지역에 있음
          allowdup := FALSE;  //공성전 지역에서는 겹칠 수 없음
    end;

    if HorseRunTo(n14,allowdup) then begin
      if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;

      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result:=True;
      Dec(m_nHealthTick,60);
      Dec(m_nSpellTick,10);
      m_nSpellTick:=_MAX(0,m_nSpellTick);
      Dec(m_nPerHealth);
      Dec(m_nPerSpell);
      m_dwTigerTick := GetTickCount;
      m_boSunchunUse := False;
    end else begin
      WalkTimeOverCount := 0;
      WalkTimeOverSum := 0;
    end;
end;


function TPlayObject.ClientSpellXY(wIdent:Word;nKey:Integer;nTargetX, nTargetY:Integer;TargeTBaseObject: TBaseObject): Boolean;//004CBCEC
  function CheckWeapon():Boolean;  //체크
  var
    AmuletStdItem:TItem;
  begin
    Result:=False;
    if self.m_UseItems[U_WEAPON].wIndex > 0 then begin
      AmuletStdItem:=UserEngine.GetStdItem(self.m_UseItems[U_WEAPON].wIndex);
      if (AmuletStdItem <> nil) and ((AmuletStdItem.StdMode = 99)) then Result:=True;
    end;
  end;
var
  UserMagic     :pTUserMagic;
  nSpellPoint   :Integer;
  nPower, n14   :Integer;
  BaseObject    :TBaseObject;
begin
  Result:=False;
  if not m_boCanSpell then exit;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE] <> 0) or (m_wStatusTimeArr[POISON_FREEZE] <> 0) or
      ((m_wStatusTimeArr[POISON_STUN] <> 0) and not g_Config.ClientConf.boParalyCanSpell) then exit;

    m_boSunchunUse := False;
    if GetTickCount - m_dwMagicAttackTick > longword(m_dwMagicAttackInterval) then
      m_dwMagicAttackCount := 0
    else inc(m_dwMagicAttackCount);

    if m_dwMagicAttackCount < 2 then begin
      UserMagic := nil;
      Dec(m_nSpellTick,450);
      m_nSpellTick:=_MAX(0,m_nSpellTick);

      UserMagic:=GetMagicInfo(nKey);
      if UserMagic <> nil then begin

      if (m_btRaceServer = RC_PLAYOBJECT) and (m_PEnvir.m_boNOTALLOWMAGIC) then begin    //사용금지2
        if not m_PEnvir.AllowMagic(UserMagic.MagicInfo.sMagicName) then begin
          SysMsg('뎠품뒈暠꼇콘賈痰' + UserMagic.MagicInfo.sMagicName + '。', c_red, t_hint);
          exit;
        end;
      end;                                    //딜레이
      if MagicManager.IsWarrSkill(UserMagic.wMagIdx) then
        m_dwMagicAttackInterval := 0
      else
        m_dwMagicAttackInterval := UserMagic.MagicInfo.dwDelayTime + 500;
      m_dwMagicAttackTick := GetTickCount;

      if (UserMagic.wMagIdx = SKILL_WINDBLADE) then begin   //풍검술
        if not checkweapon then begin  //자객 무기 없음
           exit;
        end;
      end;
      if  (UserMagic.wMagIdx = SKILL_BALDO{62}) then begin  //,발도술
        if not checkweapon then begin  //자객 무기 없음
           exit;
        end;
      end;
      if  (UserMagic.wMagIdx = SKILL_FINALBUN{88}) then begin  //일격비
        if not checkweapon then begin  //자객 무기 없음
           exit;
        end;
      end;

      if m_wStatusTimeArr[STATE_PENETRATE] > 0 then    //망자의옷
        m_wStatusTimeArr[STATE_PENETRATE]:=1;

      case UserMagic.wMagIdx of
        SKILL_ERGUM{12}: begin  //어검술
          if m_MagicErgumSkill <> nil then begin
            if not m_boUseThrusting then begin
              ThrustingOnOff(True);
              SendSocket(nil,'+LNG');
            end else begin
              ThrustingOnOff(False);
              SendSocket(nil,'+ULNG');
            end;
          end;
          Result:=True;
        end;
        SKILL_TAGUBONG{114}: begin  //타구봉법 - 승려
          if m_MagicTaguSkill <> nil then begin
            if not m_boUseTagu then begin
              if m_boCrsBongHitkill then begin   //회풍천봉법 꺼주자
                SkillCrsBongOnOff(False);
                SendSocket(nil,'+UCRBS');
              end;
              TaguOnOff(True);
              SendSocket(nil,'+TAGU');
            end else begin
              TaguOnOff(False);
              SendSocket(nil,'+UTAGU');
            end;
          end;
          Result:=True;
        end;

        SKILL_BANWOL{25}: begin //반월검법
          if m_MagicBanwolSkill <> nil then begin
            if not m_boUseHalfMoon then begin
              if m_boCrsHitkill then begin
                 SkillCrsOnOff(False);
                 SendSocket(nil,'+UCRS');
              end;
              if m_boNanCrsHitkill then begin
                 SkillNanCrsOnOff(False);
                 SendSocket(nil,'+UNCRS');
              end;
              HalfMoonOnOff(True);
              SendSocket(nil,'+WID');
            end else begin
              HalfMoonOnOff(False);
              SendSocket(nil,'+UWID');
            end;
          end;
          Result:=True;
        end;
        SKILL_FIRESWORD{26}: begin //염화결
          if m_MagicFireSwordSkill <> nil then begin
            if AllowFireHitSkill then begin
              nSpellPoint:=GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil,'+FIR');
              end else
                 ;
            end;
            Result:=True;
          end;
        end;

        SKILL_DEATHHIT{110}: begin //살생도
          if m_MagicDeathSwordSkill <> nil then begin
            if AllowDeathHitSkill then begin
              nSpellPoint:=GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil,'+DEA');
              end else
                 ;
            end;
            Result:=True;
          end;
        end;

        SKILL_MOOTEBO{27}: begin //무태보
          Result:=True;
          if (GetTickCount - m_dwDoMotaeboTick) > 3 * 1000 then begin
            m_dwDoMotaeboTick:=GetTickCount();
            m_btDirection:=nTargetX;
            nSpellPoint:=GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if nSpellPoint > 0 then begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              if DoMotaebo(m_btDirection,UserMagic.btLevel) then begin
                if UserMagic.btLevel < 3 then begin
                  if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then begin
                    TrainSkill(UserMagic,Random(3) + 1);
                    if not CheckMagicLevelup(UserMagic) then begin

                      SendDelayMsg(Self,
                                   RM_MAGIC_LVEXP,
                                   0,
                                   UserMagic.MagicInfo.wMagicId,
                                   UserMagic.btLevel,
                                   UserMagic.nTranPoint,
                                   '',1000);
                    end;
                  end;
                end;
              end;
            end;
          end; //004CC1B5
        end;

        SKILL_CROSSMOON: begin  //광풍참
          if m_MagicCrsSkill <> nil then begin
            if not m_boCrsHitkill then begin
              if m_boUseHalfMoon then begin
                HalfMoonOnOff(False);
                SendSocket(nil,'+UWID');
              end;
              if m_boNanCrsHitkill then begin
                 SkillNanCrsOnOff(False);
                 SendSocket(nil,'+UNCRS');
              end;
              SkillCrsOnOff(True);
              SendSocket(nil,'+CRS');
            end else begin
              SkillCrsOnOff(False);
              SendSocket(nil,'+UCRS');
            end;
          end;
          Result:=True;
        end;

        SKILL_NANHWA{131}: begin   //난화혈풍참
          if m_MagicNanCrsSkill <> nil then begin
            if not m_boNanCrsHitkill then begin
              if m_boUseHalfMoon then begin
                HalfMoonOnOff(False);
                SendSocket(nil,'+UWID');
              end;
              if m_boCrsHitkill then begin
                 SkillCrsOnOff(False);
                 SendSocket(nil,'+UCRS');
              end;
              SkillNanCrsOnOff(True);
              SendSocket(nil,'+NCRS');
            end else begin
              SkillNanCrsOnOff(False);
              SendSocket(nil,'+UNCRS');
            end;
          end;
          Result:=True;
        end;

        SKILL_CROSSBONG: begin  //회풍천봉법
          if m_MagicCrsBongskill <> nil then begin
            if not m_boCrsBongHitkill then begin
              if m_boUseTagu then begin   //타구봉법 꺼주자
                TaguOnOff(False);
                SendSocket(nil,'+UTAGU');
              end;
              SkillCrsBongOnOff(True);
              SendSocket(nil,'+CRBS');
            end else begin
              SkillCrsBongOnOff(False);
              SendSocket(nil,'+UCRBS');
            end;
          end;
          Result:=True;
        end;


        SKILL_TWINBLADE:{38} begin  //쌍룡참
          if m_MagicTwnHitSkill <> nil then begin
            if AllowTwinHitSkill then begin
              nSpellPoint:=GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil,'+TWN');
              end else
                 ;
            end;
            Result:=True;
          end;
        end;

        SKILL_THUNDERSHAILIN{117}: begin  //뇌룡봉법
          if m_MagicThunderShaolin <> nil then begin
            if AllowThunderHitSkill then begin
              nSpellPoint:=GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil,'+THWN');
              end else
                 ;
            end;
            Result:=True;
          end;
        end;

        SKILL_FIRESHAOLIN{119}: begin  //천화봉법
          if m_MagicFireShaolin <> nil then begin
            if AllowFireShaolinSkill then begin
              nSpellPoint:=GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil,'+FIWN');
              end else
                 ;
            end;
            Result:=True;
          end;
        end;

        SKILL_BALDO: begin  //발도술
         Result:=True;
         m_btDirection:=nTargetX;
         nSpellPoint:=GetSpellPoint(UserMagic);
         if m_WAbil.MP >= nSpellPoint then begin
            if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
            end;
            if DoBaldo(m_btDirection,UserMagic) then begin
               if UserMagic.btLevel < 3 then begin
                  if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then begin
                    TrainSkill(UserMagic,Random(3) + 1);
                    if not CheckMagicLevelup(UserMagic) then begin
                      SendDelayMsg(Self,
                                   RM_MAGIC_LVEXP,
                                   0,
                                   UserMagic.MagicInfo.wMagicId,
                                   UserMagic.btLevel,
                                   UserMagic.nTranPoint,
                                   '',1000);
                    end;
                  end;
               end;
            end;
         end;
         Result:=True;
        end;

        SKILL_CHENMU: begin   //천무
          if m_MagicChunMuSkill <> nil then begin
            nSpellPoint:=GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then begin
              if AllowChunMuSkill(m_MagicChunMuSkill) then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                case UserMagic.btLevel of
                  0 : begin nPower := 11; n14 := 6; end;
                  1 : begin nPower := 14; n14 := 7; end;
                  2 : begin nPower := 17; n14 := 8; end;
                  3 : begin nPower := 20; n14 := 9; end;
                end;
                ChenMuUp(nPower, n14, 25 - m_MagicChunMuSkill.btLevel );
              end;
            end else
                ;
            Result := True;
          end;
        end;

        SKILL_WINDBLADE{60}: begin //풍검술
          if m_MagicWindbladeSkill <> nil then begin
            if not m_boUseWindblade then begin
              WindbladeOnOff(True);
              SendSocket(nil,'+WB');
            end else begin
              WindbladeOnOff(False);
              SendSocket(nil,'+UWB');
            end;
          end;
          Result:=True;
        end;

        SKILL_BLASTHIT: begin //참진격
          Result := True;
          m_btDirection := nTargetX;
          nSpellPoint := GetSpellPoint(UserMagic);
          if m_WAbil.MP >= nSpellPoint then begin
            if nSpellPoint > 0 then begin
              DamageSpell(nSpellPoint);
              HealthSpellChanged();
            end;
            if BlastMotaebo(m_btDirection, UserMagic) then begin
              if UserMagic.btLevel < 3 then begin
                if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then begin
                  TrainSkill(UserMagic, Random(3) + 1);
                  if not CheckMagicLevelup(UserMagic) then begin

                    SendDelayMsg(Self,
                      RM_MAGIC_LVEXP,
                      0,
                      UserMagic.MagicInfo.wMagicId,
                      UserMagic.btLevel,
                      UserMagic.nTranPoint,
                      '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end;

        SKILL_FINALBUN{88}: begin  //일격비
           Result:=True;
           m_btDirection:=nTargetX;
           if GetTickCount - m_DontEatTick > UserMagic.MagicInfo.dwUseDelayTime * 1000 then begin
             if (m_WAbil.HP >= (m_WAbil.MaxHP div 3)) then begin
               if FinalBun(m_btDirection,UserMagic.btLevel) then begin
                 m_DontEatTick:= GetTickCount();
                 if UserMagic.btLevel < 3 then begin
                    if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then begin
                      TrainSkill(UserMagic,Random(3) + 1);
                      if not CheckMagicLevelup(UserMagic) then begin
                        SendDelayMsg(Self,
                                   RM_MAGIC_LVEXP,
                                   0,
                                   UserMagic.MagicInfo.wMagicId,
                                   UserMagic.btLevel,
                                   UserMagic.nTranPoint,
                                   '',1000);
                      end;
                    end;
                 end;
                 m_WAbil.HP := 1;
                 m_WAbil.MP := 1;
                 HealthSpellChanged();
               end;
             end else begin
               SysMsg('휑샌莖矜狼돨廬폭꼇璃，헝쀼릿廬폭瞳賈痰。',c_RedWhite,t_Hint);
             end;
           end else begin
            SysMsg(IntToStr(UserMagic.MagicInfo.dwUseDelayTime - (GetTickCount - m_DontEatTick) div 1000) + '취빈옵鹿瞳疼늴賈痰。',c_Green,t_Hint);
           end;
           Result:=True;
        end;

        else begin

          n14:=GetNextDirection(m_nCurrX,m_nCurrY,nTargetX,nTargetY);
          m_btDirection:=n14;
          BaseObject:=nil;
          if CretInNearXY(TargeTBaseObject,nTargetX,nTargetY) then begin
            BaseObject:=TargeTBaseObject;
            nTargetX:=BaseObject.m_nCurrX;
            nTargetY:=BaseObject.m_nCurrY;
          end;

          if not DoSpell(UserMagic,nTargetX,nTargetY,BaseObject) then begin
            SendRefMsg(RM_MAGICFIREFAIL,0,0,0,0,'');
          end;
          Result:=True;
        end;
      end;

     end;
    end else begin
      UserMagic :=  GetMagicInfo(nKey);
      if UserMagic <> nil then begin        //딜레이
        if  MagicManager.IsWarrSkill(UserMagic.wMagIdx) then begin
           m_dwMagicAttackCount := 0 ;
           exit;
        end;
      end;
      m_dwMagicAttackTick := GetTickCount;

    {  Inc (m_nOverSpeedCount);
      if m_nOverSpeedCount > 8 then
         M_boEmergencyClose := TRUE;

      if g_Config.boViewHackMessage then
         MainOutMessage ('[스피드핵 마법] ' + IntToStr(m_nOverSpeedCount) + '  ' + m_sCharName + ' ' + TimeToStr(Time));  }
    end;
end;


function TPlayObject.ClientBowXY(wIdent:Word;nKey:Integer;nTargetX, nTargetY:Integer;TargeTBaseObject: TBaseObject): Boolean;//004CBCEC
var
  UserMagic     :pTUserMagic;
  nSpellPoint   :Integer;
  nPower, n14   :Integer;
  BaseObject    :TBaseObject;
  Magic:pTMagic;
begin
  Result:=False;
  if not m_boCanHit then exit;      //공격 딜레이
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE] <> 0) or (m_wStatusTimeArr[POISON_FREEZE] <> 0) or
    ((m_wStatusTimeArr[POISON_STUN] <> 0) and not g_Config.ClientConf.boParalyCanSpell) then exit;

  Magic:=UserEngine.FindMagic(13);

  n14:=GetNextDirection(m_nCurrX,m_nCurrY,nTargetX,nTargetY);
  m_btDirection:=n14;
  BaseObject:=nil;
  if CretInNearXY(TargeTBaseObject,nTargetX,nTargetY) then begin
    BaseObject:=TargeTBaseObject;
    nTargetX:=BaseObject.m_nCurrX;
    nTargetY:=BaseObject.m_nCurrY;
  end;

  New(UserMagic);
  UserMagic.MagicInfo:=Magic;
  UserMagic.wMagIdx:=Magic.wMagicId;
  UserMagic.btLevel:=3;
  UserMagic.btKey:=0;
  UserMagic.nTranPoint:=0;

  if not DoSpell(UserMagic,nTargetX,nTargetY,BaseObject) then begin
    SendRefMsg(RM_MAGICFIREFAIL,0,0,0,0,'');
  end;
  Result:=True;

  Dec(m_nHealthTick,30);
  Dec(m_nSpellTick,100);
  m_nSpellTick:=_MAX(0,m_nSpellTick);
  Dec(m_nPerHealth,2);
  Dec(m_nPerSpell,2);  //004CBB62
  m_boSunchunUse := False;
end;

//004C42C0
function TBaseObject.RunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer): Boolean;
var
  nOldX,nOldY:Integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::RunTo';
begin
  Result:=False;
  try
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    m_btDirection:=btDir;
    case btDir of
      DR_UP: begin
        if (m_nCurrY > 1) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY -2,True) > 0)then begin

          Dec(m_nCurrY,2);
        end;
      end;
      DR_UPRIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -2) and
           (m_nCurrY > 1) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 2,m_nCurrY -2,True) > 0)then begin

          Inc(m_nCurrX,2);
          Dec(m_nCurrY,2);
        end;
      end;
      DR_RIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -2) and
           (m_PEnvir.CanWalk(m_nCurrX + 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX + 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 2,m_nCurrY,True) > 0)then begin

          Inc(m_nCurrX,2);
        end;
      end;
      DR_DOWNRIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
           (m_nCurrY < m_PEnvir.m_nHeight -2) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 2,m_nCurrY +2,True) > 0)then begin

          Inc(m_nCurrX,2);
          Inc(m_nCurrY,2);
        end;
      end;
      DR_DOWN: begin
        if (m_nCurrY < m_PEnvir.m_nHeight -2) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY +2,True) > 0)then begin

          Inc(m_nCurrY,2);
        end;
      end;
      DR_DOWNLEFT: begin
        if (m_nCurrX > 1) and
           (m_nCurrY < m_PEnvir.m_nHeight -2) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 2,m_nCurrY +2,True) > 0)then begin

          Dec(m_nCurrX,2);
          Inc(m_nCurrY,2);
        end;      
      end;
      DR_LEFT: begin
        if (m_nCurrX > 1) and
           (m_PEnvir.CanWalk(m_nCurrX - 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX - 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 2,m_nCurrY,True) > 0)then begin

          Dec(m_nCurrX,2);
        end;
      end;
      DR_UPLEFT: begin
        if (m_nCurrX > 1) and
           (m_nCurrY > 1) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 2,m_nCurrY -2,True) > 0)then begin

          Dec(m_nCurrX,2);
          Dec(m_nCurrY,2);
        end;
      end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) then begin
      if Walk(RM_RUN) then Result:=True
      else begin
        m_nCurrX:=nOldX;
        m_nCurrY:=nOldY;
        m_PEnvir.MoveToMovingObject(nOldX,nOldY,Self,m_nCurrX,m_nCurrX,True);
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.HorseRunTo(btDir: Byte;boFlag:boolean): Boolean;
var
  n10,n14:Integer;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::HorseRunTo';
begin
  Result:=False;
  try
    n10:=m_nCurrX;
    n14:=m_nCurrY;
    m_btDirection:=btDir;
    case btDir of
      DR_UP{0}: begin
        if (m_nCurrY > 2) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY -3,True) > 0)then begin

          Dec(m_nCurrY,3);
        end;
      end;
      DR_UPRIGHT{1}: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
           (m_nCurrY > 2) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX +3,m_nCurrY -3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 3,m_nCurrY -3,True) > 0)then begin

          Inc(m_nCurrX,3);
          Dec(m_nCurrY,3);
        end;
      end;
      DR_RIGHT{2}: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -3) and
           (m_PEnvir.CanWalk(m_nCurrX + 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX + 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX + 3,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 3,m_nCurrY,True) > 0)then begin

          Inc(m_nCurrX,3);
        end;
      end;
      DR_DOWNRIGHT{3}: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
           (m_nCurrY < m_PEnvir.m_nHeight -3) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX +3,m_nCurrY +3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 3,m_nCurrY +3,True) > 0)then begin

          Inc(m_nCurrX,3);
          Inc(m_nCurrY,3);
        end;
      end;
      DR_DOWN{4}: begin
        if (m_nCurrY < m_PEnvir.m_nHeight -3) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY +3,True) > 0)then begin

          Inc(m_nCurrY,3);
        end;
      end;
      DR_DOWNLEFT{5}: begin
        if (m_nCurrX > 2) and
           (m_nCurrY < m_PEnvir.m_nHeight -3) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX -3,m_nCurrY +3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 3,m_nCurrY +3,True) > 0)then begin

          Dec(m_nCurrX,3);
          Inc(m_nCurrY,3);
        end;      
      end;
      DR_LEFT{6}: begin
        if (m_nCurrX > 2) and
           (m_PEnvir.CanWalk(m_nCurrX - 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX - 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX - 3,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 3,m_nCurrY,True) > 0)then begin

          Dec(m_nCurrX,3);
        end;
      end;
      DR_UPLEFT{7}: begin
        if (m_nCurrX > 2) and
           (m_nCurrY > 2) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.CanWalk(m_nCurrX -3,m_nCurrY -3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll){True}))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 3,m_nCurrY -3,True) > 0)then begin

          Dec(m_nCurrX,3);
          Dec(m_nCurrY,3);
        end;
      end;
    end;
//    SysMsg(format('覩X:%d 覩Y:%d 劤X:%d 劤Y:%d',[n10,n14,m_nCurrX,m_nCurrY]),c_Green,t_Hint);
    if (m_nCurrX <> n10) or (m_nCurrY <> n14) then begin
      if Walk(RM_HORSERUN) then Result:=True
      else begin
        m_nCurrX:=n10;
        m_nCurrY:=n14;
        m_PEnvir.MoveToMovingObject(n10,n14,Self,m_nCurrX,m_nCurrX,True)
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.SpeedRunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer): Boolean;   //경신보
var
  nOldX,nOldY:Integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::SpeedRunTo';
begin
  Result:=False;
  try
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    m_btDirection:=btDir;
    case btDir of
      DR_UP: begin
        if (m_nCurrY > 2) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY -3,True) > 0)then begin

          Dec(m_nCurrY,3);
        end;
      end;
      DR_UPRIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -3) and
           (m_nCurrY > 2) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +3,m_nCurrY -3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 3,m_nCurrY -3,True) > 0)then begin

          Inc(m_nCurrX,3);
          Dec(m_nCurrY,3);
        end;
      end;
      DR_RIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -3) and
           (m_PEnvir.CanWalk(m_nCurrX + 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX + 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX + 3,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 3,m_nCurrY,True) > 0)then begin

          Inc(m_nCurrX,3);
        end;
      end;
      DR_DOWNRIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
           (m_nCurrY < m_PEnvir.m_nHeight - 3) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +3,m_nCurrY +3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 3,m_nCurrY +3,True) > 0)then begin

          Inc(m_nCurrX,3);
          Inc(m_nCurrY,3);
        end;
      end;
      DR_DOWN: begin
        if (m_nCurrY < m_PEnvir.m_nHeight -3) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY +3,True) > 0)then begin

          Inc(m_nCurrY,3);
        end;
      end;
      DR_DOWNLEFT: begin
        if (m_nCurrX > 2) and
           (m_nCurrY < m_PEnvir.m_nHeight -3) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -3,m_nCurrY +3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 3,m_nCurrY +3,True) > 0)then begin

          Dec(m_nCurrX,3);
          Inc(m_nCurrY,3);
        end;      
      end;
      DR_LEFT: begin
        if (m_nCurrX > 2) and
           (m_PEnvir.CanWalk(m_nCurrX - 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX - 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX - 3,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 3,m_nCurrY,True) > 0)then begin

          Dec(m_nCurrX,3);
        end;
      end;
      DR_UPLEFT: begin
        if (m_nCurrX > 2) and
           (m_nCurrY > 2) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -3,m_nCurrY -3,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 3,m_nCurrY -3,True) > 0)then begin

          Dec(m_nCurrX,3);
          Dec(m_nCurrY,3);
        end;
      end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) then begin
      if Walk(RM_SPEEDRUN) then Result:=True
      else begin
        m_nCurrX:=nOldX;
        m_nCurrY:=nOldY;
        m_PEnvir.MoveToMovingObject(nOldX,nOldY,Self,m_nCurrX,m_nCurrX,True);
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.DownRunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer): Boolean;
var
  nOldX,nOldY:Integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::DownRunTo';
begin
  Result:=False;
  try
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;
    m_btDirection:=btDir;
    case btDir of
      DR_UP: begin
        if (m_nCurrY > 1) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY -2,True) > 0)then begin

          Dec(m_nCurrY,2);
        end;
      end;
      DR_UPRIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -2) and
           (m_nCurrY > 1) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 2,m_nCurrY -2,True) > 0)then begin

          Inc(m_nCurrX,2);
          Dec(m_nCurrY,2);
        end;
      end;
      DR_RIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth -2) and
           (m_PEnvir.CanWalk(m_nCurrX + 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX + 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 2,m_nCurrY,True) > 0)then begin

          Inc(m_nCurrX,2);
        end;
      end;
      DR_DOWNRIGHT: begin
        if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
           (m_nCurrY < m_PEnvir.m_nHeight -2) and
           (m_PEnvir.CanWalk(m_nCurrX +1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX +2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX + 2,m_nCurrY +2,True) > 0)then begin

          Inc(m_nCurrX,2);
          Inc(m_nCurrY,2);
        end;
      end;
      DR_DOWN: begin
        if (m_nCurrY < m_PEnvir.m_nHeight -2) and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX,m_nCurrY +2,True) > 0)then begin

          Inc(m_nCurrY,2);
        end;
      end;
      DR_DOWNLEFT: begin
        if (m_nCurrX > 1) and
           (m_nCurrY < m_PEnvir.m_nHeight -2) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY +1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY +2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 2,m_nCurrY +2,True) > 0)then begin

          Dec(m_nCurrX,2);
          Inc(m_nCurrY,2);
        end;      
      end;
      DR_LEFT: begin
        if (m_nCurrX > 1) and
           (m_PEnvir.CanWalk(m_nCurrX - 1,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX - 2,m_nCurrY,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 2,m_nCurrY,True) > 0)then begin

          Dec(m_nCurrX,2);
        end;
      end;
      DR_UPLEFT: begin
        if (m_nCurrX > 1) and
           (m_nCurrY > 1) and
           (m_PEnvir.CanWalk(m_nCurrX -1,m_nCurrY -1,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.CanWalk(m_nCurrX -2,m_nCurrY -2,boFlag or g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll)))and
           (m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,m_nCurrX - 2,m_nCurrY -2,True) > 0)then begin

          Dec(m_nCurrX,2);
          Dec(m_nCurrY,2);
        end;
      end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY)) then begin
      if Walk(RM_DOWNRUN) then Result:=True
      else begin
        m_nCurrX:=nOldX;
        m_nCurrY:=nOldY;
        m_PEnvir.MoveToMovingObject(nOldX,nOldY,Self,m_nCurrX,m_nCurrX,True);
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;


function TPlayObject.ClientRunXY(wIdent:Word;nX, nY:Integer): Boolean;//004CB11C
var
  nDir, dis:Integer;
  allowdup: Boolean;
  Castle:TUserCastle;
begin
  Result:=False;

  if not m_boCanRun then exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) and not g_Config.ClientConf.boParalyCanRun) then exit;//렝쮸

  {if GetTickCount - LatestWalkTime < 600 then begin
    Inc (WalkTimeOverCount);
    Inc (WalkTimeOverSum);
   if g_SpeedHackCheck > 0 then begin
         dis := GetTickCount - LatestWalkTime;
         if (dis < g_SpeedHackCheck) and (WalkTimeOverSum > 1) then begin
            MainOutMessage('스핵체크 Run : ' + IntToStr(dis) + ' : ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + ',' + IntToStr(m_nOverSpeedCount) + '  ' + m_sCharName);
         end;
      end;
  end else begin
      WalkTimeOverCount := 0;
      if WalkTimeOverSum > 0 then
         Dec (WalkTimeOverSum);
  end;
  LatestWalkTime := GetTickCount;

  if (WalkTimeOverCount < 4) and (WalkTimeOverSum < 6) then begin  }
    m_bo316:=False;
    nDir:=GetNextDirection(m_nCurrX,m_nCurrY,nX,nY);

    allowdup := TRUE;  //평상시에는 뛸때 겹칠 수 있음
    Castle:=g_CastleManager.InCastleWarArea(Self);
    if ((Castle <> nil) and Castle.m_boUnderWar)  then begin  //공성전 중인 경우
       if m_boInFreePKArea then //프리피케이존(전쟁터)에 있음, 공성 지역에 있음
          allowdup := FALSE;  //공성전 지역에서는 겹칠 수 없음
    end;

    if RunTo(nDir,allowdup,nX,nY) then begin   //겹치기 허용
      if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;
      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result:=True;
      Dec(m_nHealthTick,60);
      Dec(m_nSpellTick,10);
      m_nSpellTick:=_MAX(0,m_nSpellTick);
      Dec(m_nPerHealth);
      Dec(m_nPerSpell);
      m_dwTigerTick := GetTickCount;
      m_boSunchunUse := False;
    end else begin
      WalkTimeOverCount := 0;
      WalkTimeOverSum := 0;
    end;
  {end else begin
      Inc (m_nOverSpeedCount);
      if m_nOverSpeedCount > 8 then
         m_boEmergencyClose := TRUE;
      if g_Config.boViewHackMessage then
         MainOutMessage ('[스피드핵 뛰기] ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + '  ' + m_sCharName + ' ' + TimeToStr(Time));
  end;  }
end;

function TPlayObject.ClientSpeedRunXY(wIdent:Word;nX, nY:Integer;nFlag:Integer): Boolean;//경신보
var
  nDir:Integer;
  allowdup: Boolean;
  Castle:TUserCastle;
begin
  Result:=False;
  if not m_boCanRun then exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) and not g_Config.ClientConf.boParalyCanRun) then exit;//렝쮸

    m_bo316:=False;
    nDir:=GetNextDirection(m_nCurrX,m_nCurrY,nX,nY);

    allowdup := TRUE;  //평상시에는 뛸때 겹칠 수 있음
    Castle:=g_CastleManager.InCastleWarArea(Self);
    if ((Castle <> nil) and Castle.m_boUnderWar)  then begin  //공성전 중인 경우
       if m_boInFreePKArea then //프리피케이존(전쟁터)에 있음, 공성 지역에 있음
          allowdup := FALSE;  //공성전 지역에서는 겹칠 수 없음
    end;

    if SpeedRunTo(nDir,allowdup,nX,nY) then begin  //경신보 겹치기 허용
      if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;
      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result:=True;
      Dec(m_nHealthTick,60);
      Dec(m_nSpellTick,10);
      m_nSpellTick:=_MAX(0,m_nSpellTick);
      Dec(m_nPerHealth);
      Dec(m_nPerSpell);
      m_dwTigerTick := GetTickCount;
      m_boSunchunUse := False;
    end else begin
      WalkTimeOverCount := 0;
      WalkTimeOverSum := 0;
    end;
end;

function TPlayObject.ClientDownRunXY(wIdent:Word;nX, nY:Integer;nFlag:Integer): Boolean;//경신보
var
  nDir:Integer;
  allowdup: Boolean;
  Castle:TUserCastle;
begin
  Result:=False;
  if not m_boCanRun then exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) and not g_Config.ClientConf.boParalyCanRun) then exit;//렝쮸

    m_bo316:=False;
    nDir:=GetNextDirection(m_nCurrX,m_nCurrY,nX,nY);

    allowdup := TRUE;  //평상시에는 뛸때 겹칠 수 있음
    Castle:=g_CastleManager.InCastleWarArea(Self);
    if ((Castle <> nil) and Castle.m_boUnderWar)  then begin  //공성전 중인 경우
       if m_boInFreePKArea then //프리피케이존(전쟁터)에 있음, 공성 지역에 있음
          allowdup := FALSE;  //공성전 지역에서는 겹칠 수 없음
    end;

    if DownRunTo(nDir,allowdup,nX,nY) then begin     //겹치기
      if m_boTransparent and (m_boHideMode) then m_wStatusTimeArr[STATE_TRANSPARENT]:=1;
      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result:=True;
      Dec(m_nHealthTick,60);
      Dec(m_nSpellTick,10);
      m_nSpellTick:=_MAX(0,m_nSpellTick);
      Dec(m_nPerHealth);
      Dec(m_nPerSpell);
      m_boSunchunUse := False;
    end else begin
      WalkTimeOverCount := 0;
      WalkTimeOverSum := 0;
    end;
end;

function TPlayObject.ClientWalkXY(wIdent:Word;nX, nY:Integer): Boolean;//004CAF08
var
  n14, dis, nMagLevel, nRate:Integer;
  dwCheckTime:LongWord;
  UserMagic: pTUserMagic;
begin
  Result:=False;
  if not m_boCanWalk then exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE] <> 0) and not g_Config.ClientConf.boParalyCanWalk) then exit;   //낙염 , 빙환

{  if GetTickCount - LatestWalkTime < 600 then begin
    Inc (WalkTimeOverCount);
    Inc (WalkTimeOverSum);
    if g_SpeedHackCheck > 0 then begin
       dis := GetTickCount - LatestWalkTime;
       if (dis < g_SpeedHackCheck) and (WalkTimeOverSum > 1) then begin
          MainOutMessage('스핵체크 Walk : ' + IntToStr(dis) + ' : ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + ',' + IntToStr(m_nOverSpeedCount) + '  ' + m_sCharName);
       end;
    end;
  end else begin
    WalkTimeOverCount := 0;
    if WalkTimeOverSum > 0 then
       Dec (WalkTimeOverSum);
  end;

  LatestWalkTime := GetTickCount;    }

//  if (WalkTimeOverCount < 4) and (WalkTimeOverSum < 6) then begin
    m_bo316:=False;
    n14:=GetNextDirection(m_nCurrX,m_nCurrY,nX,nY);

    if WalkTo(n14,True) then begin  //겹치기
      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result:=True;
      Dec(m_nHealthTick,10);
      if (m_wStatusArrValue[81] > 0) and (not m_boSunchunUse) then begin
        m_boSunchunUse := True;
      end;
    end else begin
      WalkTimeOverCount := 0;
      WalkTimeOverSum := 0;
    end;
  {end else begin
      Inc (m_nOverSpeedCount);
      if m_nOverSpeedCount > 8 then
         m_boEmergencyClose := TRUE;

      if g_Config.boViewHackMessage then
         MainOutMessage ('[스피드핵 걷기] ' + IntToStr(WalkTimeOverCount) + ',' + IntToStr(WalkTimeOverSum) + '  ' + m_sCharName + ' ' + TimeToStr(Time));
  end;    }
end;

function TPlayObject.ClientDownWalkXY(wIdent:Word;nX, nY:Integer): Boolean;//월영술
var
  n14:Integer;
  dwCheckTime:LongWord;
begin
  Result:=False;
  if not m_boCanWalk then exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) and not g_Config.ClientConf.boParalyCanWalk) then exit;//렝쮸

    m_bo316:=False;
    n14:=GetNextDirection(m_nCurrX,m_nCurrY,nX,nY);


    if DownWalkTo(n14,True) then begin      //겹치기 허용
      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result:=True;
      Dec(m_nHealthTick,10);
      m_boSunchunUse := False;
    end else begin
      WalkTimeOverCount := 0;
      WalkTimeOverSum := 0;
    end;
end;
//004BC900
procedure TBaseObject.ThrustingOnOff(boSwitch: Boolean);
begin
  m_boUseThrusting:=boSwitch;
  if m_boUseThrusting then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
        SysMsg(sThrustingOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sThrustingOn, c_Green, t_Hint);
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
        SysMsg(sThrustingOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sThrustingOff, c_Green, t_Hint);
    end;
  end;
end;
//004BC980
procedure TPlayObject.TaguOnOff(boSwitch: Boolean);
begin
  m_boUseTagu:=boSwitch;
  if m_boUseTagu then begin
    SysMsg(sTaguOn,c_Green,t_Hint);
  end else begin
    SysMsg(sTaguOff,c_Green,t_Hint);
  end;
end;

procedure TBaseObject.WindbladeOnOff(boSwitch: Boolean);    //풍검술
begin
  m_boUseWindblade:=boSwitch;
  if m_boUseWindblade then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sWindbladeOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sWindbladeOn, c_Green, t_Hint);
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sWindbladeOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sWindbladeOff, c_Green, t_Hint);
    end;
  end;
end;

procedure TBaseObject.HalfMoonOnOff(boSwitch: Boolean);
begin
  m_boUseHalfMoon:=boSwitch;
  if m_boUseHalfMoon then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
        SysMsg(sHalfMoonOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sHalfMoonOn, c_Green, t_Hint);
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
        SysMsg(sHalfMoonOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sHalfMoonOff, c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.SkillCrsOnOff(boSwitch: Boolean);
begin
  m_boCrsHitkill:=boSwitch;
  if m_boCrsHitkill then begin
    SysMsg(sCrsHitOn,c_Green,t_Hint);
  end else begin
    SysMsg(sCrsHitOff,c_Green,t_Hint);
  end;
end;

procedure TBaseObject.SkillNanCrsOnOff(boSwitch: Boolean);
begin
  m_boNanCrsHitkill:=boSwitch;
  if m_boNanCrsHitkill then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
        SysMsg(sNanCrsHitOn, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sNanCrsHitOn, c_Green, t_Hint);
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
        SysMsg(sNanCrsHitOff, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg('亶衿 ' + sNanCrsHitOff, c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.SkillCrsBongOnOff(boSwitch: Boolean); //회풍천봉법
begin
  m_boCrsBongHitkill:=boSwitch;
  if m_boCrsBongHitkill then begin
    SysMsg(sCrsBHitOn,c_Green,t_Hint);
  end else begin
    SysMsg(sCrsBHitOff,c_Green,t_Hint);
  end;
end;

function TBaseObject.AllowFireHitSkill():Boolean;//004BCA00      //염화결
begin
  Result:=False;
  if (GetTickCount - m_dwLatestFireHitTick) > 10 * 1000 then begin
    m_dwLatestFireHitTick:=GetTickCount();
    m_boFireHitSkill:=True;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sFireSpiritsSummoned, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg(sHeroFireSpiritsSummoned, c_Green, t_Hint);
    end;
    Result:=True;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SysMsg(sFireSpiritsFail, c_Green, t_Hint);
    end else
      if m_btRaceServer = RC_HEROOBJECT then begin
        THeroObject(Self).SysMsg(sFireSpiritsFail, c_Green, t_Hint);
      end;
  end;
end;

function TPlayObject.AllowChunMuSkill(UserMagic: pTUserMagic): Boolean;
begin
  Result := False;
  if (GetTickCount - m_ChenMuUpTick) > (25 - (UserMagic.btLevel * 1)) * 1000 then begin
    m_ChenMuUpTick := GetTickCount();
    m_boChunMuSkill := 1;
    Result := True;
  end;
end;

function TPlayObject.AllowDeathHitSkill():Boolean;//004BCA00      //살생도
begin
  Result:=False;
  if (GetTickCount - m_dwLatestDeathHitTick) > 10 * 1000 then begin
    m_dwLatestDeathHitTick:=GetTickCount();
    m_boDeathHitSkill:=True;
    SysMsg('콱돨嶠포◁↙탰굿쓸컷佈⇒',c_Green,t_Hint);
    Result:=True;
  end else begin
    SysMsg(sFireSpiritsFail,c_Red,t_Hint);
  end;
end;

function TBaseObject.AllowTwinHitSkill():Boolean;
begin
  Result:=False;
  if GetTickCount - m_dwLatestTwinHitTick > 1000 then begin
    m_dwLatestTwinHitTick:=GetTickCount();
    m_boTwinHitSkill := 1;
    Result:=True;
  end;
end;

function TPlayObject.AllowThunderHitSkill():Boolean;
begin
  Result:=False;
  if GetTickCount - m_dwLatestThHitTick > 500 then begin
    m_dwLatestThHitTick:=GetTickCount();
    m_boThunderHitSkill := 1;
    Result:=True;
  end;
end;

function TPlayObject.AllowFireShaolinSkill():Boolean;     //천화봉법
begin
  Result:=False;
  if GetTickCount - m_dwLatestFireShTick > 500 then begin
    m_dwLatestFireShTick:=GetTickCount();
    m_boFireShaolinSkill := 1;
    Result:=True;
  end;
end;


procedure TBaseObject.MapRandomMove(sMapName:String;nInt:Integer);//004BCB54       //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY,nEgdey:Integer;
begin
  Envir:=g_MapManager.FindMap(sMapName);
  if Envir <> nil then begin
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 30 then begin
        nEgdey:=2;
      end else nEgdey:=20;
    end else nEgdey:=50;
    nX:=Random(Envir.m_nWidth - nEgdey -1) + nEgdey;
    nY:=Random(Envir.m_nHeight - nEgdey -1) + nEgdey;
    SpaceMove(sMapName,nX,nY,nInt);
  end;
end;

procedure TBaseObject.NoMapRandomMove(sMapName:String;nInt:Integer);//004BCB54       //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY,nEgdey:Integer;
begin
  Envir:=g_MapManager.FindMap(sMapName);
  if Envir <> nil then begin
    if Envir.m_nHeight < 150 then begin
      if Envir.m_nHeight < 30 then begin
        nEgdey:=2;
      end else nEgdey:=20;
    end else nEgdey:=50;
    nX:=Random(Envir.m_nWidth - nEgdey -1) + nEgdey;
    nY:=Random(Envir.m_nHeight - nEgdey -1) + nEgdey;
    NoSpaceMove(sMapName,nX,nY,nInt);
  end;
end;

procedure TPlayObject.ClientClickNPC(NPC: Integer);//004DBA10
var
  NormNpc:TNormNpc;
begin
  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotTryDealMsg);
    exit;
  end;
  if m_boDeath or m_boGhost then exit;
    
  NormNpc:=UserEngine.FindMerchant(TObject(NPC));
  if NormNpc = nil then
    NormNpc:=UserEngine.FindNPC(TObject(NPC));

  if NormNpc <> nil then begin
    if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <= 15) and (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then begin
      NormNpc.Click(Self);
    end;
  end;//004DBA9C
end;

//004C4DB8
function TBaseObject.AddItemToBag(UserItem:PTUserItem;var boot:Boolean):Boolean;    //물약
begin
  Result:=False;
  if  AddItemToBagCategories(UserItem,boot) then begin
    WeightChanged();
    Result:=True;
  end;
end;

function  TBaseObject.AddItemToBagCategories(UserItem: PTUserItem;var boot:Boolean): Boolean;
var
 I,nc,itemidx:Integer;
 Item,jItem:TItem;
 UItem:PTUserItem;
begin
  Result:=False;
  nc := 0;
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
   if Item = nil then exit;
   if (Item.StdMode in [0,1,3,45,46]) and (UserItem.Amount = 1) then begin      //물약
     if (Item.StdMode in [0,1,3,45,46]) then
     itemidx := Item.MaxAmount; //물약 갯수
    for I := 0 to m_ItemList.Count - 1 do begin
       UItem:=m_ItemList.Items[i];
       if UItem = nil then Continue;
       jItem:=UserEngine.GetStdItem(UItem.wIndex);
      if jItem <> nil then begin
        if (UserItem.wIndex=UItem.wIndex) and (Item.Name=jItem.Name) and (Item.StdMode=jItem.StdMode) and (Item.Shape=jItem.Shape) then begin
           if UItem.Amount < itemidx then begin
            Inc(UItem.Amount,UserItem.Amount);
            inc(nc);
            TPlayObject(Self).SendAddItemmode(UItem,1);    //물약
            Result:=True;
            boot := false;
            Exit;
           end;
        end;
      end; 
    end;
    boot := True;
     if (nc = 0) then begin
       if m_ItemList.Count < MAXBAGITEM then begin
          m_ItemList.Add(UserItem);
          Result:=True;
          Exit;
       end;
     end;
   end else begin
     boot := True;
     if m_ItemList.Count < MAXBAGITEM then begin
      m_ItemList.Add(UserItem);
      Result:=True;
      Exit;
     end;
   end;
end;

//4C9BD0
function TPlayObject.GetRangeHumanCount: Integer;
begin
  Result:=UserEngine.GetMapOfRangeHumanCount(m_PEnvir,m_nCurrX,m_nCurrY,10);
end;

procedure TBaseObject.CheckMagicSpecialAbility(Magic:pTUserMagic); //004C713C
begin
  if Magic.MagicInfo.wMagicId = 28 then
    if Magic.btLevel >= 2 then m_boAbilSeeHealGauge:=True;
end;

procedure TPlayObject.GetHomePoint;
var
  I: Integer;
  StartPoint:pTStartPoint;
begin
  try
    g_StartPoint.Lock;
    for I := 0 to g_StartPoint.Count - 1 do begin
      StartPoint:=g_StartPoint.Items[I];
      if StartPoint.Envir = m_PEnvir then begin
        if (abs(m_nCurrX - StartPoint.nX) < 50) and (abs(m_nCurrY - StartPoint.nY) < 50) then begin
          m_sHomeMap:=StartPoint.sMapName;
          m_nHomeX:=StartPoint.nX;
          m_nHomeY:=StartPoint.nY;
          break;
        end;
      end;
    end;
    if PKLevel >= 2 then begin
      m_sHomeMap :=g_Config.sRedHomeMap;
      m_nHomeX   :=g_Config.nRedHomeX;
      m_nHomeY   :=g_Config.nRedHomeY;
    end;
  finally
    g_StartPoint.UnLock;
  end;
end;

function TPlayObject.GetStartPoint(var StartPoint:pTStartPoint):Boolean;
var
  i    :Integer;
  Point:pTStartPoint;
begin
  Result:=False;
  if (m_PEnvir.sMapName = g_Config.sRedHomeMap) and
     (abs(m_nCurrX - g_Config.nRedHomeX) < g_Config.nSafeZoneSize) and
     (abs(m_nCurrY - g_Config.nRedHomeY) < g_Config.nSafeZoneSize) then begin
    StartPoint:=@g_RedStartPoint;
    StartPoint.sMapName:=m_PEnvir.sMapName;
    StartPoint.Envir:=m_PEnvir;
    StartPoint.nX:=g_Config.nRedHomeX;
    StartPoint.nY:=g_Config.nRedHomeY;
    Result:=True;
    exit;
  end;
  g_StartPoint.Lock;
  try
    for I := 0 to g_StartPoint.Count - 1 do begin
      Point:=g_StartPoint.Items[I];
      if Point.Envir = m_PEnvir then begin
        if (abs(m_nCurrX - Point.nX) < Point.nSize) and (abs(m_nCurrY - Point.nY) < Point.nSize) then begin
          StartPoint:=Point;
          Result:=True;
          break;
        end;
      end;
    end;
  finally
    g_StartPoint.UnLock;
  end;
end;

procedure TPlayObject.MobPlace(sX, sY, sMonName, sCount: String); //004C1508
begin

end;

function TBaseObject.GetQuestFalgStatus(nFlag: integer): Integer;//004C1490
var
  n10,n14:Integer;
begin
  Result:=0;
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then begin
    if ((128 shr n14) and (m_QuestFlag[n10])) <> 0 then Result:=1
    else Result:=0;
  end;

  //note: swapped the results around...
end;

procedure TBaseObject.SetQuestFlagStatus(nFlag:Integer;nValue:Integer);//004C1508
var
  n10,n14:Integer;
  bt15:Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then begin
    bt15:=m_QuestFlag[n10];
    if nValue = 0 then begin
      m_QuestFlag[n10]:=(not (128 shr n14)) and (bt15);
    end else begin
      m_QuestFlag[n10]:=(128 shr n14) or (bt15);
    end;
  end;
end;
function TBaseObject.GetQuestUnitOpenStatus(nFlag: integer): Integer;//004C159C
var
  n10,n14:Integer;
begin
  Result:=0;
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    if ((128 shr n14) and (m_QuestUnitOpen[n10])) <> 0 then Result:=1
    else Result:=0;
  end;
end;
procedure TBaseObject.SetQuestUnitOpenStatus(nFlag:Integer;nValue:Integer);//004C1614
var
  n10,n14:Integer;
  bt15:Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    bt15:=m_QuestUnitOpen[n10];
    if nValue = 0 then begin
      m_QuestUnitOpen[n10]:=(not (128 shr n14)) and (bt15);
    end else begin
      m_QuestUnitOpen[n10]:=(128 shr n14) or (bt15);
    end;
  end;
end;

function TBaseObject.GetQuestUnitStatus(nFlag: integer): Integer;//004C16A8
var
  n10,n14:Integer;
begin
  Result:=0;
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    if ((128 shr n14) and (m_QuestUnit[n10])) <> 0 then Result:=1
    else Result:=0;
  end;
end;

procedure TBaseObject.SetQuestUnitStatus(nFlag:Integer;nValue:Integer);//004C1720
var
  n10,n14:Integer;
  bt15:Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    bt15:=m_QuestUnit[n10];
    if nValue = 0 then begin
      m_QuestUnit[n10]:=(not (128 shr n14)) and (bt15);
    end else begin
      m_QuestUnit[n10]:=(128 shr n14) or (bt15);
    end;
  end;
end;


procedure TPlayObject.CmdTrainingMagic(Cmd:pTGameCmd;sHumanName, sSkillName: String;
  nLevel: Integer);
var
  Magic:pTMagic;
  UserMagic:pTUserMagic;
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) or (sHumanName = '') or (sSkillName = '') or (nLevel < 0) or not (nLevel in [0..3]) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <세콘츰냔> <된섬(0~3)>',c_Red,t_Hint);
    exit;
  end;
  Magic:=UserEngine.FindMagic(sSkillName);
  if Magic = nil then begin
    SysMsg(format('세콘%s꼇닸瞳。',[sSkillName]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if PlayObject.IsTrainingSkill(Magic.wMagicId) then begin
      SysMsg(format('콱綠쒔欺構법세콘%s죄。。',[sSkillName]),c_Red,t_Hint);
      exit;
    end;
    New(UserMagic);
    UserMagic.MagicInfo:=Magic;
    UserMagic.wMagIdx:=Magic.wMagicId;
    UserMagic.btLevel:=nLevel;
    UserMagic.btKey:=0;
    UserMagic.nTranPoint:=0;
    PlayObject.m_MagicList.Add(UserMagic);
    PlayObject.SendAddMagic(UserMagic);
    PlayObject.RecalcAbilitys;
    SysMsg(format('%s綠쒔欺삔죄세콘%s，',[sHumanName,sSkillName]),c_Green,t_Hint);
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      if HeroObject.IsTrainingSkill(Magic.wMagicId) then begin
        SysMsg(Format('콱綠쒔欺構법세콘%s죄。', [sSkillName]), c_Red, t_Hint);
        Exit;
      end;
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btLevel := nLevel;
      UserMagic.btKey := 0;
      UserMagic.nTranPoint := 0;
      HeroObject.m_MagicList.Add(UserMagic);
      HeroObject.SendAddMagic(UserMagic);
      HeroObject.RecalcAbilitys;
      SysMsg(Format('亶衿%s綠쒔欺삔죄세콘%s。', [sHumanName, sSkillName]), c_Green, t_Hint);
    end else begin
      SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end;
end;

procedure TPlayObject.CmdTrainingSkill(Cmd:pTGameCmd;sHumanName, sSkillName: String;
  nLevel: Integer);
var
  I: Integer;
  UserMagic:pTUserMagic;
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sSkillName = '') or (nLevel <= 0) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <세콘츰냔> <된섬(0~3)>',c_Red,t_Hint);
    exit;
  end;
  nLevel:=_MIN(3,nLevel);
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    for I := 0 to PlayObject.m_MagicList.Count - 1 do begin
      UserMagic:=PlayObject.m_MagicList.Items[I];
      if CompareText(UserMagic.MagicInfo.sMagicName,sSkillName) = 0 then begin
        UserMagic.btLevel:=nLevel;
        PlayObject.SendMsg(PlayObject,
              RM_MAGIC_LVEXP,
              0,
              UserMagic.MagicInfo.wMagicId,
              UserMagic.btLevel,
              UserMagic.nTranPoint,
              '');
        PlayObject.SysMsg(format('세콘%s돨錦조된섬綠긴槨%d섬。',[sSkillName,nLevel]),c_Green,t_Hint);
        SysMsg(format('%s돨세콘%s돨錦조된섬긴槨%d섬。',[sHumanName,sSkillName,nLevel]),c_Green,t_Hint);
        break;
      end;
    end;
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      for I := 0 to HeroObject.m_MagicList.Count - 1 do begin
        UserMagic := HeroObject.m_MagicList.Items[I];
        if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
          UserMagic.btLevel := nLevel;
          HeroObject.SendMsg(Self,
            RM_MAGIC_LVEXP,
            0,
            UserMagic.MagicInfo.wMagicId,
            UserMagic.btLevel,
            UserMagic.nTranPoint,
            '');
          HeroObject.m_Master.SysMsg(Format('亶衿돨세콘%s돨錦조된섬綠긴槨%d섬。', [sSkillName, nLevel]), c_Green, t_Hint);
          SysMsg(Format('亶衿%s돨세콘%s돨錦조된섬綠긴槨%d섬。', [sHumanName, sSkillName, nLevel]), c_Green, t_Hint);
          Break;
        end;
      end;
    end else begin
      SysMsg(Format('세콘%s꼇닸瞳。', [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end;
end;

procedure TPlayObject.CmdAddGameGold(sCmd, sHumName: String;
  nPoint: Integer);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < 6) then exit;
  if (sHumName = '') or (nPoint <= 0) then begin
    SysMsg('@' + sCmd + ' <실ッ> <鑒좆>',c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    if (PlayObject.m_nGameGold + nPoint) < 2000000 then begin
      Inc(PlayObject.m_nGameGold,nPoint);
    end else begin
      nPoint:=2000000 - PlayObject.m_nGameGold;
      PlayObject.m_nGameGold:=2000000;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '踏狗귑藤속죄' + IntToStr(nPoint)+ '。',c_Green,t_Hint);
    PlayObject.SysMsg('콱돨踏狗귑藤속죄' + IntToStr(nPoint)+ '。',c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdDelGameGold(sCmd, sHumName: String;
  nPoint: Integer);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < 6) then exit;
  if (sHumName = '') or (nPoint <= 0) then exit;
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    if PlayObject.m_nGameGold > nPoint then begin
      Dec(PlayObject.m_nGameGold,nPoint);
    end else begin
      nPoint:=PlayObject.m_nGameGold;
      PlayObject.m_nGameGold:=0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '돨踏狗귑숑瑁' + IntToStr(nPoint)+ '。',c_Green,t_Hint);
    PlayObject.SysMsg('콱돨踏狗귑藤속죄' + IntToStr(nPoint)+ '。',c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeLuckPoint(Cmd:pTGameCmd;sHumanName:String;nPoint:integer);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
    
  if (sHumanName = '') or (nPoint < 0) or (nPoint > 2000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandAddLuckPointHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;

  PlayObject.AddBodyLuck(nPoint);
  PlayObject.SysMsg('妗頓令綠쒔맣긴。',c_BlueWhite,t_Hint);
end;

procedure TPlayObject.CmdGameGold(Cmd:pTGameCmd;sHumanName:String;sCtr:String;nGold:Integer);
var
  PlayObject:TPlayObject;
  Ctr:Char;
begin
  Ctr:='1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sCtr <> '') then begin
    Ctr:=sCtr[1];
  end;
    
  if (sHumanName = '') or not (Ctr in ['=','+','-']) or (nGold < 0) or (nGold > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandGameGoldHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  case sCtr[1] of
    '=': begin
      PlayObject.m_nGamePoint:=nGold;
    end;
    '+': Inc(PlayObject.m_nGameGold,nGold);
    '-': Dec(PlayObject.m_nGameGold,nGold);
  end;
  if g_boGameLogGameGold then begin
    AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEGOLD,
                                        PlayObject.m_sMapName,
                                        PlayObject.m_nCurrX,
                                        PlayObject.m_nCurrY,
                                        PlayObject.m_sCharName,
                                        g_Config.sGameGoldName,
                                        nGold,
                                        sCtr[1],
                                        m_sCharName,'[츱즈]']));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(format(g_sGameCommandGameGoldHumanMsg,[g_Config.sGameGoldName,nGold,PlayObject.m_nGameGold,g_Config.sGameGoldName]),c_Green,t_Hint);
  SysMsg(format(g_sGameCommandGameGoldGMMsg,[sHumanName,g_Config.sGameGoldName,nGold,PlayObject.m_nGameGold,g_Config.sGameGoldName]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdGamePoint(Cmd:pTGameCmd;sHumanName, sCtr: String; nPoint: Integer);
var
  PlayObject:TPlayObject;
  Ctr:Char;
begin
  Ctr:='1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sCtr <> '') then begin
    Ctr:=sCtr[1];
  end;
    
  if (sHumanName = '') or not (Ctr in ['=','+','-']) or (nPoint < 0) or (nPoint > 100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandGamePointHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  case sCtr[1] of
    '=': begin
      PlayObject.m_nGamePoint:=nPoint;
    end;
    '+': Inc(PlayObject.m_nGamePoint,nPoint);
    '-': Dec(PlayObject.m_nGamePoint,nPoint);
  end;
  if g_boGameLogGamePoint then begin
    AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEPOINT,
                                        PlayObject.m_sMapName,
                                        PlayObject.m_nCurrX,
                                        PlayObject.m_nCurrY,
                                        PlayObject.m_sCharName,
                                        g_Config.sGamePointName,
                                        nPoint,
                                        sCtr[1],
                                        m_sCharName,'[츱즈]']));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(format(g_sGameCommandGamePointHumanMsg,[nPoint,PlayObject.m_nGamePoint]),c_Green,t_Hint);
  SysMsg(format(g_sGameCommandGamePointGMMsg,[sHumanName,nPoint,PlayObject.m_nGamePoint]),c_Green,t_Hint);
end;



procedure TPlayObject.CmdPCPoint(Cmd:pTGameCmd;sHumanName, sCtr: String; nPoint: Integer);
var
  PlayObject:TPlayObject;
  Ctr:Char;
begin
  Ctr:='1';
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sCtr <> '') then begin
    Ctr:=sCtr[1];
  end;
    
  if (sHumanName = '') or not (Ctr in ['=','+','-']) or (nPoint < 0) or (nPoint > 100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandGamePointHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  case sCtr[1] of
    '=': begin
      PlayObject.m_nPCPoint:=nPoint;
    end;
    '+': Inc(PlayObject.m_nPCPoint,nPoint);
    '-': Dec(PlayObject.m_nPCPoint,nPoint);
  end;
  if g_boGameLogGamePoint then begin
    AddGameDataLog(format(g_sGameLogMsg1,[LOG_GAMEPOINT,
                                        PlayObject.m_sMapName,
                                        PlayObject.m_nCurrX,
                                        PlayObject.m_nCurrY,
                                        PlayObject.m_sCharName,
                                        g_Config.sGamePointName,
                                        nPoint,
                                        sCtr[1],
                                        m_sCharName,'[츱즈]']));
  end;
  PointChanged();
  PlayObject.SysMsg(format(g_sGameCommandPCPointHumanMsg,[nPoint,PlayObject.m_nPCPoint]),c_Green,t_Hint);
  SysMsg(format(g_sGameCommandPCPointGMMsg,[sHumanName,nPoint,PlayObject.m_nPCPoint]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdAddGold(Cmd:pTGameCmd;sHumName: String; nCount: Integer);//004CD550
var
  PlayObject:TPlayObject;
  nServerIndex:integer;
begin
  if (m_btPermission < 6) then exit;
  if (sHumName = '') or (nCount <= 0) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <쏜귑>',c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    if (PlayObject.m_nGold + nCount) < PlayObject.m_nGoldMax then begin
      PlayObject.IncGold(nCount);
     // Inc(PlayObject.m_nGold,nCount);
    end else begin
      nCount:=PlayObject.m_nGoldMax - PlayObject.m_nGold;
      PlayObject.m_nGold:=PlayObject.m_nGoldMax;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '돨쏜귑藤속죄 "' + IntToStr(nCount)+ '" 。',c_Green,t_Hint);
    PlayObject.SysMsg('콱돨쏜귑藤속죄 "' + IntToStr(nCount)+ '" 。',c_BlueWhite,t_Hint);
            //004CD6F6
          if g_boGameLogGold then
            AddGameDataLog('14' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        sSTRING_GOLDNAME + #9 +
                        IntToStr(nCount) + #9 +
                        '1' + #9 +
                        sHumName + #9 + '[GM쏜귑딧憐]');
  end else begin
   SysMsg(sHumName + '꼇瞳窟。',c_Red,t_Hint);
   exit;
   { if UserEngine.FindOtherServerUser(sHumName,nServerIndex) then begin
      SysMsg(sHumName + ' Has been found on server number:' + IntToStr(nServerIndex)+ '.',c_Green,t_Hint);
    end else begin
      FrontEngine.AddChangeGoldList(m_sCharName,sHumName,nCount);
      SysMsg(sHumName + ' 님의 금전 정보가 변경되었습니다.',c_Green,t_Hint);
    end;  }
  end;
end;
procedure TPlayObject.CmdAddGuild(Cmd:pTGameCmd;sGuildName, sGuildChief: String);//004CEBA0
var
  Human:TPlayObject;
  boAddState:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('Can only create guilds on masterserver',c_Red,t_Hint);
    exit;
  end;
  if (sGuildName = '') or (sGuildChief = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <契삔츰> <廊쳔>',c_Red,t_Hint);
    exit;
  end;

  boAddState:=False;
  Human:=UserEngine.GeTPlayObject(sGuildChief);   //캐릭 접속 확인
  if Human = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sGuildChief]),c_Red,t_Hint);
    exit;
  end;
  if g_GuildManager.MemberOfGuild(sGuildChief) = nil then begin     //문파 가입 여부
    if g_GuildManager.AddGuild(sGuildName,sGuildChief) then begin
      UserEngine.SendServerGroupMsg(SS_205,nServerIndex,sGuildName + '/' + sGuildChief);
      SysMsg('契삔: ' + sGuildName + ' 廊쳔: ' + sGuildChief,c_Green,t_Hint);
      boAddState:=True;
    end;
  end;//004CECB4
  if boAddState then begin
    Human.m_MyGuild:=g_GuildManager.MemberOfGuild(Human.m_sCharName);    //문파 적용..
    if Human.m_MyGuild <> nil then begin
      Human.m_sGuildRankName:=TGuild(Human.m_MyGuild).GetRankName(Human,Human.m_nGuildRankNo);
      Human.RefShowName();
    end;
  end;//004CED14
end;


procedure TPlayObject.CmdAdjuestExp(Cmd:pTGameCmd; sHumanName,sExp: String);
var
  PlayObject:TPlayObject;
  dwExp:LongWord;
  dwOExp:LongWord;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <쒔駱鑒令>',c_Red,t_Hint);
    exit;
  end;
  dwExp:=Str_ToInt(sExp,0);

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    dwOExp:=PlayObject.m_Abil.Exp;
    PlayObject.m_Abil.Exp:=dwExp;
    PlayObject.HasLevelUp(1);
    SysMsg(sHumanName + '돨쒔駱令맣긴죄。',c_Green,t_Hint);
  if g_Config.boShowMakeItemMsg then
    MainOutMessage('[쒔駱令딧憐] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(dwOExp) + ' -> ' + IntToStr(PlayObject.m_Abil.Exp) + ')');
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdAdjuestLevel(Cmd:pTGameCmd;sHumanName: String;
  nLevel: Integer);
var
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
  nOLevel:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sHumanName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <된섬>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    nOLevel:=PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level:=_MAX(1,_MIN(MAXUPLEVEL,nLevel));
    PlayObject.HasLevelUp(1);
    SysMsg(sHumanName + '돨된섬맣긴죄。',c_Green,t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[된섬딧憐] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) + ')');
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      nOLevel := HeroObject.m_Abil.Level;
      HeroObject.m_Abil.Level := _MAX(1,_MIN(MAXLEVEL,nLevel));
      HeroObject.HasLevelUp(2);
      SysMsg('亶衿' + sHumanName + '돨된섬맣긴죄。',c_Green,t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[亶衿된섬딧憐] ' + m_sCharName + '(' + HeroObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' + IntToStr(HeroObject.m_Abil.Level) + ')');
    end else begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    end;
  end;
end;
procedure TPlayObject.CmdAdjustExp(Human: TPlayObject; nExp: Integer);//004CDDAC
begin
  if (m_btPermission < 6) then exit;
end;

procedure TPlayObject.CmdBackStep(sCmd:String; nType, nCount: Integer);
begin
  if (m_btPermission < 6) then exit;
  nType:=_MIN(nType,8);
  if nType = 0 then begin
    CharPushed(GetBackDir(m_btDirection),nCount);
  end else begin
    CharPushed(RanDom(nType),nCount);
  end;
    
end;

procedure TPlayObject.CmdBonuPoint(Cmd:pTGameCmd;sHumName: String; nCount: Integer);
var
  PlayObject:TPlayObject;
  sMsg:String;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumName = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <踏狗듐>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GetPlayObject(sHumName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
    exit;
  end;
  if (nCount > 0) and (nCount <= 3000) then begin      //보너스포인트 핵
    PlayObject.m_nBonusPoint:=nCount;
    PlayObject.SendMsg (self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    exit;
  end;
  sMsg:=format('橄昑令: %d (DC: %d MC: %d SC: %d AC: %d MAC: %d HP: %d MP: %d HIT: %d SPEED: %d)',
               [PlayObject.m_nBonusPoint,
                PlayObject.m_BonusAbil.DC,
                PlayObject.m_BonusAbil.MC,
                PlayObject.m_BonusAbil.SC,
                PlayObject.m_BonusAbil.AC,
                PlayObject.m_BonusAbil.MAC,
                PlayObject.m_BonusAbil.HP,
                PlayObject.m_BonusAbil.MP,
                PlayObject.m_BonusAbil.Hit,
                PlayObject.m_BonusAbil.Speed
               ]);
  SysMsg(format('%s - %s',[sHumName,sMsg]),c_Red,t_Hint);
end;

procedure TPlayObject.CmdChangeAdminMode(sCmd:String;nPermission:Integer;sParam1:String;boFlag:Boolean);
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;

  m_boAdminMode:=boFlag;
  if m_boAdminMode then SysMsg(sGameMasterMode,c_Green,t_Hint)
  else  SysMsg(sReleaseGameMasterMode,c_Green,t_Hint);
end;

procedure TPlayObject.CmdChangeAttackMode(nMode: Integer;sParam1,sParam2,sParam3,sParam4,sParam5,sParam6,sParam7:String); //공격모드
begin
  if m_PEnvir.Flag.boDEATHMATCH or m_PEnvir.Flag.boPKZONE then exit; //데스매치 공격 못바꿈
  if (m_UseItems[U_WEAPON].wIndex <> 0) and (m_UseItems[U_WEAPON].btValue[19] = 1) then exit;  //대여 무기 공방
  if (nMode >= HAM_ALL) and (nMode <=HAM_PKATTACK) then
    m_btAttatckMode:=nMode
  else begin
    if m_btAttatckMode < HAM_PKATTACK then Inc(m_btAttatckMode)
    else m_btAttatckMode:=HAM_ALL;
  end;
  case m_btAttatckMode of      //공격모드 메시지
    HAM_ALL: SysMsg('[홍竟묑샌]',c_Green,t_Hint); //[Attack All]
    HAM_PEACE: SysMsg('[뵨틱묑샌]',c_Green,t_Hint); //[Peaceful]
    HAM_GROUP: SysMsg('[긍莉묑샌]',c_Green,t_Hint); //[Group Attack]
    HAM_GUILD: SysMsg('[契삔묑샌]',c_Green,t_Hint); //[Guild Attack]
    HAM_ENEMY: SysMsg('[젬촉묑샌]',c_Green,t_Hint);
    HAM_PKATTACK: SysMsg('[틋朱샌]',c_Green,t_Hint); //[Red White Attack]
  end;
  SendMsg(Self,RM_ATTATCKMODE,0,0,0,0,''); //공격모드 표시
end;

procedure TPlayObject.CmdChangeGender(Cmd:pTGameCmd;sHumanName, sSex: String);    //성전환
var
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
  nSex:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  nSex:= -1;
  if (sSex = 'M') or (sSex = sMAN) or (sSex = sMALE) or (sSex = '0') then begin
    nSex:=0;
  end;
  if (sSex = 'F') or (sSex = sWOMAN) or (sSex = sFEMALE) or (sSex = '1') then begin
    nSex:=1;
  end;
  if (sHumanName = '') or (nSex = -1) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <昑깎(켕/큽)>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
   if not (PlayObject.m_btJob in [4, 9]) then begin         //직업변경
     if PlayObject.m_UseItems[U_DRESS].wIndex = 0 then begin
     if PlayObject.m_btGender <> nSex then begin
       PlayObject.m_btGender:=nSex;
       PlayObject.FeatureChanged();
       SysMsg(PlayObject.m_sCharName + '돨昑깎綠쒔맣긴。',c_Green,t_Hint);
       SendMsg(PlayObject,RM_ToSendMsg,0,90,PlayObject.m_btGender,0,'');
     end else begin
       SysMsg(PlayObject.m_sCharName + '돨昑깎긴뫘呵겨。',c_Red,t_Hint);
     end;
     end else begin
      SysMsg('콱누淪륩陋돨珂빅꼇콘맣긴昑깎。',c_Red,t_Hint);
     end;
   end else begin
    SysMsg('뵨勻뿔懇磁캇案逃靜',c_Red,t_Hint);
   end;
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      if HeroObject.m_UseItems[U_DRESS].wIndex = 0 then begin
        if HeroObject.m_btGender <> nSex then begin
          HeroObject.m_btGender := nSex;
          HeroObject.FeatureChanged();
          SysMsg('亶衿' + HeroObject.m_sCharName + '돨昑깎綠쒔맣긴。', c_Green, t_Hint);
          SendMsg(HeroObject,RM_ToSendMsg,0,90,HeroObject.m_btGender,0,'');
        end else begin
          SysMsg('亶衿' + HeroObject.m_sCharName + '돨昑깎긴뫘呵겨。', c_Red, t_Hint);
        end;
      end else begin
        SysMsg('누淪륩陋돨珂빅꼇콘맣긴昑깎。',c_Red,t_Hint);
      end;
    end else begin
      SysMsg(sHumanName + '꼇瞳窟，', c_Red, t_Hint);
    end;
  end;
end;
procedure TPlayObject.CmdChangeItemName(sCmd, sMakeIndex,sItemIndex, sItemName: String);
var
  nMakeIndex,nItemIndex:Integer;
begin
  if (m_btPermission < 6) then exit;
  if (sMakeIndex = '') or (sItemIndex = '') or (sItemName = '') then begin
    SysMsg('@' + sCmd + ' <MakeIndex> <ItemIndex> <ItemName>',c_Red,t_Hint);
    exit;
  end;
  nMakeIndex:=Str_ToInt(sMakeIndex,-1);
  nItemIndex:=Str_ToInt(sItemIndex,-1);
  if (nMakeIndex <= 0) or (nItemIndex < 0) then begin
    SysMsg('@' + sCmd + ' <MakeIndex> <ItemIndex> <ItemName>',c_Red,t_Hint);
    exit;
  end;

  if ItemUnit.AddCustomItemName(nMakeIndex,nItemIndex,sItemName) then begin
    ItemUnit.SaveCustomItemName();
    SysMsg('Custom itemname saved.',c_Green,t_Hint);
    exit;
  end;

  SysMsg('Unable to save custom itemname.',c_Red,t_Hint);
end;
procedure TPlayObject.CmdChangeJob(Cmd:pTGameCmd;sHumanName,sJobName: String);//004CC714
var
  PlayObject:TPlayObject;
  FameGrade :integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;

  if (sHumanName = '') or (sJobName = '') then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandChangeJobHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if CompareText(sJobName,sWarrior) = 0 then PlayObject.m_btJob:=jWarr;
    if CompareText(sJobName,sWizard) = 0 then PlayObject.m_btJob:=jWizard;
    if CompareText(sJobName,sTaos) = 0 then PlayObject.m_btJob:=jTaos;
    if CompareText(sJobName,sAssassin) = 0 then PlayObject.m_btJob:=jAssassin;     //자객
    if CompareText(sJobName,sBonze) = 0 then PlayObject.m_btJob:=jBonze;
    if CompareText(sJobName,sUpWarr) = 0 then PlayObject.m_btJob:=jUpWarr;
    if CompareText(sJobName,sUpWiz) = 0 then PlayObject.m_btJob:=jUpWiz;
    if CompareText(sJobName,sUpTao) = 0 then PlayObject.m_btJob:=jUpTao;
    if CompareText(sJobName,sUpAssa) = 0 then PlayObject.m_btJob:=jUpAssa;     //자객
    if CompareText(sJobName,sUpBonze) = 0 then PlayObject.m_btJob:=jUpBoz;

    PlayObject.m_btJob:= PlayObject.m_btJob;
    PlayObject.HasLevelUp(1);
    PlayObject.RecalcAbilitys();
    PlayObject.FeatureChanged;

    PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, GetFameName(FameGrade));
    PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, GetFameName(FameGrade));

    PlayObject.SysMsg(g_sGameCommandChangeJobHumanMsg,c_Green,t_Hint);
    SysMsg(format(g_sGameCommandChangeJobMsg,[sHumanName]),c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeJobUp(Cmd:pTGameCmd;sHumanName,sJobName: String);//004CC714 //등선변환
var
  PlayObject:TPlayObject;
  FameGrade:integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;

  if (sHumanName = '') or (sJobName = '') then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandChangeJobUpHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
  if (PlayObject.m_UseItems[U_WEAPON].wIndex = 0) and (PlayObject.m_UseItems[U_DRESS].wIndex = 0) and (PlayObject.m_UseItems[U_TIGER].wIndex = 0) then begin
    if CompareText(sJobName,sWarrior) = 0 then PlayObject.m_btJob:=jWarr;
    if CompareText(sJobName,sWizard) = 0 then PlayObject.m_btJob:=jWizard;
    if CompareText(sJobName,sTaos) = 0 then PlayObject.m_btJob:=jTaos;
    if CompareText(sJobName,sAssassin) = 0 then PlayObject.m_btJob:=jAssassin;     //자객
    if CompareText(sJobName,sBonze) = 0 then PlayObject.m_btJob:=jBonze;
    if CompareText(sJobName,sUpWarr) = 0 then PlayObject.m_btJob:=jUpWarr;
    if CompareText(sJobName,sUpWiz) = 0 then PlayObject.m_btJob:=jUpWiz;
    if CompareText(sJobName,sUpTao) = 0 then PlayObject.m_btJob:=jUpTao;
    if CompareText(sJobName,sUpAssa) = 0 then PlayObject.m_btJob:=jUpAssa;     //자객
    if CompareText(sJobName,sUpBonze) = 0 then PlayObject.m_btJob:=jUpBoz;

    PlayObject.m_btJob:= PlayObject.m_btJob;
    PlayObject.HasLevelUp2(1);
    PlayObject.RecalcAbilitys();
    PlayObject.FeatureChanged;

    PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, GetFameName(FameGrade));
    PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, GetFameName(FameGrade));

  end else
    SysMsg('뎠콱陋구擄륩、嶠포뵨麟폄돨珂빅꼇콘到뺏되鉤。',c_Red,t_Hint);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeLevel(Cmd:pTGameCmd;sParam1:String);
var
  nOLevel:Integer;
  nLevel:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,'']),c_Red,t_Hint);
    exit;
  end;

  nLevel:=Str_ToInt(sParam1,1);
  nOLevel:=m_Abil.Level;
  m_Abil.Level:=_MIN(MAXUPLEVEL,nLevel);
  HasLevelUp(1);
  if g_Config.boShowMakeItemMsg then begin
    MainOutMessage(format(g_sGameCommandLevelConsoleMsg,[m_sCharName,nOLevel,m_Abil.Level]));
  end;
end;

procedure TPlayObject.CmdChangeObMode(sCmd:String;nPermission:Integer;sParam1:String;boFlag:Boolean);
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  if boFlag then begin
     SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, ''); //01/21
  end;
  m_boObMode:=boFlag;
  if m_boObMode then begin
    SysMsg(sObserverMode,c_Green,t_Hint);
  end else  SysMsg(g_sReleaseObserverMode,c_Green,t_Hint);
end;
procedure TPlayObject.CmdChangeSabukLord(Cmd:pTGameCmd;sCastleName,sGuildName: String; boFlag: Boolean);//004CFE1C
var
  Guild:TGuild;
  Castle:TUserCastle;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;

  if (sCastleName = '') or (sGuildName = '') then begin
    SysMsg('賈痰렘랬: @' + Cmd.sCmd + ' <냘광츰> <契삔츰>',c_Red,t_Hint);
    exit;
  end;
  Castle:=g_CastleManager.Find(sCastleName);
  if Castle = nil then begin
    SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg,[sCastleName]),c_Red,t_Hint);
    exit;
  end;

  Guild:=g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    //4CFEC7
     AddGameDataLog('27' +  #9 +
                           Castle.m_sMapName + #9 +
                           IntToStr(0) + #9 +
                           IntToStr(0) + #9 +
                           sGuildName + #9 +
                           m_sCharName + #9 +
                           '0' + #9 +
                           '1' + #9 +
                           '0' + #9 + '[' + Castle.m_sName + ' 欖쥴(퓻齡)]');

    Castle.GetCastle(Guild);
    if boFlag then
      UserEngine.SendServerGroupMsg(SS_211,nServerIndex,sGuildName);
    SysMsg(sGuildName + ' 契삔欖쥴죄' +Castle.m_sName + '。',c_Green,t_Hint);
  end else begin
    SysMsg(sGuildName + ' 契삔꼇닸瞳。',c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeSalveStatus;    //부하의 행동
begin
  if m_SlaveList.Count > 0 then begin
    m_boSlaveRelax:=not m_boSlaveRelax;
    if m_boSlaveRelax then SysMsg(sPetRest1,c_Green,t_Hint)
    else SysMsg(sPetAttack1,c_Green,t_Hint)
  end;
  if (m_MyHero <> nil) then THeroObject(m_MyHero).RestHero;
end;

procedure TPlayObject.CmdChangeSuperManMode(sCmd:String;nPermission:Integer;sParam1:String;boFlag:Boolean);
begin
  if (m_btPermission < nPermission) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  m_boSuperMan:=boFlag;
  if m_boSuperMan then SysMsg(sSupermanMode,c_Green,t_Hint)
  else  SysMsg(sReleaseSupermanMode,c_Green,t_Hint);
end;


procedure TPlayObject.CmdChangeUserFull(sCmd, sUserCount: String);
var
  nCount:Integer;
begin
  if (m_btPermission < 6) then exit;
  nCount:=Str_ToInt(sUserCount,-1);
  if (sUserCount = '') or (nCount < 1) or ((sUserCount <> '') and (sUserCount[1] = '?')) then begin
    SysMsg('@' + sCmd + ' <UserCount>',c_Red,t_Hint);
    exit;
  end;
  g_Config.nUserFull:=nCount;
  SysMsg(format('륩蛟포鞫懇玆켰箏擦轢恬桓켑 %d.',[nCount]),c_Green,t_Hint);
end;


procedure TPlayObject.CmdChangeZenFastStep(sCmd, sFastStep: String);
var
  nFastStep:Integer;
begin
  if (m_btPermission < 6) then exit;
  nFastStep:=Str_ToInt(sFastStep,-1);
  if (sFastStep = '') or (nFastStep < 1) or ((sFastStep <> '') and (sFastStep[1] = '?')) then begin
    SysMsg('@' + sCmd + ' FastStep',c_Red,t_Hint);
    exit;
  end;
  g_Config.nZenFastStep:=nFastStep;
  SysMsg(format('Zen fast step changed to %d.',[nFastStep]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdClearBagItem(Cmd: pTGameCmd; sHumanName: String);    //가방정리
var
  I: Integer;
  PlayObject:TPlayObject;
  UserItem:pTUserItem;
  DelList:TStringList;
begin
  DelList:=nil;
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,' <실ッ>']),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
    
  for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
    UserItem:=PlayObject.m_ItemList.Items[I];
    if DelList = nil then DelList:=TStringList.Create;
    DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex), TObject(UserItem.MakeIndex));
    Dispose(UserItem);
  end;
  PlayObject.m_ItemList.Clear;
  if DelList <> nil then begin
    PlayObject.SendMsg(PlayObject,RM_SENDDELITEMLIST,0,Integer(DelList),0,0,'');
  end;
 // if DelList <> nil then FreeAndNil(DelList);
end;

procedure TPlayObject.CmdClearHumanPassword(sCmd:String;nPermission:Integer;sHumanName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < nPermission) then exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format('@%s <실ッ>',[sCmd]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    exit;
  end;
  PlayObject.m_boPasswordLocked:=False;
  PlayObject.m_boUnLockStoragePwd:=False;
  PlayObject.m_sSystemPwd:='';
  PlayObject.SysMsg('퀭돨꾑욋쵱쯤綠굳쓱爻',c_Green,t_Hint);
  SysMsg(format('%s돨꾑욋쵱쯤綠쒔굳쓱爻',[sHumanName]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdClearMapMonster(Cmd:pTGameCmd;sMapName, sMonName,sItems: String);
var
  I,II: Integer;
  MonList:TList;
  Envir:TEnvirnoment;
  nMonCount:Integer;
  boKillAll:Boolean;
  boKillAllMap:Boolean;
  boNotItem:Boolean;
  BaseObject:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMapName = '') or (sMonName = '') or (sItems = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <뒈暠(*=All)> <밍膠(*=All)> <膠틔(0,1)>',c_Red,t_Hint);
    exit;
  end;
  boKillAll:=False;
  boKillAllMap:=False;
  boNotItem:=True;
  nMonCount:=0;
  Envir:=nil;
  if sMonName = '*' then boKillAll:=True;
  if sMapName = '*' then boKillAllMap:=True;
  if sItems = '1' then boNotItem:=False;

  MonList:=TList.Create;
  for I := 0 to g_MapManager.Count - 1 do begin
    Envir:=TEnvirnoment(g_MapManager.Items[I]);
    if (Envir <> nil) and (boKillAllMap or (CompareText(Envir.sMapName,sMapName) = 0)) then begin
      UserEngine.GetMapMonster(Envir,MonList);
      for II := 0 to MonList.Count - 1 do begin
        BaseObject:=TBaseObject(MonList.Items[II]);
        if boKillAll or (CompareText(sMonName,BaseObject.m_sCharName) = 0) then begin
          BaseObject.m_boNoItem:=boNotItem;
          BaseObject.m_WAbil.HP:=0;
          Inc(nMonCount);
        end;
      end;
    end;
  end;
  FreeAndNil(MonList);
  if Envir = nil then begin
    SysMsg('Map not found',c_Red,t_Hint);
    exit;
  end;

  SysMsg('Objects Cleared: ' + IntTOStr(nMonCount),c_Red,t_Hint);
end;

procedure TPlayObject.CmdClearMission(Cmd:pTGameCmd;sHumanName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <Username>)',c_Red,t_Hint);
    exit;
  end;
  if sHumanName[1] = '?' then begin
    SysMsg('This command resets a persons quest flags',c_Blue,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format('%s is not online.',[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  FillChar(PlayObject.m_QuestFlag,SizeOf(TQuestFlag),#0);
  SysMsg(format('%s has had their quest flags cleared.',[sHumanName]),c_Green,t_Hint);
end;


procedure TPlayObject.CmdContestPoint(Cmd:pTGameCmd;sGuildName: String);//004CEF08             //문파 대전의 점수를 알려준다.
var
  Guild:TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sGuildName = '')  or ((sGuildName <> '') and (sGuildName[1] = '?')) then begin
    SysMsg(format('@%s <契삔츰>',[Cmd.sCmd]),c_Red,t_Hint);
    exit;
  end;
  Guild:=g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    SysMsg(format('契삔%s돨롸鑒角%d。',[sGuildName,Guild.nContestPoint]),c_Green,t_Hint);
  end else begin
    SysMsg(format('契삔%s꼇닸瞳。',[sGuildName]),c_Green,t_Hint);
  end;
end;


function TPlayObject.PetEatItemOption(StdItem:TItem):Boolean;
begin
  Result := False;

  if not (StdItem.StdMode in [48]) and (g_boItemAll = 1) then
     Result := True;
  if (StdItem.StdMode in [5,6,7,99,90]) and (g_boItemWeapon = 1) then
     Result := True;
  if (StdItem.StdMode in [10,11,12]) and (g_boItemDress = 1) then
     Result := True;
  if (StdItem.StdMode in [15]) and (g_boItemHelmet = 1) then
     Result := True;
  if (StdItem.StdMode in [62]) and (g_boItemBoots = 1) then
     Result := True;
  if (StdItem.StdMode in [64]) and (g_boItemBelt = 1) then
     Result := True;
  if (StdItem.StdMode in [19,20,21,22,23,24,26,63,101,102]) and (g_boItemAccessory = 1) then
     Result := True;
  if not (StdItem.StdMode in [5,6,7,90,99,10,11,12,15,19,20,21,22,23,24,26,48,62,64,63,101,102]) and (g_boItemEtc = 1) then
     Result := True;
end;

procedure TPlayObject.PetOption(datat:string); //영물옵션
var
  infostr : String;
  temp:     string;
begin
  datat := GetValidStr3(Datat, infostr, ['/']);
  if infostr <> '' then begin
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemAll := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemGold := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemWeapon := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemDress := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemHelmet := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemBoots := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemBelt := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemAccessory := StrToInt(temp);
     infostr := GetValidStr3(InfoStr, temp, [':']);
     g_boItemEtc := StrToInt(temp);
  end;
end;


procedure TPlayObject.SpeedCloseFunc;       //스피드핵
begin
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self,'@SpeedClose',False);
  end;
end;


procedure TPlayObject.ChangeItem(datat:string);  //변환
var
  i,ii:integer;
  Items: array[1..6] of TItem;
  UserItems: array[1..6] of pTUseritem;
  UserItems1: array[1..6] of pTUseritem;
  GemName: String;
  Itemindexs: Array[1..6] of integer;
  tmpString : String;
  TmpItem:pTUserItem;
  loopcount,loopcount2: integer;

  ListString: String;

  StdItem: TItem;
  UserItem: pTUserItem;
  List:TStringList;

  ClientItem:TClientItem;

  sUserItemName: string;
  sCheckItemName: string;
  iJob, j:integer;
  boot: Boolean;
begin
  loopcount :=0;
  for i := 1 to 6 do begin
    tmpString:='';
    ItemIndexs[i]:=0;
    Datat:=GetValidStr3(Datat, tmpString, ['/']);
    if tmpString = '' then CraftFailed('Client cheat detected');
    ItemIndexs[i] := StrToInt64(tmpString);
    if ItemIndexs[i] <> 0 then
      inc(loopcount);
  end;
  loopcount2 := loopcount;
  for i := 0 to m_ItemList.Count - 1 do begin
    TmpItem:=m_ItemList.Items[i];
    if TmpItem = nil then continue;
    for ii := 1 to 6 do begin
      if TmpItem.MakeIndex = ItemIndexs[ii] then begin
        Items[loopcount]:= UserEngine.GetStdItem(TmpItem.wIndex);
        UserItems[loopcount]:= TmpItem;
        dec(loopcount);
      end;
    end;
  end;


  for i := 1 to loopcount2 do begin

    sUserItemName := UserEngine.GetStdItemName(UserItems[i].wIndex); //Items[i].Name;
    sCheckItemName := '';

    List := GetChangeItemJob(sUserItemName,m_btJob);

    if List <> nil then begin
      for j:= 0 to List.Count-1 do begin
        sCheckItemName := List[j];
      end;
      New(UserItems1[i]);
      if Items[i].ChangeItem then begin
        //if Items[i].Name = sUserItemName then begin
          if UserEngine.CopyToUserItemFromName(sCheckItemName,UserItems1[i]) then begin
            StdItem :=UserEngine.GetStdItem(UserItems1[i].wIndex);

            StdItem.ChangeItemUpgrade (UserItems1[i], UserItems[i], 2);

            AddItemToBag(UserItems1[i],boot);
            if boot then
            SendAddItem(UserItems1[i],1);
            WeightChanged();

            SysMsg('膠틔' + sUserItemName + '돨츰俚뫘맣槨' + StdItem.Name + '。',c_Red,t_Hint);

            DelBagItem(UserItems[i].MakeIndex, sUserItemName);

            m_DefMsg:=MakeDefaultMsg(SM_CHANGESYSTEMOK,0,0,0,0);
            SendSocket(@m_DefMsg,'');
          end else begin
            SysMsg('膠틔' + sUserItemName + '돨츰俚츰俚꼇콘맣긴。',c_Red,t_Hint);
            m_DefMsg:=MakeDefaultMsg(SM_CHANGESYSTEM_FAIL,0,0,0,0);
            SendSocket(@m_DefMsg,'');
            ClientQueryBagItems(VerInfoStr4);
          end;
      //  end;
      end else begin
        SysMsg('膠틔' + sUserItemName + '돨츰俚츰俚꼇콘맣긴。',c_Red,t_Hint);
        m_DefMsg:=MakeDefaultMsg(SM_CHANGESYSTEM_FAIL,0,0,0,0);
        SendSocket(@m_DefMsg,'');
        ClientQueryBagItems(VerInfoStr4);
      end;
    end else begin
       SysMsg('膠틔' + sUserItemName + '돨츰俚츰俚꼇콘맣긴。',c_Red,t_Hint);
       m_DefMsg:=MakeDefaultMsg(SM_CHANGESYSTEM_FAIL,0,0,0,0);
       SendSocket(@m_DefMsg,'');
       ClientQueryBagItems(VerInfoStr4);
    end;
  end;
end;

procedure TPlayObject.GemItemFail(UserItem:pTUserItem;msg:String);         //보옥(구 시스템)
begin
  SendMsg(Self,RM_MENU_OK,0,Integer(self),0,0,msg);
  SendAddItem(UserItem,1);
end;

function TPlayObject.GemItem(Gem:Integer;Itemidx:integer):integer;       //보옥(구 시스템)
var
  UserItem,GemUserItem:pTUserItem; //the 'real item stats'
  Uitem, GItem: TItem; //the db item stats
  i: integer;
  StatType: byte;
  SuccesRate: integer;
  BreakItem: boolean;
  Succes: boolean;
  intact:boolean;
  ItmeNames: string;
  DuraAdd: Integer;
begin
Result:=1;
ItmeNames := '';
  if (Gem = Itemidx) or (Gem = 0) or (Itemidx = 0) then begin
    SendMsg(Self,RM_MENU_OK,0,Integer(self),0,0,'꼇콘薨똥旱〉켑鮎래');
    exit; //cant be that the gem is also the item we using so :p
  end;

{find out what item we geming and what gem we using}
  for I := 0 to m_ItemList.Count - 1 do begin
    if pTUserItem(m_ItemList[i]).MakeIndex = Gem then //gem we using
      GemUserItem:= m_ItemList[i];
    if pTUserItem(m_ItemList[i]).MakeIndex = Itemidx then           // item we geming
      UserItem:= m_ItemList[i];
  end;
  GItem:=UserEngine.GetStdItem(GemUserItem.wIndex);
  UItem:=UserEngine.GetStdItem(UserItem.wIndex);
{check if all the items truly exist}
  if (GItem = nil) or (GemUserItem = nil) then begin
    SendMsg(Self,RM_MENU_OK,0,Integer(self),0,0,'괜柯、괜瀧句呵죄。');
    exit;
  end;
  if (Uitem = nil) or  (UserITem = nil) then begin
    GemItemFail(GemUserItem,'膠틔팎鉅죄。');
    exit;
  end;
{check if the gem used is allowed on the item we using it on}
  if (UItem.Unique) or (UserItem.btValue[19] = 1) or (UserItem.btValue[19] > 2) then begin      //대여템 봉인 보옥 x
    if (UItem.Unique) then
      SysMsg('景喝膠틔꼇콘薨땀', c_Red,t_Hint);
    if (UserItem.btValue[19] = 1) then
      SysMsg('理줏돨膠틔꼇콘薨땀', c_Red,t_Hint);
    if (UserItem.btValue[19] > 2) then
      SysMsg('룐丹돨膠틔꼇콘薨땀', c_Red,t_Hint);
    exit; //cant be that the gem is also the item we using so :p
  end;
  stattype:= GItem.AC;
  case GItem.AC of
    0,1,2: begin // dc,mc,sc
      if not (UItem.StdMode in [5,6,90,19,20,21,22,23,24,26,99]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    3,4: begin  //ac, amc
      if not (UItem.StdMode in [10,11,12,15,22,23,24,26,62,64]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    5: begin  //aspeed
      if not (UItem.StdMode in [5,6,90,19,20,21,22,23,99]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    6: begin //agil
      if not (UItem.StdMode in [10,11,12,24,26,62,64]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    7: begin  //dura
      if not (UItem.StdMode in [5,6,10,11,12,15,19,20,21,22,23,24,26,62,64,90,99]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    8: begin //중독저항
      if not (UItem.StdMode in [10,11,12,15,64]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    9,14: begin //poison,freezing
      if not (UItem.StdMode in [5,6,19,20,21,22,23,90,99]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
    15: begin //acc
      if not (UItem.StdMode in [15,19,20,21,24,26,64]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;

    12: begin //antimagic
      if not (UItem.StdMode in [10,11,12,15,19,20,21]) then begin
        SysMsg('늪膠틔轟랬薨떫권걺轍棹', c_Red,t_Hint);
        exit; //cant be that the gem is also the item we using so :p
      end;
    end;
  end;
{get succes rate and stuff}
  SuccesRate:= GItem.AC2;
  BreakItem:=FALSE;
  intact:=FALSE;
  if GItem.MAC = 0 then
   BreakItem:=TRUE;
   Succes:=TRUE;

{now add the stat to the item}
  if Succes then begin //if the gem worked
    case stattype of
      0,1,2,3,4,9: begin //파괴 마법 도력 방어 마법방어 중독
        if Random(40) <= SuccesRate - UserItem.btValue[StatType] then begin
          Succes:=FALSE;
          BreakItem:=False;
        end else
        if Random(10) <= SuccesRate - UserItem.btValue[StatType] then begin
          inc(UserItem.btValue[StatType],_MAX(1,Random(GItem.MAC2)));
        end else
          Succes:=FALSE;
      end;

      5: begin //공속
        if UItem.StdMode in [5,6,99,90] then begin//무기 btvalue 6 사용 그리고  공속 +/- 시스템 (값 10 > +, 값 10 > -)
          if UserItem.btValue[6] > 10 then begin
            if Random(40) <= SuccesRate - (UserItem.btValue[6] - 10) then begin
              BreakItem:=False;
              Succes:=FALSE;
            end else
            if Random(10) <= SuccesRate - (UserItem.btValue[6] - 10) then begin
              UserItem.btValue[6] := ItemUnit.UpgradeAttackSpeed( UserItem.btValue[6], _MAX(1,Random(GItem.MAC2)) );
            end else
              Succes:=FALSE;
          end else begin
            if Random(40) <= SuccesRate then begin
             Succes:=FALSE;
             BreakItem:=False;
            end else
            if Random(10) <= SuccesRate then begin
              UserItem.btValue[6] := ItemUnit.UpgradeAttackSpeed( UserItem.btValue[6], _MAX(1,Random(GItem.MAC2)) );
            end else
            Succes:=FALSE;
          end;
        end else
        if UItem.StdMode in [19,20,21] then begin //목걸이
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[17]) then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[17]) then begin
            inc(UserItem.btValue[17],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else begin //반지
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[16]) then begin
          BreakItem:=False;
          Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[16]) then begin
            inc(UserItem.btValue[16],_MAX(1,Random(GItem.MAC2)));
          end else
          Succes:=FALSE;
        end;
      end;

      6: begin //회피
        if UItem.StdMode in [10,11,12] then begin //옷
          if Random(40) <= SuccesRate - UserItem.btValue[StatType] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[StatType] then begin
            inc(UserItem.btValue[StatType],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else begin //팔찌 허리띠 신발
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[16]) then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[16]) then begin
            inc(UserItem.btValue[16],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end;
      end;

      7: begin //내구
        if Random(40) <= SuccesRate - (_MAX(0,(UserItem.DuraMax div 1000) - (UItem.DuraMax div 1000)) div 2) then begin
          BreakItem:=False;
          Succes:=FALSE;
        end else
        if Random(10) <= SuccesRate - (_MAX(0,(UserItem.DuraMax div 1000) - (UItem.DuraMax div 1000)) div 2) then begin
          DuraAdd:= (GItem.MAC2 * 1000); //Babyhack thanks to Sean
          if (UserItem.DuraMax + DuraAdd) > high(UserItem.DuraMax) then begin
            UserItem.DuraMax := high(UserItem.DuraMax);
          end else
            inc(UserItem.DuraMax, DuraAdd);
        end else
          Succes:=FALSE;
      end;

      8: begin //중독저항
        if UItem.StdMode in [64] then begin //벨트
          if Random(40) <= SuccesRate - UserItem.btValue[StatType] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[StatType] then begin
            inc(UserItem.btValue[StatType],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else
        if UItem.StdMode in [10,11,12] then begin //옷
          if Random(40) <= SuccesRate - UserItem.btValue[7] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[7] then begin
            inc(UserItem.btValue[7],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else begin //투구
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[9]) then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[9]) then begin
            inc(UserItem.btValue[9],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end;
      end;

      12: begin //마법저항
        if UItem.StdMode in [19,20,21] then begin //목걸이
          if Random(40) <= SuccesRate - UserItem.btValue[StatType] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[StatType] then begin
            inc(UserItem.btValue[StatType],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else
        if UItem.StdMode in [15] then begin //투구
          if Random(40) <= SuccesRate - UserItem.btValue[10] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[10] then begin
            inc(UserItem.btValue[10],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else begin //옷
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[8]) then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[8]) then begin
            inc(UserItem.btValue[8],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end;
      end;

      14: begin //혹한 둔화
        if UItem.StdMode in [5,6,90,99] then begin //무기
          if Random(40) <= SuccesRate - UserItem.btValue[8] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[8] then begin
            inc(UserItem.btValue[8],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else begin //목걸이 반지
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[StatType]) then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[StatType]) then begin
            inc(UserItem.btValue[StatType],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end;
      end;

      15: begin //정확
        if UItem.StdMode in [19,20,21,24,26,64] then begin //목걸이 팔찌 허리띠
          if Random(40) <= SuccesRate - UserItem.btValue[StatType] then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - UserItem.btValue[StatType] then begin
            inc(UserItem.btValue[StatType],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end else begin //투구
          if Random(40) <= SuccesRate - LoByte(UserItem.btValue[8]) then begin
            BreakItem:=False;
            Succes:=FALSE;
          end else
          if Random(10) <= SuccesRate - LoByte(UserItem.btValue[8]) then begin
            inc(UserItem.btValue[8],_MAX(1,Random(GItem.MAC2)));
          end else
            Succes:=FALSE;
        end;
      end;


    end;
  end;
{take away the used up orb + if a gem the failed item}
 { for i := 0 to m_ItemList.Count - 1 do begin //taking away our gem
    if pTUserItem(m_ItemList[i]).MakeIndex = GemUserItem.MakeIndex then begin
      m_ItemList.Delete(i);
      break
    end;
  end;
  Dispose(GemUserItem);   }
  QuestTakeCheckItem (GemUserItem);
  if (not Succes) and (BreakItem) then begin //if the orbing/geming failed and the item should break then take it away
    SendDelItems(UserItem);
    for i := 0 to m_ItemList.Count - 1 do begin
      if pTUserItem(m_ItemList[i]).MakeIndex = UserItem.MakeIndex then begin
        m_ItemList.Delete(i);
        break
      end;
    end;            //QuestTakeCheckItem (puJewelry);
    SendDefMessage (SM_UPGRADEITEM_RESULT, UserItem.MakeIndex , 2, 0, 0, UItem.Name);    //보옥
    Dispose(UserItem);
    ItmeNames := FilterStdShowName2(UItem, UItem.Name);
    SysMsg('膠틔('+ItmeNames+')팎鉅죄。', c_Red, t_Hint);


    if GItem.NeedIdentify = 1 then
      AddGameDataLog('38' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     GItem.Name + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[괜柯/괜瀧 묑샌]');

    exit;
  end;
  if succes then begin
    SendUpdateItem(UserItem);
    //클라이언트로 결과 메시지 전송.
    SendDefMessage (SM_UPGRADEITEM_RESULT, UserItem.MakeIndex , 2, 0, 0, UItem.Name);    //보옥
    ItmeNames := FilterStdShowName2(UItem, UItem.Name);
    case GItem.AC of
      0: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，묑샌돤돕죄'+ IntToStr(GItem.MAC2) + '듐돨瓊爻', c_Blue,t_Hint);
      1: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，침랬돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      2: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，돛減돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      3: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，렝徒돤돕죄 '+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      4: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，침랬렝徒돤돕죄 '+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      5: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，묑샌醵똑돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      6: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，츌쌥돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      7: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，넣씹돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      8: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，뗀膠뜰긁돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
      9: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，徠덤롤돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
     12: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，침랬뜰긁돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
     14: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，숑醵돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
     15: SysMsg(''+ItmeNames+'랙놔寧돛鈺縕돨좋밟，硫횅돤돕죄'+ IntToStr(GItem.MAC2) +'듐돨瓊爻', c_Blue,t_Hint);
    end;

    if GItem.NeedIdentify = 1 then
      AddGameDataLog('36' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     GItem.Name + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[괜柯/괜瀧 냥묘]');

  end else begin
    ItmeNames := FilterStdShowName2(UItem, UItem.Name);
    SysMsg(''+ItmeNames+'청唐랙虛觀慣餓。', c_Green,t_Hint);
    SendDefMessage (SM_UPGRADEITEM_RESULT, UserItem.MakeIndex , 2, 0, 0, UItem.Name);    //보옥

     if GItem.NeedIdentify = 1 then
      AddGameDataLog('37' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     GItem.Name + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[괜柯/괜瀧 呵겨]');
  end;
end;


procedure TPlayObject.CraftFailed(datat:string);
begin
  SendMsg(Self,RM_MENU_OK,0,Integer(self),0,0,datat);
end;

procedure TPlayObject.RecallGuild();    //장원 전체 소환
var
  I,II,s: Integer;
  dwValue:LongWord;
  PlayObject:TPlayObject;
  GuildRank:pTGuildRank;
  nRecallCount,nNoRecallCount:Integer;
  nx, ny, dx, dy: integer;
  number:integer;
  Envir:TEnvirnoment;
begin
  nRecallCount:=0;
  nNoRecallCount:=0;
  envir:=nil;
  dwValue:=(GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick:=m_dwGroupRcallTick + dwValue * 1000;

  if m_wGroupRcallTime > dwValue then begin
    Dec(m_wGroupRcallTime,dwValue);
  end else m_wGroupRcallTime:=0;

  if m_wGroupRcallTime > 0 then begin
    SysMsg(format('%d취鹿빈옵鹿疼늴賈痰契삔梁뻥묘콘。',[m_wGroupRcallTime]),c_Red,t_Hint);
    exit;
  end;
  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    for II:=0 to GuildRank.MemberList.Count -1 do begin
      PlayObject:=TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject <> nil then begin
        if PlayObject = Self then begin
          Continue;
        end;
        if PlayObject.m_boAllowGuildReCall then begin
          if PlayObject.m_PEnvir.Flag.boNORECALL then begin
            SysMsg(format('뒈暠%s꼇豚冀契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
          end else begin
            RecallHuman(PlayObject.m_sCharName);
            Inc(nRecallCount);
          end;
        end else begin
          Inc(nNoRecallCount);
          SysMsg(format('%s앳없契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
        end;
      end;
    end;
  end;
  SysMsg(format('梁뻥훙:%d，뒈暠梁뻥훙:%d',[nRecallCount,nNoRecallCount]),c_Green,t_Hint);
  m_dwGroupRcallTick:=GetTickCount();
  m_wGroupRcallTime:=g_Config.nGuildRecallTime;
end;

procedure TPlayObject.RecallGuildGT();    //장원 전체 소환
var
  I,II,s: Integer;
  dwValue:LongWord;
  PlayObject:TPlayObject;
  GuildRank:pTGuildRank;
  nRecallCount,nNoRecallCount:Integer;
  number:integer;
  Envir:TEnvirnoment;

  nX,nY,n18,n1C:Integer;
begin
  nRecallCount:=0;
  nNoRecallCount:=0;
  envir:=nil;
  dwValue:=(GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick:=m_dwGroupRcallTick + dwValue * 1000;

  if m_wGroupRcallTime > dwValue then begin
    Dec(m_wGroupRcallTime,dwValue);
  end else m_wGroupRcallTime:=0;

  if m_wGroupRcallTime > 0 then begin
    SysMsg(format('%d취鹿빈옵鹿疼늴賈痰契삔梁뻥묘콘。',[m_wGroupRcallTime]),c_Red,t_Hint);
    exit;
  end;
  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    for II:=0 to GuildRank.MemberList.Count -1 do begin
      PlayObject:=TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject <> nil then begin
        if PlayObject = Self then begin
          Continue;
        end;
        if PlayObject.m_boAllowGuildReCall then begin
          if PlayObject.m_PEnvir.Flag.boNORECALL then begin
            SysMsg(format('뒈暠%s꼇豚冀契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
          end else begin
          if GetFrontPosition(nX,nY) then begin
            if sub_4C5370(nX,nY,3,n18,n1C) then begin
             if PlayObject.CallToGT(TTerritory(TGuild(PlayObject.m_MyGuild).m_Territory).TerritoryNumber,n18,n1C) then
               Inc(nRecallCount);
             end;
            end else begin
               SysMsg('뎠품貫零轟랬梁뻥。',c_Red,t_Hint);
            end;
          end;
        end else begin
          Inc(nNoRecallCount);
          SysMsg(format('%s앳없契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
        end;
      end;
    end;
  end;
  SysMsg(format('梁뻥훙:%d，뒈暠梁뻥훙:%d',[nRecallCount,nNoRecallCount]),c_Green,t_Hint);
  m_dwGroupRcallTick:=GetTickCount();
  m_wGroupRcallTime:=g_Config.nGuildRecallTime;
end;


procedure TPlayObject.IndividualGuildGT(sHuman: string);    //장원 개인 소환
var
  PlayObject:TPlayObject;
  nX,nY,n18,n1C:Integer;
begin
  if TGuild(m_MyGuild).IsMember(sHuman) then begin
    PlayObject:=UserEngine.GeTPlayObject(sHuman);
    if PlayObject <> nil then begin
        if PlayObject.m_boAllowGuildReCall then begin
          if PlayObject.m_PEnvir.Flag.boNORECALL then begin
            SysMsg(format('뒈暠%s꼇豚冀契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
          end else begin
            if GetFrontPosition(nX,nY) then begin
              if sub_4C5370(nX,nY,3,n18,n1C) then begin
               if PlayObject.CallToGT(TTerritory(TGuild(PlayObject.m_MyGuild).m_Territory).TerritoryNumber,n18,n1C) then
              end;
            end else begin
                 SysMsg('뎠품貫零轟랬梁뻥。',c_Red,t_Hint);
            end;
          end;
        end else begin
          SysMsg(format('%s앳없契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
        end;
    end else begin
       SysMsg (sHuman + '꼇瞳窟。',c_Red,t_Hint);
    end;
  end else begin
    SysMsg ('콱꼇角契삔냥逃。',c_Red,t_Hint);
  end;
end;


procedure TPlayObject.CmdStartContest(Cmd:pTGameCmd;sParam1:String);//004CF008
var
  I,II: Integer;
  List10,List14:TList;
  PlayObject,PlayObjectA:TPlayObject;
  bo19:Boolean;
  s20:String;
  Guild:TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    //SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg('契삔濫轢綠쒔역迦죄...',c_Red,t_Hint);
    SysMsg(format('꽝宅契삔: @%s',[Cmd.sCmd]),c_Red,t_Hint);
    exit;
  end;

  if not m_PEnvir.Flag.boFight3Zone then begin
    SysMsg('侶꼇角契삔濫轢혐堵혐堵...',c_Red,t_Hint);
    exit;
  end;
  List10:=TList.Create;
  List14:=TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir,m_nCurrX,m_nCurrY,1000,List10);
  for I := 0 to List10.Count - 1 do begin
    PlayObject:=TPlayObject(List10.Items[I]);
    PlayObject.RefNameColor();
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then begin
      PlayObject.m_nFightZoneDieCount:=0;
      if PlayObject.m_MyGuild = nil then Continue;
      bo19:=False;
      for II := 0 to List14.Count - 1 do begin
        PlayObjectA:=TPlayObject(List14.Items[II]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19:=True;
      end;
      if not bo19 then begin
        List14.Add(PlayObject.m_MyGuild);
      end;        
    end;
  end;
  SysMsg('攣瞳쏵契契삔濫轢。',c_Green,t_Hint);
  UserEngine.CryCry(RM_CRY,m_PEnvir,m_nCurrX,m_nCurrY,1000,g_Config.btCryMsgFColor,g_Config.btCryMsgBColor,' - 攣瞳쏵契契삔濫轢。');
  s20:='';
  for I := 0 to List14.Count - 1 do begin
    Guild:=TGuild(List14.Items[I]);
    Guild.StartTeamFight();
    for II := 0 to List10.Count - 1 do  begin
      PlayObject:=TPlayObject(List10.Items[I]);
      if PlayObject.m_MyGuild = Guild then begin
        Guild.AddTeamFightMember(PlayObject.m_sCharName);
      end;
    end;
    s20:=s20 + Guild.sGuildName + ' ';
  end;
  UserEngine.CryCry(RM_CRY,m_PEnvir,m_nCurrX,m_nCurrY,1000,g_Config.btCryMsgFColor,g_Config.btCryMsgBColor,' - 꽝宅契삔: ' + s20);
  FreeAndNil(List10);
  FreeAndNil(List14);
end;

procedure TPlayObject.CmdEndContest(Cmd:pTGameCmd;sParam1:String);//004CF364
var
  I,II: Integer;
  List10,List14:TList;
  PlayObject,PlayObjectA:TPlayObject;
  bo19:Boolean;
  Guild:TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg('契삔濫轢綠쒔써監죄...',c_Red,t_Hint);
    SysMsg(format('박엊契삔: @%s',[Cmd.sCmd]),c_Red,t_Hint);
    exit;
  end;

  if not m_PEnvir.Flag.boFight3Zone then begin
    SysMsg('契삔濫轢怜콘瞳댕뒈暠쏵契。',c_Red,t_Hint);
    exit;
  end;
  List10:=TList.Create;
  List14:=TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir,m_nCurrX,m_nCurrY,1000,List10);
  for I := 0 to List10.Count - 1 do begin
    PlayObject:=TPlayObject(List10.Items[I]);
    PlayObject.RefNameColor();
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then begin
      if PlayObject.m_MyGuild = nil then Continue;
      bo19:=False;
      for II := 0 to List14.Count - 1 do begin
        PlayObjectA:=TPlayObject(List14.Items[II]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19:=True;
      end;
      if not bo19 then begin
        List14.Add(PlayObject.m_MyGuild);
      end;        
    end;
  end;
  for I := 0 to List14.Count - 1 do begin
    Guild:=TGuild(List14.Items[I]);
    Guild.EndTeamFight();
    UserEngine.CryCry(RM_CRY,m_PEnvir,m_nCurrX,m_nCurrY,1000,g_Config.btCryMsgFColor,g_Config.btCryMsgBColor,format(' - %s契삔宅콱돨契삔돨濫轢써監죄。',[Guild.sGuildName]));
  end;
  FreeAndNil(List10);
  FreeAndNil(List14);
end;

procedure TPlayObject.CmdAnnouncement(Cmd:pTGameCmd;sGuildName: String);//004CF564
var
  I: Integer;
  Guild:TGuild;
  sHumanName:String;
  nPoint:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then begin
    //SysMsg('FixMsg[559]',c_Red,t_Hint);
    SysMsg(format('賈痰렘랬: @%s <契삔츰>',[Cmd.sCmd]),c_Red,t_Hint);
    exit;
  end;

  if not m_PEnvir.Flag.boFight3Zone then begin
    SysMsg('契삔濫轢생롸쏭瞳契삔濫뒈暠무꼈。',c_Red,t_Hint);
    exit;
  end;
  Guild:=g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '------------------------------------');
    UserEngine.CryCry(RM_CRY,m_PEnvir,m_nCurrX,m_nCurrY,1000,g_Config.btCryMsgFColor,g_Config.btCryMsgBColor,format(' - %s契삔돨契삔濫생롸무꼈',[Guild.sGuildName]));
    for I := 0 to Guild.TeamFightDeadList.Count - 1 do begin
      nPoint:=Integer(Guild.TeamFightDeadList.Objects[I]);
      sHumanName:=Guild.TeamFightDeadList.Strings[I];
      UserEngine.CryCry(RM_CRY,
                        m_PEnvir,
                        m_nCurrX,
                        m_nCurrY,
                        1000,
                        g_Config.btCryMsgFColor,
                        g_Config.btCryMsgBColor,
                        format(' - %s  :삿돤契삔생롸鑒 %d / 价空늴鑒 %d',[sHumanName,HiWord(nPoint),LoWord(nPoint)]));
    end;
    UserEngine.CryCry(RM_CRY,
                        m_PEnvir,
                        m_nCurrX,
                        m_nCurrY,
                        1000,
                        g_Config.btCryMsgFColor,
                        g_Config.btCryMsgBColor,
                        format(' - [%s] 삿돤契삔생롸鑒: %d',[Guild.sGuildName,Guild.nContestPoint]));
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '------------------------------------');
  end;
end;

procedure TPlayObject.CmdAllowGroupReCall(sCmd, sParam: String);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('豚冀 [豚冀莖뒈북寧]',c_Red,t_Hint);
    exit;
  end;

  m_boAllowGroupReCall:= not m_boAllowGroupReCall;      //천지합일
  SendMsg(Self,RM_GROUPCALL,0,0,0,0,'');
  if m_boAllowGroupReCall then SysMsg(g_sEnableGroupRecall,c_Green,t_Hint)
  else SysMsg(g_sDisableGroupRecall,c_Green,t_Hint);
end;



procedure TPlayObject.CmdDearRecall(sCmd: String);         //연인 스쳐 이동
Var
 i :Integer;
 flag :Boolean;
 pstd :TItem;
begin
   flag := FALSE;
   if fLover <> nil then begin
        //만난지 10일 이상 되어야 사용 가능
      if fLover.GetLoverName <> '' then begin
         if Str_ToInt(fLover.GetLoverDays, 0) >= 1 then begin
            //커플반지 착용 체크
            for i:=0 to U_CHARM do begin
              pstd := UserEngine.GetStdItem(m_UseItems[i].wIndex);
                 if pstd <> nil then begin
                   if (pstd.StdMode = 22) and (pstd.Shape = 120) then begin
                      if GetTickCount - m_dwLoveRecallTick > g_Config.nLoverRecallTime * 1000 then begin
                        flag := TRUE;  //아이템과 날짜 조건이 맞음.
                           if CmdLoverCharSpaceMove ( fLover.GetLoverName ) then begin     //연인 스쳐 이동
                              m_dwLoveRecallTick := GetTickCount;
                           end;
                      end else begin
                        flag := TRUE;  //미착용 메시지를 출력하지 않음.
                        SysMsg('君瞳꼇콘賈痰，' + IntToStr(g_Config.nLoverRecallTime -
                           (GetTickCount - m_dwLoveRecallTick) div 1000) + '취鹿빈옵鹿疼늴賈痰。',c_Red,t_Hint);
                      end;
                      break;
                   end;
                 end;
            end;
         end else begin
           flag := TRUE;  //미착용 메시지를 출력하지 않음.
         end;
      end else begin
        flag := TRUE;  //미착용 메시지를 출력하지 않음.
      end;
   end;
   if not flag then begin
     flag := FALSE;
     SysMsg('콱矜狼톡덖헙쩟썰寧꼽콘賈痰。', c_Red,t_Hint);
   end;
   exit;
end;

procedure TPlayObject.CmdCharSpaceMove (CharName_: string);
var
   hum : TPlayObject;
   svidx : integer;
begin
   hum := UserEngine.GetPlayObject( Charname_ );

   if hum <> nil then begin
     if not (hum.m_PEnvir.Flag.boNODEARRECALL) then begin
       SpaceGTMoveEX( hum.m_PEnvir.sMapName , hum.m_nCurrX , hum.m_nCurrY + 1 , 0, m_PEnvir.Flag.nGuildTerritory);
     end;
   end else begin
     SysMsg (CharName_ + '꼇瞳窟。', c_Red,t_Hint);
   end;

end;

function TPlayObject.CmdLoverCharSpaceMove (CharName_: string): Boolean;   //연인 스쳐 이동
var
   hum : TPlayObject;
   svidx : integer;
begin
   Result := FALSE;
   hum := UserEngine.GetPlayObject( Charname_ );

   if hum <> nil then begin
      // 연인이 NoRecall 지역에 있으면 갈 수 없음.
      if not (hum.m_PEnvir.Flag.boNODEARRECALL) then begin
         SpaceGTMoveEX( hum.m_PEnvir.sMapName , hum.m_nCurrX , hum.m_nCurrY + 1 , 0, m_PEnvir.Flag.nGuildTerritory);
         Result := TRUE;
      end;
   end else begin
       SysMsg (CharName_ + '꼇瞳窟。', c_Red,t_Hint);
   end;

end;


procedure TPlayObject.CmdBreakLoverRelation;     //연인 스쳐 해제
var
   svidx : Integer;
   ReqType : integer;
   OtherName : string;
   hum : TPlayObject;
   strPayment : string;
begin
   // 위자료 낼 돈이 있는지 확인
   if m_nGold < COMPENSATORY_PAYMENT_ONEWAY then begin
      strPayment := IntToStr(COMPENSATORY_PAYMENT_ONEWAY div 10000);
      BoxMsg('잼삯矜狼連마' + strPayment + '쏜귑돨跨獨쏜。', 0);
      exit;
   end;

   if fLover = nil then exit;

   OtherName := fLover.GetLoverName;
   if OtherName = '' then exit;

   ReqType := RsState_Lover;

   //연인 일방 해제(2004/12/13)
   if RelationShipDeleteOther( ReqType , OtherName ) then begin

      //위자료 지불
      if m_nGold >= COMPENSATORY_PAYMENT_ONEWAY then begin
         DecGold(COMPENSATORY_PAYMENT_ONEWAY);
         GoldChanged;
      end;
      //상태 변경(둔화)
      MakePosion( POISON_SLOWDOWN , 3 ,1 );
      //HP, MP 변경(10%)
      m_WAbil.HP := _MAX(1, m_WAbil.HP div 10);
      m_WAbil.MP := _MAX(1, m_WAbil.MP div 10);

      //충격 메시지
      SysMsg('콱잼삯죄，잼삯돨댔샌賈돨餉篁돎羔㎎ⓙ돕도皐匣', c_Red,t_Hint);

      hum := UserEngine.GetPlayObject( OtherName );
      if hum <> nil then begin
         hum.RelationShipDeleteOther( ReqType , m_sCharName );

         //로그남김
        { AddUserLog ('47'#9 + //연인_
                     m_sMapName + ''#9 +
                     IntToStr(m_nCurrX) + ''#9 +
                     IntToStr(m_nCurrY) + ''#9 +
                     m_sCharName + ''#9 +
                     '0'#9 +
                     '0'#9 +
                     '1'#9 +  //일방해제:1
                     OtherName);    }
         ///////////////////////////////////////////////////////////
         //일방적인 해제인 경우에는 상대에게 충격이 전해지지 않음.
         ///////////////////////////////////////////////////////////
      end else begin
         Self.ServerSetRelationDBChange(OtherName , intToStr(RsState_LoverEnd));
      end;

   end else begin
      SendDefMessage (SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
   end;
end;




procedure TPlayObject.CmdDelBonuPoint(Cmd:pTGameCmd;sHumName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sHumName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ>',c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    FillChar(PlayObject.m_BonusAbil,SizeOf(TNakedAbility),#0);
    PlayObject.m_nBonusPoint:=0;
    PlayObject.SendMsg (PlayObject,RM_ADJUST_BONUS,0,0,0,0,'');
    PlayObject.HasLevelUp3(0);
    PlayObject.SysMsg('쉽쟨생롸綠굳쓱爻',c_RedWhite,t_Hint);
    SysMsg(sHumName + '돨쉽쟨생롸綠굳쓱爻',c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdReNewLevel(Cmd:pTGameCmd;sHumanName, sLevel: String);     //전직
var
  PlayObject:TPlayObject;
  nLevel:Integer;
begin
  if (m_btPermission < 6) then exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <된섬>',c_Red,t_Hint);
    exit;
  end;
  nLevel:=Str_ToInt(sLevel,-1);
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    if (nLevel >= 0) and (nLevel <= 255) then begin
      PlayObject.m_btReLevel:=nLevel;
      PlayObject.RefShowName();
    end;
    SysMsg(sHumanName + '된섬錦맣供귄。' + IntToStr(PlayObject.m_btReLevel),c_Green,t_Hint);
  end else begin
    SysMsg(sHumanName + '꼇瞳窟。',c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdRestBonuPoint(Cmd:pTGameCmd;sHumName: String);
var
  PlayObject:TPlayObject;
  nTotleUsePoint:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sHumName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ>',c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    nTotleUsePoint:=PlayObject.m_BonusAbil.DC +
                    PlayObject.m_BonusAbil.MC +
                    PlayObject.m_BonusAbil.SC +
                    PlayObject.m_BonusAbil.AC +
                    PlayObject.m_BonusAbil.MAC +
                    PlayObject.m_BonusAbil.HP +
                    PlayObject.m_BonusAbil.MP +
                    PlayObject.m_BonusAbil.Hit +
                    PlayObject.m_BonusAbil.Speed +
                    PlayObject.m_BonusAbil.X2;
    FillChar(PlayObject.m_BonusAbil,SizeOf(TNakedAbility),#0);

    if (nTotleUsePoint > g_Config.nBonusPointHack) then begin    //보너스포인트 핵
      MainOutMessage('[賈痰렷랬넋埼]쉽쟨생롸: ' + GetGoldStr(nTotleUsePoint) + ' 실: ' + PlayObject.m_sCharName
        + ' ID : ' + PlayObject.m_sUserID + ' [IP : ' + PlayObject.m_sIPaddr + ']');

      PlayObject.m_nBonusPoint := 0;
      SysMsg('[생롸賈痰쇱꿎]' + sHumName + '뚝뻣죄쉽쟨생롸。',c_Red,t_Hint);
    end;

    Inc(PlayObject.m_nBonusPoint,nTotleUsePoint);
    PlayObject.SendMsg (PlayObject,RM_ADJUST_BONUS,0,0,0,0,'');
    PlayObject.HasLevelUp3(0);
    PlayObject.SysMsg('固셕斤口쉥路零。',c_RedWhite,t_Hint);
    SysMsg(sHumName + '돨斤口綠쒔路零。',c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdSbkDoorControl(sCmd, sParam: String);
begin

end;


procedure TPlayObject.CmdSetPermission(Cmd:pTGameCmd;sHumanName,sPermission: String);
var
  nPerission:Integer;
  PlayObject:TPlayObject;
ResourceString
  sOutFormatMsg = '[홈掘긴뫘] %s (%s %d -> %d)';
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  nPerission:=Str_ToInt(sPermission,0);
  if (sHumanName = '') or not (nPerission in [0..10]) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <홈掘된섬(0 - 10)>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  if g_Config.boShowMakeItemMsg then
    MainOutMessage(format(sOutFormatMsg,[m_sCharName,PlayObject.m_sCharName,PlayObject.m_btPermission,nPerission]));
  PlayObject.m_btPermission:=nPerission;
  SysMsg(sHumanName + '돨홈掘된섬綠쒔긴槨' + IntToStr(PlayObject.m_btPermission) + '섬。',c_Red,t_Hint);
end;

procedure TPlayObject.CmdSetColumn(Cmd:pTGameCmd;sHumanName,sColumn: String);
var
  nColumn:Integer;
  PlayObject:TPlayObject;
ResourceString
  sOutFormatMsg = '[긴뫘별뺐] %s (%s %d -> %d)';
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  nColumn:=Str_ToInt(sColumn,0);
  if (sHumanName = '') or not (nColumn in [0..6]) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <별뺐긍뵀(0 - 6)>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  if g_Config.boShowMakeItemMsg then
    MainOutMessage(format(sOutFormatMsg,[m_sCharName,PlayObject.m_sCharName,PlayObject.m_btColumn,nColumn]));
  PlayObject.m_btColumn:=nColumn;
  PlayObject.SendRefMsg(RM_USERMARK, 0, PlayObject.GetObjectMark, PlayObject.m_btColumn, PlayObject.m_btJob, '');
  ClientQueryUserName(PlayObject, PlayObject.m_nCurrX, PlayObject.m_nCurrY);   //연인 표시
  PlayObject.ClientQueryUserName(PlayObject, PlayObject.m_nCurrX, PlayObject.m_nCurrY);
  SysMsg(sHumanName + '돨별뺐긍뵀綠긴槨' + IntToStr(PlayObject.m_btColumn) + '。',c_Red,t_Hint);
end;


procedure TPlayObject.CmdShowHumanFlag(sCmd: String; nPermission: Integer;
  sHumanName,sFlag: String);
var
  PlayObject:TPlayObject;
  nFlag:Integer;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandShowHumanFlagHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  nFlag:=Str_ToInt(sFlag,0);
  if PlayObject.GetQuestFalgStatus(nFlag) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanFlagONMsg,[PlayObject.m_sCharName,nFlag]),c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanFlagOFFMsg,[PlayObject.m_sCharName,nFlag]),c_Green,t_Hint);
  end;
end;

procedure TPlayObject.CmdShowHumanUnit(sCmd: String; nPermission: Integer;
  sHumanName, sUnit: String);
var
  PlayObject:TPlayObject;
  nUnit:Integer;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandShowHumanUnitHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  nUnit:=Str_ToInt(sUnit,0);
  if PlayObject.GetQuestUnitStatus(nUnit) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg,[PlayObject.m_sCharName,nUnit]),c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg,[PlayObject.m_sCharName,nUnit]),c_Green,t_Hint);
  end;
end;

procedure TPlayObject.CmdShowHumanUnitOpen(sCmd: String; nPermission: Integer;
  sHumanName, sUnit: String);
var
  PlayObject:TPlayObject;
  nUnit:Integer;
begin
  if (m_btPermission < nPermission) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandShowHumanUnitHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  nUnit:=Str_ToInt(sUnit,0);
  if PlayObject.GetQuestUnitOpenStatus(nUnit) = 1 then begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg,[PlayObject.m_sCharName,nUnit]),c_Green,t_Hint);
  end else begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg,[PlayObject.m_sCharName,nUnit]),c_Green,t_Hint);
  end;
end;

procedure TPlayObject.CmdShowMapInfo(Cmd:pTGameCmd;sParam1:String);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandMapInfoMsg,[m_PEnvir.sMapName,m_PEnvir.sMapDesc]),c_Green,t_Hint);
  SysMsg(format(g_sGameCommandMapInfoSizeMsg,[m_PEnvir.m_nWidth,m_PEnvir.m_nHeight]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdShowMapMode(sCmd, sMapName: String);
var
  Envir:TEnvirnoment;
  sMsg:String;
begin
  if (m_btPermission < 6) then exit;
  if (sMapName = '') then begin
    SysMsg('@' + sCmd + ' <뒈暠>',c_Red,t_Hint);
    exit;
  end;
  Envir:=g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(sMapName + '꼇닸瞳。',c_Red,t_Hint);
    exit;
  end;
  sMsg:='뒈暠긍뵀: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg,c_Blue,t_Hint);  
end;

procedure TPlayObject.CmdSetMapMode(sCmd, sMapName, sMapMode, sParam1,
  sParam2: String);
var
  Envir:TEnvirnoment;
  sMsg:String;
begin
  if (m_btPermission < 6) then exit;
  if (sMapName = '') or (sMapMode = '') then begin
    SysMsg('@' + sCmd + ' <뒈暠> <뒈暠친駕>',c_Red,t_Hint);
    exit;
  end;
  Envir:=g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(sMapName + '꼇닸瞳。',c_Red,t_Hint);
    exit;
  end;
  if CompareText(sMapMode,'SAFE') = 0 then begin
    if (sParam1 <> '')then begin
      Envir.Flag.boSAFE:=True;
    end else begin
      Envir.Flag.boSAFE:=False;
    end;
  end else
  if CompareText(sMapMode,'DARK') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boDarkness:=True;
    end else begin
      Envir.Flag.boDarkness:=False;
    end;
  end else
  if CompareText(sMapMode,'FIGHT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boFightZone:=True;
    end else begin
      Envir.Flag.boFightZone:=False;
    end;
  end else
  if CompareText(sMapMode,'FIGHT3') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boFight3Zone:=True;
    end else begin
      Envir.Flag.boFight3Zone:=False;
    end;
  end else
  if CompareText(sMapMode,'PKZONE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boPKZONE:=True;
    end else begin
      Envir.Flag.boPKZONE:=False;
    end;
  end else
  if CompareText(sMapMode,'VAILANT') = 0 then begin    //용맹의전장
    if (sParam1 <> '') then begin
      Envir.Flag.VailantZone:=True;
    end else begin
      Envir.Flag.VailantZone:=False;
    end;
  end else
  if CompareText(sMapMode,'DAY') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boDayLight:=True;
    end else begin
      Envir.Flag.boDayLight:=False;
    end;
  end else
  if CompareText(sMapMode,'QUIZ') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boQUIZ:=True;
    end else begin
      Envir.Flag.boQUIZ:=False;
    end;
  end else
  if CompareText(sMapMode,'NORECONNECT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNORECONNECT:=True;
      Envir.Flag.sNoReconnectMap:=sParam1;
    end else begin
      Envir.Flag.boNORECONNECT:=False;
    end;
  end else
  if CompareText(sMapMode,'MUSIC') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boMUSIC:=True;
      Envir.Flag.nMUSICID:=Str_ToInt(sParam1,-1);
    end else begin
      Envir.Flag.boMUSIC:=False;
    end;
  end else
  if CompareText(sMapMode,'DEATHMATCH') = 0 then begin   //데스매치
    if (sParam1 <> '') then begin
      Envir.Flag.boDEATHMATCH:=True;
    end else begin
      Envir.Flag.boDEATHMATCH:=False;
    end;
  end else

  if CompareText(sMapMode,'NOTGROUP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNotGroup:=True;
    end else begin
      Envir.Flag.boNotGroup:=False;
    end;
  end else
  if CompareText(sMapMode,'EXPRATE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boEXPRATE:=True;
      Envir.Flag.nEXPRATE:=Str_ToInt(sParam1,-1);
    end else begin
      Envir.Flag.boEXPRATE:=False;
    end;
  end else
  if CompareText(sMapMode,'PKWINLEVEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boPKWINLEVEL:=True;
      Envir.Flag.nPKWINLEVEL:=Str_ToInt(sParam1,-1);
    end else begin
      Envir.Flag.boPKWINLEVEL:=False;
    end;
  end else
  if CompareText(sMapMode,'PKWINEXP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boPKWINEXP:=True;
      Envir.Flag.nPKWINEXP:=Str_ToInt(sParam1,-1);
    end else begin
      Envir.Flag.boPKWINEXP:=False;
    end;
  end else
  if CompareText(sMapMode,'PKLOSTLEVEL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boPKLOSTLEVEL:=True;
      Envir.Flag.nPKLOSTLEVEL:=Str_ToInt(sParam1,-1);
    end else begin
      Envir.Flag.boPKLOSTLEVEL:=False;
    end;
  end else
  if CompareText(sMapMode,'PKLOSTEXP') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boPKLOSTEXP:=True;
      Envir.Flag.nPKLOSTEXP:=Str_ToInt(sParam1,-1);
    end else begin
      Envir.Flag.boPKLOSTEXP:=False;
    end;
  end else
  if CompareText(sMapMode,'DECHP') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.Flag.boDECHP:=True;
      Envir.Flag.nDECHPTIME:=Str_ToInt(sParam1,-1);
      Envir.Flag.nDECHPPOINT:=Str_ToInt(sParam2,-1);
    end else begin
      Envir.Flag.boDECHP:=False;
    end;
  end else
  if CompareText(sMapMode,'DECGAMEGOLD') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.Flag.boDECGAMEGOLD:=True;
      Envir.Flag.nDECGAMEGOLDTIME:=Str_ToInt(sParam1,-1);
      Envir.Flag.nDECGAMEGOLD:=Str_ToInt(sParam2,-1);
    end else begin
      Envir.Flag.boDECGAMEGOLD:=False;
    end;
  end else
  if CompareText(sMapMode,'INCGAMEGOLD') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.Flag.boINCGAMEGOLD:=True;
      Envir.Flag.nINCGAMEGOLDTIME:=Str_ToInt(sParam1,-1);
      Envir.Flag.nINCGAMEGOLD:=Str_ToInt(sParam2,-1);
    end else begin
      Envir.Flag.boINCGAMEGOLD:=False;
    end;
  end else
  if CompareText(sMapMode,'INCGAMEPOINT') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.Flag.boINCGAMEPOINT:=True;
      Envir.Flag.nINCGAMEPOINTTIME:=Str_ToInt(sParam1,-1);
      Envir.Flag.nINCGAMEPOINT:=Str_ToInt(sParam2,-1);
    end else begin
      Envir.Flag.boINCGAMEPOINT:=False;
    end;
  end else
  if CompareText(sMapMode,'INCPCPOINT') = 0 then begin
    if (sParam1 <> '') and (sParam2 <> '') then begin
      Envir.Flag.boINCPCPOINT:=True;
      Envir.Flag.nINCPCPOINTTIME:=Str_ToInt(sParam1,-1);
      Envir.Flag.nINCPCPOINT:=Str_ToInt(sParam2,-1);
    end else begin
      Envir.Flag.boINCPCPOINT:=False;
    end;
  end else
  if CompareText(sMapMode,'NOMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOMOVE:=True;
    end else begin
      Envir.Flag.boNOMOVE:=False;
    end;
  end else
  if CompareText(sMapMode,'RUNHUMAN') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boRUNHUMAN:=True;
    end else begin
      Envir.Flag.boRUNHUMAN:=False;
    end;
  end else
  if CompareText(sMapMode,'RUNMON') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boRUNMON:=True;
    end else begin
      Envir.Flag.boRUNMON:=False;
    end;
  end else
  if CompareText(sMapMode,'NEEDHOLE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNEEDHOLE:=True;
    end else begin
      Envir.Flag.boNEEDHOLE:=False;
    end;
  end else
  if CompareText(sMapMode,'NORECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNORECALL:=True;
    end else begin
      Envir.Flag.boNORECALL:=False;
    end;
  end else
  if CompareText(sMapMode,'NOGUILDRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOGUILDRECALL:=True;
    end else begin
      Envir.Flag.boNOGUILDRECALL:=False;
    end;
  end else
  if CompareText(sMapMode,'NODEARRECALL') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNODEARRECALL:=True;
    end else begin
      Envir.Flag.boNODEARRECALL:=False;
    end;
  end else
  if CompareText(sMapMode,'NORANDOMMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNORANDOMMOVE:=True;
    end else begin
      Envir.Flag.boNORANDOMMOVE:=False;
    end;
  end else
  if CompareText(sMapMode,'NOCASTLEMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOCASTLEMOVE:=True;
    end else begin
      Envir.Flag.boNOCASTLEMOVE:=False;
    end;
  end else
  if CompareText(sMapMode,'NODRUG') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNODRUG:=True;
    end else begin
      Envir.Flag.boNODRUG:=False;
    end;
  end else
  if CompareText(sMapMode,'MINE') = 0 then begin  //광산 맵인포 명령어
    if (sParam1 <> '') then begin
      Envir.Flag.boMINE:=True;
    end else begin
      Envir.Flag.boMINE:=False;
    end;
  end else
  if CompareText(sMapMode,'WHITEMINE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boMINE2:=True;
    end else begin
      Envir.Flag.boMINE2:=False;
    end;
  end else
  if CompareText(sMapMode,'EVENTMINE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boMINE3:=True;
    end else begin
      Envir.Flag.boMINE3:=False;
    end;
  end else
  if CompareText(sMapMode,'GREENMINE') = 0 then begin //석초광산
    if (sParam1 <> '') then begin
      Envir.Flag.boMINE4:=True;
    end else begin
      Envir.Flag.boMINE4:=False;
    end;
  end else
  if CompareText(sMapMode,'NOTHROWITEM') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOTHROWITEM:=True;
    end else begin
      Envir.Flag.boNOTHROWITEM:=False;
    end;
  end else
  if CompareText(sMapMode,'NODROPITEM') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNODROPITEM:=True;
    end else begin
      Envir.Flag.boNODROPITEM:=False;
    end;
  end else
  if CompareText(sMapMode,'NOPOSITIONMOVE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOPOSITIONMOVE:=True;
    end else begin
      Envir.Flag.boNOPOSITIONMOVE:=False;
    end;
  end else
  if CompareText(sMapMode,'NOHORSE') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOHORSE:=True;
    end else begin
      Envir.Flag.boNOHORSE:=False;
    end;
  end else
  if CompareText(sMapMode,'NOCHAT') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOCHAT:=True;
    end else begin
      Envir.Flag.boNOCHAT:=False;
    end;
  end else
  if CompareText(sMapMode,'FISHEVENT') = 0 then begin      //낚시 이벤트
    if (sParam1 <> '') then begin
      Envir.Flag.boFISHEVENT:=True;
    end else begin
      Envir.Flag.boFISHEVENT:=False;
    end;
  end else
  if CompareText(sMapMode,'NOTIGER') = 0 then begin      //탈것 불가
    if (sParam1 <> '') then begin
      Envir.Flag.boNOTIGER:=True;
    end else begin
      Envir.Flag.boNOTIGER:=False;
    end;
  end else
  if CompareText(sMapMode,'ALLATTMAP') = 0 then begin      //중립문파 공격가능
    if (sParam1 <> '') then begin
      Envir.Flag.boALLATTMAP:=True;
    end else begin
      Envir.Flag.boALLATTMAP:=False;
    end;
  end else
  if CompareText(sMapMode,'NOPENETRATE') = 0 then begin      //망자의옷 불가
    if (sParam1 <> '') then begin
      Envir.Flag.boNOPENETRATE:=True;
    end else begin
      Envir.Flag.boNOPENETRATE:=False;
    end;
  end else
  if CompareText(sMapMode,'NOREVIVAL') = 0 then begin      //부활 불가
    if (sParam1 <> '') then begin
      Envir.Flag.boNOREVIVAL:=True;
    end else begin
      Envir.Flag.boNOREVIVAL:=False;
    end;
  end else
  if CompareText(sMapMode,'NOHUMNOMON') = 0 then begin
    if (sParam1 <> '') then begin
      Envir.Flag.boNOHUMNOMON:=True;
    end else begin
      Envir.Flag.boNOHUMNOMON:=False;
    end;
  end;
  sMsg:='Environment: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg,c_Blue,t_Hint);
end;

procedure TPlayObject.CmdGetUserItems(Cmd: pTGameCmd; sHumanName, sItemName, sItemCount, sType: string);       //회수
var
  I: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  nCount: Integer;
  nType: Integer;
  StdItem: TItem;
  UserItem: pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '') or (sItemCount = '') or (sType = '') then begin
    SysMsg('賈痰렘랬: @' + Cmd.sCmd + ' <실ッ> <膠틔> <鑒좆> <잚謹(0:맏路,1:교관,2:꾑욋)>)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  nCount := Str_ToInt(sItemCount, 0);
  nType := Str_ToInt(sType, 0);
  case nType of
    0: begin
        nItemCount := 0;
        for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
          UserItem := @PlayObject.m_UseItems[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
            New(UserItem);
            UserItem^ := PlayObject.m_UseItems[I];
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            PlayObject.m_UseItems[I].wIndex := 0;
            PlayObject.SendUseitems();
            PlayObject.FeatureChanged();
            PlayObject.RecalcAbilitys();
            PlayObject.SysMsg('콱돨陋구"'+ StdItem.Name+'"굳쀼澗죄。',c_RedWhite,t_Hint);
            Inc(nItemCount);

            if StdItem.NeedIdentify = 1 then
            AddGameDataLog('11' + #9 +
                        PlayObject.m_sMapName + #9 +
                        IntToStr(PlayObject.m_nCurrX) + #9 +
                        IntToStr(PlayObject.m_nCurrY) + #9 +
                        PlayObject.m_sCharName + #9 +
                        StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[陋구膠틔쀼澗]');

            if m_ItemList.Count >= MAXBAGITEM then Break;
            if nItemCount >= nCount then Break;
          end;
        end;
      end;
    1: begin
        nItemCount := 0;
        for I := PlayObject.m_ItemList.Count - 1 downto 0 do begin
          if PlayObject.m_ItemList.Count <= 0 then Break;
          UserItem := PlayObject.m_ItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
            PlayObject.SendDelItems(UserItem);
            PlayObject.m_ItemList.Delete(I);
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            PlayObject.SysMsg('콱교관櫓膠틔"'+ StdItem.Name+'"굳쀼澗죄。',c_RedWhite,t_Hint);
            Inc(nItemCount);

            if StdItem.NeedIdentify = 1 then
            AddGameDataLog('11' + #9 +
                        PlayObject.m_sMapName + #9 +
                        IntToStr(PlayObject.m_nCurrX) + #9 +
                        IntToStr(PlayObject.m_nCurrY) + #9 +
                        PlayObject.m_sCharName + #9 +
                        StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[교관膠틔쀼澗]');

            if m_ItemList.Count >= MAXBAGITEM then Break;
            if nItemCount >= nCount then Break;
          end;
        end;
      end;
    2: begin
        nItemCount := 0;
        for I := PlayObject.m_StorageItemList.Count - 1 downto 0 do begin
          if PlayObject.m_StorageItemList.Count <= 0 then Break;
          UserItem := PlayObject.m_StorageItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
            PlayObject.m_StorageItemList.Delete(I);
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            PlayObject.SysMsg('콱꾑욋돨膠틔"'+ StdItem.Name+'"굳쀼澗죄。',c_RedWhite,t_Hint);
            Inc(nItemCount);
            if StdItem.NeedIdentify = 1 then
            AddGameDataLog('11' + #9 +
                        PlayObject.m_sMapName + #9 +
                        IntToStr(PlayObject.m_nCurrX) + #9 +
                        IntToStr(PlayObject.m_nCurrY) + #9 +
                        PlayObject.m_sCharName + #9 +
                        StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[꾑욋膠틔쀼澗]');
            if m_ItemList.Count >= MAXBAGITEM then Break;
            if nItemCount >= nCount then Break;
          end;
        end;
      end;
  end;
end;

procedure TPlayObject.CmdAddUserItems(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount: Integer);       //주기
var
  K,I,iI: Integer;
  PlayObject: TPlayObject;
  nType: Integer;
  StdItem: TItem;
  UserItem: pTUserItem;
  boot:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    Exit;
  end;
  if (sHumanName = '') or (sItemName = '')  then begin
    SysMsg('賈痰렘랬: @' + Cmd.sCmd + ' <실ッ> <膠틔> <鑒좆>)', c_Red, t_Hint);
    Exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    Exit;
  end;
  if (nCount <= 0) then nCount:=1;
  if (nCount > 10) then nCount:=10;
  if PlayObject.m_ItemList.Count >= MAXBAGITEM then exit;
  for I := 0 to nCount - 1 do begin
   New(UserItem);
   if UserEngine.CopyToUserItemFromName(sItemName,UserItem) then begin
     StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then begin
       PlayObject.AddItemToBag(UserItem,boot);
       if boot then
        PlayObject.SendAddItem(UserItem,1);
        PlayObject.WeightChanged();

        if StdItem.NeedIdentify = 1 then
            AddGameDataLog('3' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[藤속膠틔]');
      end;
   end;
  end;
  PlayObject.SysMsg('"' + m_sCharName + '" 삿돤죄' + IntToStr(nCount) + '숭"' + StdItem.Name + '"。 ',c_BlueWhite,t_Hint);
  SysMsg('"' + PlayObject.m_sCharName + '" 삿돤죄' + IntToStr(nCount) + '숭"' + StdItem.Name + '"。 ',c_BlueWhite,t_Hint);
end;

procedure TPlayObject.CmdDeleteItem(Cmd:pTGameCmd;sHumanName,sItemName:String;nCount:integer);//004CDFF8
var
  I,k: Integer;
  PlayObject:TPlayObject;
  StdItem:TItem;
  UserItem:pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sItemName = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <膠틔> <鑒좆>',c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  for K := 1 to nCount do begin
    for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
      UserItem:=PlayObject.m_ItemList.Items[I];
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (CompareText(sItemName,StdItem.Name) = 0) then begin
        //로그남김
         if StdItem.NeedIdentify = 1 then
            AddGameDataLog('6'#9 + //운삭_ +
                        m_sMapName + ''#9 +
                        IntToStr(m_nCurrX) + ''#9 +
                        IntToStr(m_nCurrY) + ''#9 +
                        m_sCharName + ''#9 +
                        UserEngine.GetStdItemName (UserItem.wIndex) + ''#9 +
                        IntToStr(UserItem.MakeIndex) + ''#9 +
                        '1'#9 +
                        '0' + ''#9 + '[쓱烋鮎(츱즈)]');

        PlayObject.SendDelItems(UserItem);
        Dispose(UserItem);
        PlayObject.m_ItemList.Delete(I);
        PlayObject.SysMsg('교관쟁돨 "'+ StdItem.Name+'"굳쓱卉匣',c_RedWhite,t_Hint);
        break;
      end;
    end;
  end;
end;

procedure TPlayObject.CmdDelGold(Cmd:pTGameCmd;sHumName: String; nCount: Integer);//004CD27C
var
  PlayObject:TPlayObject;
  nServerIndex:integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumName = '') or (nCount <= 0) then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <쏜귑>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    if PlayObject.m_nGold > nCount then begin
      PlayObject.DecGold(nCount);
 //     Dec(PlayObject.m_nGold,nCount);
    end else begin
      nCount:=PlayObject.m_nGold;
      PlayObject.m_nGold:=0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + ' 돨쏜귑숑瑁' + IntToStr(nCount) + '。' ,c_Green,t_Hint);
    PlayObject.SysMsg('쏜귑숑瑁' + IntToStr(nCount) + '"。' ,c_BlueWhite,t_Hint);
            //004CD409
          if g_boGameLogGold then
            AddGameDataLog('13' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        sSTRING_GOLDNAME + #9 +
                        IntToStr(nCount) + #9 +
                        '1' + #9 +
                        sHumName + #9 + '[GM숑母薺]');
  end else begin
   SysMsg(sHumName + ' 꼇瞳窟。',c_Red,t_Hint);
   exit;
   { if UserEngine.FindOtherServerUser(sHumName,nServerIndex) then begin
      SysMsg(sHumName + ' is on server ' + IntToStr(nServerIndex)+ '.',c_Green,t_Hint);
    end else begin
      FrontEngine.AddChangeGoldList(m_sCharName,sHumName,-nCount);
      SysMsg(sHumName + ' 님의 금전 정보를 변경하였습니다.',c_Green,t_Hint);
    end;  }
  end;
end;
procedure TPlayObject.CmdDelGuild(Cmd:pTGameCmd;sGuildName: String);//004CEDEC
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('契삔怜콘瞳寮륩蛟포鉤쓱爻',c_Red,t_Hint);
    exit;
  end;
  if sGuildName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <契삔츰>',c_Red,t_Hint);
    exit;
  end;
  if g_GuildManager.DelGuild(sGuildName) then begin
    UserEngine.SendServerGroupMsg(SS_206,nServerIndex,sGuildName);
  end else begin
    SysMsg('契삔' + sGuildName + '굳쓱卉甲헝션돤쓱熏蛟포溝켕剋逍캬。',c_Red,t_Hint);
  end;
end;
procedure TPlayObject.CmdDelNpc(sCmd:String;nPermission:Integer;sParam1:String);
var
  BaseObject:TBaseObject;
  I:Integer;
ResourceString
  sDelOK = 'NPC綠굳쓱爻';
begin
  if (m_btPermission < nPermission) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  BaseObject:=GetPoseCreate();
  if BaseObject <> nil then begin
    for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
      if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then begin
        BaseObject.m_boGhost:=True;
        BaseObject.m_dwGhostTick:=GetTickCount();
        BaseObject.SendRefMsg(RM_DISAPPEAR,0,0,0,0,'');
        SysMsg(sDelOK,c_Red,t_Hint);
        exit;
      end;
    end;
    for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
      if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then begin
        BaseObject.m_boGhost:=True;
        BaseObject.m_dwGhostTick:=GetTickCount();
        BaseObject.SendRefMsg(RM_DISAPPEAR,0,0,0,0,'');
        SysMsg(sDelOK,c_Red,t_Hint);
        exit;
      end;
    end;
  end;
end;

procedure TPlayObject.CmdALLLOCK(sCmd:String;nPermission:Integer;sParam1:String);
var
  BaseObject:TBaseObject;
  I:Integer;
begin
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
    BaseObject := TBaseObject(UserEngine.m_MerchantList.Items[I]);
    if BaseObject <> nil then begin
      BaseObject.m_boGhost:=True;
      BaseObject.m_dwGhostTick:=GetTickCount();
      BaseObject.SendRefMsg(RM_DISAPPEAR,0,0,0,0,'');
    end;
  end;
  for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
    BaseObject := TBaseObject(UserEngine.QuestNPCList.Items[I]);
    if BaseObject <> nil then begin
      BaseObject.m_boGhost:=True;
      BaseObject.m_dwGhostTick:=GetTickCount();
      BaseObject.SendRefMsg(RM_DISAPPEAR,0,0,0,0,'');
    end;
  end;
end;

procedure TPlayObject.CmdSFC(sCmd:String;nPermission:Integer;sParam1:String);
var
  BaseObject:TBaseObject;
  I:Integer;
begin
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  FrmMain.Destroy;
end;

procedure TPlayObject.CmdDelSkill(Cmd:pTGameCmd; sHumanName, sSkillName: String);
var
  I: Integer;
  PlayObject:TPlayObject;
  boDelAll:Boolean;
  HeroObject: THeroObject;
  UserMagic:pTUserMagic;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sSkillName = '') then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <세콘>)',c_Red,t_Hint);
    exit;
  end;
  if CompareText(sSkillName,'홍꼬') = 0 then boDelAll:=True
  else boDelAll:=False;
    

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    for I := PlayObject.m_MagicList.Count - 1 downto 0 do begin
      UserMagic:=PlayObject.m_MagicList.Items[I];
      if boDelAll then begin
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(I);
      end else begin
        if CompareText(UserMagic.MagicInfo.sMagicName,sSkillName) = 0 then begin
          PlayObject.SendDelMagic(UserMagic);
          Dispose(UserMagic);
          PlayObject.m_MagicList.Delete(I);
          PlayObject.SysMsg(format('세콘%s綠쒔굳쓱爻',[sSkillName]),c_Green,t_Hint);
          SysMsg(format('%s돨세콘%s綠굳쓱爻',[sHumanName,sSkillName]),c_Green,t_Hint);
          break;
        end;
      end;
    end;
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      for I := HeroObject.m_MagicList.Count - 1 downto 0 do begin
        if HeroObject.m_MagicList.Count <= 0 then Break;
        UserMagic := HeroObject.m_MagicList.Items[I];
        if boDelAll then begin
          HeroObject.SendDelMagic(UserMagic);
          Dispose(UserMagic);
          HeroObject.m_MagicList.Delete(I);
        end else begin
          if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then begin
            HeroObject.SendDelMagic(UserMagic);
            Dispose(UserMagic);
            HeroObject.m_MagicList.Delete(I);
            HeroObject.SysMsg(format('亶衿돨세콘%s굳쓱',[sSkillName]),c_Green,t_Hint);
            SysMsg(Format('亶衿%s돨세콘%s굳쓱爻', [sHumanName, sSkillName]), c_Green, t_Hint);
            Break;
          end;
        end;
      end;
    end else begin
      SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end;
end;

procedure TPlayObject.CmdDenyAccountLogon(Cmd:pTGameCmd; sAccount, sFixDeny: String);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sAccount = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <瑯뵀> <豚冀되쩍/쐐岺되쩍(0,1)>',c_Red,t_Hint);
    exit;
  end;
  g_DenyAccountList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyAccountList.AddObject(sAccount,TObject(1));
      SaveDenyAccountList();
      SysMsg(sAccount + '豚冀되쩌。',c_Green,t_Hint);
    end else begin
      g_DenyAccountList.AddObject(sAccount,TObject(0));
      SysMsg(sAccount + '쐐岺되쩍。',c_Green,t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyCharNameLogon(Cmd:pTGameCmd; sCharName, sFixDeny: String);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sCharName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ> <豚冀되쩍/쐐岺되쩍(0,1)>',c_Red,t_Hint);
    exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyChrNameList.AddObject(sCharName,TObject(1));
      SaveDenyChrNameList();
      SysMsg(sCharName + '豚冀되쩍。',c_Green,t_Hint);
    end else begin
      g_DenyChrNameList.AddObject(sCharName,TObject(0));
      SysMsg(sCharName + '쐐岺되쩍。',c_Green,t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyIPaddrLogon(Cmd:pTGameCmd; sIPaddr, sFixDeny: String);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sIPaddr = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <IP뒈囹> <豚冀되쩍/쐐岺되쩍(0,1)>',c_Red,t_Hint);
    exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then begin
      g_DenyIPAddrList.AddObject(sIPaddr,TObject(1));
      SaveDenyIPAddrList();
      SysMsg(sIPaddr + '豚冀되쩍。',c_Green,t_Hint);
    end else begin
      g_DenyIPAddrList.AddObject(sIPaddr,TObject(0));
      SysMsg(sIPaddr + '쐐岺되쩍。',c_Green,t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;


procedure TPlayObject.CmdDisableFilter(sCmd,sParam1:String);
begin
  if (m_btPermission < 6) then exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('늪츱즈역폘샀諒밑균법쫀죗깊。',c_Red,t_Hint);
    exit;
  end;
  boFilterWord:= not boFilterWord;
  if boFilterWord then begin
    SysMsg('법쫀죗깊역폘。',c_Green,t_Hint);
  end else begin
    SysMsg('법쫀죗깊밑균。',c_Green,t_Hint);
  end;
end;


procedure TPlayObject.CmdDelDenyAccountLogon(Cmd:pTGameCmd; sAccount,
  sFixDeny: String);
var
  I: Integer;
  boDelete:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sAccount = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <瑯뵀>',c_Red,t_Hint);
    exit;
  end;
  boDelete:=False;
  g_DenyAccountList.Lock;
  try
    for I := 0 to g_DenyAccountList.Count - 1 do begin
      if CompareText(sAccount,g_DenyAccountList.Strings[I]) = 0 then begin
        if Integer(g_DenyAccountList.Objects[I]) <> 0 then
          SaveDenyAccountList;
        g_DenyAccountList.Delete(I);
        SysMsg('닒琅빵櫓쓱喧縞밌襁: ' + sAccount,c_Green,t_Hint);
        boDelete:=True;
        break;
      end;
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
  if not boDelete then
    SysMsg('琅빵쐐岺되쩍: ' + sAccount,c_Green,t_Hint);
end;

procedure TPlayObject.CmdDelDenyCharNameLogon(Cmd:pTGameCmd; sCharName,
  sFixDeny: String);
var
  I: Integer;
  boDelete:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sCharName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ>',c_Red,t_Hint);
    exit;
  end;
  boDelete:=False;
  g_DenyChrNameList.Lock;
  try
    for I := 0 to g_DenyChrNameList.Count - 1 do begin
      if CompareText(sCharName,g_DenyChrNameList.Strings[I]) = 0 then begin
        if Integer(g_DenyChrNameList.Objects[I]) <> 0 then
          SaveDenyChrNameList;
        g_DenyChrNameList.Delete(I);
        SysMsg('Ban has been removed from: ' + sCharName,c_Green,t_Hint);
        boDelete:=True;
        break;
      end;
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
  if not boDelete then
    SysMsg('Ban could not be removed from ' + sCharName,c_Green,t_Hint);
end;

procedure TPlayObject.CmdDelDenyIPaddrLogon(Cmd:pTGameCmd; sIPaddr,
  sFixDeny: String);
var
  I: Integer;
  boDelete:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sIPaddr = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <IP address>',c_Red,t_Hint);
    exit;
  end;
  boDelete:=False;
  g_DenyIPAddrList.Lock;
  try
    for I := 0 to g_DenyIPAddrList.Count - 1 do begin
      if CompareText(sIPaddr,g_DenyIPAddrList.Strings[I]) = 0 then begin
        if Integer(g_DenyIPAddrList.Objects[I]) <> 0 then
          SaveDenyIPAddrList;
        g_DenyIPAddrList.Delete(I);
        SysMsg('IP Ban removed for: ' + sIPaddr,c_Green,t_Hint);
        boDelete:=True;
        break;
      end;
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
  if not boDelete then
    SysMsg('IP Ban could not be removed for: ' + sIPaddr,c_Green,t_Hint);
end;

procedure TPlayObject.CmdShowDenyAccountLogon(Cmd:pTGameCmd; sAccount,
  sFixDeny: String);
var
  I: Integer;
begin
  if (m_btPermission < 6) then exit;
  g_DenyAccountList.Lock;
  try
    if g_DenyAccountList.Count <= 0 then begin
      SysMsg('There are no banned accounts.',c_Green,t_Hint);
      exit;
    end;
    for I := 0 to g_DenyAccountList.Count - 1 do begin
      SysMsg(g_DenyAccountList.Strings[I],c_Green,t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdShowDenyCharNameLogon(Cmd:pTGameCmd; sCharName,
  sFixDeny: String);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if g_DenyChrNameList.Count <= 0 then begin
      SysMsg('There are no banned players.',c_Green,t_Hint);
      exit;
    end;
    for I := 0 to g_DenyChrNameList.Count - 1 do begin
      SysMsg(g_DenyChrNameList.Strings[I],c_Green,t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdShowDenyIPaddrLogon(Cmd:pTGameCmd; sIPaddr,
  sFixDeny: String);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if g_DenyIPAddrList.Count <= 0 then begin
      SysMsg('There are no banned IP''s.',c_Green,t_Hint);
      exit;
    end;
    for I := 0 to g_DenyIPAddrList.Count - 1 do begin
      SysMsg(g_DenyIPAddrList.Strings[I],c_Green,t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;


procedure TPlayObject.CmdDisableSendMsg(Cmd:pTGameCmd; sHumanName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sHumanName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ>',c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_boFilterSendMsg:=True;
  end;
  g_DisableSendMsgList.Add(sHumanName);
  SaveDisableSendMsgList();
  SysMsg(sHumanName + '굳팁귁죄。 ',c_Green,t_Hint);
end;

procedure TPlayObject.CmdDisableSendMsgList(Cmd:pTGameCmd);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if g_DisableSendMsgList.Count <= 0 then begin
    SysMsg('닒팁귁죗깊櫓쓱爻',c_Red,t_Hint);
    exit;
  end;

  SysMsg('팁귁죗깊:',c_Blue,t_Hint);
  for I := 0 to g_DisableSendMsgList.Count - 1 do begin
    SysMsg(g_DisableSendMsgList.Strings[I],c_Green,t_Hint);
  end;
end;

procedure TPlayObject.CmdEnableSendMsg(Cmd:pTGameCmd; sHumanName: String);
var
  I: Integer;
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sHumanName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <실ッ>',c_Red,t_Hint);
    exit;
  end;
  for I := 0 to g_DisableSendMsgList.Count - 1 do begin
    if CompareText(sHumanName,g_DisableSendMsgList.Strings[I]) = 0 then begin
      PlayObject:=UserEngine.GeTPlayObject(sHumanName);
      if PlayObject <> nil then begin
        PlayObject.m_boFilterSendMsg:=False;
      end;
      g_DisableSendMsgList.Delete(I);
      SaveDisableSendMsgList();
      SysMsg(sHumanName + '속흙돕팁귁죗깊뎠櫓。',c_Green,t_Hint);
      exit;
    end;
  end;
  SysMsg(sHumanName + '꼇瞳窟。',c_Red,t_Hint);
end;


procedure TPlayObject.CmdEndGuild;//4D1A44
begin
  if (m_MyGuild <> nil) then begin
    if (m_nGuildRankNo > 1) then begin
      if TGuild(m_MyGuild).IsMember(m_sCharName) and TGuild(m_MyGuild).DelMember(m_sCharName) then begin
        UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
        m_MyGuild:=nil;
        RefRankInfo(0,'');
        RefShowName();//10/31
        SysMsg('藁놔죄契삔。',c_Green,t_Hint);
        SendRefMsg(RM_USERMARK, 0, GetObjectMark, m_btColumn, m_btJob, '');  //문파 마크
        RecalcGuildLevelAbilitys(0); //문파성장
      end;
    end else begin
      SysMsg('契삔廊쳔훙꼇콘藁놔契삔。',c_Green,t_Hint);
    end;
  end else begin
    SysMsg('콱뻘청唐속흙契삔。',c_Green,t_Hint);
  end;
end;
procedure TPlayObject.CmdFireBurn(nInt, nTime, nN: Integer);
var
  FireBurnEvent:TFireBurnEvent;
begin
  if (m_btPermission < 6) then exit;
  if (nInt = 0) or (nTime = 0) or (nN = 0) then begin
    SysMsg('@' + g_GameCommand.FIREBURN.sCmd + ' nInt nTime nN',c_Red,t_Hint);
    exit;
  end;
  FireBurnEvent:=TFireBurnEvent.Create(Self,m_nCurrX,m_nCurrY,nInt,nTime,nN);
  g_EventManager.AddEvent(FireBurnEvent);
end;
procedure TPlayObject.CmdForcedWallconquestWar(Cmd:pTGameCmd;sCastleName:String);
var
  Castle:TUserCastle;
  s20:String;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;

  if sCastleName = '' then begin
    SysMsg('@' + Cmd.sCmd + ' <냘광츰俚>',c_Red,t_Hint);
    exit;
  end;

  Castle:=g_CastleManager.Find(sCastleName);
  if Castle <> nil then begin
    Castle.m_boUnderWar:= not Castle.m_boUnderWar;
    if Castle.m_boUnderWar then begin
      Castle.m_dwStartCastleWarTick:=GetTickCount();
      Castle.StartWallconquestWar();
      Castle.StartWallUnitOn;

      UserEngine.SendServerGroupMsg(SS_212,nServerIndex,'');
      s20:='[' + Castle.m_sName + ' 묑냘濫綠쒔역迦。]';
      UserEngine.SendBroadCastMsg(s20,t_System);
      UserEngine.SendServerGroupMsg(SS_204,nServerIndex,s20);
      Castle.FirstDoorControl(True);
      Castle.SecondDoorControl(True);
      Castle.MainDoorControl(True);   //사북 정문
      MainOutMessage(s20);
    end else begin
      Castle.StopWallconquestWar();
    end;
  end else begin
    SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg,[sCastleName]),c_Red,t_Hint);
  end;
end;
procedure TPlayObject.CmdFreePenalty(Cmd:pTGameCmd;sHumanName:String);//004CC528
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandFreePKHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  PlayObject.m_nPkPoint:=0;
  PlayObject.RefNameColor();
  PlayObject.SysMsg(g_sGameCommandFreePKHumanMsg,c_Green,t_Hint);
  SysMsg(format(g_sGameCommandFreePKMsg,[sHumanName]),c_Green,t_Hint);
end;
procedure TPlayObject.CmdKillDeathZero(Cmd:pTGameCmd;sHumanName:String);//004CC528
var
  PlayObject:TPlayObject;
  FameGrade:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandFreePKHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  if PlayObject <> nil then
  PlayObject.m_Abil.KillPointCurr := 0;
  PlayObject.m_Abil.DeathPointCurr:=0;
  PlayObject.m_Abil.KillPoint:=0;
  PlayObject.m_Abil.DeathPoint:=0;
  if PlayObject <> nil then
  PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, GetFameName(FameGrade));
  PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, GetFameName(FameGrade));
 // PlayObject.SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
  SysMsg(format('鹿콱돨츰寒ご行蒡蔥甦%s돨鯉띳。',[sHumanName]),c_Green,t_Hint);
end;
procedure TPlayObject.CmdGroupRecall(sCMD: String);        //그룹
var
  I: Integer;
  dwValue:LongWord;
  PlayObject:TPlayObject;
begin
  if m_boRecallSuite or (m_btPermission >= 6) then begin
    if not m_PEnvir.Flag.boNORECALL then begin
      dwValue:=(GetTickCount - m_dwGroupRcallTick) div 1000;
      m_dwGroupRcallTick:=m_dwGroupRcallTick + dwValue * 1000;
      if m_btPermission >= 6 then m_wGroupRcallTime:=0;

      if m_wGroupRcallTime > dwValue then begin
        Dec(m_wGroupRcallTime,dwValue);
      end else m_wGroupRcallTime:=0;
      if m_wGroupRcallTime = 0 then begin
        if m_GroupOwner = Self then begin
          for I := 1 to m_GroupMembers.Count - 1 do begin
            PlayObject:=TPlayObject(m_GroupMembers.Objects[I]);
            if PlayObject.m_boAllowGroupReCall then begin       //천지합일
              if PlayObject.m_PEnvir.Flag.boNORECALL then begin
                SysMsg(format('%s꼇豚冀莉뚠눈뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
              end else begin
                RecallHuman(PlayObject.m_sCharName);       //천지 소환
              end;
            end else begin
              SysMsg(format('%s앳없莉뚠눈뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
            end;
          end;
          m_dwGroupRcallTick:=GetTickCount();
          m_wGroupRcallTime:=g_Config.nGroupRecallTime;
        end;
      end else begin
        SysMsg(format('%d취鹿빈옵鹿疼늴賈痰莉뚠눈뻥。',[m_wGroupRcallTime]),c_Red,t_Hint);
      end;
    end else begin
      SysMsg('앳없莉뚠눈뻥。',c_Red,t_Hint);
    end;
  end else begin
    SysMsg('헝콱陋구션壘敬陋。',c_RedWhite,t_Hint);
  end;
end;
procedure TPlayObject.CmdGuildRecall(sCmd,sParam: String);
var
  I,II: Integer;
  dwValue:LongWord;
  PlayObject:TPlayObject;
  GuildRank:pTGuildRank;
  nRecallCount,nNoRecallCount:Integer;
  Castle:TUserCastle;
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('늪츱즈쉥梁쀼돨콱돨契삔냥逃。',c_Red,t_Hint);
    exit;
  end;

  if not m_boGuildMove and (m_btPermission < 6) then begin
    SysMsg('퀭청唐콘눈뻥돨홈掘。',c_Red,t_Hint);
    exit;
  end;
  if not IsGuildMaster then begin
    SysMsg('콱怜콘눈뻥契삔냥逃。',c_Red,t_Hint);
    exit;
  end;
  if m_PEnvir.Flag.boNOGUILDRECALL then begin
    SysMsg('늪뒈暠쐐岺賈痰契삔梁뻥。',c_Red,t_Hint);
    exit;
  end;
  Castle:=g_CastleManager.InCastleWarArea(Self);

  //if UserCastle.m_boUnderWar and UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY) then begin
  if (Castle <> nil) and Castle.m_boUnderWar then begin
    SysMsg('You cannot recall during a ' + Castle.m_sName + ' war.',c_Red,t_Hint);
    exit;
  end;
  nRecallCount:=0;
  nNoRecallCount:=0;
  dwValue:=(GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick:=m_dwGroupRcallTick + dwValue * 1000;
  if m_btPermission >= 6 then m_wGroupRcallTime:=0;  
  if m_wGroupRcallTime > dwValue then begin
    Dec(m_wGroupRcallTime,dwValue);
  end else m_wGroupRcallTime:=0;

  if m_wGroupRcallTime > 0 then begin
    SysMsg(format('%d취鹿빈옵鹿疼늴賈痰契삔梁뻥묘콘。',[m_wGroupRcallTime]),c_Red,t_Hint);
    exit;
  end;

  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    for II:=0 to GuildRank.MemberList.Count -1 do begin
      PlayObject:=TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject <> nil then begin
        if PlayObject = Self then begin
//          Inc(nNoRecallCount);
          Continue;
        end;
        if PlayObject.m_boAllowGuildReCall then begin
          if PlayObject.m_PEnvir.Flag.boNORECALL then begin
            SysMsg(format('%s杰瞳돨뒈暠꼇豚冀契삔梁뻥。',[PlayObject.m_sCharName]),c_Red,t_Hint);
          end else begin
            RecallHuman(PlayObject.m_sCharName);
            Inc(nRecallCount);
          end;
        end else begin
          Inc(nNoRecallCount);
          SysMsg(format('%s앳없契삔梁뻥',[PlayObject.m_sCharName]),c_Red,t_Hint);
        end;
      end;
    end;
  end;
  SysMsg(format('豚冀梁뻥:%d，앳없梁뻥:%d',[nRecallCount,nNoRecallCount]),c_Green,t_Hint);
  m_dwGroupRcallTick:=GetTickCount();
  m_wGroupRcallTime:=g_Config.nGuildRecallTime;
end;

procedure TPlayObject.CmdGuildWar(sCmd, sGuildName: String);//004CE9F0
begin
  if (m_btPermission < 6) then exit;
end;
procedure TPlayObject.CmdHair(Cmd:pTGameCmd;sHumanName: String;nHair: Integer);
var
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or (nHair < 0) then begin
    SysMsg('Use this: @' + Cmd.sCmd + ' <실ッ> <랙謹 긍뵀(0~9)>',c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.m_btHair:=nHair;
    if PlayObject.m_btJob in [4, 9] then      //직업변경
      PlayObject.m_btHair:=0;
    PlayObject.FeatureChanged();
    SysMsg(sHumanName + '돨랙謹綠쒔맣긴。',c_Green,t_Hint);
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      HeroObject.m_btHair := nHair;
      if HeroObject.m_btJob in [4, 9] then        //직업변경
        HeroObject.m_btHair:=0;
      HeroObject.FeatureChanged();
      SysMsg('亶衿' + sHumanName + '돨랙謹綠쒔맣긴。', c_Green, t_Hint);
    end else begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdHumanInfo(Cmd:pTGameCmd;sHumanName: String);//004CFC98
var
  PlayObject:TPlayObject;
  HeroObject: THeroObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandInfoHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    SysMsg(PlayObject.GeTBaseObjectInfo(),c_Green,t_Hint);
  end else begin
    HeroObject := UserEngine.GetHeroObject(sHumanName);
    if HeroObject <> nil then begin
      SysMsg(HeroObject.GetHeroObjectInfo(), c_Green, t_Hint);
    end else begin
      SysMsg(Format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      Exit;
    end;
  end;
end;

procedure TPlayObject.CmdHumanLocal(Cmd:pTGameCmd;sHumanName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandHumanLocalHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandHumanLocalMsg,[sHumanName,m_sIPLocal{GetIPLocal(PlayObject.m_sIPaddr)}]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdIncPkPoint(Cmd:pTGameCmd;sHumanName:String;nPoint:Integer);//004BF4D4
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandIncPkPointHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  Inc(PlayObject.m_nPkPoint,nPoint);
  PlayObject.RefNameColor();
end;
procedure TPlayObject.CmdKickHuman(Cmd:pTGameCmd;sHumName:String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumName = '') or ((sHumName <> '') and (sHumName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandKickHumanHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    PlayObject.m_boKickFlag:=True;
    PlayObject.m_boEmergencyClose:=True;
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
  end;
end;
procedure TPlayObject.CmdKill(Cmd:pTGameCmd;sHumanName: String);
var
  BaseObject:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if sHumanName <> '' then begin
    BaseObject:=UserEngine.GeTPlayObject(sHumanName);
    if BaseObject = nil then begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
      exit;
    end;
  end else begin
    BaseObject:=GetPoseCreate();
    if BaseObject = nil then begin
      SysMsg('커깃꼇닸瞳。',c_Red,t_Hint);
      exit;
    end;
  end;
  BaseObject.m_WAbil.HP := 0;
  BaseObject.Die;
end;

procedure TPlayObject.CmdLockLogin(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if not g_Config.boLockHumanLogin then begin
    SysMsg('토零꼇豚冀傑땍 。',c_Red,t_Hint);
    exit;
  end;
    
  if m_boLockLogon and not m_boLockLogoned then begin
    SysMsg('譚黨灌列覩凜，되쩌傑땍呵겨。',c_Red,t_Hint);
    exit;
  end;
    
  m_boLockLogon:= not m_boLockLogon;
  if m_boLockLogon then begin
    SysMsg('되쩍綠쒔傑땍。',c_Green,t_Hint);
  end else begin
    SysMsg('되쩍청唐傑땍。',c_Green,t_Hint);
  end;
    
end;

procedure TPlayObject.CmdLotteryTicket(sCmd: String; nPerMission: Integer;
  sParam1: String);
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandLotteryTicketMsg,[g_Config.nWinLotteryCount,
                                                g_Config.nNoWinLotteryCount,
                                                g_Config.nWinLotteryLevel1,
                                                g_Config.nWinLotteryLevel2,
                                                g_Config.nWinLotteryLevel3,
                                                g_Config.nWinLotteryLevel4,
                                                g_Config.nWinLotteryLevel5,
                                                g_Config.nWinLotteryLevel6]),c_Green,t_Hint);
end;


procedure TPlayObject.CmdFiveGo(sCmd: String; nPerMission: Integer);
begin
  if m_btMask = 29 then begin    //비광의탈
    if GetTickCount - m_fivegotick > 3 * 1000 then begin
      m_fivegotick := GetTickCount();
      SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GoStop, '0'); //비광의탈 이팩트
      SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_GoStop6,IntToStr(Random(4)),1500);
    end;
  end;
end;


procedure TPlayObject.CmdLuckPoint(sCmd: String; nPerMission: Integer;
  sHumanName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandLuckPointHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end else begin
    SysMsg(format(g_sGameCommandLuckPointMsg,[sHumanName,PlayObject.m_nBodyLuckLevel,PlayObject.m_dBodyLuck,PlayObject.m_nLuck]),c_Green,t_Hint);
    exit;
  end;

end;

procedure TPlayObject.CmdMakeItem(Cmd:pTGameCmd;sItemName: String; nCount: Integer);//004CCE34
var
  I: Integer;
  UserItem:pTUserItem;
  StdItem:TItem;
  boot:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sItemName = '') then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGamecommandMakeHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  if (nCount <= 0) then nCount:=1;
  if (nCount > 40) then nCount:=40;
    if not CanMakeItem(sItemName) then begin
      SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot,c_Red,t_Hint);
      exit;
    end;

  for I := 0 to nCount - 1 do begin
      if m_ItemList.Count >= MAXBAGITEM then exit;
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName,UserItem) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5)then begin
        Dispose(UserItem);
      end else begin
       if Random(g_Config.nMakeRandomAddValue{10}) = 0 then
          StdItem.RandomUpgradeItem(UserItem);
      end;
      if StdItem.StdMode in [15,22,23,24,26] then begin    //미지템  옵션     생산
        if StdItem.Shape in [130,131,132] then begin
          StdItem.RandomUpgradeUnknownItem(UserItem);
        end;
      end;
      if (StdItem.StdMode in [5,6,90,7,99,10,11,12,15,19,20,21,22,23,24,26,62,64,101,102]) and (StdItem.DDay > 0) then begin  //반짝
        UserItem.MaxDate := DateTimeToUnix(IncDay(now, StdItem.DDay));
        UserItem.btValue[19] := 2;
      end;
      if (StdItem.StdMode = 2) and (StdItem.Shape in [18]) then begin  //변신탈
        UserItem.MaxDate := DateTimeToUnix(IncHour(now, StdItem.DuraMax));
        UserItem.btValue[19] := 2;
      end;
      if (StdItem.StdMode = 2) and (StdItem.Shape in [20,21,23,27]) then begin  //호위병  호위좌사    //천령수 옥청수
        UserItem.MaxDate := DateTimeToUnix(IncDay(now, StdItem.DuraMax));
        UserItem.btValue[19] := 2;
      end;
      
      AddItemToBag(UserItem,boot);
      if boot then
      SendAddItem(UserItem,1);
      WeightChanged();

      if g_Config.boShowMakeItemMsg and (m_btPermission >= Cmd.nPermissionMax) then
        MainOutMessage('[齡芚] ' + m_sCharName + ' ' + sItemName + '(' + IntToStr(UserItem.MakeIndex) + ')');
            //004CD10D
      if StdItem.NeedIdentify = 1 then
            AddGameDataLog('5' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                        StdItem.Name + #9 +
                        IntToStr(UserItem.MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[齡芚]');
    end else begin //004CD114
      Dispose(UserItem);
      SysMsg(format(g_sGamecommandMakeItemNameNotFound,[sItemName]),c_Red,t_Hint);
      break;
    end;
  end;
end;

{procedure TPlayObject.CmdMakeItem1(Cmd:pTGameCmd;sItemName: String; nCount: Integer);//004CCE34       //유저 생산 명령어
var
  I: Integer;
  UserItem:pTUserItem;
  StdItem:TItem;
  boot:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sItemName = '') then begin
   // SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGamecommandMakeHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  if (nCount <= 0) then nCount:=1;
  if (nCount > 10) then nCount:=10;
    if not CanMakeItem(sItemName) then begin
    //  SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot,c_Red,t_Hint);
      exit;
    end;


  for I := 0 to nCount - 1 do begin
      if m_ItemList.Count >= MAXBAGITEM then exit;
      New(UserItem);
     if UserEngine.CopyToUserItemFromName(sItemName,UserItem) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5)then begin
        Dispose(UserItem);
      end else begin
       //if Random(g_Config.nMakeRandomAddValue) = 0 then
          StdItem.RandomUpgradeItem(UserItem);
      end;
      if StdItem.StdMode in [15,22,23,24,26] then begin    //미지템  옵션
        if StdItem.Shape in [130,131,132] then begin
          StdItem.RandomUpgradeUnknownItem(UserItem);
        end;
      end;
        AddItemToBag(UserItem,boot);
        if boot then
        SendAddItem(UserItem,1);
        WeightChanged();
    end else begin //004CD114
      Dispose(UserItem);
    //  SysMsg(format(g_sGamecommandMakeItemNameNotFound,[sItemName]),c_Red,t_Hint);
      break;
    end;
  end;
end;     }

procedure TPlayObject.CmdTRACK(Cmd:pTGameCmd;sItemName: String; nCount: Integer);
var
  I: Integer;
  UserItem:pTUserItem;
  StdItem:TItem;
  boot:Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    exit;
  end;
  if (sItemName = '') then begin
    exit;
  end;
  if (nCount <= 0) then nCount:=1;
  if (nCount > 10) then nCount:=10;
    if not CanMakeItem(sItemName) then begin
      exit;
    end;


  for I := 0 to nCount - 1 do begin
      if m_ItemList.Count >= MAXBAGITEM then exit;
      New(UserItem);
     if UserEngine.CopyToUserItemFromName(sItemName,UserItem) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5)then begin
        Dispose(UserItem);
      end else begin
       if Random(g_Config.nMakeRandomAddValue{10}) = 0 then
          StdItem.RandomUpgradeItem(UserItem);
      end;
      if StdItem.StdMode in [15,22,23,24,26] then begin
        if StdItem.Shape in [130,131,132] then begin
          StdItem.RandomUpgradeUnknownItem(UserItem);
        end;
      end;
        AddItemToBag(UserItem,boot);
        if boot then
        SendAddItem(UserItem,1);
        WeightChanged();
    end else begin //004CD114
      Dispose(UserItem);

      break;
    end;
  end;
end;

procedure TPlayObject.CmdMapMove(Cmd:pTGameCmd;sMapName: String);
var
  Envir:TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandMoveHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  Envir:=g_MapManager.FindMap(sMapName);
  if (Envir = nil) then begin
    SysMsg(format(g_sTheMapNotFound,[sMapName]),c_Red,t_Hint);
    exit;
  end;
  if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then begin
    SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
    NoMapRandomMove(sMapName,0);         //nomove작업
  end else begin
    SysMsg(format(g_sTheMapDisableMove,[sMapName,Envir.sMapDesc]),c_Red,t_Hint);
  end;
end;
//004CDA38
procedure TPlayObject.CmdPositionMove(Cmd:pTGameCmd;sMapName, sX, sY: String);      //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
begin
try
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMapName = '') or (sX = '') or (sY = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandPositionMoveHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then begin
    Envir:=g_MapManager.FindMap(sMapName);
    if Envir <> nil then begin
      nX:=Str_ToInt(sX,0);
      nY:=Str_ToInt(sY,0);
      if Envir.CanWalk(nX,nY,True) then begin
        NoSpaceMove(sMapName,nX,nY,0);           //nomove작업
      end else begin
        SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap,[sMapName,sX,sY]),c_Green,t_Hint);
      end;
    end;
  end else begin
    SysMsg(format(g_sTheMapDisableMove,[sMapName,Envir.sMapDesc]),c_Red,t_Hint);
  end;
except
  on e: Exception do begin
    MainOutMessage('[Exceptioin] TPlayObject.CmdPositionMove');
    MainOutMessage(E.Message);
  end;

end;
end;

procedure TPlayObject.CmdMapClickMove(Cmd:pTGameCmd; sX, sY: String);      //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
  I: Integer;
  PlayObject:TPlayObject;
  StdItem:TItem;
  UserItem:pTUserItem;
  okmove:Boolean;
begin
  if (sX = '') or (sY = '') then begin
    exit;
  end;
  okmove := False;
  PlayObject:=UserEngine.GeTPlayObject(Self.m_sCharName);
  if PlayObject <> nil then begin
    for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
      UserItem:=PlayObject.m_ItemList.Items[I];
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (StdItem.StdMode = 45) and (StdItem.Shape = 1) then begin
        if CanMoveMap(PlayObject.m_PEnvir.sMapName) then begin
          Envir:=g_MapManager.FindMap(PlayObject.m_PEnvir.sMapName);
          if Envir <> nil then begin
            nX:=Str_ToInt(sX,0);
            nY:=Str_ToInt(sY,0);
            if Envir.CanWalk(nX,nY,True) and (nX <> PlayObject.m_nCurrX) and (nY <> PlayObject.m_nCurrY) then begin
              okmove := True;
              NoSpaceMove(PlayObject.m_PEnvir.sMapName,nX,nY,0);           //nomove작업
            end else begin
              okmove := False;
              SysMsg('轟랬盧땡。',c_Green,t_Hint);
            end;
          end;
        end;
        if okmove then begin
          if (UserItem.Amount > StdItem.MaxAmount) then begin  //물약 버그
            PlayObject.SendDelItems(UserItem);
            Dispose(UserItem);
            PlayObject.m_ItemList.Delete(I);
          end else begin
            if (UserItem.Amount > 1) then begin
              Dec(UserItem.Amount,1);
              SendAddItemmode(UserItem,3);  //물약
            end else begin
              PlayObject.SendDelItems(UserItem);
              Dispose(UserItem);
              PlayObject.m_ItemList.Delete(I);
            end;
          end;
        end;
        break;
      end;
    end;
  end;

end;

procedure TPlayObject.CmdShoutGreen(Cmd:pTGameCmd; sStr: String);      //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
  I: Integer;
  StdItem:TItem;
  UserItem:pTUserItem;
  okmove:Boolean;
begin
  if (sStr = '') then exit;
  okmove := False;

  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (StdItem.StdMode = 45) and (StdItem.Shape = 2) then begin
      if m_Abil.Level >= StdItem.NeedLevel then begin
        okmove := True;
        UserEngine.SendBroadCastMsg(m_sCharName + #9 + GetItemInfo(sStr),t_Cust);       //고성 녹색
      end else begin
        SysMsg(g_sLevelNot,c_Red,t_Hint);
      end;
      if okmove then begin
        if (UserItem.Amount > StdItem.MaxAmount) then begin  //물약 버그
          SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(I);
        end else begin
          if (UserItem.Amount > 1) then begin
            Dec(UserItem.Amount,1);
            SendAddItemmode(UserItem,3);  //물약
          end else begin
            SendDelItems(UserItem);
            Dispose(UserItem);
            m_ItemList.Delete(I);
          end;
        end;
      end;
      break;
    end;
  end;
end;

procedure TPlayObject.CmdShoutPurple(Cmd:pTGameCmd; sStr: String);      //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
  I: Integer;
  StdItem:TItem;
  UserItem:pTUserItem;
  okmove:Boolean;
begin
  if (sStr = '') then exit;
  okmove := False;

  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (StdItem.StdMode = 45) and (StdItem.Shape = 3) then begin
      if m_Abil.Level >= StdItem.NeedLevel then begin
        okmove := True;
        UserEngine.SendBroadCastMsg(m_sCharName + #9 + GetItemInfo(sStr),t_Cust1);      //고성 보라
      end else begin
        SysMsg(g_sLevelNot,c_Red,t_Hint);
      end;
      if okmove then begin
        if (UserItem.Amount > StdItem.MaxAmount) then begin  //물약 버그
          SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(I);
        end else begin
          if (UserItem.Amount > 1) then begin
            Dec(UserItem.Amount,1);
            SendAddItemmode(UserItem,3);  //물약
          end else begin
            SendDelItems(UserItem);
            Dispose(UserItem);
            m_ItemList.Delete(I);
          end;
        end;
      end;
      break;
    end;
  end;
end;


procedure TPlayObject.CmdPositionGtMove(Cmd:pTGameCmd;sMapName, sX, sY, number: String);
var
  Envir:TEnvirnoment;
  nX,nY,nNumber:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    exit;
  end;

  if (sMapName = '') or (sX = '') or (sY = '') or (number = '')  or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandPositionGtMoveHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  nNumber := Str_ToInt(number,1);

  Envir:=g_MapManager.FindMap(sMapName);
  if Envir <> nil then begin
    nX:=Str_ToInt(sX,0);
    nY:=Str_ToInt(sY,0);
    if Envir.CanWalk(nX,nY,True) then begin
      if (sMapName = 'GA0') or (sMapName = 'GA1') or (sMapName = 'GA2')or (sMapName = 'GA3') then begin
        SpaceGTMoveEX(sMapName,nX,nY,0,nNumber);
      end else begin
        SysMsg('鏤蹈뒈暠긍뵀：GA0,GA1,GA2,GA3 (댕畇).',c_Green,t_Hint);
      end;
    end else begin
      SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap,[sMapName,sX,sY]),c_Green,t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdHomeMove(Cmd:pTGameCmd);  //마을이동
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (not m_PEnvir.Flag.boNOCASTLEMOVE) then begin
    SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
    if PKLevel < 2 then begin
      BaseObjectMove(m_sHomeMap,IntToStr(m_nHomeX),IntToStr(m_nHomeY));
    end else begin
      BaseObjectMove(g_Config.sRedHomeMap,IntToStr(g_Config.nRedHomeX),IntToStr(g_Config.nRedHomeY));
    end;
  end else begin
    SysMsg('묑냘濫珂쐐岺賈痰。',c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdMaskClear(Cmd:pTGameCmd);  //변신탈 해제
begin
 if m_PEnvir.Flag.boDEATHMATCH then exit;
 if (m_btMask > 0) then begin
  m_dwStatusArrTimeOutTick[16]:=0;
  m_dwStatusArrTimeOutTick[27]:=0;
  m_dwStatusArrTimeOutTick[37]:=0;
  m_dwStatusArrTimeOutTick[38]:=0;
  m_dwStatusArrTimeOutTick[39]:=0;
  m_nKillMonExpRate3:= 100;
  m_dwStatusArrTimeOutTick[80]:=0;
 end;
end;

procedure TPlayObject.CmdMapMoveHuman(Cmd:pTGameCmd;sSrcMap,sDenMap:String);
var
  SrcEnvir,DenEnvir:TEnvirnoment;
  HumanList:TList;
  I:Integer;
  MoveHuman:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sDenMap = '') or (sSrcMap = '') or ((sSrcMap <> '') and (sSrcMap[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandMapMoveHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  SrcEnvir:=g_MapManager.FindMap(sSrcMap);
  DenEnvir:=g_MapManager.FindMap(sDenMap);
  if (SrcEnvir = nil) then begin
    SysMsg(format(g_sGameCommandMapMoveMapNotFound,[sSrcMap]),c_Red,t_Hint);
    exit;
  end;
  if (DenEnvir = nil) then begin
    SysMsg(format(g_sGameCommandMapMoveMapNotFound,[sDenMap]),c_Red,t_Hint);
    exit;
  end;

  HumanList:=TList.Create;
  UserEngine.GetMapRageHuman(SrcEnvir,SrcEnvir.m_nWidth div 2,SrcEnvir.m_nHeight div 2,1000,HumanList);
  for I := 0 to HumanList.Count - 1 do begin
    MoveHuman:=TPlayObject(HumanList.Items[I]);
    if MoveHuman <> Self then
      MoveHuman.MapRandomMove(sDenMap,0);
  end;
  FreeAndNil(HumanList);
end;

procedure TPlayObject.CmdMemberFunction(sCmd, sParam: String);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('This command triggers the @Member label from manage npc',c_Red,t_Hint);
    exit;
  end;
  if g_ManageNPC <> nil then begin
    g_ManageNPC.GotoLable(Self,'@Member',False);
  end;
end;


procedure TPlayObject.CmdMemberFunctionEx(sCmd, sParam: String);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg('This command triggers the @member label from function npc',c_Red,t_Hint);
    exit;
  end;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self,'@Member',False);
  end;
end;

procedure TPlayObject.CmdMission(Cmd:pTGameCmd;sX, sY: String);//004CCA08
var
  nX,nY:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sX = '') or (sY = '') then begin
    SysMsg('賈痰렘랬: @' + Cmd.sCmd + ' <X> <Y>',c_Red,t_Hint);
    exit;
  end;
  nX:=Str_ToInt(sX,0);
  nY:=Str_ToInt(sY,0);
  g_boMission:=True;
  g_sMissionMap:=m_sMapName;
  g_nMissionX:=nX;
  g_nMissionY:=nY;
  SysMsg('Misson target set: ' + m_sMapName + '(' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ')',c_Green,t_Hint);
end;
procedure TPlayObject.CmdMob(Cmd:pTGameCmd;sMonName:String;nCount,nLevel:Integer; nExpRatio:Integer = -1); //004CC7F4
var
  I: Integer;
  nX,nY:Integer;
  Monster:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandMobHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  
  if nCount <= 0 then nCount:=1;
  if not (nLevel in [0..10]) then nLevel:=0;
    
  nCount:=_MIN(64,nCount);
  GetFrontPosition(nX,nY);
  for I := 0 to nCount - 1 do begin
    Monster:=UserEngine.RegenMonsterByName(m_PEnvir,nX,nY,sMonName);
    if Monster <> nil then begin
      Monster.m_btSlaveMakeLevel:=nLevel;
      Monster.m_btSlaveExpLevel:=nLevel;
      Monster.RecalcAbilitys;
      Monster.RefNameColor;
      if nExpRatio <> -1 then begin
        nExpRatio := _MIN(100,nExpRatio);
        Monster.m_dwFightExp := Monster.m_dwFightExp * nExpRatio;
      end;
    end else begin
      SysMsg(g_sGameCommandMobMsg,c_Red,t_Hint);
      break;
    end;      
  end;
end;

procedure TPlayObject.CmdMobCount(Cmd:pTGameCmd;sMapName: String);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandMobCountHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  Envir:=g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    SysMsg(g_sGameCommandMobCountMapNotFound,c_Red,t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandMobCountMonsterCount,[UserEngine.GetMapMonster(Envir,nil)]),c_Green,t_Hint);
end;


procedure TPlayObject.CmdHumanCount(Cmd:pTGameCmd;sMapName: String);
var
  Envir: TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandHumanCountHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  Envir:=g_MapManager.FindMap(sMapName);
  if Envir = nil then begin
    SysMsg(g_sGameCommandMobCountMapNotFound,c_Red,t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandMobCountMonsterCount,[UserEngine.GetMapHuman(sMapName)]),c_Green,t_Hint);
  SysMsg(IntToStr(Envir.HumCount),c_Green,t_Hint);
end;

procedure TPlayObject.CmdGMEventAbill(Cmd:pTGameCmd;Abil,Index,MinLevel,MaxLevel:String);     //gm 이벤트
var
  PlayObject:TPlayObject;
  i, nAbil, nIndex, nMinLevel, nMaxLevel: integer;
  str: string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    exit;
  end;

  if (Abil = '') or (Index = '') or (MinLevel = '') or (MaxLevel = '') then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandGMEventAbillHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  nAbil := StrToInt(Abil);
  nIndex := StrToInt(Index);
  nMinLevel := StrToInt(MinLevel);
  nMaxLevel := StrToInt(MaxLevel);
  for i := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
    PlayObject:=TPlayObject(UserEngine.m_PlayObjectList.Objects[i]);
    if PlayObject.m_btRaceServer = RC_PLAYOBJECT then begin
     if (PlayObject.m_Abil.Level >= nMinLevel) and (PlayObject.m_Abil.Level <= nMaxLevel) then begin
      Case nAbil of
        0: begin
           PlayObject.m_wStatusArrValue[52] := 0;
           PlayObject.m_wStatusArrValue[53] := 0;
           PlayObject.m_wStatusArrValue[54] := 0;
           PlayObject.m_wStatusArrValue[55] := 0;
           PlayObject.m_wStatusArrValue[56] := 0;
           PlayObject.m_wStatusArrValue[57] := 0;
           PlayObject.m_wStatusArrValue[58] := 0;
           PlayObject.m_wStatusArrValue[59] := 0;
           PlayObject.m_nKillMonExpRate7 := 100;
        end;
        1: begin
           PlayObject.m_wStatusArrValue[52] := nIndex;
        end;
        2: begin
           PlayObject.m_wStatusArrValue[53] := nIndex;
        end;
        3: begin
           PlayObject.m_wStatusArrValue[54] := nIndex;
        end;
        4: begin
           PlayObject.m_wStatusArrValue[55] := nIndex;
        end;
        5: begin
           PlayObject.m_wStatusArrValue[56] := nIndex;
        end;
        6: begin
           PlayObject.m_wStatusArrValue[57] := nIndex;
        end;
        7: begin
           PlayObject.m_wStatusArrValue[58] := nIndex;
        end;
        8: begin
           PlayObject.m_wStatusArrValue[59] := nIndex;
        end;
        9: begin
           PlayObject.m_nKillMonExpRate7 := 100 + nIndex;
        end;
      end;
      if nAbil <> 0 then begin
        str := '[ GM ]\';
        if PlayObject.m_wStatusArrValue[52] > 0 then
           str := str + '묑샌 +' + IntToStr(PlayObject.m_wStatusArrValue[52]) + '-' + IntToStr(PlayObject.m_wStatusArrValue[52]) + '\';
        if PlayObject.m_wStatusArrValue[53] > 0 then
           str := str + '침랬 +' + IntToStr(PlayObject.m_wStatusArrValue[53]) + '-' + IntToStr(PlayObject.m_wStatusArrValue[53]) + '\';
        if PlayObject.m_wStatusArrValue[54] > 0 then
           str := str + '돛減 +' + IntToStr(PlayObject.m_wStatusArrValue[54]) + '-' + IntToStr(PlayObject.m_wStatusArrValue[54]) + '\';
        if PlayObject.m_wStatusArrValue[55] > 0 then
           str := str + '렝徒 +' + IntToStr(PlayObject.m_wStatusArrValue[55]) + '-' + IntToStr(PlayObject.m_wStatusArrValue[55]) + '\';
        if PlayObject.m_wStatusArrValue[56] > 0 then
           str := str + '침랬렝徒 +' + IntToStr(PlayObject.m_wStatusArrValue[56]) + '-' + IntToStr(PlayObject.m_wStatusArrValue[56]) + '\';
        if PlayObject.m_wStatusArrValue[57] > 0 then
           str := str + '餉篁 +' + IntToStr(PlayObject.m_wStatusArrValue[57]) + '\';
        if PlayObject.m_wStatusArrValue[58] > 0 then
           str := str + '침랬令 +' + IntToStr(PlayObject.m_wStatusArrValue[58]) + '\';
        if PlayObject.m_wStatusArrValue[59] > 0 then
           str := str + '妗頓 +' + IntToStr(PlayObject.m_wStatusArrValue[59]) + '\';
        if PlayObject.m_nKillMonExpRate7 > 100 then
           str := str + '쒔駱令 +' + IntToStr(PlayObject.m_nKillMonExpRate7) + '%\';

        PlayObject.SendMsg(self, RM_BUFF, 65, 0, 51, 1, Str); //GM 버프
      end else begin
        PlayObject.SendMsg(self, RM_BUFF, 65, 0, 51, 0, ''); //GM 버프
      end;
      PlayObject.RecalcAbilitys;
     // PlayObject.SendRefMsg(RM_10205,0,PlayObject.m_nCurrX,PlayObject.m_nCurrY,119,'0');  //gm 이벤트 이팩
      PlayObject.SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      PlayObject.SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
     end;
    end;
  end;
end;

procedure TPlayObject.CmdMobFireBurn(Cmd: pTGameCmd; sMap, sX, sY, sType,
  sTime, sPoint: String);
var
  nX,nY,nType,nTime,nPoint:Integer;
  FireBurnEvent:TFireBurnEvent;
  Envir:TEnvirnoment;
  OldEnvir:TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMap = '') or ((sMap <> '') and (sMap[1] = '?')) then begin
    SysMsg(format(g_sGameCommandMobFireBurnHelpMsg,[Cmd.sCmd,sMap, sX, sY, sType,sTime, sPoint]),c_Red,t_Hint);
    exit;
  end;

  nX:=Str_ToInt(sX,-1);
  nY:=Str_ToInt(sY,-1);
  nType:=Str_ToInt(sType,-1);
  nTime:=Str_ToInt(sTime,-1);
  nPoint:=Str_ToInt(sPoint,-1);
  if nPoint < 0 then nPoint:=1;
    
  if (sMap = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or (nPoint < 0) then begin
    SysMsg(format(g_sGameCommandMobFireBurnHelpMsg,[Cmd.sCmd,sMap, sX, sY, sType,sTime, sPoint]),c_Red,t_Hint);
    exit;
  end;
  Envir:=g_MapManager.FindMap(sMap);
  if Envir <> nil then begin
    OldEnvir:=m_PEnvir;
    m_PEnvir:=Envir;
    FireBurnEvent:=TFireBurnEvent.Create(Self,nX,nY,nType,nTime * 1000,nPoint);
    g_EventManager.AddEvent(FireBurnEvent);
    m_PEnvir:=OldEnvir;
    exit;
  end;
  SysMsg(format(g_sGameCommandMobFireBurnMapNotFountMsg,[Cmd.sCmd,sMap]),c_Red,t_Hint);
end;

procedure TPlayObject.CmdMobLevel(Cmd:pTGameCmd;Param:String); //004CFD5C
var
  I: Integer;
  BaseObjectList:TList;
  BaseObject:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((Param <> '') and (Param[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,'']),c_Red,t_Hint);
    exit;
  end;

  BaseObjectList:=TList.Create;
  m_PEnvir.GetRangeBaseObject(m_nCurrX,m_nCurrY,2,True,BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do begin
    BaseObject:=TBaseObject(BaseObjectList.Items[i]);
    SysMsg(BaseObject.GeTBaseObjectInfo(),c_Green,t_Hint);
  end;
  FreeAndNil(BaseObjectList);
end;
procedure TPlayObject.CmdMobNpc(sCmd:String;nPermission:Integer;sParam1,sParam2,sParam3,sParam4:String);
var
  nAppr:Integer;
  boIsCastle:Boolean;
  Merchant:TMerchant;
  nX,nY:Integer;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sParam1 = '') or (sParam2 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandMobNpcHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  nAppr:=Str_ToInt(sParam3,0);
  boIsCastle:=(Str_ToInt(sParam4,0) = 1);
  if sParam1 = '' then begin
    SysMsg('賈痰렘랬: @' + sCmd + ' <NPC츰俚> <냘광츰俚> <Appr> <Castle Npc>(0,1)',c_Red,t_Hint);
    exit;
  end;
  Merchant:=TMerchant.Create;
  Merchant.m_sCharName:=sParam1;
  Merchant.m_sMapName:=m_sMapName;
  Merchant.m_PEnvir:=m_PEnvir;
  Merchant.m_wAppr:=nAppr;
  Merchant.m_nFlag:=0;
  Merchant.m_boCastle:=boIsCastle;
  Merchant.m_sScript:=sParam2;
  GetFrontPosition(nX,nY);
  Merchant.m_nCurrX:=nX;
  Merchant.m_nCurrY:=nY;
  Merchant.Initialize();
  UserEngine.AddMerchant(Merchant);
end;
procedure TPlayObject.CmdMobPlace(Cmd:pTGameCmd;sX, sY, sMonName, sCount: String); //004CCBB4
var
  I: Integer;
  nCount,nX,nY:Integer;
  MEnvir:TEnvirnoment;
  Mon:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  nCount:=_MIN(500,Str_ToInt(sCount,0));
  nX:=Str_ToInt(sX,0);
  nY:=Str_ToInt(sY,0);
  MEnvir:=g_MapManager.FindMap(g_sMissionMap);
  if (nX <= 0) or (nY <= 0) or (sMonName = '') or (nCount <= 0) then begin
    SysMsg('賈痰렘랬: @' + Cmd.sCmd + ' <X> <Y> <밍膠츰俚> <鑒좆>',c_Red,t_Hint);
    exit;
  end;
  if not g_boMission or (MEnvir = nil) then begin
    SysMsg('You need to set a mission objective first',c_Red,t_Hint);
    SysMsg('Use this: @' + g_GameCommand.MISSION.sCmd + ' command first',c_Red,t_Hint);
    exit;
  end;

  for I := 0 to nCount - 1 do begin
    Mon:=UserEngine.RegenMonsterByName(g_sMissionMap,nX,nY,sMonName);
    if Mon <> nil then begin
      Mon.m_boMission:=True;
      Mon.m_nMissionX:=g_nMissionX;
      Mon.m_nMissionY:=g_nMissionY;
    end else break;
  end;
  SysMsg(IntToStr(nCount) + ' times ' + sMonName + ' have spawned at: ' + g_sMissionMap + ' ' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + '',c_Green,t_Hint);
end;

procedure TPlayObject.CmdNpcScript(sCmd:String;nPermission:Integer;sParam1,sParam2,sParam3:String);
var
  BaseObject:TBaseObject;
  nNPCType:Integer;
  I:Integer;
  sScriptFileName:String;
  Merchant:TMerchant;
  NormNpc:TNormNpc;
  LoadList:TStringList;
  sScriptLine:String;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  {if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandNpcScriptHelpMsg]),c_Red,t_Hint);
    exit;
  end; }
  
  nNPCType:= -1;
  BaseObject:=GetPoseCreate();
  if BaseObject <> nil then begin
    for I := 0 to UserEngine.m_MerchantList.Count - 1 do begin
      if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then begin
        nNPCType:=0;
        break;
      end;
    end;
    for I := 0 to UserEngine.QuestNPCList.Count - 1 do begin
      if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then begin
        nNPCType:=1;
        break;
      end;
    end;
  end;
  if nNPCType < 0 then begin
    SysMsg('Npc not found',c_Red,t_Hint);
    exit;
  end;

  if sParam1 = '' then begin
    if nNPCType = 0 then begin
      Merchant:=TMerchant(BaseObject);
      sScriptFileName:=g_Config.sEnvirDir + sMarket_Def + Merchant.m_sScript + '-' + Merchant.m_sMapName  + '.txt';
    end;
    if nNPCType = 1 then begin
      NormNpc:=TNormNpc(BaseObject);
      sScriptFileName:=g_Config.sEnvirDir + sNpc_def + NormNpc.m_sCharName + '-' + NormNpc.m_sMapName  + '.txt';
    end;
    if FileExists(sScriptFileName) then begin
      LoadList:=TStringList.Create;
      try
      LoadList.LoadFromFile(sScriptFileName);
      except
        SysMsg('File Read error: ' + sScriptFileName,c_Red,t_Hint);
      end;
      for I := 0 to LoadList.Count - 1 do begin
        sScriptLine:=Trim(LoadList.Strings[I]);
        sScriptLine:=ReplaceChar(sScriptLine,' ',',');
        SysMsg(IntToStr(I) + ',' + sScriptLine,c_Blue,t_Hint);
      end;
      FreeAndNil(LoadList);
    end;
  end;
end;
procedure TPlayObject.CmdOPDeleteSkill(sHumanName, sSkillName: String);//004CE938
begin
  if (m_btPermission < 6) then exit;
end;
procedure TPlayObject.CmdOPTraining(sHumanName, sSkillName: String;
  nLevel: Integer);//004CC468
begin
  if (m_btPermission < 6) then exit;
end;
procedure TPlayObject.CmdPKpoint(Cmd:pTGameCmd;sHumanName:String);//004CC61C
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandPKPointHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandPKPointMsg,[sHumanName,PlayObject.m_nPkPoint]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdPrvMsg(sCmd: String; nPermission: Integer;
  sHumanName: String);
var
  I: Integer;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandPrvMsgHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  for I := 0 to m_BlockWhisperList.Count - 1 do begin
    if CompareText(m_BlockWhisperList.Strings[I],sHumanName) = 0 then begin
      m_BlockWhisperList.Delete(I);
      SysMsg(format(g_sGameCommandPrvMsgUnLimitMsg,[sHumanName]),c_Green,t_Hint);
      exit;
    end;
  end;
  m_BlockWhisperList.Add(sHumanName);
  SysMsg(format(g_sGameCommandPrvMsgLimitMsg,[sHumanName]),c_Green,t_Hint);

end;

procedure TPlayObject.CmdReAlive(Cmd:pTGameCmd;sHumanName: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandReAliveHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  PlayObject.ReAlive;
  PlayObject.m_WAbil.HP:= Round(PlayObject.m_WAbil.MaxHP * 0.10);
  PlayObject.SendMsg(PlayObject,RM_ABILITY,0,0,0,0,'');

  SysMsg(format(g_sGameCommandReAliveMsg,[sHumanName]),c_Green,t_Hint);
  SysMsg(sHumanName + '굳릿삶죄。',c_Green,t_Hint);
end;

procedure TPlayObject.CmdRecallHuman(Cmd:pTGameCmd;sHumanName:String); //004CE250
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandRecallHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  RecallHuman(sHumanName);
end;
procedure TPlayObject.CmdRecallMob(Cmd:pTGameCmd;sMonName:String;nCount,nLevel:Integer);//004CC8C4
var
  I: Integer;
  nX,nY:Integer;
  Mon:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandRecallMobHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  
  if nLevel >=10 then nLevel:=0;
  if nCount <= 0 then nCount:=1;    
  for I := 0 to nCount - 1 do begin
    if m_SlaveList.Count >= 20 then break;
    GetFrontPosition(nX,nY);
    Mon:=UserEngine.RegenMonsterByName(m_PEnvir,nX,nY,sMonName);
    if Mon <> nil then begin
      Mon.m_Master:=Self;
      Mon.m_dwMasterRoyaltyTick:=GetTickCount + 24 * 60 * 60 * 1000;
      Mon.m_btSlaveMakeLevel:=3;
      Mon.m_btSlaveExpLevel:=nLevel;
      Mon.RecalcAbilitys();
      Mon.RefNameColor();
      m_SlaveList.Add(Mon);
    end;
  end;
end;
procedure TPlayObject.CmdReconnection(sCmd,sIPaddr, sPort: String);
//004CE380
begin
  if (m_btPermission < 6) then exit;
  if (sIPaddr <> '') and (sIPaddr[1] = '?') then begin
    SysMsg('this command allows you to reconnect to a different ip/port',c_Blue,t_Hint);
    exit;
  end;
    
  if (sIPaddr = '') or (sPort = '') then begin
    SysMsg('Usage: @' + sCmd + ' IP port',c_Red,t_Hint);
    exit;
  end;
  if (sIPaddr <> '') and (sPort <> '') then begin
    SendMsg(Self,RM_RECONNECTION,0,0,0,0,sIPaddr + '/' + sPort);
  end;
end;
procedure TPlayObject.CmdRefineWeapon(Cmd:pTGameCmd;nDC, nMC, nSC, nHit: Integer);//004CD1C4
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (nDC + nMC + nSC) > 20 then exit;
  if m_UseItems[U_WEAPON].wIndex <= 0 then exit;
  m_UseItems[U_WEAPON].btValue[0]:=nDC;
  m_UseItems[U_WEAPON].btValue[1]:=nMC;
  m_UseItems[U_WEAPON].btValue[2]:=nSC;
  m_UseItems[U_WEAPON].btValue[5]:=nHit;
  SendUpdateItem(@m_UseItems[U_WEAPON]);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  MainOutMessage('[밗잿逃 嶠포薨]' +  m_sCharName + ' DC:' + IntToStr(nDC) + ' MC' + IntToStr(nMC) + ' SC' + IntToStr(nSC) + ' HIT:' + IntToStr(nHit));
end;
procedure TPlayObject.CmdReGotoHuman(Cmd:pTGameCmd;sHumanName:String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandReGotoHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  SpaceMove(PlayObject.m_PEnvir.sMapName,PlayObject.m_nCurrX,PlayObject.m_nCurrY,0);

end;


procedure TPlayObject.CmdReloadAbuse(sCmd: String; nPerMission: Integer;
  sParam1: String);
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
end;

procedure TPlayObject.CmdReLoadAdmin(sCmd: String);
begin
  if (m_btPermission < 6) then exit;
  FrmDB.LoadAdminList();
  UserEngine.SendServerGroupMsg(213,nServerIndex,'');
  SysMsg('路劤속潼밗잿逃죗깊냥묘...',c_Green,t_Hint);
end;

procedure TPlayObject.CmdReLoadColumn(sCmd: String);  //홍보단
begin
  if (m_btPermission < 6) then exit;
  FrmDB.LoadColumnList();
  UserEngine.SendServerGroupMsg(213,nServerIndex,'');
  SysMsg('路劤속潼淚으죗깊냥묘...',c_Green,t_Hint);
end;

procedure TPlayObject.CmdReloadGuild(sCmd: String; nPerMission: Integer;      //문파 리로드
  sParam1: String);
var
  Guild:TGuild;
  PlayObject:TPlayObject;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandReloadGuildHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg(g_sGameCommandReloadGuildOnMasterserver,c_Red,t_Hint);
    exit;
  end;

  Guild:=g_GuildManager.FindGuild(sParam1);
  if Guild = nil then begin
    SysMsg(format(g_sGameCommandReloadGuildNotFoundGuildMsg,[sParam1]),c_Red,t_Hint);
    exit;
  end;
  Guild.LoadGuild();
end;


procedure TPlayObject.CmdloadGuild(sCmd: String; nPerMission: Integer;   //초보문파
  sParam1: String);
var
  Guild:TGuild;
  PlayObject:TPlayObject;
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,g_sGameCommandReloadGuildHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg(g_sGameCommandReloadGuildOnMasterserver,c_Red,t_Hint);
    exit;
  end;

  Guild:=g_GuildManager.FindGuild(sParam1);
  if Guild = nil then begin
    SysMsg(format(g_sGameCommandReloadGuildNotFoundGuildMsg,[sParam1]),c_Red,t_Hint);
    exit;
  end;
  Guild.LoadGuild();

  m_MyGuild:=g_GuildManager.MemberOfGuild(m_sCharName);
  m_sGuildRankName:=TGuild(m_MyGuild).GetRankName(Self,m_nGuildRankNo);
  TGuild(m_MyGuild).SendGuildMsg('(!)' + #7 + m_sCharName + #7 +'쏵흙죄踏狗。');
  UserEngine.SendServerGroupMsg(SS_208,nServerIndex,TGuild(m_MyGuild).sGuildName + '/' + '' + '/' + m_sCharName + '쏵흙죄踏狗。');
  m_MyGuild:= m_MyGuild;
  RefShowName();

  SysMsg(format(g_sGameCommandReloadGuildSuccessMsg,[sParam1]),c_Green,t_Hint);
  UserEngine.SendServerGroupMsg(SS_207,nServerIndex,sParam1);
end;

procedure TPlayObject.CmdReloadGuildAll;//004CE530
begin
  if (m_btPermission < 6) then exit;
end;


procedure TPlayObject.CmdReloadLineNotice(sCmd: String;
  nPerMission: Integer; sParam1: String);
begin
  if (m_btPermission < nPermission) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  if LoadLineNotice(g_Config.sNoticeDir + 'LineNotice.txt') then begin
    SysMsg(g_sGameCommandReloadLineNoticeSuccessMsg,c_Green,t_Hint);
  end else begin
    SysMsg(g_sGameCommandReloadLineNoticeFailMsg,c_Red,t_Hint);
  end;
  if LoadLineHint(g_Config.sNoticeDir + 'LineHint.txt') then begin
    SysMsg('路劤속潼瞳窟瓊刻斤口냥묘...', c_Green, t_Hint);
  end
  else begin
    SysMsg('路劤속潼瞳窟瓊刻斤口呵겨...', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadManage(Cmd:pTGameCmd;sParam:String);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam <> '') and (sParam[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  if sParam = '' then begin
    if g_ManageNPC <> nil then begin
      g_ManageNPC.ClearScript();
      g_ManageNPC.LoadNPCScript();
      SysMsg('Manage Script reloaded..',c_Green,t_Hint);
    end else begin
      SysMsg('Manage Script not found...',c_Green,t_Hint);
    end;
  end else begin
    if g_FunctionNPC <> nil then begin
      g_FunctionNPC.ClearScript();
      g_FunctionNPC.LoadNPCScript();
      SysMsg('Function Script reloaded...',c_Green,t_Hint);
    end else begin
      SysMsg('Function Script not found...',c_Green,t_Hint);
    end;
  end;
end;
procedure TPlayObject.CmdReloadRobot;
begin
  RobotManage.ReLoadRobot();
  SysMsg('Robot Reloaded...',c_Green,t_Hint);
end;
procedure TPlayObject.CmdReloadRobotManage;
begin
  if (m_btPermission < 6) then exit;
  if g_RobotNPC <> nil then begin
    g_RobotNPC.ClearScript();
    g_RobotNPC.LoadNPCScript();
    RobotManage.RELOADROBOT();
    SysMsg('Robot Script Reloaded...',c_Green,t_Hint);
  end else begin
    SysMsg('Robot Script not found...',c_Green,t_Hint);
  end;
end;
procedure TPlayObject.CmdReloadMonItems;//
var
  I: Integer;
  Monster:pTMonInfo;
begin
  if (m_btPermission < 6) then exit;
try
    for I := 0 to UserEngine.MonsterList.Count - 1 do begin
      Monster:=UserEngine.MonsterList.Items[I];
      FrmDB.LoadMonitems(Monster.sName,Monster.ItemList);
    end;
  SysMsg('路劤속潼괵쪽斤口냥묘..',c_Green,t_Hint);
except
  SysMsg('路劤속潼괵쪽斤口呵겨..',c_Green,t_Hint);
end;
end;
procedure TPlayObject.CmdReloadNpc(sParam: String); //004CFFF8
var
  I: Integer;
  TmpList:TList;
  Merchant:TMerchant;
  Npc:TNormNpc;
begin
  if (m_btPermission < 6) then exit;
  if CompareText('all',sParam) = 0 then begin
    FrmDB.ReLoadMerchants();
    UserEngine.ReloadMerchantList();
    SysMsg('Merchantlist Reloaded',c_Red,t_Hint);
    UserEngine.ReloadNpcList();
    SysMsg('Npc list reloaded',c_Red,t_Hint);
    exit;
  end; //004D0136
  TmpList:=TList.Create;
  if UserEngine.GetMerchantList(m_PEnvir,m_nCurrX,m_nCurrY,9,TmpList) > 0 then begin
    for I := 0 to TmpList.Count - 1 do begin
      Merchant:=TMerchant(TmpList.Items[i]);
      Merchant.ClearScript;
      Merchant.LoadNPCScript;
      SysMsg(Merchant.m_sCharName + ' reloaded...',c_Green,t_Hint);
    end;    // for
  end else begin
    SysMsg('No Merchant''s in area to reload...',c_Red,t_Hint);
  end;
  TmpList.Clear;
  if UserEngine.GetNpcList(m_PEnvir,m_nCurrX,m_nCurrY,9,TmpList) > 0 then begin
    for I := 0 to TmpList.Count - 1 do begin
      Npc:=TNormNpc(TmpList.Items[i]);
      Npc.ClearScript;
      Npc.LoadNPCScript;
      SysMsg(Npc.m_sCharName + 'reloaded...',c_Green,t_Hint);
    end;    // for
  end else begin
    SysMsg('No Npc''s in area to reload...',c_Red,t_Hint);
  end;
  FreeAndNil(TmpList);
end;
procedure TPlayObject.CmdAddKillPoint (sCmd, sHumanName ,sCtr,strFameCur : string);    //킬 포인트 주기
var
   nFameCur : integer;
   FameGrade: integer;
   Ctr:Char;
   PlayObject:TPlayObject;
begin
   // 길이 초과
 if m_boProbeNecklace or (m_btPermission >= 6) then begin
  if (sHumanName = '') or (sCtr = '') or (strFameCur = '') then begin
    SysMsg('賈痰렘랬: @' + sCmd + ' <실ッ>' + '<+,-,=>' + ' <굘畇狂>',c_Red,t_Hint);
    exit;
  end;
  if (Length(strFameCur) > 10) then exit;
   PlayObject:=UserEngine.GeTPlayObject(sHumanName);
   if PlayObject <> nil then begin
     nFameCur := Str_ToInt(strFameCur, -1);
     Ctr:=sCtr[1];
     if (nFameCur = -1) then begin
       SysMsg('뎠품돨굘畇狂酵' + IntToStr(PlayObject.m_Abil.KillPointCurr),c_Green,t_Hint);
     end else begin
       // 음수 검사
       if (nFameCur < 0) then exit;

       if PlayObject.m_Abil.KillPointCurr + nFameCur > 30000 then exit;
       if PlayObject.m_Abil.KillPoint + nFameCur > 30000 then exit;

       case Ctr of
         '=': begin
          PlayObject.m_Abil.KillPointCurr := nFameCur;
          PlayObject.m_Abil.KillPoint := nFameCur;
         end;
         '-': begin
          if PlayObject.m_Abil.KillPointCurr - nFameCur < 0 then exit;
          if PlayObject.m_Abil.KillPoint - nFameCur < 0 then exit;
           PlayObject.m_Abil.KillPointCurr := PlayObject.m_Abil.KillPointCurr - nFameCur;
           PlayObject.m_Abil.KillPoint := PlayObject.m_Abil.KillPoint - nFameCur;
         end;
         '+': begin
          PlayObject.m_Abil.KillPointCurr := PlayObject.m_Abil.KillPointCurr + nFameCur;
          PlayObject.m_Abil.KillPoint := PlayObject.m_Abil.KillPoint + nFameCur;
         end;
       end;

       SysMsg('콱돨굘畇狂烋' + IntToStr(PlayObject.m_Abil.KillPointCurr) + '늴。',c_Green,t_Hint);
       PlayObject.SysMsg('콱돨굘畇狂烋' + IntToStr(PlayObject.m_Abil.KillPointCurr) + '늴。',c_Green,t_Hint);
      //명성치 변화를 알려줌.
       PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, GetFameName(FameGrade));
       PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, GetFameName(FameGrade));
     //  PlayObject.SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
    end;
   end else
    SysMsg(sHumanName + ' 꼇瞳窟。',c_RedWhite,t_Hint);
 end else begin
    SysMsg('맡츱즈꼇옵痰。',c_Red,t_Hint);
 end;
end;

procedure TPlayObject.CmdAddDeathPoint (sCmd, sHumanName,sCtr ,strFameCur : string);    //킬 포인트 주기
var
   nFameCur : integer;
   FameGrade: integer;
   Ctr:Char;
   PlayObject:TPlayObject;
begin
   // 길이 초과
 if m_boProbeNecklace or (m_btPermission >= 6) then begin
  if (sHumanName = '') or (sCtr = '') or (strFameCur = '') then begin
    SysMsg('賈痰렘랬: @' + sCmd + ' <실ッ>' + '<+,-,=>' + ' <价空늴鑒>',c_Red,t_Hint);
    exit;
  end;
  if (Length(strFameCur) > 10) then exit;
   PlayObject:=UserEngine.GeTPlayObject(sHumanName);
   if PlayObject <> nil then begin
     nFameCur := Str_ToInt(strFameCur, -1);
     Ctr:=sCtr[1];
     if (nFameCur = -1) then begin
       SysMsg('뎠품价空늴鑒槨：' + IntToStr(PlayObject.m_Abil.DeathPointCurr),c_Green,t_Hint);
     end else begin
       // 음수 검사
       if (nFameCur < 0) then exit;

       if PlayObject.m_Abil.DeathPointCurr + nFameCur > 30000 then exit;
       if PlayObject.m_Abil.DeathPoint + nFameCur > 30000 then exit;

       case Ctr of
         '=': begin
          PlayObject.m_Abil.DeathPointCurr := nFameCur;
          PlayObject.m_Abil.DeathPoint := nFameCur;
         end;
         '-': begin
          if PlayObject.m_Abil.DeathPointCurr - nFameCur < 0 then exit;
          if PlayObject.m_Abil.DeathPoint - nFameCur < 0 then exit;
           PlayObject.m_Abil.DeathPointCurr := PlayObject.m_Abil.DeathPointCurr - nFameCur;
           PlayObject.m_Abil.DeathPoint := PlayObject.m_Abil.DeathPoint - nFameCur;
         end;
         '+': begin
          PlayObject.m_Abil.DeathPointCurr := PlayObject.m_Abil.DeathPointCurr + nFameCur;
          PlayObject.m_Abil.DeathPoint := PlayObject.m_Abil.DeathPoint + nFameCur;
         end;
       end;

       SysMsg('콱돨价空늴鑒槨' +  IntToStr(PlayObject.m_Abil.DeathPointCurr) + '늴。',c_Green,t_Hint);
       PlayObject.SysMsg('콱돨价空늴鑒槨' + IntToStr(PlayObject.m_Abil.DeathPointCurr) + '늴。',c_Green,t_Hint);
      //명성치 변화를 알려줌.
       PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT, 0, m_Abil.KillPointCurr, 0, 0, GetFameName(FameGrade));
       PlayObject.SendMsg (self, RM_CHANGEFAMEPOINT2, 0, m_Abil.DeathPointCurr, 0, 0, GetFameName(FameGrade));
      // PlayObject.SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(FameGrade));
    end;
   end else
    SysMsg(sHumanName + ' 꼇瞳窟。',c_RedWhite,t_Hint);
 end else begin
    SysMsg('맡츱즈꼇옵痰。',c_Red,t_Hint);
 end;
end;

procedure TPlayObject.CmdSearchHuman(sCmd, sHumanName: String);    //탐색 목걸이
var
  PlayObject:TPlayObject;
begin
  if m_boProbeNecklace or (m_btPermission >= 6) then begin
    if (sHumanName = '') then begin
      SysMsg('賈痰렘랬: @' + sCmd + ' <실ッ>',c_Red,t_Hint);
      exit;
    end;
    if ((GetTickCount - m_dwProbeTick) > 60000) or (m_btPermission >= 3) then begin
      m_dwProbeTick:=GetTickCount();
      PlayObject:=UserEngine.GeTPlayObject(sHumanName);
      if PlayObject <> nil then begin
          SysMsg(sHumanName + '君瞳攣瞳뒈暠' + PlayObject.m_PEnvir.sMapDesc + '뇹，麟깃槨X：' + IntToStr(PlayObject.m_nCurrX) + 'Y:' + IntToStr(PlayObject.m_nCurrY) + '。',c_Green,t_Hint);
      end else
        SysMsg(sHumanName + ' 꼇瞳窟。',c_Green,t_Hint);
    end else begin
      SysMsg(IntToStr(60 - (GetTickCount - m_dwProbeTick) div 1000) + '취鹿빈옵鹿疼늴賈痰，',c_Red,t_Hint);
    end;
  end;
end;
procedure TPlayObject.CmdShowSbkGold(Cmd:pTGameCmd;sCastleName,sCtr,sGold:String);
var
  I: Integer;
  Ctr:Char;
  nGold:Integer;
  Castle:TUserCastle;
  List:TStringList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sCastleName <> '') and (sCastleName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,'']),c_Red,t_Hint);
    exit;
  end;
  if sCastleName = '' then begin
   List:=TStringList.Create;
   g_CastleManager.GetCastleGoldInfo(List);
   for I := 0 to List.Count - 1 do begin
     SysMsg(List.Strings[I],c_Green,t_Hint);
   end;
   FreeAndNil(List);
   exit;
  end;
  Castle:=g_CastleManager.Find(sCastleName);
  if Castle = nil then begin
    SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg,[sCastleName]),c_Red,t_Hint);
    exit;
  end;
    
  Ctr:=sCtr[1];
  nGold:=Str_ToInt(sGold,-1);
  if not (Ctr in ['=','-','+']) or (nGold < 0) or (nGold > 100000000) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandSbkGoldHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  case Ctr of
    '=': Castle.m_nTotalGold:=nGold;
    '-': Dec(Castle.m_nTotalGold);
    '+': Inc(Castle.m_nTotalGold,nGold);
  end;
  if Castle.m_nTotalGold < 0 then Castle.m_nTotalGold:=0;
    
end;


procedure TPlayObject.CmdShowUseItemInfo(Cmd: pTGameCmd;
  sHumanName: String);
var
  I: Integer;
  PlayObject:TPlayObject;
  UserItem:pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandShowUseItemInfoHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do begin
    UserItem:=@PlayObject.m_UseItems[I];
    if UserItem.wIndex = 0 then Continue;
    SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]',
                 [GetUseItemName(I),
                  UserEngine.GetStdItemName(UserItem.wIndex),
                  UserItem.wIndex,
                  UserItem.MakeIndex,
                  UserItem.Dura,
                  UserItem.DuraMax]),
                  c_Blue,t_Hint);
  end;
end;

procedure TPlayObject.CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: String);
var
  I: Integer;
  PlayObject:TPlayObject;
  UserItem:pTUserItem;
  nItem,nBind:Integer;
  ItemBind:pTItemBind;
  nItemIdx,nMakeIdex:Integer;
  sBindName:String;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  nBind:=-1;
  nItem:=GetUseItemIdx(sItem);
  if CompareText(sType,'UserID') = 0 then nBind:=0;
  if CompareText(sType,'CharName') = 0 then nBind:=1;
  if CompareText(sType,'IP') = 0 then nBind:=2;
    
  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandBindUseItemHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  UserItem:=@PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then begin
    SysMsg(format(g_sGameCommandBindUseItemNoItemMsg,[sHumanName,sItem]),c_Red,t_Hint);
    exit;
  end;
  nItemIdx:=UserItem.wIndex;
  nMakeIdex:=UserItem.MakeIndex;
  case nBind of    //
    0: begin
      sBindName:=PlayObject.m_sUserID;
      g_ItemBindAccount.Lock;
      try
        for I := 0 to g_ItemBindAccount.Count - 1 do begin
          ItemBind:=g_ItemBindAccount.Items[I];
          if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
            SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,[sHumanName,sItem]),c_Red,t_Hint);
            exit;
          end;
        end;
        New(ItemBind);
        ItemBind.nItemIdx:=nItemIdx;
        ItemBind.nMakeIdex:=nMakeIdex;
        ItemBind.sBindName:=sBindName;
        g_ItemBindAccount.Insert(0,ItemBind);
      finally
        g_ItemBindAccount.UnLock;
      end;
      SaveItemBindAccount();
      SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]BindName: %s',
                   [GetUseItemName(nItem),
                    UserEngine.GetStdItemName(UserItem.wIndex),
                    UserItem.wIndex,
                    UserItem.MakeIndex,
                    UserItem.Dura,
                    UserItem.DuraMax,
                    sBindName]),
                    c_Blue,t_Hint);
      PlayObject.SysMsg(format('Item: %s[%s]is now bound using: %s[%s]',
                                [GetUseItemName(nItem),
                                 UserEngine.GetStdItemName(UserItem.wIndex),
                                 sType,
                                 sBindName
                                ]),c_Blue,t_Hint);
    end;
    1: begin
      sBindName:=PlayObject.m_sCharName;
      g_ItemBindCharName.Lock;
      try
        for I := 0 to g_ItemBindCharName.Count - 1 do begin
          ItemBind:=g_ItemBindCharName.Items[I];
          if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
            SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,[sHumanName,sItem]),c_Red,t_Hint);
            exit;
          end;
        end;
        New(ItemBind);
        ItemBind.nItemIdx:=nItemIdx;
        ItemBind.nMakeIdex:=nMakeIdex;
        ItemBind.sBindName:=sBindName;
        g_ItemBindCharName.Insert(0,ItemBind);
      finally
        g_ItemBindCharName.UnLock;
      end;
      SaveItemBindCharName();
      SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]Name: %s',
                   [GetUseItemName(nItem),
                    UserEngine.GetStdItemName(UserItem.wIndex),
                    UserItem.wIndex,
                    UserItem.MakeIndex,
                    UserItem.Dura,
                    UserItem.DuraMax,
                    sBindName]),
                    c_Blue,t_Hint);
      PlayObject.SysMsg(format('Item: %s[%s]Is now bound using %s[%s]',
                                [GetUseItemName(nItem),
                                 UserEngine.GetStdItemName(UserItem.wIndex),
                                 sType,
                                 sBindName
                                ]),c_Blue,t_Hint);
    end;
    2: begin
      sBindName:=PlayObject.m_sIPaddr;
      g_ItemBindIPaddr.Lock;
      try
        for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
          ItemBind:=g_ItemBindIPaddr.Items[I];
          if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
            SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,[sHumanName,sItem]),c_Red,t_Hint);
            exit;
          end;
        end;
        New(ItemBind);
        ItemBind.nItemIdx:=nItemIdx;
        ItemBind.nMakeIdex:=nMakeIdex;
        ItemBind.sBindName:=sBindName;
        g_ItemBindIPaddr.Insert(0,ItemBind);
      finally
        g_ItemBindIPaddr.UnLock;
      end;
      SaveItemBindIPaddr();
      SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]BindName: %s',
                   [GetUseItemName(nItem),
                    UserEngine.GetStdItemName(UserItem.wIndex),
                    UserItem.wIndex,
                    UserItem.MakeIndex,
                    UserItem.Dura,
                    UserItem.DuraMax,
                    sBindName]),
                    c_Blue,t_Hint);
      PlayObject.SysMsg(format('Item: %s[%s]is now bound using: %s[%s]',
                                [GetUseItemName(nItem),
                                 UserEngine.GetStdItemName(UserItem.wIndex),
                                 sType,
                                 sBindName
                                ]),c_Blue,t_Hint);
    end;
  end;
end;
procedure TPlayObject.CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: String);
var
  I: Integer;
  PlayObject:TPlayObject;
  UserItem:pTUserItem;
  nItem,nBind:Integer;
  ItemBind:pTItemBind;
  nItemIdx,nMakeIdex:Integer;
  sBindName:String;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  nBind:=-1;
  nItem:=GetUseItemIdx(sItem);
  if CompareText(sType,'琅뵀') = 0 then nBind:=0;
  if CompareText(sType,'훙膠') = 0 then nBind:=1;
  if CompareText(sType,'IP') = 0 then nBind:=2;
    
  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandBindUseItemHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
    exit;
  end;
  UserItem:=@PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then begin
    SysMsg(format(g_sGameCommandBindUseItemNoItemMsg,[sHumanName,sItem]),c_Red,t_Hint);
    exit;
  end;
  nItemIdx:=UserItem.wIndex;
  nMakeIdex:=UserItem.MakeIndex;
  case nBind of    //물약 묶음
    0: begin
      sBindName:=PlayObject.m_sUserID;
      g_ItemBindAccount.Lock;
      try
        for I := 0 to g_ItemBindAccount.Count - 1 do begin
          ItemBind:=g_ItemBindAccount.Items[I];
          if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
            SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,[sHumanName,sItem]),c_Red,t_Hint);
            exit;
          end;
        end;
        New(ItemBind);
        ItemBind.nItemIdx:=nItemIdx;
        ItemBind.nMakeIdex:=nMakeIdex;
        ItemBind.sBindName:=sBindName;
        g_ItemBindAccount.Insert(0,ItemBind);
      finally
        g_ItemBindAccount.UnLock;
      end;
      SaveItemBindAccount();
      SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]BindName: %s',
                   [GetUseItemName(nItem),
                    UserEngine.GetStdItemName(UserItem.wIndex),
                    UserItem.wIndex,
                    UserItem.MakeIndex,
                    UserItem.Dura,
                    UserItem.DuraMax,
                    sBindName]),
                    c_Blue,t_Hint);
      PlayObject.SysMsg(format('Item: %s[%s]is now bound using: %s[%s]',
                                [GetUseItemName(nItem),
                                 UserEngine.GetStdItemName(UserItem.wIndex),
                                 sType,
                                 sBindName
                                ]),c_Blue,t_Hint);
    end;
    1: begin
      sBindName:=PlayObject.m_sCharName;
      g_ItemBindCharName.Lock;
      try
        for I := 0 to g_ItemBindCharName.Count - 1 do begin
          ItemBind:=g_ItemBindCharName.Items[I];
          if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
            SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,[sHumanName,sItem]),c_Red,t_Hint);
            exit;
          end;
        end;
        New(ItemBind);
        ItemBind.nItemIdx:=nItemIdx;
        ItemBind.nMakeIdex:=nMakeIdex;
        ItemBind.sBindName:=sBindName;
        g_ItemBindCharName.Insert(0,ItemBind);
      finally
        g_ItemBindCharName.UnLock;
      end;
      SaveItemBindCharName();
      SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]BindName: %s',
                   [GetUseItemName(nItem),
                    UserEngine.GetStdItemName(UserItem.wIndex),
                    UserItem.wIndex,
                    UserItem.MakeIndex,
                    UserItem.Dura,
                    UserItem.DuraMax,
                    sBindName]),
                    c_Blue,t_Hint);
      PlayObject.SysMsg(format('Item: %s[%s]is now bound using: %s[%s]',
                                [GetUseItemName(nItem),
                                 UserEngine.GetStdItemName(UserItem.wIndex),
                                 sType,
                                 sBindName
                                ]),c_Blue,t_Hint);
    end;
    2: begin
      sBindName:=PlayObject.m_sIPaddr;
      g_ItemBindIPaddr.Lock;
      try
        for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
          ItemBind:=g_ItemBindIPaddr.Items[I];
          if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then begin
            SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,[sHumanName,sItem]),c_Red,t_Hint);
            exit;
          end;
        end;
        New(ItemBind);
        ItemBind.nItemIdx:=nItemIdx;
        ItemBind.nMakeIdex:=nMakeIdex;
        ItemBind.sBindName:=sBindName;
        g_ItemBindIPaddr.Insert(0,ItemBind);
      finally
        g_ItemBindIPaddr.UnLock;
      end;
      SaveItemBindIPaddr();
      SysMsg(format('%s[%s]IDX[%d]MakeIndex[%d]Durability[%d-%d]BindName: %s',
                   [GetUseItemName(nItem),
                    UserEngine.GetStdItemName(UserItem.wIndex),
                    UserItem.wIndex,
                    UserItem.MakeIndex,
                    UserItem.Dura,
                    UserItem.DuraMax,
                    sBindName]),
                    c_Blue,t_Hint);
      PlayObject.SysMsg(format('Item: %s[%s]is now bound using: %s[%s]',
                                [GetUseItemName(nItem),
                                 UserEngine.GetStdItemName(UserItem.wIndex),
                                 sType,
                                 sBindName
                                ]),c_Blue,t_Hint);
    end;
  end;
end;
procedure TPlayObject.CmdShutup(Cmd:pTGameCmd;sHumanName,sTime:String);
var
  dwTime:LongWord;
  nIndex:Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
  //  SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sTime = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandShutupHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  dwTime:=Str_ToInt(sTime,5);
  g_DenySayMsgList.Lock;
  try
    nIndex:=g_DenySayMsgList.GetIndex(sHumanName);
    if nIndex >= 0 then begin
      g_DenySayMsgList.Objects[nIndex]:=TObject(GetTickCount + dwTime * 60 * 1000);
    end else begin
      g_DenySayMsgList.AddRecord(sHumanName,GetTickCount + dwTime * 60 * 1000);
    end;      
  finally
    g_DenySayMsgList.UnLock;
  end;
  SysMsg(format(g_sGameCommandShutupHumanMsg,[sHumanName,dwTime]),c_Red,t_Hint);
end;
procedure TPlayObject.CmdShutupList(Cmd:pTGameCmd;sParam1:String);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,'']),c_Red,t_Hint);
    exit;
  end;

  if (m_btPermission < 6) then exit;
  g_DenySayMsgList.Lock;
  try
    if g_DenySayMsgList.Count <= 0 then begin
      SysMsg(g_sGameCommandShutupListIsNullMsg,c_Green,t_Hint);
      exit;
    end;
    for I := 0 to g_DenySayMsgList.Count - 1 do begin
      SysMsg(g_DenySayMsgList.Strings[I] + ' ' + IntToStr((LongWord(g_DenySayMsgList.Objects[I]) - GetTickCount) div 60000),c_Green,t_Hint);
    end; 
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdSvnInfo(Cmd:pTGameCmd;sParam1:String);
var
  I: Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
    SysMsg('콱轟홈賈痰맡츱즈。',c_Red,t_Hint);
    exit;
  end;

  if (m_btPermission < 6) then exit;


  {if (SVN_ISTracking) and (SVN_DETAILS.Count > 0) then begin
    SysMsg('SVN Information:', c_Red, t_SVN1);
    for I := 0 to SVN_DETAILS.Count-1 do SysMsg(' ['+inttostr(I+1)+'] '+SVN_DETAILS.Strings[I], c_Red, t_SVN1);
    SysMsg('SVN Revision: '+inttostr(SVN_REVISION), c_Green, t_SVN2);
  end
  else begin
    SysMsg('No SVN Revision Data Available', c_Red, t_SVN3);
  end;
  SysMsg('Build Time: '+FormatDateTime('dd mmm yyyy/hh:nn:ss',UnixToDateTime(BUILDTIME))+' ('+inttostr(BUILDTIME)+')', c_Green, t_SVN2);  }
end;


procedure TPlayObject.CmdShutupRelease(Cmd:pTGameCmd;sHumanName:String;boAll:Boolean);
var
  I:Integer;
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandShutupReleaseHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  g_DenySayMsgList.Lock;
  try
    I:=g_DenySayMsgList.GetIndex(sHumanName);
    if I >= 0 then begin
      g_DenySayMsgList.Delete(I);
      PlayObject:=UserEngine.GeTPlayObject(sHumanName);
      if PlayObject <> nil then begin
        PlayObject.SysMsg(g_sGameCommandShutupReleaseCanSendMsg,c_Red,t_Hint);
      end;
      if boAll then begin
        UserEngine.SendServerGroupMsg(SS_210,nServerIndex,sHumanName);
      end;
      SysMsg(format(g_sGameCommandShutupReleaseHumanCanSendMsg,[sHumanName]),c_Green,t_Hint);
    end;      
  finally
    g_DenySayMsgList.UnLock;
  end;
end;
procedure TPlayObject.CmdSmakeItem(Cmd:pTGameCmd;nWhere,nValueType,nValue:Integer);
var
  sShowMsg:String;
  StdItem:TItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  //0옷, 1무기, 2횃불, 3목걸이, 4투구, 5 6 팔찌 ,7 8 반지, 9 부적, 10 벨트 ,11신발, 12 수호석 ,13 탈것
  if (nWhere in [0..13]) and (nValueType in [0..21]) and (nValue in [0..255])then begin
    if m_UseItems[nWhere].wIndex > 0 then begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem = nil then exit;

      if nValueType in [20,21] then begin
        nValue:=_MIN(65,nValue);
        if nValueType = 20 then m_UseItems[nWhere].Dura:= nValue * 1000;
        if nValueType = 21 then m_UseItems[nWhere].DuraMax:= nValue * 1000;
      end else begin
          m_UseItems[nWhere].btValue[nValueType]:=nValue;
      end;

      RecalcAbilitys();
      SendUpdateItem(@m_UseItems[nWhere]);
        sShowMsg:=IntToStr(m_UseItems[nWhere].wIndex) + '-' + IntToStr(m_UseItems[nWhere].MakeIndex) + ' ' +
                  IntToStr(m_UseItems[nWhere].Dura) + '/' + IntToStr(m_UseItems[nWhere].DuraMax) + ' ' +
                  IntToStr(m_UseItems[nWhere].btValue[0]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[1]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[2]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[3]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[4]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[5]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[6]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[7]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[8]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[9]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[10]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[11]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[12]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[13]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[14]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[15]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[16]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[17]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[18]) + '/' +
                  IntToStr(m_UseItems[nWhere].btValue[19]);
        SysMsg(sShowMsg,c_Blue,t_Hint);
        SendMsg(Self,RM_ABILITY,0,0,0,0,'');
        SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[멕섬齡芚] ' + m_sCharName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');

      if StdItem.NeedIdentify = 1 then
            AddGameDataLog('5' + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        StdItem.Name + #9 +
                        IntToStr(m_UseItems[nWhere].MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[멕섬齡芚] ' + sShowMsg);
    end else begin
      SysMsg(g_sGamecommandSuperMakeHelpMsg,c_Red,t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdYourmakeItem(Cmd:pTGameCmd;sHumName:String;nWhere,nValueType,nValue:Integer);
var
  sShowMsg:String;
  StdItem:TItem;
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  //0옷, 1무기, 2횃불, 3목걸이, 4투구, 5 6 팔찌 ,7 8 반지, 9 부적, 10 벨트 ,11신발, 12 수호석 ,13 탈것
  if (sHumName <> '') and (nWhere in [0..13]) and (nValueType in [0..21]) and (nValue in [0..255])then begin
    PlayObject:=UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then begin
      if PlayObject.m_UseItems[nWhere].wIndex > 0 then begin
        StdItem:=UserEngine.GetStdItem(PlayObject.m_UseItems[nWhere].wIndex);
        if StdItem = nil then exit;

        if nValueType in [20,21] then begin
          nValue:=_MIN(65,nValue);
          if nValueType = 20 then PlayObject.m_UseItems[nWhere].Dura:= nValue * 1000;
          if nValueType = 21 then PlayObject.m_UseItems[nWhere].DuraMax:= nValue * 1000;
        end else begin
          PlayObject.m_UseItems[nWhere].btValue[nValueType]:=nValue;
        end;

        PlayObject.RecalcAbilitys();
        PlayObject.SendUpdateItem(@PlayObject.m_UseItems[nWhere]);
        sShowMsg:=IntToStr(PlayObject.m_UseItems[nWhere].wIndex) + '-' + IntToStr(PlayObject.m_UseItems[nWhere].MakeIndex) + ' ' +
                  IntToStr(PlayObject.m_UseItems[nWhere].Dura) + '/' + IntToStr(PlayObject.m_UseItems[nWhere].DuraMax) + ' ' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[0]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[1]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[2]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[3]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[4]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[5]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[6]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[7]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[8]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[9]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[10]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[11]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[12]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[13]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[14]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[15]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[16]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[17]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[18]) + '/' +
                  IntToStr(PlayObject.m_UseItems[nWhere].btValue[19]);
        SysMsg(sShowMsg,c_Blue,t_Hint);
        PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');
        PlayObject.SendMsg(PlayObject, RM_SUBABILITY, 0, 0, 0, 0, '');
        if g_Config.boShowMakeItemMsg then
          MainOutMessage('[宮뚤멕섬齡芚] ' + PlayObject.m_sCharName + '(' + StdItem.Name + ' -> ' + sShowMsg + ')');

        if StdItem.NeedIdentify = 1 then
            AddGameDataLog('5' + #9 +
                        PlayObject.m_sMapName + #9 +
                        IntToStr(PlayObject.m_nCurrX) + #9 +
                        IntToStr(PlayObject.m_nCurrY) + #9 +
                        PlayObject.m_sCharName + #9 +
                        StdItem.Name + #9 +
                        IntToStr(PlayObject.m_UseItems[nWhere].MakeIndex) + #9 +
                        '1' + #9 +
                        '0' + #9 + '[宮뚤멕섬齡芚] ' + sShowMsg);
      end;
    end else begin
      SysMsg(sHumName + '꼇瞳窟。',c_Red,t_Hint);
    end;
  end else begin
    SysMsg(g_sGamecommandYourMakeHelpMsg,c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdSpirtStart(sCmd, sParam1: String);
var
  nTime:Integer;
  dwTime:LongWord;
begin
  if (m_btPermission < 6) then exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('늪츱즈珂륩蛟포溝켄漢均琬顚┱民畸謁늬А',c_Red,t_Hint);
    exit;
  end;
  nTime:=Str_ToInt(sParam1,-1);
  if nTime > 0 then begin
    dwTime:=LongWord(nTime) * 1000;
  end else begin
    dwTime:=g_Config.dwSpiritMutinyTime;
  end;
    
  g_dwSpiritMutinyTick:=GetTickCount + dwTime;
  SysMsg('杰唐녘膠瞳' + IntToStr(dwTime div 1000) + '취코뇹黨턺긴榴檄。',c_Green,t_Hint);
end;
procedure TPlayObject.CmdSpirtStop(sCmd, sParam1: String);
begin
  if (m_btPermission < 6) then exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then begin
    SysMsg('늪츱즈珂륩蛟포溝켄漢均琬顚┱民畸謁늬А',c_Red,t_Hint);
    exit;
  end;
  g_dwSpiritMutinyTick:=0;
  SysMsg('杰唐녘膠떼턺긴죄。',c_Green,t_Hint);

end;



procedure TPlayObject.CmdStartQuest(Cmd:pTGameCmd; sQuestName: String);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sQuestName = '') then begin
    SysMsg('Usage: @' + Cmd.sCmd + ' questname',c_Red,t_Hint);
    exit;
  end;
  UserEngine.SendQuestMsg(sQuestName);
end;

procedure TPlayObject.CmdSuperTing(Cmd:pTGameCmd;sHumanName,sRange:String);
var
  I: Integer;
  PlayObject:TPlayObject;
  MoveHuman:TPlayObject;
  nRange:Integer;
  HumanList:TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sRange = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandSuperTingHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  nRange:=_MAX(10,Str_ToInt(sRange,2));
  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    HumanList:=TList.Create;
    UserEngine.GetMapRageHuman(PlayObject.m_PEnvir,PlayObject.m_nCurrX,PlayObject.m_nCurrY,nRange,HumanList);
    for I := 0 to HumanList.Count - 1 do begin
      MoveHuman:=TPlayObject(HumanList.Items[I]);
      if MoveHuman <> Self then  
        MoveHuman.MapRandomMove(MoveHuman.m_sHomeMap,0);
    end;
    FreeAndNil(HumanList);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
  end;

end;

procedure TPlayObject.CmdTakeOffHorse(sCmd, sParam: String);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
  //  SysMsg('this command will let you unmount from your horse',c_Red,t_Hint);
  //  SysMsg(format('Usage: @%s',[sCmd]),c_Red,t_Hint);
    exit;
  end;
  if not m_boOnHorse then exit;

  if GetTickCount - m_dwTigerTick > 2 * 1000 then begin
    m_dwTigerTick := GetTickCount;
    m_boOnHorse:=False;
    FeatureChanged();
  end;
end;

procedure TPlayObject.CmdTakeOnHorse(sCmd, sParam: String);
begin
  if (sParam <> '') and (sParam[1] = '?') then begin
 //   SysMsg('This command will let you mount your horse',c_Red,t_Hint);
 //   SysMsg(format('Use this: @%s',[sCmd]),c_Red,t_Hint);
    exit;
  end;
  if m_boOnHorse then exit;

  if (m_btHorseType = -1) then begin
    exit;
  end;
  if GetTickCount - m_dwTigerTick > 2 * 1000 then begin
    if (m_UseItems[U_TIGER].wIndex > 0) and (m_UseItems[U_TIGER].Dura > 0) then begin
      if (m_UseItems[U_PETS3].wIndex > 0) and (m_UseItems[U_PETS3].Dura > 0) then begin   //안장 착용
        if not(m_wStatusTimeArr[STATE_YEONGMU] <> 0) and not(m_wStatusTimeArr[STATE_ASSTRANSPARENT] <> 0) then begin   //월영술 월영무
          m_dwTigerTick := GetTickCount;
          m_boOnHorse:=True;
          FeatureChanged();
        end;
      end else begin
        SysMsg('콱극伎陋구같야꼽콘賈痰。',c_Red,t_Hint);
      end;
    end else begin
      SysMsg('콱돨麟폄돨瀘넒똑법됴。',c_Red,t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdTestFire(sCmd:String;nRange,nType,nTime,nPoint:Integer);
var
  nX,nY:Integer;
  FireBurnEvent:TFireBurnEvent;
  nMinX,nMaxX,nMinY,nMaxY:Integer;
begin
  nMinX:=m_nCurrX - nRange;
  nMaxX:=m_nCurrX + nRange;
  nMinY:=m_nCurrY - nRange;
  nMaxY:=m_nCurrY + nRange;
  for nX:= nMinX to nMaxX do begin
    for nY:= nMinY to nMaxY do begin
      if ((nX < nMaxX) and (nY = nMinY)) or
         ((nY < nMaxY) and (nX = nMinX)) or
         (nX = nMaxX) or (nY = nMaxY) then begin
        FireBurnEvent:=TFireBurnEvent.Create(Self,nX,nY,nType,nTime * 1000,nPoint);
        g_EventManager.AddEvent(FireBurnEvent);
      end;
    end;
  end;
end;

procedure TPlayObject.CmdTestGetBagItems(Cmd: pTGameCmd; sParam: String);
var
  btDc,btSc,btMc,btDura:Byte;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sParam <> '') and (sParam[1] = '?') then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandTestGetBagItemsHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  btDc:=0;
  btSc:=0;
  btMc:=0;
  btDura:=0;
  GetBagUseItems(btDc,btSc,btMc,btDura);
  SysMsg(format('DC:%d SC:%d MC:%d DURA:%d',[btDc,btSc,btMc,btDura]),c_Blue,t_Hint);
end;


procedure TPlayObject.CmdTestSpeedMode(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  m_boTestSpeedMode:= not m_boTestSpeedMode;
  if m_boTestSpeedMode then begin
    SysMsg('폘痰꿎桿醵똑친駕',c_Red,t_Hint);
  end else begin
    SysMsg('밑균꿎桿醵똑친駕',c_Red,t_Hint);
  end;

end;

procedure TPlayObject.CmdTestStatus(sCmd: String; nType, nTime: Integer);
begin
  if (m_btPermission < 6) then exit;
  if (not (nType in [Low(TStatusTime)..High(TStatusTime)])) or (nTime < 0) then begin
    SysMsg('賈痰렘랬: @' + sCmd + ' statusvalue(0..11) time',c_Red,t_Hint);
    exit;
  end;
  m_wStatusTimeArr[nType]:=nTime * 1000;
  m_dwStatusArrTick[nType]:=GetTickCount();
  m_nCharStatus:=GetCharStatus();
  StatusChanged();
  SysMsg(format('user status changed for: %d seconds',[nType,nTime]),c_Green,t_Hint);
end;

procedure TPlayObject.CmdTing(Cmd:pTGameCmd;sHumanName:String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandTingHelpMsg]),c_Red,t_Hint);
    exit;
  end;

  PlayObject:=UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then begin
    PlayObject.MapRandomMove(m_sHomeMap,0);
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumanName]),c_Red,t_Hint);
  end;
end;
procedure TPlayObject.CmdTraining(sSkillName: String; nLevel: Integer); //004CC414
begin
  if (m_btPermission < 6) then exit;
end;

procedure TPlayObject.CmdUserMoveXY(sCMD, sX, sY: String);
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
begin
  if m_boTeleport then begin
    nX:=Str_ToInt(sX,-1);
    nY:=Str_ToInt(sY,-1);
    if not m_PEnvir.Flag.boNOPOSITIONMOVE then begin //순반 이동
      if m_PEnvir.CanWalkOfItem(nX,nY,g_Config.boUserMoveCanDupObj,g_Config.boUserMoveCanOnItem) then begin
        if (GetTickCount - m_dwTeleportTick) > g_Config.dwUserMoveTime * 1000{10000} then begin
          m_dwTeleportTick:=GetTickCount();
          SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');

          if m_PEnvir.Flag.nGuildTerritory > 0 then begin //순반 장원
            SpaceGTMoveEX(m_sMapName,nX,nY,0,m_PEnvir.Flag.nGuildTerritory);
          end else begin
           SpaceMove(m_sMapName,nX,nY,0);
          end;
        end else begin
          SysMsg(IntToStr(g_Config.dwUserMoveTime - (GetTickCount - m_dwTeleportTick) div 1000) + '취鹿빈옵鹿疼늴賈痰。',c_Red,t_Hint);
        end;
      end else begin
         SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap,[m_sMapName,sX,sY]),c_Green,t_Hint);
      end;
    end else begin
      SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap,[m_sMapName,sX,sY]),c_Red,t_Hint);
    end;
  end else begin
  //  SysMsg('You must be wearing the items associated with this command to use it.',c_Red,t_Hint);
  end;
end;
procedure TPlayObject.CmdViewDiary(sCMD: String; nFlag: Integer);//004D1B70
begin

end;

procedure TPlayObject.CmdViewWhisper(Cmd:pTGameCmd; sCharName, sParam2: String);
var
  PlayObject:TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;
  if (sCharName = '') or ((sCharName <> '') and (sCharName[1] = '?')) then begin
    SysMsg(format(g_sGameCommandParamUnKnow,[Cmd.sCmd,g_sGameCommandViewWhisperHelpMsg]),c_Red,t_Hint);
    exit;
  end;
  PlayObject:=UserEngine.GeTPlayObject(sCharName);
  if PlayObject <> nil then begin
    if PlayObject.m_GetWhisperHuman = Self then begin
      PlayObject.m_GetWhisperHuman:=nil;
      SysMsg(format(g_sGameCommandViewWhisperMsg1,[sCharName]),c_Green,t_Hint);
    end else begin
      PlayObject.m_GetWhisperHuman:=Self;
      SysMsg(format(g_sGameCommandViewWhisperMsg2,[sCharName]),c_Green,t_Hint);
    end;
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sCharName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.CmdTradeGT(Cmd: pTGameCmd);
var
  BaseObject:TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then begin
   // SysMsg(g_sGameCommandPermissionTooLow,c_Red,t_Hint);
    exit;
  end;  
  if m_boDealing then exit;
  if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime{3000} then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sPleaseTryDealLaterMsg);
    exit;
  end;
  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotTryDealMsg);
    exit;
  end;
  if (m_MyGuild = nil) or (TGuild(m_MyGuild).m_Territory = nil) or (IsGuildMaster = False) then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'청唐契삔鏤蹈。');
    exit;
  end;
  if TTerritory(TGuild(m_MyGuild).m_Territory).ForSale = False then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'청唐놔簡돨契삔鏤蹈。');
    exit;
  end;
  BaseObject:=GetPoseCreate();
  if (BaseObject <> nil) and (BaseObject <> self) then begin
    if (BaseObject.GetPoseCreate = Self) and (not BaseObject.m_boDealing) then begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
        if (BaseObject.m_boAllowDeal and TPlayObject(BaseObject).m_boCanDeal) then begin
          if (BaseObject.m_MyGuild = nil) or (BaseObject.IsGuildMaster = False) then begin
            SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'뚤렘청唐속흙契삔。');
            exit
          end;
          if g_GuildTerritory.FindGuildTerritoryEx(TGuild(BaseObject.m_MyGuild).sGuildName) <> nil then begin
            SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'뚤렘綠쒔唐契삔鏤蹈죄。');
            exit;
          end;
          m_boDealing:=True;
          m_boDealGT:=True;
          m_DealCreat:=BaseObject;
          m_DealLastTick:=GetTickCount();
          BaseObject.m_boDealing := True;
          BaseObject.m_DealCreat := self;
          BaseObject.m_DealLastTick := GetTickCount();
          SysMsg('攣瞳된덤뚤렘횅땍슥弄...',c_Red,t_Hint);
          TPlayObject(BaseObject).SendDefMessage(SM_GTTRADE,TTerritory(TGuild(m_MyGuild).m_Territory).ForSaleGold,0,0,0,'');
        end else begin //004DD1CC
          SysMsg('뚤렘혤句죄슥弄。',c_Red,t_Hint);
        end;
      end;

    end else begin //004DD1E0
      SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'콱뵨깎훙돨슥弄攣瞳쏵契뎠櫓。');
      exit;
    end;
  end else begin //004DD1F9
      SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'슥弄鏤蹈珂崗렘극伎충뚤충돨籃淪。');
      exit;
  end;
end;

constructor TPlayObject.Create;//004C9860
begin
  inherited;
  m_btRaceServer     := RC_PLAYOBJECT;
  m_boEmergencyClose := False;
  m_boSwitchData     := False;
  m_boReconnection   := False;
  m_boKickFlag       := False;
  m_boSoftClose      := False;
  m_boReadyRun       := False;
  bo698              := False;
  n69C               := 0;
  m_dwSaveRcdTick    := GetTickCount();
  m_boWantRefMsg     := True;
  m_boRcdSaved       := False;
  m_boDieInFight3Zone              := False;
  m_Script           := nil;
  m_boTimeRecall     := False;
  m_boTimeRecallGroup:= False;
  m_boCastleRecall   := False;

  m_sRankName        := ' ';
  m_nRankColor       := 0;

  m_sMoveMap         := '';
  m_nMoveX           := 0;
  m_nMoveY           := 0;

  //스피드핵
  m_dwHitTime        := GetTickCount;
  m_dwRunTime        := GetTickCount;
  m_dwMagicHitTime   := GetTickCount;

  m_boHitDelay       := False;
  m_boRunDelay       := False;
  m_boMagicHitDelay  := False;

  m_nHitCount        := 0;
  m_nRunCount        := 0;
  m_nMagicHitCount   := 0;

  m_dwRunTick        := GetTickCount();
  m_nRunTime         := 250;
  m_dwSearchTime     := 1000;
  m_dwSearchTick     := GetTickCount();
  m_nViewRange       := 12;
  m_boNewHuman       := False;
  m_boLoginNoticeOK  := False;
  bo6AB              := False;
  m_boExpire         := False;
  m_boSendNotice     := False;
  m_dwCheckDupObjTick          := GetTickCount();
  m_dwThunderWaveTick    := GetTickCount();
  dwTick578          := GetTickCount();
  m_boInSafeArea              := False;
  n5FC               := 0;
  m_dwMagicAttackTick     := GetTickCount();
  m_dwMagicAttackInterval := 0;
  m_dwAttackTick          := GetTickCount();
  m_dwActionTick          := GetTickCount();
  m_dwAttackCount         := 0;
  m_dwAttackCountA        := 0;
  m_dwMagicAttackCount    := 0;
  m_nOverSpeedCount       := 0;
  LatestWalkTime := GetTickCount;
  WalkTimeOverCount := 0;
  WalkTimeOverSum := 0;
  m_sOldSayMsg            := '';
  m_dwSayMsgTick          := GetTickCount();
  m_boDisableSayMsg       := False;
  m_dwDisableSayMsgTick   := GetTickCount();
  m_dLogonTime            := Now();
  m_dwLogonTick           := GetTickCount();
  m_dwLoginTick           := GetTickCount();
  n_sLoginCount           := 1;
  n584                    := 0;
  n588                    := 0;
  m_boSwitchData          := False;
  m_boSwitchDataSended    := False;
  m_nWriteChgDataErrCount := 0;
  m_dwShowLineNoticeTick  := GetTickCount();
  m_nShowLineNoticeIdx    := 0;
  m_nSoftVersionDateEx    := 0;
  m_CanJmpScriptLableList := TStringList.Create;
  m_nKillMonExpMultiple   := 1;
  m_nKillMonDropRate      := 100; //드롭율
  m_dwDropRateTick        := GetTickCount();   //드롭율
  m_nKillMonExpRate       := 100;
  m_nKillMonExpRate2      := 100;              //경험치가산
  m_nKillMonExpRate3      := 100;              //검성 검후 경험치
  m_nKillMonExpRate4      := 100;              //사제 경치
  m_nKillMonExpRate5      := 100;              //초보문파 경험치
  m_nKillMonExpRate6      := 100;              //문파성장 경험치
  m_nKillMonExpRate7      := 100;              //gm 이벤트 경험치
  m_nKillMonExpRate8      := 100;
  m_nKillMonExpRate9      := 100;             //영웅버프
  m_nKillMonExpRate10     := 100;             //그룹버프
  m_dwRateTick            := GetTickCount();
  m_dwRateTick2           := GetTickCount();   //경험치가산
  m_dwRateTick3           := GetTickCount();   //검성 검후 경험치
  m_dwRateTick4           := GetTickCount();   //사제 경치
  m_dwRateTick8           := GetTickCount();   //사제 경치
  m_nPowerRate            := 100;
  m_nPowerRate2           := 100;
  m_nPowerRate3           := 100;
  m_nPowerRate4           := 100; //문파성장 공력
  m_nPowerRate5           := 100;
  m_nPowerRate6           := 100;
  m_dwPowerRateTick       := GetTickCount();
  m_dwPowerRateTick2      := GetTickCount();;  //천령수 공력
  m_dwPowerRateTick3      := GetTickCount();  //문파성장 공력

  m_boSetStoragePwd       :=False;
  m_boReConfigPwd         :=False;
  m_boCheckOldPwd         :=False;
  m_boUnLockPwd           :=False;
  m_boUnLockStoragePwd    :=False;
  m_boPasswordLocked      :=False;  //傑꾑욋
  m_btPwdFailCount        :=0;
  m_sTempPwd              :='';
  m_sSystemPwd            :='';
  m_sStoragePwd           :='';;     //창고암호
  m_boStoragePwd          :=False;   //창고암호
  m_boFilterSendMsg       :=False;

  m_boCanRental           :=True;   //대여
  m_boCanDeal             :=True;
  m_boCanDrop             :=True;
  m_boCanGetBackItem        :=True;
  m_boCanWalk               :=True;
  m_boCanRun                :=True;
  m_boCanHit                :=True;
  m_boCanSpell              :=True;
  m_boCanUseItem            :=True;

  m_nGameGold               := 0;
  m_boDecGameGold           := False;
  m_nDecGameGold            := 1;
  m_dwDecGameGoldTick       := GetTickCount();
  m_dwDecGameGoldTime       := 60 * 1000;

  m_boIncGameGold           := False;
  m_nIncGameGold            := 1;
  m_dwIncGameGoldTick       := GetTickCount();
  m_dwIncGameGoldTime       := 60 * 1000;

  m_nGamePoint              := 0;
  m_dwIncGamePointTick      := GetTickCount();

  m_nPCPoint                := 0;
  m_dwPCPointTick           := GetTickCount();

  m_boSendMsgFlag           := False;
  m_boSendMsgFlag1          := False;
  m_boChangeItemNameFlag    := False;

  m_dwLoveRecallTick        := GetTickCount();
  m_btReColorIdx            := 0;
  m_GetWhisperHuman         := nil;
  m_boOnHorse               := False;
  m_sRankLevelName          := g_sRankLevelName;      //랭크네임
  m_boFixedHideMode         := False;
  FillChar(m_nMval,SizeOf(m_nMval),#0);
  //m_nClientFlagMode         := -1;
  m_dwAutoGetExpTick        := GetTickCount;
  m_nAutoGetExpPoint        := 0;
  m_AutoGetExpEnvir         := nil;

  m_DynamicVarList          := TList.Create;
  m_SessInfo                := nil;
  m_boTestSpeedMode         := False;
  m_boLockLogon             := True;
  m_boLockLogoned           := False;
  m_dwchecksafearea         := GetTickCount();
  m_dwBBSDelayTime          := getTickCount();
  m_dwBBSPostDelay          := getTickCount();
  m_fivegotick              := 0;
  m_dwMassPoison            := 0; //독무 딜레이
  m_dwChunGong              := 0;
  m_WalkSpeedUpTick         := 0; //경신보 딜레이
  m_MagMakeShadowTick       := 0; //열화신 딜레이
  m_MagGreatWallTick        := 0;
  m_ChenMuUpTick            := 0; //천무 딜레이
  m_AbyssTick               := 0; //심연술 딜레이
  m_BloodSword              := 0; //혈룡검법 딜레이
  m_ThunderWave             := 0;
  m_ThunderClap             := 0;
  m_SkyTick                 := 0; //천상비술 딜레이
  m_CatSword                := 0; //묘설란 딜레이
  m_SpaceMove               := 0; //이형환위 딜레이
  m_Authenitcity            := 0; //진위보 딜레이
  m_Summon                  := 0; //격공섭물 딜레이
  m_SuperIce                := 0; //빙월격 딜레이
  m_Allfire                 := 0; //만천염옥 딜레이
  m_IceShok                 := 0; //빙뇌천 딜레이
  m_DontEatTick             := 0; //일격비 물약
  m_Penetrate               := 0; //망자의눈 딜레이
  m_KumGang                 := 0; //금강불괴 딜레이
  m_Roeseon                 := 0; //뢰선풍 딜레이
  m_Ohaeng                  := 0; //음양오행진 딜레이

  m_YeongMuTick             := 0; //월영무 딜레이
  m_Shadow                  := 0; //영적추 딜레이
  m_TigerHit                := 0; //백호강타 딜레이
  m_Kyo                     := 0; //교악 딜레이
  m_Singi                   := 0; //신기묘산 딜레이
  m_AllThunder              := 0; //운중뢰격 딜레이
  m_CLOUD                   := 0; //암독만계 딜레이
  m_JuckSalDel              := 0; //천인적살풍 딜레이
  m_Fahangbo                := 0; //파황보 딜레이
  nFahangboCount            := 0;
  m_MagKangHo               := 0;
  m_130Time                 := 0;
  m_132Time                 := 0;
  m_133Time                 := 0;
  m_134Time                 := 0;
  m_135Time                 := 0;
  m_137Time                 := 0;
  m_138Time                 := 0;
  m_139Time                 := 0;
  m_140Time                 := 0;
  m_141Time                 := 0;

  m_boStore := False;        //개인상점
  m_StoreItemList := TList.Create;     //개인상점

  fLover     := TRelationShipMgr.Create;     //연인 스쳐
  fMentor    := TMentorShipMgr.Create;  //사제 스쳐

  g_boItemAuto       := 1;
  g_boItemAll        := 1;
  g_boItemGold       := 0;
  g_boItemWeapon     := 0;
  g_boItemDress      := 0;
  g_boItemHelmet     := 0;
  g_boItemBoots      := 0;
  g_boItemBelt       := 0;
  g_boItemAccessory  := 0;
  g_boItemEtc        := 0;

  SafeFillChar(m_nCheckMsgArr, SizeOf(m_nCheckMsgArr), #0);
  m_CheckMsgList := TList.Create;

  m_sTempHeroName := '';
  m_sHeroCharName := '';
  m_boWaitHeroDate := False;
  m_MyHero := nil;
  m_dwRecallHeroTick := 0;
  g_dwLastHeroTurnTick := GetTickCount - 1000;
  g_dwLastHeroMoveTick := GetTickCount - 3000;
end;

procedure TPlayObject.DealCancel; //004DD394      //거래
begin
  if not m_boDealing then exit;
  m_boDealing:=False;
  SendDefMessage(SM_DEALCANCEL,0,0,0,0,'');
  if m_DealCreat <> nil then begin
    TPlayObject(m_DealCreat).DealCancel;
  end;
  m_DealCreat:=nil;
  GetBackDealItems();
  SysMsg(g_sDealActionCancelMsg,c_Green,t_Hint);
  m_DealLastTick:=GetTickCount();
end;


procedure TPlayObject.DealCancelA;       //거래
begin
  m_Abil.HP:=m_WAbil.HP;
  DealCancel();
end;


procedure TPlayObject.RentalCancel; //004DD394      //대여
begin
  if not m_boRentaling then exit;
  m_boRentaling:=False;
  SendDefMessage(SM_RENTALCANCEL,0,0,0,0,'');
  if m_RentalCreat <> nil then begin
    TPlayObject(m_RentalCreat).RentalCancel;
  end;
  m_RentalCreat:=nil;
  GetBackRentalItems();
  SysMsg(g_sDealActionCancelMsg,c_Red,t_Hint);
  m_RentalLastTick:=GetTickCount();
end;


procedure TPlayObject.RentalCancelA;      //대여
begin
  m_Abil.HP:=m_WAbil.HP;
  RentalCancel();
end;

procedure TPlayObject.ExChangeCancel; //환전 취소
begin
  GetBacExChange();
end;

procedure TPlayObject.StoreCancel;    //개인상점
begin
  GetBackStoreItems();
  if not m_boStore then Exit;
  m_boStore := False;
  SendDefMessage(SM_SENDSTOPSTORE_OK, 0, 0, 0, 0, '');
  SendRefMsg(RM_SENDSTORE, m_btDirection, m_nCurrX, m_nCurrY, Integer(m_boStore), '');
end;

procedure TPlayObject.GetBackStoreItems();    //개인상점
var
  I: Integer;
  StoreServerItem: pTStoreServerItem;
begin
  if m_StoreItemList.Count > 0 then begin
    for I := 0 to m_StoreItemList.Count - 1 do begin
      StoreServerItem := pTStoreServerItem(m_StoreItemList.Items[I]);
      Dispose(StoreServerItem);
    end;
    m_StoreItemList.Clear;
  end;
end;


function TBaseObject.DecGold(nGold: Integer): Boolean; //004BF6A8
begin
  Result:=False;
  if nGold < 0 then Exit;

  if Int64(m_nGold) - nGold >= 0 then begin
     m_nGold := m_nGold - nGold;
     Result:=True;

     if nGold >= 5000000 then begin
       if g_boGameLogGold then
         //로그 남겨야 함
         AddGameDataLog('13'+ #9 + //금전_
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     sSTRING_GOLDNAME{'금전'} + #9 +
                     IntToStr(-nGold) + ''#9 +
                     IntToStr(m_Abil.level) + #9 +
                     IntToStr(m_nGold) + #9 + '[쏜풀句봬]');
     end;
     if m_nGold > g_Config.nHumanMaxGold then begin
        MainOutMessage('[쓱喧薺] 실ッ: ' + m_sCharName + '쏜귑鑒좆: ' + IntToStr(m_nGold) );
     end;

  end;
end;


procedure TPlayObject.DecPCPoint(nPoint: Integer); //004BF6A8
begin
  if nPoint < 0 then Exit;
  if m_nPCPoint >= nPoint then begin
    Dec(m_nPCPoint, nPoint);
  end else m_nPCPoint := 0;
end;

procedure TPlayObject.DecGameGold(nGameGold: Integer);
begin
  if m_nGameGold >= nGameGold then begin
    Dec(m_nGameGold, nGameGold);
  end else m_nGameGold := 0;
end;

destructor TPlayObject.Destroy;//004C9B54
var
  I: Integer;
  CheckMsg: pTCheckMsg;
begin

  for I := 0 to m_DynamicVarList.Count - 1 do begin
    Dispose(pTDynamicVar(m_DynamicVarList.Items[I]));
  end;
  m_DynamicVarList.Free;
  m_CanJmpScriptLableList.Free;

  if m_CheckMsgList <> nil then begin
    if m_CheckMsgList.Count > 0 then begin
      for i := 0 to m_CheckMsgList.Count - 1 do begin
        CheckMsg := m_CheckMsgList.Items[i];
        if CheckMsg <> nil then begin
          ClientCheckMsg(CheckMsg.tClass, CheckMsg.AllPurpose, -1);
          DisPose(CheckMsg);
        end;
      end;
    end;
    FreeAndNil(m_CheckMsgList);
  end;

  for I := 0 to m_StoreItemList.Count - 1 do begin            //개인상점
    Dispose(pTStoreServerItem(m_StoreItemList.Items[I]));
  end;
  m_StoreItemList.Free;

  fLover.Free;  //연인 스쳐
  fMentor.Free;  //사제 스쳐
  inherited;
end;


procedure TPlayObject.Disappear;//004CA89C
begin
  if m_boReadyRun then DisappearA;
  if m_boTransparent and m_boHideMode then m_wStatusTimeArr[STATE_TRANSPARENT]:=0;  //고정 은신술.. 이동한경우에는 은신술이 풀린다.  // 접속을 끊으면 투명이 풀림
  if m_GroupOwner <> nil then begin
    m_GroupOwner.DelMember(Self);
  end;
  if m_MyGuild <> nil then begin
    TGuild(m_MyGuild).DelHumanObj(Self);
  end;
  LogonTimcCost();      //접속 기록을 남긴다.
  inherited;
end;

procedure TPlayObject.DropUseItems(BaseObject:TBaseObject; DieFromMob : Boolean); //004BB6C8
var
  I,nRate:Integer;
  StdItem:TItem;
  DropItemList:TStringList;
  PlayObject:TPlayObject;
  tCode:integer;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::DropUseItems %d';
begin
  DropItemList:=nil;
  try
    if m_boNoDropUseItem then exit;
    if m_boDropDurg then exit;   //환템 드랍
    tCode:=0;
    if (m_btRaceServer = RC_PLAYOBJECT) then begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
      if StdItem <> nil then begin
        if ( (StdItem.StdMode = 63) and (StdItem.Shape = 5) ) then begin    //복조리
          tCode:=1;
          if DieFromMob then begin
            if StdItem.boCanDeathDrop then begin
              tCode:=2;
              if DropItemList = nil then DropItemList:=TStringList.Create;
              tCode:=3;
              DropItemList.AddObject(UserEngine.GetStdItemName (m_UseItems[U_CHARM].wIndex),TObject(m_UseItems[U_CHARM].MakeIndex));
              tCode:=4;
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('16' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name + #9 +
                     IntToStr(m_UseItems[U_CHARM].MakeIndex) + #9 +
                     BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                     '0'  + #9 + '[밍膠괵놔]');
                m_UseItems[U_CHARM].wIndex:=0;
                tCode:=5;
            end;
          end;
          m_boNoDropBagItem := True;  //가방템 보호
          tCode:=6;
          if DropItemList <> nil then begin
            tCode:=7;
            SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DropItemList),0,0,'');
          end;
          tCode:=8;
          Exit;
        end;
      end;

      //초혼시리즈 사라짐
      // 2003/03/15 아이템 인벤토리 확장
      for i:=0 to U_CHARM do begin     // 8->12
            // 몹한테 죽은게 아니면 안사라진다.
        if (i = U_CHARM) and (not DieFromMob) then continue;

        StdItem := UserEngine.GetStdItem (m_UseItems[i].wIndex);
        if StdItem <> nil then begin
           if ( StdItem.Reserved and 8 ) <> 0 then begin
             // 초혼시리즈도 몹한테 죽은게 아니면 안사라짐(sonmg 2004/06/24)
             if not DieFromMob then continue;

             if DropItemList = nil then DropItemList := TStringList.Create;
               //버그 수정(sonmg 2005/03/14)
             DropItemList.AddObject(UserEngine.GetStdItemName (m_UseItems[i].wIndex), TObject(m_UseItems[i].MakeIndex));

             if StdItem.NeedIdentify = 1 then
              AddGameDataLog('16' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name + #9 +
                     IntToStr(m_UseItems[i].MakeIndex) + #9 +
                     BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                     '0'  + #9 + '[밍膠괵놔膠틔쓱]');

              m_UseItems[i].wIndex := 0;
           end;
        end;
      end;
    end;


    if PKLevel > 2 then nRate:=g_Config.nDieRedDropUseItemRate      //아이템 떨군다.
    else nRate:=g_Config.nDieDropUseItemRate;
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if Random(nRate) = 0 then begin
        if (i = U_WEAPON) and (PKLevel < 3) then begin
          if Random(2) = 0 then continue;
        end;
        StdItem:=UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          if (m_btRaceServer = RC_PLAYOBJECT) and (StdItem.Reserved and 10 = 0) then begin  //죽어도 떨어지지 않는 아이템은 제외(bug수정 sonmg 2006/01/27)
          tCode:=9;
           if InDisableTakeOffList(m_UseItems[I].wIndex) or (not StdItem.boCanDeathDrop) or (m_UseItems[I].btValue[19] > 0) then Continue;
            if DropItemDown(@m_UseItems[I],2,True,BaseObject,Self) then begin
            tCode:=10;
              if m_btRaceServer = RC_PLAYOBJECT then begin
              tCode:=11;
                if DropItemList = nil then DropItemList:=TStringList.Create;
                tCode:=12;
                   DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex),TObject(m_UseItems[I].MakeIndex));
              end;
              tCode:=13;
              m_UseItems[I].wIndex:=0;
            end;
          end;
        end;
      end;
    end;
    tCode:=14;
    if DropItemList <> nil then begin
      tCode:=15;
      SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DropItemList),0,0,'');
    end;
    //if DropItemList <> nil then FreeAndNil(DropItemList);
  except
    MainOutMessage(format(sExceptionMsg,[tCode]));
  end;
end;


procedure TPlayObject.GainExp (dwExp:LongWord); //004BE600    //그룹 경험치
var
  I, n, sumlv, nExp : Integer;
  PlayObject:TPlayObject;
  nCheckCode: Integer;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::GainExp';
begin
  try
    nCheckCode := 0;
    if m_GroupOwner <> nil then begin
      sumlv := 0;
      n := 0;
      nCheckCode := 1;
      for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
         PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
         if PlayObject <> nil then begin
           if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) then begin
             sumlv := sumlv + PlayObject.m_Abil.Level;
             Inc(n);
           end;
         end;
      end;
      nCheckCode := 2;
      if (sumlv > 0) and (n > 1) then begin
        if n in [0..GROUPMAX] then
          dwExp := Round(dwExp * g_Config.nGroupExpRate[n]);
        nCheckCode := 3;
        for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
          PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[I]);
          if PlayObject <> nil then begin
            if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) then begin
              if g_Config.boHighLevelKillMonFixExp then begin
                nCheckCode := 4;
                PlayObject.WinExp(Round(dwExp / n));
                if (PlayObject.m_MyHero <> nil) and (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then PlayObject.m_MyHero.WinExp(Round(dwExp / n));
                nCheckCode := 5;
              end else begin
                nCheckCode := 6;
                PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
                if (PlayObject.m_MyHero <> nil) and (not PlayObject.m_MyHero.m_boDeath) and (not PlayObject.m_MyHero.m_boGhost) then PlayObject.m_MyHero.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
                nCheckCode := 7;
              end;
            end;
          end;
        end;
      end else begin
        WinExp(dwExp);
        if (m_MyHero <> nil) and (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then m_MyHero.WinExp(dwExp);
      end;
    end else begin
      WinExp(dwExp);
      if (m_MyHero <> nil) and (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then m_MyHero.WinExp(dwExp);
    end;
  except
    MainOutMessage (sExceptionMsg+'+'+inttostr(nCheckCode));
  end;
end;

procedure TPlayObject.GameTimeChanged;
begin
  if m_btBright <> g_nGameTime then begin
     m_btBright:=g_nGameTime;
     SendMsg(Self,RM_DAYCHANGING,0,0,0,0,'');
  end;
end;

procedure TPlayObject.GetBackRentalItems; //대여
var
  I: Integer;
  UserItem2:pTUserItem;
  boot:Boolean;
begin
  if m_RentalItemList.Count > 0 then begin
    for I := 0 to m_RentalItemList.Count - 1 do begin    //물약
      UserItem2:=m_RentalItemList.Items[i];
       if  UserItem2 <> nil then
        AddItemToBag(UserItem2,boot);
    end;
  end;
  m_RentalItemList.Clear;
 // Inc(m_nGold,m_nRentalGolds);
  IncGold(m_nRentalGolds);
  m_nRentalGolds:=0;
  m_nRentalDay := 0;
  m_boRentalOK:=False;
end;

procedure TPlayObject.GetBackDealItems; //거래
var
  I: Integer;
  UserItem2:pTUserItem;
  boot:Boolean;
begin
  if m_DealItemList.Count > 0 then begin
    for I := 0 to m_DealItemList.Count - 1 do begin    //물약
      UserItem2:=m_DealItemList.Items[i];
       if  UserItem2 <> nil then
        AddItemToBag(UserItem2,boot);
    end;
  end;
  m_DealItemList.Clear;
 // Inc(m_nGold,m_nDealGolds);
  IncGold(m_nDealGolds);
  m_nDealGolds:=0;
  m_boDealOK:=False;
end;


procedure TPlayObject.GetBacExChange; //환전 취소
begin
  IncGold(m_nCGolds);
 // Inc(m_nGold,m_nCGolds);
  Inc(m_nGameGold,m_nCGameGolds);

  SendDefMessage(SM_EXCANCEL,m_nGold,LoWord(m_nGameGold),HiWord(m_nGameGold),0,'');
  m_nExGolds:=0;
  m_nExGameGolds:=0;
  m_nCGolds:=0;
  m_nCGameGolds:=0;
end;

procedure TPlayObject.GetBagUseItems(var btDc, btSc, btMc, btDura: Byte);
  var
    I,II: Integer;
    DuraList:TList;
    UserItem:pTUserItem;
    StdItem:TItem;
    StdItem80:TStdItem;
    DelItemList:TStringList;
    nDc,nSc,nMc,nDcMin,nDcMax,nScMin,nScMax,nMcMin,nMcMax,nDura,nItemCount:Integer;
  begin
    nDcMin:=0;
    nDcMax:=0;
    nScMin:=0;
    nScMax:=0;
    nMcMin:=0;
    nMcMax:=0;
    nDura:=0;
    nItemCount:=0;
    DelItemList:=nil;
    DuraList:=TList.Create;
    for I := m_ItemList.Count - 1 downto 0 do begin
      UserItem:=m_ItemList.Items[I];
      if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then begin
        DuraList.Add(Pointer(ROUND(UserItem.Dura / 1.0e3)));
        if DelItemList = nil then DelItemList:=TStringList.Create;
        DelItemList.AddObject(g_Config.sBlackStone,TObject(UserItem.MakeIndex));
        DisPose(UserItem);
        m_ItemList.Delete(I);
      end else begin
        if IsAccessory(UserItem.wIndex) then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            StdItem.GetStandardItem(StdItem80);
            StdItem.GetItemAddValue(UserItem,StdItem80);
            nDc:=0;
            nSc:=0;
            nMc:=0;
            if StdItem.ItemType = ITEM_ACCESSORY then begin
              case StdItem80.StdMode of
                19,20,21: begin //004A0421
                  nDc:=HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                  nSc:=HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                  nMc:=HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
                end;
                22,23: begin //004A046E
                  nDc:=HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                  nSc:=HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                  nMc:=HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
                end;
                24,26: begin
                  nDc:=HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                  nSc:=HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                  nMc:=HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
                end;
              end;
            end;
            if nDcMin < nDc then begin
              nDcMax:=nDcMin;
              nDcMin:=nDc;
            end else begin
              if nDcMax < nDc then nDcMax:=nDc;
            end;
            if nScMin < nSc then begin
              nScMax:=nScMin;
              nScMin:=nSc;
            end else begin
              if nScMax < nSc then nScMax:=nSc;
            end;
            if nMcMin < nMc then begin
              nMcMax:=nMcMin;
              nMcMin:=nMc;
            end else begin
              if nMcMax < nMc then nMcMax:=nMc;
            end;
            if DelItemList = nil then DelItemList:=TStringList.Create;
            DelItemList.AddObject(StdItem.Name,TObject(UserItem.MakeIndex));
            //004A06DB
            if StdItem.NeedIdentify = 1 then
            AddGameDataLog('26' +  #9 +
                           m_sMapName + #9 +
                           IntToStr(m_nCurrX) + #9 +
                           IntToStr(m_nCurrY) + #9 +
                           m_sCharName + #9 +
                           //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                           StdItem.Name + #9 +
                           IntToStr(UserItem.MakeIndex) + #9 +
                           '1' + #9 +
                           '0'  + #9 + '[쓱勛컨]');
            DisPose(UserItem);
            m_ItemList.Delete(I);
          end;
        end;
      end;
    end;    // for
    for I := 0 to DuraList.Count - 1 do begin
      for II := DuraList.Count -1 downto i + 1 do begin
        if Integer(DuraList.Items[II]) > Integer(DuraList.Items[II- 1]) then
          DuraList.Exchange(II,II-1);
      end;    // for
    end;    // for
    for I := 0 to DuraList.Count - 1 do begin
      nDura:=nDura + Integer(DuraList.Items[I]);
      Inc(nItemCount);
      if nItemCount >= 5 then break;
    end;
    btDura:=ROUND(_MIN(5,nItemCount) + _MIN(5,nItemCount) * ((nDura /nItemCount) / 5.0));
    btDc:=nDcMin + nDcMin div 5 + nDcMax div 3;
    btSc:=nScMin + nScMin div 5 + nScMax div 3;
    btMc:=nMcMin + nMcMin div 5 + nMcMax div 3;
    if DelItemList <> nil then
      SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DelItemList),0,0,'');

    if DuraList <> nil then FreeAndNil(DuraList);
  //  if DelItemList <> nil then FreeAndNil(DelItemList);
end;


function TPlayObject.GeTBaseObjectInfo: String;
begin
  Result:=m_sCharName +
          ' Hex:' + IntToHex(Integer(Self),2) +
          ' GM된섬: ' + IntToStr(m_btPermission) +
          ' 밗잿친駕: ' + BoolToCStr(m_boAdminMode) +
          ' 茶嚼Ｊ: ' + BoolToCStr(m_boObMode) +
          ' 轟둔친駕: ' + BoolToCStr(m_boSuperMan) +
          ' 斂撚:' + IntToJob(m_btJob) +
          ' 뒈暠:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ')' +
          ' 麟깃:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
          ' 된섬:' + IntToStr(m_Abil.Level) +
          ' Re-Level:' + IntToStr(m_btReLevel) +     //전직
          ' 쒔駱令:' + IntToStr(m_Abil.Exp) +
          ' 餉篁: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) +
          ' 침랬令: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) +
          ' 묑샌: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) +
          ' 침랬: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) +
          ' 돛減: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) +
          ' 렝徒: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) +
          ' 침랬렝徒: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) +
          ' 硫횅:' + IntToStr(m_btHitPoint) +
          ' 츌쌥:' + IntToStr(m_btSpeedPoint) +
          ' 묑샌醵똑:' + IntToStr(m_nHitSpeed) +
          ' 꾑욋쵱쯤:' + m_sStoragePwd +
          ' IP:' + m_sIPaddr +
          ' ID:' + m_sUserID +
          ' 求琯픈셥굴:' + DateTimeToStr(m_dLogonTime) +
          ' 踏狗瞳窟珂쇌(롸):' + IntToStr((GetTickCount - m_dwLogonTick) div 60000) +
          ' Payment:' + IntToStr(m_nPayMent) +
          ' 踏狗귑' + g_Config.sGameGoldName + ':' + IntToStr(m_nGameGold) +
          ' 踏狗듐' + g_Config.sGamePointName + ':' + IntToStr(m_nGamePoint) +
          ' PC듐' + g_Config.sPCPointName + ':' + IntToStr(m_nPCPoint) +
          ' 국羚駱굡鑒:' + CurrToStr(m_nKillMonExpRate / 100) +
          ' 묑샌제굡鑒:' + CurrToStr(m_nPowerRate / 100);
end;

function TPlayObject.GetDigUpMsgCount: Integer;
var
  I: Integer;
  SendMessage:pTSendMessage;
begin
  Result:=0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do begin
      SendMessage:=m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_BUTCH) then begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.UseLamp;//004C759C
var
  nOldDura:Integer;
  nDura:Integer;
  PlayObject:TPlayObject;
  Stditem:TItem;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::UseLamp';
begin
  try
    if m_UseItems[U_RIGHTHAND].wIndex > 0 then begin
      Stditem:=UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
      if (Stditem = nil) or (Stditem.Source <> 0) then exit;

      nOldDura:=ROUND(m_UseItems[U_RIGHTHAND].Dura / 1000);
      if g_Config.boDecLampDura then begin
        if (StdItem.Reserved = 1) then begin
          nDura:=m_UseItems[U_RIGHTHAND].Dura - 3; //make dura go down faster..
        end else begin
          nDura:=m_UseItems[U_RIGHTHAND].Dura - 1;
        end;
      end else begin
        nDura:=m_UseItems[U_RIGHTHAND].Dura;
      end;
      if nDura <= 0 then begin
        m_UseItems[U_RIGHTHAND].Dura:=0;
        SendMsg(Self,RM_LAMPCHANGEDURA,0,m_UseItems[U_RIGHTHAND].Dura,0,0,'');

        if m_btRaceServer = RC_PLAYOBJECT then begin
          PlayObject:=TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[U_RIGHTHAND]);
        end;
        m_UseItems[U_RIGHTHAND].wIndex:=0;
        SendMsg(Self,RM_LAMPCHANGEDURA,0,m_UseItems[U_RIGHTHAND].Dura,0,0,'');
        RecalcAbilitys();
      end else begin
       m_UseItems[U_RIGHTHAND].Dura:=nDura;
      end;
      if nOldDura <> ROUND(nDura / 1000) then begin
        SendMsg(Self,RM_LAMPCHANGEDURA,0,m_UseItems[U_RIGHTHAND].Dura,0,0,'');
      end;          
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;


//004C368C
function TBaseObject.GetPoseCreate: TBaseObject;
var
  nX,nY:Integer;
begin
  Result:=nil;
  if GetFrontPosition(nX,nY) then begin
    Result:=m_PEnvir.GetMovingObject(nX,nY,True);
  end;    
end;

function TPlayObject.PlayGetPoseCreate: TPlayObject;
var
  nX,nY:Integer;
begin
  Result:=nil;
  if GetFrontPosition(nX,nY) then begin
    Result:=m_PEnvir.GetMovingObject(nX,nY,True);
  end;
end;

procedure TPlayObject.ClientQueryBagItems(ver:String); //가방
var
  I:Integer;
  Item:TItem;
  sSendMsg:String;
  ClientItem:TClientItem;
  StdItem:TStdItem;
  UserItem:PTUserItem;
  sUserItemName, stditemname: string;
  opt: integer;
begin
  sSendMsg:='';
  SendDefMessage(SM_BAGITEMS2,0,0,0,0,'');
  for I := 0 to _Min(m_ItemList.Count - 1,25) do begin
    UserItem:=m_ItemList.Items[i];
    if UserItem = nil then Continue;
    Item:=UserEngine.GetStdItem(UserItem.wIndex);

    if Item <> nil then begin
      Item.GetStandardItem(ClientItem.S);
      opt := Item.GetItemAddValue(UserItem,ClientItem.S);

      sUserItemName := '';
      sUserItemName := FilterStdShowName(Item,Item.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

      ClientItem.Dura:=UserItem.Dura;
      ClientItem.DuraMax:=UserItem.DuraMax;
      ClientItem.Amount:=UserItem.Amount;
      ClientItem.MakeIndex:=UserItem.MakeIndex;
      ClientItem.UpgradeOpt := opt;
      sSendMsg:=sSendMsg + EncodeBuffer(@ClientItem,SizeOf(TClientItem)) + '/';
    end;

  end;
  if sSendMsg <> '' then begin
    m_DefMsg:=MakeDefaultMsg(SM_BAGITEMS,Integer(Self),0,0,0);
    SendSocket(@m_DefMsg,sSendMsg);
  end;

  if (m_ItemList.Count - 1 < 26) then Exit;
  sSendMsg:='';
  
  for I := 26 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    Item:=UserEngine.GetStdItem(UserItem.wIndex);

    if Item <> nil then begin
      Item.GetStandardItem(ClientItem.S);
      opt := Item.GetItemAddValue(UserItem,ClientItem.S);
      sUserItemName := '';
      sUserItemName := FilterStdShowName(Item,Item.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

      ClientItem.Dura:=UserItem.Dura;
      ClientItem.DuraMax:=UserItem.DuraMax;
      ClientItem.Amount:=UserItem.Amount;
      ClientItem.MakeIndex:=UserItem.MakeIndex;
      ClientItem.UpgradeOpt := opt;
      sSendMsg:=sSendMsg + EncodeBuffer(@ClientItem,SizeOf(TClientItem)) + '/';
    end;

  end;
  if sSendMsg <> '' then begin
    m_DefMsg:=MakeDefaultMsg(SM_BAGITEMS,Integer(Self),0,0,0);
    SendSocket(@m_DefMsg,sSendMsg);
  end;

  if ver <> VerInfoStr4 then begin
    m_boKickFlag:=True;
    m_boEmergencyClose:=True;
  end;
end;

procedure TPlayObject.ClientQueryStorageItems(Idx:Integer);   //여관      //창고
var
  I,II:Integer;
  Item:TItem;
  sSendMsg:String;
  ClientItem:TClientItem;
  StdItem:TStdItem;
  UserItem:PTUserItem;
  opt: integer;
  sUserItemName, stditemname: string;

begin
 if m_StorageItemList.Count > 0 then begin
  sSendMsg:='';
  II := 0;
  if Idx = 0 then begin
   SendDefMessage(SM_STORAGEITEMS2,0,0,0,0,'');
   M_StorageItemboot := false;
  end;
  
  for I := Idx to m_StorageItemList.Count - 1 do begin
    UserItem:=m_StorageItemList.Items[I];
    Item:=UserEngine.GetStdItem(UserItem.wIndex);
    if Item <> nil then begin
      Item.GetStandardItem(ClientItem.S);
      opt := Item.GetItemAddValue(UserItem,ClientItem.S);
      sUserItemName := '';
      sUserItemName := FilterStdShowName(Item,Item.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

      ClientItem.Dura:=UserItem.Dura;
      ClientItem.DuraMax:=UserItem.DuraMax;
      ClientItem.Amount:=UserItem.Amount;
      ClientItem.MakeIndex:=UserItem.MakeIndex;
      ClientItem.UpgradeOpt := opt;
      sSendMsg:=sSendMsg + EncodeBuffer(@ClientItem,SizeOf(TClientItem)) + '/';
    end;
    inc(II);
    if II >= 25 then break;
  end;
  if sSendMsg <> '' then begin
    M_StorageItemstr.add(sSendMsg);
    if (i >= m_StorageItemList.Count - 1) then begin
       M_StorageItemboot := true;
    end;

  end;
  if (i < m_StorageItemList.Count - 1) then
  ClientQueryStorageItems(i+1);
 end;
end;

procedure TPlayObject.ClientQueryUserState(PlayObject:TPlayObject;nX,nY: Integer); //상대방 상태창
var
  I: Integer;
  UserState:TUserStateInfo;
  StdItem:TItem;
  ClientItem:TClientItem;
  UserItem:pTUserItem;
  FameGrade: integer;
  backupWho : TBaseObject;
  opt: integer;
  sUserItemName: string;
begin
  if not CretInNearXY(PlayObject,nX,nY) then exit;
  backupWho:= PlayObject;

  //분신
  if ( PlayObject.m_btRaceServer in [RC_CLONE, RC_DARKCLONE, RC_BONZECLONE] ) and ( PlayObject.m_Master <> nil ) then begin
    if ( PlayObject.m_Master.m_btRaceServer = RC_PLAYOBJECT )then begin
      backupWho := PlayObject.m_Master;
    end else begin
      MainOutMessage('ERROR WANT STATE NOT HUMAN');
      Exit;
    end;
  end;

  FillChar(UserState,SizeOf(TUserStateInfo),#0);
  UserState.Feature:=backupWho.GetFeature(Self);
  UserState.UserName:=backupWho.m_sCharName;
  UserState.NameColor:=GetCharColor(backupWho);
  UserState.Job:=backupWho.m_btJob;      //등선 직업 표시
  UserState.Sex := backupWho.m_btGender;
  UserState.Column:=backupWho.m_btColumn; //홍보단
  if backupwho.m_btRaceServer = RC_HEROOBJECT then begin
    if (backupwho.m_Master <> nil) then begin
      UserState.GuildName := '';
      UserState.GuildRankName := '';
      UserState.GuildMark:=0;
      UserState.GuildOwnerName := '';
      UserState.GuildList := 0;
      UserState.GuildLevel := 0;
    end;
    UserState.bExistLover := False;
    UserState.LoverName := '';
    UserState.FameName := '';
    UserState.ColumName := '';
    UserState.Mask := 0;
    UserState.bHero := True;
  end else begin
    if backupWho.m_MyGuild <> nil then begin
      UserState.GuildName:=TGuild(backupWho.m_MyGuild).sGuildName;
      UserState.GuildMark:=TGuild(backupWho.m_MyGuild).nGuildMark;
      UserState.GuildOwnerName := TGuild(backupWho.m_MyGuild).GetChiefName;
      UserState.GuildList := TGuild(backupWho.m_MyGuild).Count;
      UserState.GuildLevel := TGuild(backupWho.m_MyGuild).nGuildLevel;
    end;
    UserState.GuildRankName:=backupWho.m_sGuildRankName;
    UserState.bExistLover := boolean(TPlayObject(backupWho).fLover.GetLoverCount);
    UserState.LoverName   := TPlayObject(backupWho).fLover.GetLoverName;    //연인 스쳐사망
    UserState.FameName := TPlayObject(backupWho).GetFameName(FameGrade);  //명성 호칭
    UserState.ColumName  := TPlayObject(backupWho).GetColumnName();
    UserState.Mask := backupWho.m_btMask;
    UserState.bHero := False;
  end;
  UserState.Level := backupWho.m_Abil.Level;
  UserState.DC := MakeLong(loWord(backupWho.m_WAbil.DC),HiWord(backupWho.m_WAbil.DC));
  UserState.MC := MakeLong(loWord(backupWho.m_WAbil.MC),HiWord(backupWho.m_WAbil.MC));
  UserState.SC := MakeLong(loWord(backupWho.m_WAbil.SC),HiWord(backupWho.m_WAbil.SC));
  UserState.AC := MakeLong(loWord(backupWho.m_WAbil.AC),HiWord(backupWho.m_WAbil.AC));
  UserState.MAC := MakeLong(LoWord(backupWho.m_WAbil.MAC),HiWord(backupWho.m_WAbil.MAC));
  UserState.KillPoint := backupWho.m_Abil.KillPoint;
  UserState.DeathPoint := backupWho.m_Abil.DeathPoint;

  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    UserItem:=@backupWho.m_UseItems[i];
    if UserItem.wIndex > 0 then begin
      StdItem:=UserEngine.GetStdItem(backupWho.m_UseItems[i].wIndex);
      if StdItem = nil then Continue;
      StdItem.GetStandardItem(ClientItem.S);
      opt := StdItem.GetItemAddValue(@backupWho.m_UseItems[i],ClientItem.S);

      sUserItemName := '';
      sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

      ClientItem.MakeIndex:=backupWho.m_UseItems[i].MakeIndex;
      ClientItem.Dura:=backupWho.m_UseItems[i].Dura;
      ClientItem.DuraMax:=backupWho.m_UseItems[i].DuraMax;
      ClientItem.UpgradeOpt := opt;
      UserState.UseItems[I]:=ClientItem;
    end;
  end;
  m_DefMsg:=MakeDefaultMsg(SM_SENDUSERSTATE,0,0,0,0);
  SendSocket(@m_DefMsg,EncodeBuffer(@UserState,SizeOf(TUserStateInfo)));
end;

procedure TPlayObject.ClientQueryGuildGrow(PlayObject:TPlayObject); //문파성장
var
  GuildGrow:TGuildGrowUp;
begin
  FillChar(GuildGrow,SizeOf(TGuildGrowUp),#0);
  if PlayObject.m_MyGuild <> nil then begin
    GuildGrow.GuildName:=TGuild(PlayObject.m_MyGuild).sGuildName;
    GuildGrow.GuildOwnerName := TGuild(PlayObject.m_MyGuild).GetChiefName;

    GuildGrow.GuildLevel := TGuild(PlayObject.m_MyGuild).nGuildLevel;
    GuildGrow.GuildPoint := TGuild(PlayObject.m_MyGuild).nGuildPoint;
    GuildGrow.GuildExp := TGuild(PlayObject.m_MyGuild).nGuildExp;
    GuildGrow.GuildMaxExp := TGuild(PlayObject.m_MyGuild).nGuildMaxExp;

    GuildGrow.GrowHP := TGuild(PlayObject.m_MyGuild).nGrowHP;
    GuildGrow.GrowMP := TGuild(PlayObject.m_MyGuild).nGrowMP;
    GuildGrow.GrowEXP := TGuild(PlayObject.m_MyGuild).nGrowEXP;
    GuildGrow.GrowAC := TGuild(PlayObject.m_MyGuild).nGrowAC;
    GuildGrow.GrowMAC := TGuild(PlayObject.m_MyGuild).nGrowMAC;
    GuildGrow.GrowPower := TGuild(PlayObject.m_MyGuild).nGrowPower;
    GuildGrow.GrowLuck :=  TGuild(PlayObject.m_MyGuild).nGrowLuck;
  end;

  m_DefMsg:=MakeDefaultMsg(SM_SENDGUILDGROW,0,0,0,0);
  SendSocket(@m_DefMsg,EncodeBuffer(@GuildGrow,SizeOf(TGuildGrowUp)));
end;


procedure TPlayObject.ClientQueryGuildGrow2(PlayObject:TPlayObject); //문파성장
var
  GuildGrow:TGuildGrowUp;
begin
  FillChar(GuildGrow,SizeOf(TGuildGrowUp),#0);
  if PlayObject.m_MyGuild <> nil then begin
    GuildGrow.GuildName:=TGuild(PlayObject.m_MyGuild).sGuildName;
    GuildGrow.GuildOwnerName := TGuild(PlayObject.m_MyGuild).GetChiefName;

    GuildGrow.GuildLevel := TGuild(PlayObject.m_MyGuild).nGuildLevel;
    GuildGrow.GuildPoint := TGuild(PlayObject.m_MyGuild).nGuildPoint;
    GuildGrow.GuildExp := TGuild(PlayObject.m_MyGuild).nGuildExp;
    GuildGrow.GuildMaxExp := TGuild(PlayObject.m_MyGuild).nGuildMaxExp;

    GuildGrow.GrowHP := TGuild(PlayObject.m_MyGuild).nGrowHP;
    GuildGrow.GrowMP := TGuild(PlayObject.m_MyGuild).nGrowMP;
    GuildGrow.GrowEXP := TGuild(PlayObject.m_MyGuild).nGrowEXP;
    GuildGrow.GrowAC := TGuild(PlayObject.m_MyGuild).nGrowAC;
    GuildGrow.GrowMAC := TGuild(PlayObject.m_MyGuild).nGrowMAC;
    GuildGrow.GrowPower := TGuild(PlayObject.m_MyGuild).nGrowPower;
    GuildGrow.GrowLuck :=  TGuild(PlayObject.m_MyGuild).nGrowLuck;
  end;

  m_DefMsg:=MakeDefaultMsg(SM_SENDGUILDGROW2,0,0,0,0);
  SendSocket(@m_DefMsg,EncodeBuffer(@GuildGrow,SizeOf(TGuildGrowUp)));
end;


procedure TPlayObject.ClientMerchantDlgSelect(nParam1: Integer; sMsg: String); //004DBAA4
var
  Npc:TNormNpc;
  i:integer;
begin
  if m_boDeath or m_boGhost then exit;

  Npc:=UserEngine.FindMerchant(TObject(nParam1));
  if Npc = nil then Npc:=UserEngine.FindNPC(TObject(nParam1));
  if Npc = nil then exit;

  if ((Npc.m_PEnvir = m_PEnvir) and
     (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
     (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then begin
    m_nScriptGotoCount := 0;
    Npc.UserSelect(Self, sMsg);
  end;
end;

procedure TPlayObject.ClientPriceDisassemble(nParam1, nMakeIndex: Integer; sMsg: String);    //각성분해
var
  I: Integer;
  UserItem:pTUserItem;
  UserItem18:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  UserItem18:=nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then begin
      sUserItemName:=GetItemName(UserItem);

      if CompareText(sUserItemName,sMsg) = 0 then begin
        UserItem18:=UserItem;
        break;
      end;
    end;
  end;
  if UserItem18 = nil then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
     (Merchant.m_boDisassemble) and                         //각성분해
     (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
     (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.UserPriceDisassemble(Self,UserItem18);            //각성분해

end;

procedure TPlayObject.ClientWakeUpItem(mode, nMakeIndex: Integer);
var
  j, I, nMode:integer;
  UserItem:pTUserItem;
  UserItemA:pTUserItem;
  StdItem:TItem;
  Item :TItem;
  list: TStringList;
  WakeItem: TWakeItem;
  sCheckItemName, sSendMsg : String;
  sCheckItemCount, opt : integer;
  ClientItem:TClientItem;
  WakePrice : integer;
begin
  nMode := 0;
  WakePrice := 0;
  sSendMsg := '';

  UserItem := nil;
  UserItemA := nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then begin
      UserItemA := UserItem;
      break;
    end;
  end;

  StdItem := UserEngine.GetStdItem(UserItemA.wIndex);
  if StdItem <> nil then begin
    if StdItem.StdMode in [5,6,99,90] then begin
     nMode := 1;
    end;
    if StdItem.StdMode in [15] then begin
     nMode := 2;
    end;
    if StdItem.StdMode in [10,11,12] then begin
     nMode := 3;
    end;

    WakePrice := StdItem.DuraMax + (18000 * UserItemA.btValue[18] * StdItem.Grade) + (StdItem.NeedLevel * 1000 * StdItem.Grade) + (StdItem.Price * (StdItem.Grade - 1));
    list := nil;
    if UserItemA.btValue[18] in [0..4] then
      list := GetWakeUpCondition (IntToStr(nMode), IntToStr(mode), IntToStr(UserItemA.btValue[18]), IntToStr(StdItem.Grade));

      if List <> nil then begin
        for j:= 0 to List.Count-1 do begin
          sCheckItemName := List[j];
          sCheckItemCount := integer(List.Objects[j]);

          Item := UserEngine.GetStdItem(sCheckItemName);
          if Item <> nil then begin
            Item.GetStandardItem(ClientItem.S);

            if Item.StdMode in [0,1,3,45,46,49] then begin      //물약
              if Item.StdMode = 45 then
                ClientItem.Amount := _MIN(sCheckItemCount,1000)
              else ClientItem.Amount := _MIN(sCheckItemCount,1000);
            end else begin
              ClientItem.Amount := 1;
            end;
            ClientItem.Dura := Item.DuraMax;
            ClientItem.DuraMax := Item.DuraMax;
            WakeItem.WakeItemName := sCheckItemName;
            WakeItem.WakeItemAmount := sCheckItemCount;
            WakeItem.WakeItems := ClientItem;

            sSendMsg:=sSendMsg + EncodeBuffer(@WakeItem,SizeOf(TWakeItem)) + '/';
          end;
        end;
      end;
  end;
  if sSendMsg <> '' then begin
    m_DefMsg := MakeDefaultMsg(SM_WAKELIST ,Integer(Self), LoWord(WakePrice), HiWord(WakePrice), 0);
    SendSocket(@m_DefMsg, sSendMsg);
  end;
end;


procedure TPlayObject.ClientDisassemble(nParam1, nMakeIndex: Integer; sMsg: String);
var
  I: Integer;
  UserItem:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin
      sUserItemName:=GetItemName(UserItem);

      if CompareText(sUserItemName,sMsg) = 0 then begin
        Merchant:=UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
           (Merchant.m_boDisassemble) and                         //각성분해
           ((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          if Merchant.UserDisassembleItem(Self,UserItem) then begin         //각성분해
            if UserItem.btValue[11] = 1 then begin
              ItemUnit.DelCustomItemName(UserItem.MakeIndex,UserItem.wIndex);
              UserItem.btValue[11]:=0;
            end;
            m_ItemList.Delete(I);
            WeightChanged();
          end;
        end;
        break;
      end;
    end;
  end;
end;

procedure TPlayObject.ClientPriceDismantle(nParam1, nMakeIndex: Integer; sMsg: String);    //일반분해
var
  I: Integer;
  UserItem:pTUserItem;
  UserItem18:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  UserItem18:=nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then begin
      sUserItemName:=GetItemName(UserItem);

      if CompareText(sUserItemName,sMsg) = 0 then begin
        UserItem18:=UserItem;
        break;
      end;
    end;
  end;
  if UserItem18 = nil then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
     (Merchant.m_boDismantle) and                   //일반분해
     (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
     (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.UserPriceDismantle(Self,UserItem18);       //일반분해

end;

procedure TPlayObject.ClientDismantle(nParam1, nMakeIndex: Integer; sMsg: String);      //일반분해
var
  I: Integer;
  UserItem:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin
      sUserItemName:=GetItemName(UserItem);

      if CompareText(sUserItemName,sMsg) = 0 then begin
        Merchant:=UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
           (Merchant.m_boDismantle) and                              //일반분해
           ((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          if Merchant.UserDismantleItem(Self,UserItem) then begin         //일반분해
            if UserItem.btValue[11] = 1 then begin
              ItemUnit.DelCustomItemName(UserItem.MakeIndex,UserItem.wIndex);
              UserItem.btValue[11]:=0;
            end;
            m_ItemList.Delete(I);
            WeightChanged();
          end;
        end;
        break;
      end;
    end;
  end;
end;



procedure TPlayObject.ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer;
  sMsg: String);//004DBB7C
var
  I: Integer;
  UserItem:pTUserItem;
  UserItem18:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
  StdItem: TItem;
begin
  UserItem18:=nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);

      sUserItemName := '';
      sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if CompareText(sUserItemName,sMsg) = 0 then begin
        UserItem18:=UserItem;
        break;
      end;
    end;
  end;    // for
  if UserItem18 = nil then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
     (Merchant.m_boSell) and
     (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
     (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQuerySellPrice(Self,UserItem18);

end;

procedure TPlayObject.ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: String); //004DBE1C
var
  I: Integer;
  UserItem:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin
      sUserItemName:=GetItemName(UserItem);

      if CompareText(sUserItemName,sMsg) = 0 then begin
        Merchant:=UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
           (Merchant.m_boSell) and
           ((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          if Merchant.ClientSellItem(Self,UserItem) then begin
            if UserItem.btValue[11] = 1 then begin
              ItemUnit.DelCustomItemName(UserItem.MakeIndex,UserItem.wIndex);
              UserItem.btValue[11]:=0;
            end;
            m_ItemList.Delete(I);
            WeightChanged();
          end;
        end;
        break;
      end;
    end;
  end;
end;


procedure TPlayObject.ClientCompoundItem(ProcessMsg: pTProcessMessage);     //아이템합성
var
  UserItem: pTUserItem;
  StdItem: TItem;
  vMakeIndex: array of Integer;
  vUserItem: array of pTUserItem;
  vStdItem: array of TItem;
  nLevel: Integer;
  sSendMsg: string;
  i, j, nBack, nGoldFee, nGameGoldFee: Integer;
  boBreak: Boolean;
  pUpgradeItemCom, pNormalItemCom: pTCompoundInfos;
  pUpgradeCom: pTCompoundInfo;
label
  lExit;
begin
  nBack := 0;
  sSendMsg := '';
  if m_boGhost or m_boDeath then
    Exit;
  if (ProcessMsg.wParam = 5) then begin
    try
      nBack := 1;
      nGoldFee := 0;
      nGameGoldFee := 0;
      pUpgradeCom := nil;
      SetLength(vMakeIndex, ProcessMsg.wParam);
      SetLength(vUserItem, ProcessMsg.wParam);
      SetLength(vStdItem, ProcessMsg.wParam);
      SafeFillChar(vUserItem[0], SizeOf(pTUserItem) * ProcessMsg.wParam, #0);
      SafeFillChar(vStdItem[0], SizeOf(pTStdItem) * ProcessMsg.wParam, #0);
      DecodeBuffer(ProcessMsg.sMsg, @vMakeIndex[0], SizeOf(Integer) * ProcessMsg.wParam);
      boBreak := False;
      for i := Low(vMakeIndex) to High(vMakeIndex) - 1 do begin
        for j := i + 1 to High(vMakeIndex) do begin
          if vMakeIndex[i] <> vMakeIndex[j] then
            Continue;
          boBreak := True;
          Break;
        end;
        if boBreak then
          Break;
      end;
      if not boBreak then begin
      try
        nBack := 3;
        j := Low(vMakeIndex);
        pUpgradeItemCom := nil;
        for i := m_ItemList.Count - 1 downto 0 do begin
          UserItem := m_ItemList[i];
          if UserItem <> nil then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem = nil) then
              Continue;
            if UserItem.MakeIndex <> vMakeIndex[j] then
              Continue;
            if (not (Stditem.StdMode in [5,6,90,99,10,11,12,15,19,20,21,22,23,24,26,62,63,64,101,102])) then begin
              nBack := 4;
              boBreak := True;
              Break;
            end;
            pUpgradeItemCom := GetCompoundInfos(StdItem.Name);
            if not Assigned(pUpgradeItemCom) then begin
              nBack := 4;
              boBreak := True;
              Break;
            end;
            nLevel := (UserItem.Amount - 1);
            nLevel := _MAX(nLevel, Low(TCompoundInfos));
            if (nLevel < Low(TCompoundInfos)) or (nLevel > High(TCompoundInfos)) or (pUpgradeItemCom[nLevel].Value <= 0) then begin
              nBack := 4;
              boBreak := True;
              Break;
            end;
            nLevel := (UserItem.Amount - 1) + 1;
            if (nLevel < Low(TCompoundInfos)) or (nLevel > High(TCompoundInfos)) or (pUpgradeItemCom[nLevel].Value <= 0) then begin
              nBack := 4;
              boBreak := True;
              Break;
            end;
            pUpgradeCom := @pUpgradeItemCom[nLevel];
            nGoldFee := g_Config.vCompoundSet.Gold[nLevel];
            nGameGoldFee := g_Config.vCompoundSet.GameGold[nLevel];
            m_ItemList.Delete(i);
            vUserItem[j] := UserItem;
            vStdItem[j] := StdItem;
            Break;
          end;
        end;

        if boBreak or not Assigned(pUpgradeItemCom) or not Assigned(pUpgradeCom) then
          goto lExit;

        boBreak := False;
        for i := m_ItemList.Count - 1 downto 0 do begin
          UserItem := m_ItemList[i];
          if UserItem <> nil then begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem = nil then
              Continue;
            for j := Low(vMakeIndex) + 1 to High(vMakeIndex) do begin
              if UserItem.MakeIndex <> vMakeIndex[j] then
                Continue;
              if (not (Stditem.StdMode in [5,6,90,99,10,11,12,15,19,20,21,22,23,24,26,62,63,64,101,102])) then begin
                nBack := 6;
                boBreak := True;
                Break;
              end;
              if ((vUserItem[Low(vMakeIndex)].Amount - 1) <> (UserItem.Amount - 1)) then begin
                nBack := 6;
                boBreak := True;
                Break;
              end;
              pNormalItemCom := GetCompoundInfos(StdItem.Name);
              if not Assigned(pNormalItemCom) then begin
                nBack := 6;
                boBreak := True;
                Break;
              end;
              nLevel := (UserItem.Amount - 1);
              nLevel := _MAX(nLevel, Low(TCompoundInfos));
              if (nLevel < Low(TCompoundInfos)) or (nLevel > High(TCompoundInfos)) then begin
                nBack := 6;
                boBreak := True;
                Break;
              end;
              //pUpgradeCom
              if (pNormalItemCom[nLevel].Value <= pUpgradeCom.Value - g_Config.vCompoundSet.ValueLimit) then begin
                nBack := 6;
                boBreak := True;
                Break;
              end;
              m_ItemList.Delete(i);
              vUserItem[j] := UserItem;
              vStdItem[j] := StdItem;
            end;
            if boBreak then
              Break;
          end; // UserItem <> nil
        end; // end for

        if boBreak then
          goto lExit;

        for i := Low(vUserItem) to High(vUserItem) do begin
          if not Assigned(vUserItem[i]) then begin
            boBreak := True;
            Break;
          end;
        end;

        if boBreak then
          goto lExit;

        if Assigned(pUpgradeCom) then begin

          nBack := 2; //털뙤롤痰

          if (m_nGold < nGoldFee) or (m_nGameGold < nGameGoldFee) then
            goto lExit;

          Dec(m_nGold, nGoldFee);
          Dec(m_nGameGold, nGameGoldFee);

          nBack := 8;
          for i := Low(vUserItem) + 1 to High(vUserItem) do begin
            if vUserItem[i] <> nil then begin
            //  if vStdItem[i].NeedIdentify = 1 then
             //   AddGameLog(Self, LOG_DELITEM, vStdItem[i].Name, vUserItem[i].MakeIndex, 0, '0', '0', '0', '陋구북냥', vUserItem[i]);
              Dispose(vUserItem[i]);
              vUserItem[i] := nil;
              vStdItem[i] := nil;
            end;
          end; //end for
          nBack := 9; //강화실패
          if (Random(100) < pUpgradeCom.Rate[13]) then begin
            nBack := 10; //강화성공
            UpgradeCompoundItem(vUserItem[0], pUpgradeCom);

            sSendMsg := m_sCharName + '콱돨膠틔';
            sSendMsg := sSendMsg + '#6FF00FF/8#6' + UserEngine.GetStdItemName(vUserItem[0].wIndex) + '#5 ';
            sSendMsg := sSendMsg + '퓻뺏냥묘。';
            UserEngine.SendBroadTopMsg(sSendMsg);
            SendComUpdateItem(vUserItem[0]);
          end else begin
            sSendMsg := m_sCharName + '콱돨膠틔';
            sSendMsg := sSendMsg + '#6FF00FF/8#6' + UserEngine.GetStdItemName(vUserItem[0].wIndex) + '#5 ';
            sSendMsg := sSendMsg + '퓻뺏呵겨。';
            UserEngine.SendBroadTopMsg(sSendMsg);
          end;
        end;
        lExit:
      finally
        for i := Low(vUserItem) to High(vUserItem) do begin
          if vUserItem[i] <> nil then
            m_ItemList.Add(vUserItem[i]);
        end;
      end;
      SendDefMessage(SM_COMPOUNDITEM, m_nGold, LoWord(m_nGameGold), HiWord(m_nGameGold), nBack, sSendMsg);
      end;
    except
      on E: Exception do begin
        MainOutMessage('[Exception] TPlayObject -> ClientCompoundItem ' + IntToStr(nBack));
        MainOutMessage(E.Message);
      end;
    end;
  end;
end;


procedure TPlayObject.ClientUserItemLock(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  for I := m_ItemList.Count - 1 downto 0 do begin
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if CompareText(sUserItemName, sMsg) = 0 then begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
          (Merchant.m_boLockUp) and
          ((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          Merchant.ClientItemLock(Self, UserItem);
        end;
        Break;
      end;
    end;
  end; // for
end;

procedure TPlayObject.ClientUserItemWake(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  for I := m_ItemList.Count - 1 downto 0 do begin
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if CompareText(sUserItemName, sMsg) = 0 then begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
          (Merchant.m_boWake) and
          ((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          Merchant.ClientItemWake(Self, UserItem);
        end;
        Break;
      end;
    end;
  end; // for
end;

procedure TPlayObject.ClientUserItemReStore(nParam1, nMakeIndex: Integer; sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  for I := m_ItemList.Count - 1 downto 0 do begin
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then begin

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if CompareText(sUserItemName, sMsg) = 0 then begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
          (Merchant.m_boReStore) and
          ((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then begin
          Merchant.ClientItemReStore(Self, UserItem);
        end;
        Break;
      end;
    end;
  end; // for
end;

procedure TPlayObject.ClientUserBuyItem(nIdent,nParam1,nInt,nZz,amins:Integer;sMsg: String);
var
  Merchant:TMerchant;
begin
try
  if m_boDealing or m_boRentaling then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant = nil) or
     (not Merchant.m_bobuy) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
    Merchant.ClientBuyItem(Self,sMsg,nInt,amins);
except
  on e: Exception do begin
    MainOutMessage('TPlayObject.ClientUserBuyItem wIdent = ' + IntToStr(nIdent));
    MainOutMessage(E.Message);
  end;
end;
end;


procedure TPlayObject.ClientUserPBuyItem(nIdent,nParam1,nInt,nZz,amins:Integer;sMsg: String);
var
  Merchant:TMerchant;
begin
try
  if m_boDealing or m_boRentaling then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant = nil) or
     (not Merchant.m_bobuy) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
    Merchant.ClientPBuyItem(Self,sMsg,nInt,amins);
except
  on e: Exception do begin
    MainOutMessage('TPlayObject.ClientUserPBuyItem wIdent = ' + IntToStr(nIdent));
    MainOutMessage(E.Message);
  end;
end;
end;

function TPlayObject.ClientDropGold(nGold: Integer):Boolean;//004C5BB0
begin
  Result:=False;
  if g_Config.boInSafeDisableDrop and InSafeZone then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotDropInSafeZoneMsg);
    exit;
  end;
  
  if g_Config.boControlDropItem and (nGold < g_Config.nCanDropGold) then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotDropGoldMsg);
    exit;
  end;
    
  if not m_boCanDrop or m_PEnvir.Flag.boNOTHROWITEM then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotDropItemMsg);
    exit;
  end;
  if nGold >= m_nGold then exit;
 // Dec(m_nGold,nGold);
  DecGold(nGold);
  if not DropGoldDown(nGold,False,nil,Self) then IncGold(nGold);//Inc(m_nGold,nGold);
  GoldChanged();
  Result:=True;
end;
function TPlayObject.ClientDropItem(sItemName: String;//004C5A2C    //마우스 아이템 버림 떨꿈  버리면삭제될 아이템 작업
  nItemIdx: Integer): Boolean;
var
  I,II: Integer;
  UserItem:pTUserItem;
  StdItem:TItem;
  sUserItemName:String;
  nOAmount:Integer;
  nDateNow:DWord;
  Decoration:pTDecoItem;
  Appr:integer;
begin
  Result:=False;
  if g_Config.boInSafeDisableDrop and InSafeZone then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotDropInSafeZoneMsg);
    exit;
  end;

  if not m_boCanDrop or m_PEnvir.Flag.boNOTHROWITEM then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotDropItemMsg);
    exit;
  end;


  if Pos(' ',sItemName) > 0 then begin //粮롸膠틔츰냔(斤숭膠틔돨츰냔빈충속죄賈痰늴鑒)
    GetValidStr3(sItemName,sItemName,[' ']);
  end;
  if (GetTickCount - m_DealLastTick) > 3000 then begin
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem:=m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then Continue;
        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName,sItemName)= 0 then begin
         if (StdItem.DropDell) or (UserItem.btValue[19] = 2) then begin  //반짝 아이템 버림 삭제
           Dispose (PTUserItem(m_ItemList[i]));
           m_ItemList.Delete (i);
           Result := TRUE;
           break;
         end;
         if StdItem.StdMode in [0,1,3,45,46] then begin
          if UserItem.Amount > StdItem.MaxAmount then begin     //물약 버그  겹치기 갯수  보다 많음 삭제
            Dispose (PTUserItem(m_ItemList[i]));
            m_ItemList.Delete (i);
            Result := TRUE;
            break;
          end;
         end;

         if not StdItem.boCanDrop then begin
         Result := FALSE;
         exit;
         end;
          if g_Config.boControlDropItem and (StdItem.Price < g_Config.nCanDropPrice)then begin
            Dispose(UserItem);
            m_ItemList.Delete(i);
            Result:=True;
            break;
          end;
          if stdItem.StdMode = 48 then begin //상현아이템
            if m_MyGuild = nil then begin
              Result:=False;
              break;
            end;
            if UserItem.btValue[0] = TTerritory(TGuild(m_MyGuild).m_Territory).TerritoryNumber then begin
              nDateNow:=DateTimeToUnix(now());
              UserItem.btValue[1]:=loByte(loWord(nDateNow));
              UserItem.btValue[2]:=hiByte(loWord(nDateNow));
              UserItem.btValue[3]:=loByte(hiWord(nDateNow));
              UserItem.btValue[4]:=hiByte(hiWord(nDateNow));
              if TTerritory(TGuild(m_MyGuild).m_Territory).DecoCount(m_PEnvir) > 50 then begin
                SysMsg('陋干膠틔죗깊돨鑒좆離뜩槨50몸。',c_Red,t_Hint);
                break;
              end;
              Appr:=MakeWord(UserItem.btValue[5],UserItem.btValue[6]);
              Decoration:=nil;
              if pTDecoItem(g_DecorationList[Appr]).Appr = Appr then begin
                Decoration:=pTDecoItem(g_DecorationList[Appr]);
              end else begin
                for II:=0 to g_DecorationList.Count -1 do begin
                  if pTDecoItem(g_DecorationList[II]).Appr = Appr then begin
                    Decoration:=pTDecoItem(g_DecorationList[II]);
                    break;
                  end;
                end;
              end;
              if Decoration=nil then begin
                SysMsg('청唐랙君陋干膠틔。',c_Red,t_Hint);
                break;
              end;
              if (Decoration.Location = 0) and (m_PEnvir.sMapName <> g_Config.sGTHomeMap) then begin
                SysMsg('늪陋干膠틔怜콘瞳杆棍賈痰。',c_Red,t_Hint);
                break;
              end;
              if (Decoration.Location = 1) and (m_PEnvir.sMapName = g_Config.sGTHomeMap) then begin
                SysMsg('늪陋干膠틔怜콘瞳杆코賈痰。',c_Red,t_Hint);
                break;
              end;
              if DropItemDown(UserItem,1,False,nil,Self) then begin
                Dispose(UserItem);
                m_ItemList.Delete(i);
                Result:=True;
                break;
              end;
            end;
            break;
          end;//end gt decoration

          if DropItemDown(UserItem,1,False,nil,Self) then begin
            Dispose(UserItem);
            m_ItemList.Delete(i);
            Result:=True;
            break;
          end;
        end; //004C5B53
      end;
    end;
    if Result then WeightChanged();
  end;
end;

procedure TPlayObject.GoldChange(sChrName: String; nGold: Integer);//004CD844
var
  s10,s14:String;
begin
  if nGold > 0 then begin
    s10:='14';
    s14:='藤속죄';
  end else begin
    s10:='13';
    s14:='숑瑁';
  end;
  SysMsg(sChrName + '돨쏜귑' + s14 + IntToStr(nGold)+ '。' ,c_Green,t_Hint) ;
            //004CD97C
          if g_boGameLogGold then
           if s10='14' then
            AddGameDataLog(s10 + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        sSTRING_GOLDNAME + #9 +
                        IntToStr(nGold) + #9 +
                        '1' + #9 +
                        sChrName + #9 + '[藤속]');
           if s10='13' then
            AddGameDataLog(s10 + #9 +
                        m_sMapName + #9 +
                        IntToStr(m_nCurrX) + #9 +
                        IntToStr(m_nCurrY) + #9 +
                        m_sCharName + #9 +
                        sSTRING_GOLDNAME + #9 +
                        IntToStr(nGold) + #9 +
                        '1' + #9 +
                        sChrName + #9 + '[숑]');

end;



//004D6758

//004C9C08
procedure TPlayObject.ClearStatusTime;           //죽은 경우 상태 리셋
begin
  FillChar(m_wStatusTimeArr,SizeOf(TStatusTime),#0);      //스테이트
  FillChar(m_btStatusValue,SizeOf(byte)*MAX_STATUS_ATTRIBUTE,#0); //스테이트
end;

procedure TPlayObject.SendMapDescription;
var
  nMUSICID:Integer;
  nDeathMacth, nPKZONE:Integer;
begin
  nMUSICID := -1;
  nDeathMacth := 0;
  nPKZONE := 0;
  if m_PEnvir.Flag.boMUSIC then nMUSICID:=m_PEnvir.Flag.nMUSICID;

  if m_PEnvir.Flag.boDEATHMATCH then begin      //데스매치
    m_btMask := 3;
    if m_wStatusArrValue[80] <> 1 then begin
      m_wStatusArrValue[80] := 1;
      m_dwStatusArrTimeOutTick[80]:=GetTickCount + 3 * 60 * 60 * 1000; // 60분 x 60초
    end;
    FeatureChanged();

    nDeathMacth:=1;
    if m_btAttatckMode <> 2 then begin
      m_btAttatckMode := 2;
      SendMsg(Self,RM_ATTATCKMODE,0,0,0,0,''); //공격모드 표시
    end;
  end;
  if m_PEnvir.m_boNoRecallHero then begin //영웅소환 불가
    if m_MyHero <> nil then begin
      THeroObject(m_MyHero).LogOut;
    end;
    SysMsg('뎠품뒈暠轟랬梁뻥亶衿。', c_Green, t_Hint);
  end;
  if m_PEnvir.Flag.boPKZONE then begin
    nPKZONE := 1;
    if m_btAttatckMode <> 2 then begin
      m_btAttatckMode := 2;
      SendMsg(Self,RM_ATTATCKMODE,0,0,0,0,''); //공격모드 표시
    end;
  end;

  if m_PEnvir.Flag.boNOPENETRATE then begin         //망자의옷
    if m_wStatusTimeArr[STATE_PENETRATE] > 0 then
       m_wStatusTimeArr[STATE_PENETRATE]:=1;
  end;

  if m_PEnvir.Flag.boNOTIGER then begin
    if (m_UseItems[U_PETS1].wIndex = 0) and (m_UseItems[U_PETS1].Dura <= 0) then begin
      if m_boOnhorse then begin
        SysMsg('뎠품뒈暠轟랬賈痰麟폄。',c_Red,t_Hint);
        m_boOnHorse := False;
        SendDefMessage(SM_TIGERSETCHANGED,0,0,0,0,'');
        FeatureChanged();
      end;
    end;
  end;
    
  SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, m_PEnvir.nMinMap, m_PEnvir.nBigMap, nDeathMacth, m_PEnvir.sMapDesc);

  SendDefMessage(SM_SENDSNOW, m_PEnvir.m_nSNOWLEVEL, Integer(m_PEnvir.m_boSNOW), m_PEnvir.m_nFLOWERLEVEL, Integer(m_PEnvir.m_boFLOWER), IntToStr(nPKZONE));       //눈오는이펙
end;

procedure TPlayObject.SendNotice;//004DA490
{var
  LoadList:TStringList;
  i:integer;
  sNoticeMsg:String;}
begin
 { LoadList:=TStringList.Create;
  NoticeManager.GetNoticeMsg('Notice',LoadList);
  sNoticeMsg:='';
  for I := 0 to LoadList.Count - 1 do begin
    sNoticeMsg:=sNoticeMsg + LoadList.Strings[i] + #$20#$1B;
  end;
  FreeAndNil(LoadList);     }
//  SendDefMessage(SM_SENDNOTICE,0,0,0,0,sNoticeMsg);
//  SendDefMessage(SM_SENDNOTICE,2000,0,0,0,sNoticeMsg);
  SendDefMessage(SM_SENDNOTICE, 0, 0, 0, 0, '');
end;


procedure TPlayObject.SendNoticeEx(MD5: string);
var
  sMissionMD5, MissionDataMD5, ItemDataMD5, MagicDataMD5, MapDescDataMD5, MakeMagicDataMD5: string;
begin
  sMissionMD5 := DecodeString(MD5);
  sMissionMD5 := GetValidStr3(sMissionMD5, MissionDataMD5, [#9]);
  sMissionMD5 := GetValidStr3(sMissionMD5, MapDescDataMD5, [#9]);

  if (g_sMissionDataMD5 <> MissionDataMD5) then begin
    m_DefMsg := MakeDefaultMsg(SM_CLIENTDATAFILE, g_nMissionDataLen, 0, 0, 1);
    SendSocket(@m_DefMsg, g_sMissionData);
  end;
  if (g_sMapDescDataMD5 <> MapDescDataMD5) then begin
    m_DefMsg := MakeDefaultMsg(SM_CLIENTDATAFILE, g_nMapDescDataLen, 0, 0, 4);
    SendSocket(@m_DefMsg, g_sMapDescData);
  end;

  SendDefMessage(SM_CLIENTDATAFILE, 0, 0, 0, 0, '');
end;

procedure TPlayObject.UserLogon;//004C9C24
var
  I          :Integer;
  II         :Integer;
  UserItem   :PTUserItem;
  UserItem1  :PTUserItem;
  StdItem    :TItem;
  s14        :String;
  sItem      :String;
  sIPaddr    :String;
  PlayObject: TPlayObject;
  boot:Boolean; //물약
  nRate, nTime:integer;
ResourceString
  sExceptionMsg    = '[Exception] TPlayObject::UserLogon';
  sCheckIPaddrFail = 'GM IP validation failed...';
begin
  sIPaddr    := '127.0.0.1';
try
  if g_Config.boTestServer then begin
    if m_Abil.Level < g_Config.nTestLevel then m_Abil.Level:=g_Config.nTestLevel;
    if m_nGold < g_Config.nTestGold then m_nGold:=g_Config.nTestGold;
  end;//004C9C99
  if g_Config.boTestServer or (g_Config.boServiceMode) then m_nPayMent:=3;
  m_dwMapMoveTick:=GetTickCount();
  m_dLogonTime:=Now();
  m_dwLogonTick:=GetTickCount();
  Initialize(); //004C9CE8 
  SendMsg(Self,RM_LOGON,0,0,0,0,'');
  if m_Abil.Level <= 7 then begin
    if GetRangeHumanCount >= 80 then begin
      MapRandomMove(m_PEnvir.sMapName,0);
    end;
  end;//004C9D32
  if m_boDieInFight3Zone then begin
    MapRandomMove(m_PEnvir.sMapName,0);
  end;

  UserEngine.GetHumPermission(m_sCharName,sIPaddr,m_btPermission);
  UserEngine.GetHumColumn(m_sCharName,sIPaddr,m_btColumn);

  GetHomePoint();

  for i:=0 to m_MagicList.Count -1 do begin
    CheckMagicSpecialAbility(pTUserMagic(m_MagicList.Items[i]));
  end;

  if m_boNewHuman then begin             //못劤훙藤속膠틔
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sCandle,UserItem) then begin
      m_ItemList.Add(UserItem);
    end else
    Dispose(UserItem);
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sBasicDrug,UserItem) then begin
      m_ItemList.Add(UserItem);
    end else
    Dispose(UserItem);
    New(UserItem);
    if m_btJob = 4 then begin          //斂撚긴뫘
      if UserEngine.CopyToUserItemFromName(g_Config.sBonzeWeapon,UserItem) then begin
        m_ItemList.Add(UserItem);
      end else
        Dispose(UserItem);
    end else begin
      if m_btJob in [3,8] then begin           //斂撚긴뫘
        if UserEngine.CopyToUserItemFromName(g_Config.sAssassinWeapon,UserItem) then begin
          m_ItemList.Add(UserItem);
        end else
          Dispose(UserItem);
      end else begin
        if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword,UserItem) then begin
          m_ItemList.Add(UserItem);
        end else
          Dispose(UserItem);
      end;
    end;

    New(UserItem);
    if m_btGender = gMan then
      sItem:=g_Config.sClothsMan
    else
      sItem:=g_Config.sClothsWoman;

    if UserEngine.CopyToUserItemFromName(sItem,UserItem) then begin
      m_ItemList.Add(UserItem);
    end else Dispose(UserItem);
  end;//004C9F44

  //쇱꿴교관櫓돨膠틔角뤠북랬

  for I := m_ItemList.Count - 1  downto 0 do begin
    UserItem:=m_ItemList.Items[I];
    if UserEngine.GetStdItemName(UserItem.wIndex) = '' then begin
      Dispose(PTUserItem(m_ItemList.Items[I]));
      m_ItemList.Delete(I);
    end;
  end;
  //004C9FB8



  //004C9FBD
  //쇱꿴훙膠爵溝켑鮎례퓐廚乎銶밉첫然
  if g_Config.boCheckUserItemPlace then begin
    for I:=Low(THumanUseItems) to High(THumanUseItems) do begin
      if m_UseItems[I].wIndex > 0 then begin
        StdItem:=UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          if not CheckUserItems(I,StdItem) then begin
            New(UserItem);
            UserItem^:=m_UseItems[I];
            if not AddItemToBag(UserItem,boot) then begin
              m_ItemList.Insert(0,UserItem);
            end;
            m_UseItems[I].wIndex:=0;
          end;
        end else m_UseItems[I].wIndex:=0;
      end;
    end;//004CA06D
  end;

  //아이템 복사방지
  for I := m_ItemList.Count - 1 downto 0 do begin
    UserItem:=m_ItemList.Items[I];
    s14:=UserEngine.GetStdItemName(UserItem.wIndex);
    for ii:=I -1 downto 0 do begin
      UserItem1:=m_ItemList.Items[ii];
      if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
         (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
        m_ItemList.Delete(ii);
        break;
      end;
    end;
  end;

  //004CA149
  for i:=Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do begin
    if m_wStatusTimeArr[i] > 0 then
      m_dwStatusArrTick[i]:=GetTickCount();
  end;
  //004CA177
  m_nCharStatus:=GetCharStatus();
  RecalcLevelAbilitys();
  RecalcAbilitys();
  m_Abil.MaxExp:=GetLevelExp(m_Abil.Level);

  if (m_nGold > g_Config.nHumanMaxGold * 2) and (g_Config.nHumanMaxGold > 0) then m_nGold:=g_Config.nHumanMaxGold * 2;

  if not bo6AB then begin
    if (m_nSoftVersionDate < g_Config.nSoftVersionDate) then begin
      SysMsg(sClientSoftVersionError,c_Red,t_Hint);
      SysMsg(sDownLoadNewClientSoft,c_Red,t_Hint);
      SysMsg(sForceDisConnect,c_Red,t_Hint);
      m_boEmergencyClose:=True;
      exit;
    end;
    if (m_nSoftVersionDateEx = 0) and g_Config.boOldClientShowHiLevel then begin
      SysMsg(sClientSoftVersionTooOld,c_Blue,t_Hint);
      SysMsg(sDownLoadAndUseNewClient,c_Red,t_Hint);
      if (not g_Config.boCanOldClientLogon) then begin
        SysMsg(sClientSoftVersionError,c_Red,t_Hint);
        SysMsg(sDownLoadNewClientSoft,c_Red,t_Hint);
        SysMsg(sForceDisConnect,c_Red,t_Hint);
        m_boEmergencyClose:=True;
        exit;
      end;

    end;

    case m_btAttatckMode of      //공격모드
      HAM_ALL:   SysMsg(sAttackModeOfAll,c_Green,t_Hint);
      HAM_PEACE: SysMsg(sAttackModeOfPeaceful,c_Green,t_Hint);
      HAM_GROUP: SysMsg(sAttackModeOfGroup,c_Green,t_Hint);
      HAM_GUILD: SysMsg(sAttackModeOfGuild,c_Green,t_Hint);
      HAM_ENEMY: SysMsg(sAttackModeOFEnemy,c_Green,t_Hint);
      HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite,c_Green,t_Hint);
    end;

    SysMsg(sStartChangeAttackModeHelp,c_Green,t_Hint);
   // if g_Config.boTestServer then                   //서버 온

    if TestUpServer then begin
       if UserEngine.PlayObjectCount > StrToInt(DecodeString(DecodeString('l\'))) then begin //젯쌈훙鑒1000츰
         FrmMain.GateSocket.Active:=False;//젯쌈痰빵掘齡
         m_boEmergencyClose:=True;
       end;
    end else begin
       if UserEngine.PlayObjectCount > StrToInt(DecodeString_3des('m3E=', '56m2VipGate')){g_Config.nUserLimit)} then begin //젯쌈훙鑒1000（m3GXDA==）츰
         FrmMain.GateSocket.Active:=False;//젯쌈痰빵掘齡
         if m_btPermission < 2 then begin
           SysMsg(sOnlineUserFull,c_Red,t_Hint);
           SysMsg(sForceDisConnect,c_Red,t_Hint);
           m_boEmergencyClose:=True;
         end;
       end;
    end;
  end;

  m_btBright:=g_nGameTime;
  m_Abil.MaxExp:=GetLevelExp(m_Abil.Level); //jacky 2004/09/15 되쩌路劤혤돤薨똥悍渦駱令

  SendMsg(Self,RM_TOSENDMSG, 0, 93, 0, GetAllowGroupReCall, VerInfoStr2);   //접속기 버전
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  SendMsg(Self,RM_ADJUST_BONUS,0,0,0,0,'');
  SendMsg(Self,RM_DAYCHANGING,0,0,0,0,'');
  SendMsg(Self,RM_SENDUSEITEMS,0,0,0,0,'');
  SendMsg(Self,RM_SENDMYMAGIC,0,0,0,0,'');
  SendMsg(Self,RM_ATTATCKMODE,0,0,0,0,''); //공격모드 표시
  GetObjectEffect; //기퍼짐
  GetObjectEventEffect; //빼빼로

  ClientFriendChangeState(Self,True);

  m_MyGuild:=g_GuildManager.MemberOfGuild(m_sCharName);
  if m_MyGuild <> nil then begin
    m_sGuildRankName:=TGuild(m_MyGuild).GetRankName(Self,m_nGuildRankNo);
    for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do begin
      SysMsg('*** '+TGuild(m_MyGuild).GuildWarList.Strings[i] +  ' 攣瞳뵨콱돨契삔쏵契契삔濫轢。',c_Green,t_Hint);
    end;
    //문파원 접속 메시지
    TGuild(m_MyGuild).SendGuildMsg('(!)'+ #7 + m_sCharName + #7 +' 綠쏵흙踏狗。');
    UserEngine.SendServerGroupMsg(SS_208,nServerIndex,TGuild(m_MyGuild).sGuildName + '/' + '' + '/' + m_sCharName + ' 綠쏵흙踏狗。');
    if TGuild(m_MyGuild).m_Territory <> nil then
      SysMsg(TTerritory(TGuild(m_MyGuild).m_Territory).UserLogon(),c_Green,t_Hint);
    if TGuild(m_MyGuild).nGuildMark > 0 then
      SendRefMsg(RM_USERMARK, 0, GetObjectMark, m_btColumn, m_btJob, '');  //문파 마크

      RecalcGuildLevelAbilitys(0); //문파성장
  end;

  //if m_boOnHorse then m_boOnHorse := False;    //호랑이 버그

  SendMsg( Self, RM_LM_DBGETLIST, 0, 0, 0, 0, '');    //연인 스쳐

  SendMsg( Self, RM_ME_DBGETLIST, 0, 0, 0, 0, '1');    //사제 스쳐
  
  RefShowName();
  if (m_nPayMent = 1) then begin
    if not bo6AB then  SysMsg(sYouNowIsTryPlayMode,c_Red,t_Hint);

    m_nGoldMax:=g_Config.nHumanTryModeMaxGold;
    if m_Abil.Level > g_Config.nTryModeLevel then begin
      SysMsg('눈箇친駕옵鹿賈痰돕離멕섬깎槨' + IntToStr(g_Config.nTryModeLevel),c_Red,t_Hint);
      SysMsg('젯쌈綠老岺。',c_Red,t_Hint);
      m_boEmergencyClose:=True;
    end;
  end;//004CA4FA
  if (m_nPayMent = 3) and not bo6AB then
    SysMsg(g_sNowIsFreePlayMode,c_Green,t_Hint);

  if g_Config.boVentureServer then
    SysMsg('뻑短윱돕챨麴륩蛟포。',c_Green,t_Hint);
  if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting)then begin
    m_boUseThrusting:=True;
    SendSocket(nil,'+LNG');
  end;
  if m_PEnvir.Flag.boNORECONNECT then
    MapRandomMove(m_PEnvir.Flag.sNoReconnectMap,0);

  if CheckDenyLogon() then exit;

  if g_ManageNPC <> nil then begin
    g_ManageNPC.GotoLable(Self,'@Login',False);
  end;

  m_boFilterSendMsg:=GetDisableSendMsgList(m_sCharName);

  if g_Config.boPasswordLockSystem then begin  //창고암호
    if m_boPasswordLocked then begin
      m_boCanGetBackItem:=not g_Config.boLockGetBackItemAction;
    end;

    if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then begin
      m_boCanDeal    :=not g_Config.boLockDealAction;
      m_boCanDrop    :=not g_Config.boLockDropAction;
      m_boCanUseItem :=not g_Config.boLockUserItemAction;
      m_boCanWalk    :=not g_Config.boLockWalkAction;
      m_boCanRun     :=not g_Config.boLockRunAction;
      m_boCanHit     :=not g_Config.boLockHitAction;
      m_boCanSpell   :=not g_Config.boLockSpellAction;
      m_boCanSendMsg :=not g_Config.boLockSendMsgAction;
      m_boObMode     :=g_Config.boLockInObModeAction;
      m_boAdminMode  :=g_Config.boLockInObModeAction;

      SysMsg(g_sActionIsLockedMsg + ' Connected with limited ability''s use: @' + g_GameCommand.LOCKLOGON.sCmd ,c_Red,t_Hint);
      SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sActionIsLockedMsg + '\ \'
                      + 'Password required use: @' + g_GameCommand.PASSWORDLOCK.sCmd);
    end;
    if not m_boPasswordLocked then begin
      SysMsg(format(g_sPasswordNotSetMsg,[g_GameCommand.PASSWORDLOCK.sCmd]) ,c_Red,t_Hint);
    end;
    if not m_boLockLogon and m_boPasswordLocked then begin
      SysMsg(format(g_sNotPasswordProtectMode,[g_GameCommand.LOCKLOGON.sCmd]) ,c_Red,t_Hint);
    end;
  end;

  m_dwIncGamePointTick := GetTickCount();
  m_dwIncGameGoldTick  := GetTickCount();
  m_dwAutoGetExpTick   := GetTickCount();
  m_dwPCPointTick      := GetTickCount();
except
  on e: Exception do begin
    MainOutMessage(sExceptionMsg);
    MainOutMessage(E.Message);
  end;
end;
  //ReadAllBook();
end;

procedure TPlayObject.ReadAllBook();
var
  I: Integer;
  Magic:pTMagic;
  UserMagic:pTUserMagic;
begin
  for I := 0 to UserEngine.m_MagicList.Count - 1 do begin
    Magic:=UserEngine.m_MagicList.Items[I];
    New(UserMagic);
    UserMagic.MagicInfo := Magic;
    UserMagic.wMagIdx   := Magic.wMagicId;
    UserMagic.btLevel   := 2;
    UserMagic.btKey     := 0;
    UserMagic.btLevel   := 0;
    UserMagic.nTranPoint:=100000;
    m_MagicList.Add(UserMagic);
    SendAddMagic(UserMagic);
  end;
end;

procedure TPlayObject.SendGoldInfo(boSendName:Boolean);
var
  sMsg:String;
begin
  if m_nSoftVersionDateEx = 0 then exit;

  if boSendName then
    sMsg:=g_Config.sGameGoldName + #13 + g_Config.sGamePointName;

  SendDefMessage(SM_GAMEGOLDNAME,
                 m_nGameGold,
                 LoWord(m_nGamePoint),
                 HiWord(m_nGamePoint),
                 BoolToInt(m_sHeroCharName <> ''),
                 sMsg);

end;


// 상대방이 자신을 관계해제 시켰을 경우
function TPlayObject.RelationShipDeleteOther(ReqType: integer;         //연인 스쳐사망
  OtherName: string): boolean;
begin
  Result := False;
  if fLover.Find(OtherName) then begin
    fLover.Delete(OtherName);
    SendDefMessage(SM_LM_DELETE, 0, ReqType, 0, 0, OtherName);
    SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_SuccessDelete, 0, OtherName);
    // DB에서 삭제한다.
    SendMsg(Self, RM_LM_DBDELETE, 0, 0, 0, 0, OtherName);
    Result := True;
  end;

end;

// 상대방이 자신을 관계해제 시켰을 경우
procedure TPlayObject.MentorShipDeleteOther(ReqType: integer;         //사제 스쳐 정상 해제
  OtherName: string; day :integer);
begin
  if fMentor.Find(OtherName) then begin
    fMentor.Delete(OtherName);
    SendDefMessage(SM_LM_DELETE, 0, ReqType, 0, 0, OtherName);
    SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_SuccessDelete, 0, '');
    // DB에서 날짜 변경 시킨다.
    ServerSetMentorDBChange(OtherName ,m_sCharName , RsState_MasterEnd , day);       //사제 스쳐 정상 해제
    if fMentor.GetMode = 0 then //제자이면
      RecalcPupilAbilitys(1);
  end;
end;


// 상대방이 자신을 관계해제 시켰을 경우
procedure TPlayObject.MentorShipDeleteOther2(ReqType: integer;         //사제 스쳐 레벨 높아 해제
  OtherName: string);
begin
  if fMentor.Find(OtherName) then begin
    fMentor.Delete(OtherName);
    SendDefMessage(SM_LM_DELETE, 0, ReqType, 0, 0, OtherName);
    SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_SuccessDelete2, g_Config.nMasterLevel, '');
    // DB에서 날짜 변경 시킨다.
    ServerSetMentorDBChange(OtherName ,m_sCharName , RsState_MasterEnd , 1);     //사제 스쳐 레벨 높아 해제
    if fMentor.GetMode = 0 then//제자이면
      RecalcPupilAbilitys(1);
  end;
end;


////////////////////////
// SEED 아이템 체크.
function TPlayObject.CheckSeedItem (puSeed: PTUserItem ;psSeed, psJewelry: TItem) : Integer;            //스쳐
begin

   /////////////////////////////////////////////////////////////////////////////
   //바느질용품 또는 뼈망치.
   if psJewelry.StdMode = 59 then begin
      if psJewelry.Shape = 20 then begin
         //옷, 투구, 신발, 허리띠
         if psSeed.StdMode in [10,11,12,15,62,64] then Result := 11
         else Result := 10;
         exit;
      end else if psJewelry.Shape = 21 then begin
         //목걸이, 반지, 팔찌
         if psSeed.StdMode in [19,20,21,22,23,24,26] then Result := 11
         else Result := 10;
         exit;
      end else if psJewelry.Shape = 22 then begin
         //목걸이, 반지, 팔찌
         if psSeed.StdMode in [10,11,12,15,62,64] then Result := 12
         else Result := 10;
         exit;
      end else if psJewelry.Shape = 23 then begin
         //목걸이, 반지, 팔찌
         if psSeed.StdMode in [19,20,21,22,23,24,26] then Result := 12
         else Result := 10;
         exit;
      end;
   end;

   /////////////////////////////////////////////////////////////////////////////


   // 무기,옷,투구,목걸이,반지,팔찌, 신발,벨트.
   if psSeed.StdMode in [5,6,90,99,12,10,11,15,19,20,21,22,23,24,26,62,64] then Result := 2
   else Result := 0;

   // 유니크 아이템 체크
   if (psSeed.Unique) then begin
      Result := 3;
      exit;
   end;

   // 무기,옷,투구,목걸이,반지,팔찌, 신발,벨트.
   if (puSeed.btValue[19] = 1) then begin     //대여 보옥 금지
     Result := 4;
     exit;
   end;

   if (puSeed.btValue[19] > 2) then begin     //봉인 보옥 금지
     Result := 5;
     exit;
   end;


   case psSeed.StdMode of
      5, 6, 99, 90: // 무기         방어 마항 정확 민첩 중저항 마저항 안됨
         begin
            if (psJewelry.AC > 0) or (psJewelry.MAC > 0) or (psJewelry.Accurate > 0) or
               (psJewelry.Agility > 0) or (psJewelry.MagAvoid > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      10, 11, 12: // 옷          //파괴 마법 도력 정확 공속 중독 둔화 안됨
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.Accurate > 0) or (psJewelry.AtkSpd > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) then begin
                  Result := 1;
            end;
         end;
      15: // 투구      파괴 마법 도력 민첩 공속 둔화 중독 안됨
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.Agility > 0) or (psJewelry.AtkSpd > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) then begin
                  Result := 1;
            end;
         end;
      19,20,21: // 목걸이         //방어,마항 민첩 중독저항 안됨
         begin
            if (psJewelry.AC > 0) or (psJewelry.MAC > 0) or (psJewelry.Agility > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      22,23: // 반지      //정확 민첩 중독저항 마법저항 안됨
         begin
            if (psJewelry.Accurate > 0) or (psJewelry.Agility > 0) or
               (psJewelry.MagAvoid > 0) or (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      24,26: // 팔찌26       //공속 마저항 중독저항 둔화 중독 안됨
         begin
            if (psJewelry.AtkSpd > 0) or (psJewelry.MagAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      62: // 신발         파괴 마법 도력 정확 공속 중저항 둔화 중독 중저항 안됨
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.Accurate > 0) or (psJewelry.AtkSpd > 0) or (psJewelry.MagAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) or
               (psJewelry.ToxAvoid > 0) then begin
                  Result := 1;
            end;
         end;
      64: // 벨트        //파괴 도력 마법 공속 마법저항 둔화 중독 안됨
         begin
            if (psJewelry.DC > 0) or (psJewelry.MC > 0) or (psJewelry.SC > 0) or
               (psJewelry.AtkSpd > 0) or (psJewelry.MagAvoid > 0) or
               (psJewelry.Slowdown > 0) or (psJewelry.Tox > 0) then begin
                  Result := 1;
            end;
         end;
      else
         begin
            Result := 0;
         end;
   end;

end;

// 보옥류 아이템 체크.
function TPlayObject.CheckJewelryItem (iStdMode: integer) : Boolean;         //스쳐
begin
   // 보옥,신주,노끈.
   if iStdMode in [59,60,61] then Result := TRUE
   else Result := FALSE;
end;

/////////////////////////
// 기존 속성값의 합.
function TPlayObject.SumOfOptions(puSeedItem: PTUserItem; psSeedItem: TItem) : integer;            //스쳐
begin
   Result := 0;
   case psSeedItem.StdMode of
      5, 6, 99, 90:  // 무기           파괴 마법 도력 공속 중독 둔화  (정확 도 포함)
         begin
            Result := puSeedItem.btValue[0] + puSeedItem.btValue[1] + puSeedItem.btValue[2]
                      + puSeedItem.btValue[5] + puSeedItem.btValue[9] + puSeedItem.btValue[8];
            // 공속 합산(무기).
            Result := Result + _MAX( 0, ItemUnit.RealAttackSpeed( puSeedItem.btValue[6] ) );
         end;
      10, 11, 12: // 옷     방어 마항 중독저항 마법저항 민첩
         begin
            Result := puSeedItem.btValue[3] + puSeedItem.btValue[4]
                     + puSeedItem.btValue[6] + puSeedItem.btValue[7] + puSeedItem.btValue[8];       //옷 민첩
         end;
      15:  //투구
         begin
            Result := puSeedItem.btValue[3] + puSeedItem.btValue[4]
                     + puSeedItem.btValue[8] + puSeedItem.btValue[9] + puSeedItem.btValue[10];      //투구 정확
         end;

      19,20,21: // 목걸이19     //목걸이19
         begin
            Result := puSeedItem.btValue[0] + puSeedItem.btValue[1]
                     + puSeedItem.btValue[2] + puSeedItem.btValue[9]
                     + puSeedItem.btValue[12] + puSeedItem.btValue[14] + puSeedItem.btValue[15];
            // 공속 합산.
            if puSeedItem.btValue[17] > 0 then
               Result := Result + puSeedItem.btValue[17];
         end;
      22,23: // 반지     //반지22  //반지23
         begin
            Result := puSeedItem.btValue[0] + puSeedItem.btValue[1] + puSeedItem.btValue[2]
                     + puSeedItem.btValue[3] + puSeedItem.btValue[4]
                     + puSeedItem.btValue[9] + puSeedItem.btValue[14];
            // 공속 합산.
            if puSeedItem.btValue[16] > 0 then
               Result := Result + puSeedItem.btValue[16];
         end;
      24,26: // 팔찌        //팔찌26
         begin
            Result := puSeedItem.btValue[0] + puSeedItem.btValue[1] + puSeedItem.btValue[2]
                     + puSeedItem.btValue[3] + puSeedItem.btValue[4]
                     + puSeedItem.btValue[15] + puSeedItem.btValue[16];
         end;
      62: // 신발        //신발
         begin
            Result := puSeedItem.btValue[3] + puSeedItem.btValue[4] + puSeedItem.btValue[16];
         end;
      64: // 벨트
         begin
            Result := puSeedItem.btValue[3] + puSeedItem.btValue[4] + puSeedItem.btValue[15]
                     + puSeedItem.btValue[16] + puSeedItem.btValue[8];          //벨트 중저항
         end;
   end;

   // 내구력 합산.   //단계가 1000 -> 2000 으로 증가 2003-11-7 PDS
   Result := Result + _MAX( 0, Round( (puSeedItem.DuraMax - psSeedItem.DuraMax) / 2000 ) );
end;

///////////////////////////////////
// 확률 계산 및 결과 리턴 함수.
function TPlayObject.CalcUpgradeProbability(puSeedItem, puJewelryItem: PTUserItem; psSeedItem, psJewelryItem: TItem; iExecCount: Integer; var iRetSum: integer; var fRetProb: Double) : integer;      //스쳐
var
   iSucceed, iFail: Integer;
   iSum, iRandom: Integer;
   UpProb: array [0..10] of TUpgradeProb;
   i, testSucceed, testNoChange, testFail: Integer;

   /////////////////////////////////////////////
   // 확률값 초기화.(이렇게 해도 되나? sonmg)
   procedure InitProbability;
   var
      MFactor, DFactor: integer;
   begin
      MFactor := 4;  //보옥의 1.5배로 수정(임시), 원래값 4
      DFactor := 2;
      with UpProb[0] do begin
         iBase := 10000;
         iValue[0] := 5000;   //보옥
         iValue[1] := 5000;   //보옥
         iValue[2] := 5000;   //보옥
         //임시 1.5배로 수정
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);   //신주
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);   //신주
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);   //신주
      end;
      with UpProb[1] do begin
         iBase := 10000;
         iValue[0] := 4500;
         iValue[1] := 3000;
         iValue[2] := 4000;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[2] do begin
         iBase := 10000;
         iValue[0] := 4000;
         iValue[1] := 1000;
         iValue[2] := 3000;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[3] do begin
         iBase := 10000;
         iValue[0] := 3500;
         iValue[1] := 500;
         iValue[2] := 1000;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[4] do begin
         iBase := 10000;
         iValue[0] := 3000;
         iValue[1] := 100;
         iValue[2] := 500;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[5] do begin
         iBase := 10000;
         iValue[0] := 1500;
         iValue[1] := 25;
         iValue[2] := 100;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[6] do begin
         iBase := 10000;
         iValue[0] := 400;
         iValue[1] := 5;
         iValue[2] := 25;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[7] do begin
         iBase := 10000;
         iValue[0] := 100;
         iValue[1] := 5;
         iValue[2] := 5;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[8] do begin
         iBase := 10000;
         iValue[0] := 25;
         iValue[1] := 5;
         iValue[2] := 5;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[9] do begin
         iBase := 10000;
         iValue[0] := 5;
         iValue[1] := 5;
         iValue[2] := 5;
         iValue[3] := Integer(iValue[0] * MFactor div DFactor);
         iValue[4] := Integer(iValue[1] * MFactor div DFactor);
         iValue[5] := Integer(iValue[2] * MFactor div DFactor);
      end;
      with UpProb[10] do begin
         iBase := 10000;
         iValue[0] := 0;
         iValue[1] := 0;
         iValue[2] := 0;
         iValue[3] := 0;
         iValue[4] := 0;
         iValue[5] := 0;
      end;
   end;
begin
   Result := 2;
   // 옵션합 10 이상은 무시. 옵션합 0이하는 0로 만든다.
   iSum := _MIN( 10, _MAX(0, SumOfOptions(puSeedItem, psSeedItem)) );
   iRetSum := iSum;

   // 확률값 초기화.
   InitProbability;

   testSucceed := 0;
   testNoChange := 0;
   testFail := 0;
   iSucceed := 0;
   iFail := 0;
   iRandom := 0;

   if iExecCount < 1 then iExecCount := 1;

   //확률 테스트
   for i := 0 to iExecCount - 1 do begin

      iRandom := Random( UpProb[iSum].iBase );

      if psJewelryItem.StdMode = 60 then begin
         if psSeedItem.StdMode in [5,6,99,90] then begin //무기
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[0] * ABS( (29 + m_nBodyLuckLevel + (LOBYTE(psSeedItem.AC) + puSeedItem.btValue[3] - LOBYTE(psSeedItem.MAC) - puSeedItem.btValue[4]) / 2 ) / 30 ) ) );
         end else if psSeedItem.StdMode in [10,11,12] then begin //옷
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[0] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode in [24,26,62] then begin  //팔찌,신발
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[1] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode = 19 then begin  //목걸이19
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[2] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end else begin //기타
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[2] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end;

         // 공속 확률 따로 적용.(sonmg 2003/12/22)
         if psJewelryItem.Shape = 7 then
         begin
            iSucceed := (iSucceed * 60) div 100;
         end;

         iFail := Round( (UpProb[iSum].iBase - iSucceed) {* 0.65}* 0.7 );  //임시 0.65로 수정, 원래값 0.7

         if (iRandom >= 0) and (iRandom < iSucceed) then
            Result := 2    //성공
         else if (iRandom >= iSucceed) and (iRandom < iSucceed + iFail) then
            Result := 1   //불변
         else
            Result := 0;   //파손
      end else if psJewelryItem.StdMode = 61 then begin
         if psSeedItem.StdMode in [5,6,99,90] then begin //무기
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[3] * ABS( (29 + m_nBodyLuckLevel + (LOBYTE(psSeedItem.AC) + puSeedItem.btValue[3] - LOBYTE(psSeedItem.MAC) - puSeedItem.btValue[4]) / 2 ) / 30 ) ) );
         end else if psSeedItem.StdMode in [10,11,12] then begin //옷
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[3] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode in [24,26,62] then begin  //팔찌,신발
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[4] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end else if psSeedItem.StdMode = 19 then begin  //목걸이19
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[5] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end else begin //기타
            iSucceed := _MIN( UpProb[iSum].iBase, Round( UpProb[iSum].iValue[5] * ABS( (29 + m_nBodyLuckLevel) / 30 ) ) );
         end;

         // 공속 확률 따로 적용.(sonmg 2003/12/22)
         if psJewelryItem.Shape = 7 then
         begin
            iSucceed := (iSucceed * 60) div 100;
         end;

         // 신주 깨지지 않음.
//         iFail := Integer( Round( 0.7 * (UpProb[iSum].iBase - iSucceed) ) );

         if (iRandom >= 0) and (iRandom < iSucceed) then
            Result := 2    //성공
         else
            Result := 1;   //불변
      end;

      fRetProb := iSucceed / UpProb[iSum].iBase;

      if Result = 2 then Inc(testSucceed)
      else if Result = 1 then Inc(testNoChange)
      else if Result = 0 then Inc(testFail);

   end;
 {
   
   if psJewelryItem.StdMode = 60 then begin
      MainOutMessage( '[UpgradeItem:확률] ' + '=> '
         + '옵션합:' + IntToStr(iSum) + ', 성공확률:' + IntToStr(iSucceed)
         + ', 불변확률:' + IntToStr(iFail) + ', 파손확률:' + IntToStr(UpProb[iSum].iBase-iSucceed-iFail)
         + ', iRandom:' + IntToStr(iRandom)
         + ', Body행운:' + IntToStr(m_nBodyLuckLevel) + ', 무기행운:' + IntToStr(LOBYTE(psSeedItem.AC) + puSeedItem.btValue[3])
         + ', 무기불운:' + IntToStr(LOBYTE(psSeedItem.MAC) + puSeedItem.btValue[4]) );
   end else if psJewelryItem.StdMode = 61 then begin
      MainOutMessage( '[UpgradeItem:확률] ' + '=> '
         + '옵션합:' + IntToStr(iSum) + ', 성공확률:' + IntToStr(iSucceed)
         + ', 불변확률:' + IntToStr(UpProb[iSum].iBase-iSucceed)
         + ', iRandom:' + IntToStr(iRandom)
         + ', Body행운:' + IntToStr(m_nBodyLuckLevel) + ', 무기행운:' + IntToStr(LOBYTE(psSeedItem.AC) + puSeedItem.btValue[3])
         + ', 무기불운:' + IntToStr(LOBYTE(psSeedItem.MAC) + puSeedItem.btValue[4]) );
   end;
          }

end;

///////////////////////////////////////////////////////////////
//added by sonmg...
procedure TPlayObject.CmdUpgradeItem (seedname, jewelryname: string; seedindex, jewelryindex, ExecCount : integer);     //스쳐
var
   iResult: integer;
   i, j, k, iVal: integer;
   puSeed, puJewelry: PTUserItem;
   psSeed, psJewelry: TItem;
   strResult, strEtc: string;
   iSumOfOption: integer;
   fProbability: Double;
   iBeforeValue, iAfterValue: integer;
   iShape: integer;
   dellist: TStringList;
begin
   puSeed := nil;
   puJewelry := nil;
   psSeed := nil;
   psJewelry := nil;
   iSumOfOption := 0;
   fProbability := 0;
   iBeforeValue := 0;
   iAfterValue := 0;

   try
      if seedname = '' then
         exit;
      if jewelryname = '' then
         exit;

      ///////////////////////////////////////////////////
      // 보옥류 검사
         for i := 0 to m_ItemList.Count-1 do begin
            if jewelryindex = PTUserItem(m_ItemList[i]).MakeIndex then begin
               psJewelry := UserEngine.GetStdItem (PTUserItem(m_ItemList[i]).wIndex);
               puJewelry := PTUserItem(m_ItemList[i]);
               break;
            end;
         end;
         if i = m_ItemList.Count then exit;
      ///////////////////////////////////////////////////
         for i := 0 to m_ItemList.Count-1 do begin
            if seedindex = PTUserItem(m_ItemList[i]).MakeIndex then begin
               psSeed := UserEngine.GetStdItem (PTUserItem(m_ItemList[i]).wIndex);
               puSeed := PTUserItem(m_ItemList[i]);
               break;
            end;
         end;
         if i = m_ItemList.Count then exit;


      if puSeed.wIndex > 0 then begin
         if CheckJewelryItem(psJewelry.StdMode) then begin
            iVal := CheckSeedItem(puSeed, psSeed, psJewelry);

            if iVal = 2 then begin
               iResult := CalcUpgradeProbability(puSeed, puJewelry, psSeed, psJewelry, ExecCount, iSumOfOption, fProbability);

               // 업그레이드 이전 값을 얻어온다.
               iBeforeValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

               case iResult of
                  2: begin //성공
                     // 아이템 업그레이드 실행.
                     if DoUpgradeItem (puSeed, psSeed, psJewelry) = 0 then begin
                        SysMsg('늪橄昑轟랬薨땀', c_Green,t_Hint);
                        exit;
                     end;

                     // 업그레이드 이후 값을 얻어온다.
                     iAfterValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

                     // Jewelry 아이템 삭제.
                     QuestTakeCheckItem (puJewelry);

                     SysMsg (seedname + '랙놔寧돛鈺縕돨좋밟，' + strResult + strEtc + '듐。', c_Blue,t_Hint);

                     AddGameDataLog('36' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     seedname + #9 +
                     IntToStr(seedindex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[괜圖/괜瀧 꼇긴]' +
                      UpgradeResultToStr(iSumOfOption, strResult, iBeforeValue, iAfterValue, fProbability, psJewelry.StdMode));


                     //클라이언트로 결과 메시지 전송.
                     SendDefMessage (SM_UPGRADEITEM_RESULT, seedindex, iResult, 0, 0, seedname);    //보옥

                  end;
                  1: begin // 불변
                     // 업그레이드 이후 값을 얻어온다.
                     iAfterValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

                     // Jewelry 아이템 삭제.
                     QuestTakeCheckItem (puJewelry);

                     // 임시 확인 메시지.
                     SysMsg (seedname + '청唐랙虛觀慣餓', c_Green,t_Hint);

                      AddGameDataLog('37' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     seedname + #9 +
                     IntToStr(seedindex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[괜圖/괜瀧 맣긴]' +
                      UpgradeResultToStr(iSumOfOption, strResult, iBeforeValue, iAfterValue, fProbability, psJewelry.StdMode));

                     //클라이언트로 결과 메시지 전송.
                     SendDefMessage (SM_UPGRADEITEM_RESULT, seedindex, iResult, 0, 0, seedname);    //보옥

                  end;
                  0: begin // 실패(파괴)
                     // 업그레이드 이후 값을 얻어온다.
                     iAfterValue := GetTotalValueOfOption(puSeed, psSeed, psJewelry, strResult, strEtc);

                     // Jewelry 아이템 삭제.
                     QuestTakeCheckItem (puJewelry);
                     // Seed 아이템 삭제.
                     QuestTakeCheckItem2 ( puSeed, Word(true) ); // 파괴 효과를 위한 패킷

                     SysMsg ('膠틔('+ seedname +')팎鉅죄。', c_Red,t_Hint);

                      AddGameDataLog('38' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     seedname + #9 +
                     IntToStr(seedindex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[괜圖/괜瀧 팎鉅]' +
                      UpgradeResultToStr(iSumOfOption, strResult, iBeforeValue, iAfterValue, fProbability, psJewelry.StdMode));

                     //클라이언트로 결과 메시지 전송.
                     SendDefMessage (SM_UPGRADEITEM_RESULT, seedindex, iResult, 0, 0, seedname);   //보옥

                  end;
                  else begin
                     // 서버에 메시지를 남김.
                   //  MainOutMessage ('[UpgradeItem] ' + UserName + ' DoUpgradeItem의 결과값 이상' );
                  end;
               end;  // end of case.
            end else if iVal = 1 then begin
               SysMsg('侶숭膠틔轟랬薨땀', c_Red,t_Hint)
            end else if iVal = 3 then begin
               SysMsg('景喝膠틔轟랬薨땀', c_Red,t_Hint)
            end else if iVal = 4 then begin
               SysMsg('理줏돨膠틔轟랬薨땀', c_Red,t_Hint)
            end else if iVal = 5 then begin
               SysMsg('룐丹돨데틔꼇콘薨땀', c_Red,t_Hint)
            // 바느질용품, 뼈망치.
            end else if iVal = 11 then begin
               if RepairItemNormaly( psSeed, puSeed ) then begin
                  // 수리용품 아이템 삭제.
                  QuestTakeCheckItem (puJewelry);
                  SendDefMessage (SM_UPGRADEITEM_RESULT, seedindex, iResult, 0, 0, seedname);   //보옥
               end;
            end else if iVal = 12 then begin
               if RepairItemSuper( psSeed, puSeed ) then begin
                  // 수리용품 아이템 삭제.
                  QuestTakeCheckItem (puJewelry);
                  SendDefMessage (SM_UPGRADEITEM_RESULT, seedindex, iResult, 0, 0, seedname);   //보옥
               end;
            end else if iVal = 10 then begin
               SysMsg('늪膠틔轟랬錦잿。', c_Red,t_Hint)
            end else
               SysMsg (seedname + ' : 轟랬賈痰。', c_Red,t_Hint);
         end;
      end;

   except
      MainOutMessage ('[Exception] TUserHuman.CmdUpgradeItem');
   end;
end;

// 인덱스로 기본값+업그레이드된값을 리턴하는 함수
function TPlayObject.GetTotalValueOfOption( pu: PTUserItem; pstd, psJewelry: TItem; var strResult, strEtc: string ): integer;      //스쳐
var
   iBaseValue, iUpgradeValue: integer;
   iOptionIndex: integer;
begin
   Result := 0;
   iBaseValue := 0;
   iUpgradeValue := 0;
   iOptionIndex := 0;

   ////////////////////////////////////////////////
   // 업그레이드 옵션 확인
   // 결과 문자열 리턴.
   // 업그레이드 할 수 있는 옵션은 한번에 하나(맨 처음 나오는 옵션을 선택한다.)
   if psJewelry.DC > 0 then begin
      iOptionIndex := 100;
      strResult := '묑샌';
      strEtc := '藤속죄' + IntToStr(psJewelry.DC);
   end else if psJewelry.MC > 0 then begin
      iOptionIndex := 101;
      strResult := '침랬';
      strEtc := '藤속죄' + IntToStr(psJewelry.MC);
   end else if psJewelry.SC > 0 then begin
      iOptionIndex := 102;
      strResult := '돛減';
      strEtc := '藤속죄' + IntToStr(psJewelry.SC);
   end else if psJewelry.AC > 0 then begin
      iOptionIndex := 103;
      strResult := '렝徒';
      strEtc := '藤속죄' + IntToStr(psJewelry.AC);
   end else if psJewelry.MAC > 0 then begin
      iOptionIndex := 104;
      strResult := '침랬렝徒';
      strEtc := '藤속죄' + IntToStr(psJewelry.MAC);
   end else if psJewelry.DuraMax > 0 then begin
      iOptionIndex := 105;
      strResult := '넣씹';
      strEtc := '藤속죄' + IntToStr( Round( psJewelry.DuraMax / 1000 ) );
   end else if psJewelry.Accurate > 0 then begin
      iOptionIndex := 106;
      strResult := '硫횅';
      strEtc := '藤속죄' + IntToStr(psJewelry.Accurate);
   end else if psJewelry.Agility > 0 then begin
      iOptionIndex := 107;
      strResult := '츌쌥';
      strEtc := '藤속죄' + IntToStr(psJewelry.Agility);
   end else if psJewelry.AtkSpd > 0 then begin
      iOptionIndex := 108;
      strResult := '묑샌醵똑속';
      strEtc := '藤속죄' + IntToStr(psJewelry.AtkSpd);
   end else if psJewelry.Slowdown > 0 then begin
      iOptionIndex := 109;
      strResult := '숑醵';
      strEtc := '藤속죄' + IntToStr(psJewelry.Slowdown);
   end else if psJewelry.Tox > 0 then begin
      iOptionIndex := 110;
      strResult := '櫓뗀';
      strEtc := '藤속죄' + IntToStr(psJewelry.Tox);
   end else if psJewelry.MagAvoid > 0 then begin
      iOptionIndex := 111;
      strResult := '침랬뜰긁';
      strEtc := '藤속죄' + IntToStr(psJewelry.MagAvoid);
   end else if psJewelry.ToxAvoid > 0 then begin
      iOptionIndex := 112;
      strResult := '뗀膠뜰긁';
      strEtc := '藤속죄' + IntToStr(psJewelry.ToxAvoid);
   end;
   ////////////////////////////////////////////////

   // iIndex값의 의미
   // 100:파괴, 101:마법, 102:도력, 103:방어, 104:마항, 105:내구
   // 106:정확, 107:민첩, 108:공속, 109:둔화, 110:중독, 111:마저항, 112:중저항
   case pstd.StdMode of
      ///////////////////////////////////////////////////////
      5, 6, 99, 90:  // 무기
         begin
            case iOptionIndex of
               100://파괴
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.btValue[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://마법
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.btValue[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://도력
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.btValue[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://방어
                  begin
                  end;
               104://마항
                  begin
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확                    //무기 정확
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.btValue[5];          //무기 정확
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://민첩
                  begin
                  end;
               108://공속
                  begin
                     iBaseValue := ItemUnit.RealAttackSpeed( pstd.AtkSpd );
                     iUpgradeValue := ItemUnit.RealAttackSpeed( pu.btValue[6] );   //무기 공속
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://둔화
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.btValue[8];   //무기 둔화
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://중독
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.btValue[9];  //무기 중독
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://마저항
                  begin
                  end;
               112://중저항
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      10, 11, 12 : // 옷,
         begin
            case iOptionIndex of
               100://파괴
                  begin

                  end;
               101://마법
                  begin

                  end;
               102://도력
                  begin

                  end;
               103://방어
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.btValue[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://마항
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.btValue[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin
                  end;
               107://민첩
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.btValue[6];        //옷 민첩
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://공속
                  begin
                  end;
               109://둔화
                  begin
                  end;
               110://중독
                  begin
                  end;
               111://마저항
                  begin
                     iBaseValue := pstd.MagAvoid;
                     iUpgradeValue := pu.btValue[8];           //옷 마법저항
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://중저항
                  begin
                     iBaseValue := pstd.ToxAvoid;
                     iUpgradeValue := pu.btValue[7];             //옷 중독저항
                     Result := iBaseValue + iUpgradeValue;
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////

      15: // 투구
         begin
            case iOptionIndex of
               100://파괴
                  begin

                  end;
               101://마법
                  begin

                  end;
               102://도력
                  begin

                  end;
               103://방어
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.btValue[3];               //투구 방어
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://마항
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.btValue[4];              //투구 마방
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin // 투구에만 해당
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.btValue[8];         //투구 정확
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://민첩
                  begin // 옷에만 해당

                  end;
               108://공속
                  begin
                  end;
               109://둔화
                  begin
                  end;
               110://중독
                  begin
                  end;
               111://마저항
                  begin
                     iBaseValue := pstd.MagAvoid;
                     iUpgradeValue := pu.btValue[10];             //투구 마법저항
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://중저항
                  begin
                     iBaseValue := pstd.ToxAvoid;
                     iUpgradeValue := pu.btValue[9];           //투구 중독저항
                     Result := iBaseValue + iUpgradeValue;
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      19,20,21: // 목걸이19             //목걸이19
         begin
            case iOptionIndex of
               100://파괴
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.btValue[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://마법
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.btValue[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://도력
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.btValue[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://방어
                  begin
                  end;
               104://마항
                  begin
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.btValue[15];           //목걸이 정확
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://민첩
                  begin
                  end;
               108://공속
                  begin
                     iBaseValue := pstd.AtkSpd;
                     iUpgradeValue := pu.btValue[17];           //목걸이 공속
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://둔화
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.btValue[14];            //목걸이 둔화
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://중독
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.btValue[9];          //목걸이 중독
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://마저항
                  begin
                     iBaseValue := pstd.MagAvoid;
                     iUpgradeValue := pu.btValue[12];         //목걸이 마저항
                     Result := iBaseValue + iUpgradeValue;
                  end;
               112://중저항
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      22,23: // 반지  //반지22    //반지23
         begin
            case iOptionIndex of
               100://파괴
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.btValue[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://마법
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.btValue[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://도력
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.btValue[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://방어
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.btValue[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://마항
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.btValue[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin
                  end;
               107://민첩
                  begin
                  end;
               108://공속
                  begin
                     iBaseValue := pstd.AtkSpd;
                     iUpgradeValue := pu.btValue[16];               //반지 공속
                     Result := iBaseValue + iUpgradeValue;
                  end;
               109://둔화
                  begin
                     iBaseValue := pstd.Slowdown;
                     iUpgradeValue := pu.btValue[14];              //반지 둔화
                     Result := iBaseValue + iUpgradeValue;
                  end;
               110://중독
                  begin
                     iBaseValue := pstd.Tox;
                     iUpgradeValue := pu.btValue[9];                //반지 중독
                     Result := iBaseValue + iUpgradeValue;
                  end;
               111://마저항
                  begin
                  end;
               112://중저항
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      24,26: // 팔찌         //팔찌26
         begin
            case iOptionIndex of
               100://파괴
                  begin
                     iBaseValue := HIBYTE(pstd.DC);
                     iUpgradeValue := pu.btValue[0];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               101://마법
                  begin
                     iBaseValue := HIBYTE(pstd.MC);
                     iUpgradeValue := pu.btValue[1];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               102://도력
                  begin
                     iBaseValue := HIBYTE(pstd.SC);
                     iUpgradeValue := pu.btValue[2];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               103://방어
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.btValue[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://마항
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.btValue[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.btValue[15];                 //팔찌 정확
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://민첩
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.btValue[16];                 //팔찌 민첩
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://공속
                  begin
                  end;
               109://둔화
                  begin
                  end;
               110://중독
                  begin
                  end;
               111://마저항
                  begin
                  end;
               112://중저항
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      62: // 신발        //신발
         begin
            case iOptionIndex of
               100://파괴
                  begin
                  end;
               101://마법
                  begin
                  end;
               102://도력
                  begin
                  end;
               103://방어
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.btValue[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://마항
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.btValue[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin
                  end;
               107://민첩
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.btValue[16];                 //신발 민첩
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://공속
                  begin
                  end;
               109://둔화
                  begin
                  end;
               110://중독
                  begin
                  end;
               111://마저항
                  begin
                  end;
               112://중저항
                  begin
                  end;
            end;//case iOptionIndex of
         end;
      ///////////////////////////////////////////////////////
      64: // 벨트
         begin
            case iOptionIndex of
               100://파괴
                  begin
                  end;
               101://마법
                  begin
                  end;
               102://도력
                  begin
                  end;
               103://방어
                  begin
                     iBaseValue := HIBYTE(pstd.AC);
                     iUpgradeValue := pu.btValue[3];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               104://마항
                  begin
                     iBaseValue := HIBYTE(pstd.MAC);
                     iUpgradeValue := pu.btValue[4];
                     Result := iBaseValue + iUpgradeValue;
                  end;
               105://내구
                  begin
                     iBaseValue := Round( pstd.DuraMax / 1000 );
                     iUpgradeValue := Round( pu.DuraMax / 1000 );
                     Result := iUpgradeValue;   // 내구
                  end;
               106://정확
                  begin
                     iBaseValue := pstd.Accurate;
                     iUpgradeValue := pu.btValue[15];                        //벨트 정확
                     Result := iBaseValue + iUpgradeValue;
                  end;
               107://민첩
                  begin
                     iBaseValue := pstd.Agility;
                     iUpgradeValue := pu.btValue[16];                       //벨트 민첩
                     Result := iBaseValue + iUpgradeValue;
                  end;
               108://공속
                  begin
                  end;
               109://둔화
                  begin
                  end;
               110://중독
                  begin
                  end;
               111://마저항
                  begin
                  end;
               112://중저항
                  begin
                     iBaseValue := pstd.ToxAvoid;
                     iUpgradeValue := pu.btValue[8];        //벨트 중저항
                     Result := iBaseValue + iUpgradeValue;
                  end;
            end;//case iOptionIndex of
         end;
   end;

end;

// added by sonmg.
function TPlayObject.DoUpgradeItem( puSeed: PTUserItem; psSeed, psJewelry: TItem ): integer;  //스쳐
begin
   Result := 1;

   // 업그레이드 값 반영.
   case psSeed.StdMode of
      5, 6, 99, 90: // 무기
         begin
            puSeed.btValue[0] := puSeed.btValue[0] + psJewelry.DC;
            puSeed.btValue[1] := puSeed.btValue[1] + psJewelry.MC;
            puSeed.btValue[2] := puSeed.btValue[2] + psJewelry.SC;

            if psJewelry.AtkSpd > 0 then begin
               // 공속 업그레이드
               puSeed.btValue[6] := ItemUnit.UpgradeAttackSpeed( puSeed.btValue[6], psJewelry.AtkSpd );
               // 공속 한계를 넘을 경우 한계값을 대입함.
               puSeed.btValue[6] := _MIN(15 + 10, puSeed.btValue[6]);
            end;
            puSeed.btValue[8] := puSeed.btValue[8] + psJewelry.Slowdown;   //무기 둔화
            puSeed.btValue[9] := puSeed.btValue[9] + psJewelry.Tox;        //무기 중독
         end;
      10, 11, 12: // 옷
         begin
            puSeed.btValue[3] := puSeed.btValue[3] + psJewelry.AC;
            puSeed.btValue[4] := puSeed.btValue[4] + psJewelry.MAC;
            puSeed.btValue[6] := puSeed.btValue[6] + psJewelry.Agility;
            puSeed.btValue[8] := puSeed.btValue[8] + psJewelry.MagAvoid;
            puSeed.btValue[7] := puSeed.btValue[7] + psJewelry.ToxAvoid;
         end;
      15: // 투구
         begin
            puSeed.btValue[3] := puSeed.btValue[3] + psJewelry.AC;
            puSeed.btValue[4] := puSeed.btValue[4] + psJewelry.MAC;
            puSeed.btValue[8] := puSeed.btValue[8] + psJewelry.Accurate;     //투구 정확
            puSeed.btValue[9] := puSeed.btValue[9] + psJewelry.ToxAvoid;     //투구 중독저항
            puSeed.btValue[10] := puSeed.btValue[10] + psJewelry.MagAvoid;   //투구 마법저항
         end;
      19,20,21: // 목걸이19           //목걸이19
         begin
            puSeed.btValue[0] := puSeed.btValue[0] + psJewelry.DC;
            puSeed.btValue[1] := puSeed.btValue[1] + psJewelry.MC;
            puSeed.btValue[2] := puSeed.btValue[2] + psJewelry.SC;

            // 정확
            puSeed.btValue[15] := puSeed.btValue[15] + psJewelry.Accurate;
            //마법저항
            puSeed.btValue[12] := puSeed.btValue[12] + psJewelry.MagAvoid;

            if psJewelry.AtkSpd > 0 then begin
               puSeed.btValue[17] := puSeed.btValue[17] + psJewelry.AtkSpd;
               // 공속 한계를 넘을 경우 한계값을 대입함.
               puSeed.btValue[17] := _MIN(15, puSeed.btValue[17]);
            end;
            puSeed.btValue[14] := puSeed.btValue[14] + psJewelry.Slowdown;
            puSeed.btValue[9] := puSeed.btValue[9] + psJewelry.Tox;
         end;
      22,23: // 반지    //반지22     //반지23
         begin
            puSeed.btValue[3] := puSeed.btValue[3] + psJewelry.AC;
            puSeed.btValue[4] := puSeed.btValue[4] + psJewelry.MAC;
            puSeed.btValue[0] := puSeed.btValue[0] + psJewelry.DC;
            puSeed.btValue[1] := puSeed.btValue[1] + psJewelry.MC;
            puSeed.btValue[2] := puSeed.btValue[2] + psJewelry.SC;
            if psJewelry.AtkSpd > 0 then begin
               puSeed.btValue[16] := puSeed.btValue[16] + psJewelry.AtkSpd;
               // 공속 한계를 넘을 경우 한계값을 대입함.
               puSeed.btValue[16] := _MIN(15, puSeed.btValue[16]);            //반지 공속
            end;
            puSeed.btValue[14] := puSeed.btValue[14] + psJewelry.Slowdown;    //반지 둔화
            puSeed.btValue[9] := puSeed.btValue[9] + psJewelry.Tox;          //반지 중독
         end;
      24,26: // 팔찌26      //팔찌26
         begin
            puSeed.btValue[0] := puSeed.btValue[0] + psJewelry.DC;
            puSeed.btValue[1] := puSeed.btValue[1] + psJewelry.MC;
            puSeed.btValue[2] := puSeed.btValue[2] + psJewelry.SC;
            puSeed.btValue[3] := puSeed.btValue[3] + psJewelry.AC;
            puSeed.btValue[4] := puSeed.btValue[4] + psJewelry.MAC;
            // 정확
            puSeed.btValue[15] := puSeed.btValue[15] + psJewelry.Accurate;
            // 민첩
            puSeed.btValue[16] := puSeed.btValue[16] + psJewelry.Agility;
         end;
      62: // 신발     //신발
         begin
            puSeed.btValue[3] := puSeed.btValue[3] + psJewelry.AC;
            puSeed.btValue[4] := puSeed.btValue[4] + psJewelry.MAC;

            // 민첩
            puSeed.btValue[16] := puSeed.btValue[16] + psJewelry.Agility;
         end;
      64: // 벨트
         begin
            puSeed.btValue[3] := puSeed.btValue[3] + psJewelry.AC;
            puSeed.btValue[4] := puSeed.btValue[4] + psJewelry.MAC;

            // 정확
            puSeed.btValue[15] := puSeed.btValue[15] + psJewelry.Accurate;
            // 민첩
            puSeed.btValue[16] := puSeed.btValue[16] + psJewelry.Agility;

            puSeed.btValue[8] := puSeed.btValue[8] + psJewelry.ToxAvoid;   //벨트 중독저항
         end;
      else
         begin
            Result := 0;
            exit;
         end;
   end;

   // 최대내구력 업그레이드
   puSeed.DuraMax := _MIN(65000, puSeed.DuraMax + psJewelry.DuraMax);

   SendUpdateItem (puSeed);
   SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');
   SendMsg (self, RM_SUBABILITY, 0, 0, 0, 0, '');
end;


procedure TPlayObject.ServerSendItemCountChanged (mindex, icount, increase: integer; itmname: string);
begin
   if icount <= 0 then
      MainOutMessage ('[Caution!] icount <= 0 in TPlayObject.ServerSendItemCountChanged');

   m_DefMsg := MakeDefaultMsg (SM_COUNTERITEMCHANGE, mindex, icount, increase, 0);
   SendSocket (@m_DefMsg, EncodeString (itmname));
end;


procedure TPlayObject.ServerGetLoverLogout;   //연인 스쳐
begin
   if fLover = nil then exit;

   SysMsg(fLover.GetLoverName + '綠藁놔踏狗。', c_Pink, t_Hint);

   GetObjectEventEffect;  //빼빼로

end;

procedure TPlayObject.ServerGetMentorLogout;  //사제 스쳐 접속 종료
var
  msgstr  : string;
  ListCnt : integer;
begin
  if fMentor = nil then exit;

   FMentor.Change( fMentor.GetMentorName , 0 , 0 , 0);

   msgstr := Self.FMentor.GetListmsg( RsState_Master , ListCnt );
   if ( ListCnt > 0 ) then begin
     SendDefMessage (SM_ME_INFO, 0, ListCnt, 0, 0, msgstr);
   end;

end;


// 관계시스템등에서 맵정보를 알아온다.
function  TPlayObject.GetCharMapInfo( charname : string ) : String;
var
   userinfo : TPlayObject;
begin
   Result      := '';
   userinfo    := nil;
   if charname = '' then exit;

   userinfo := userengine.GetPlayObject( charname );
   if ( userinfo <> nil ) and ( userinfo.m_PEnvir <> nil )then begin
      Result := userinfo.m_PEnvir.sMapDesc;
   end;
end;


function TPlayObject.GetNameRank( ) : string;
begin
  Result := '';
  if m_btRaceServer = RC_PLAYOBJECT then
  Result := m_sRankName;
end;

function TPlayObject.GetRankColor( ) : integer;
begin
  Result := 0;
  if m_btRaceServer = RC_PLAYOBJECT then
  Result := m_nRankColor;
end;

function TPlayObject.GetColumnName( ) : string;
begin
  Result := '';
  if m_btRaceServer <> RC_PLAYOBJECT then exit;
  if g_Config.boShowColumnName then begin
    if m_btColumn > 0 then begin          //칼럼이름
      case m_btColumn of
        1: Result := g_sColumn1;
        2: Result := g_sColumn2;
        3: Result := g_sColumn3;
        4: Result := g_sColumn4;
        5: Result := g_sColumn5;
        6: Result := g_sColumn6;
      end;
    end else
      Result := '';
  end;
end;
//명성 호칭과 등급을 얻는 함수
function TPlayObject.GetFameName( var nGrade: integer ) : string;          //킬/데스 명성
var
   strJob : string;
   strFame : string;
begin
   Result := '';

   if m_btRaceServer <> RC_PLAYOBJECT then exit;

   strJob := '';
   strFame := '';

   nGrade := 0;

   //명성 수식어
   if m_Abil.KillPoint <= 10 then begin
      nGrade := 1;
      strFame := '轟츰돨';
      case m_btJob of          //직업변경
      0: strJob := '濫却';
      1: strJob := '랬可';
      2: strJob := '돛却';
      3: strJob := '늬와';
      4: strJob := '뵨';
      5: strJob := '궷沂濫却';
      6: strJob := '븍旣랬可';
      7: strJob := '奏鉤돛却';
      8: strJob := '령邏늬와';
      9: strJob := '팎썰';
      end;
   end else if m_Abil.KillPoint <= 20 then begin
      nGrade := 2;
      strFame := '틱럴돨';
      case m_btJob of           //직업변경
      0: strJob := '濫却';
      1: strJob := '랬可';
      2: strJob := '돛却';
      3: strJob := '늬와';
      4: strJob := '뵨';
      5: strJob := '궷沂濫却';
      6: strJob := '븍旣랬可';
      7: strJob := '奏鉤돛却';
      8: strJob := '령邏늬와';
      9: strJob := '팎썰';
      end;
   end else if m_Abil.KillPoint <= 40 then begin
      nGrade := 3;
      strFame := '坎족뒈';
      case m_btJob of            //직업변경
      0: strJob := '濫却';
      1: strJob := '랬可';
      2: strJob := '돛却';
      3: strJob := '늬와';
      4: strJob := '뵨';
      5: strJob := '궷沂濫却';
      6: strJob := '븍旣랬可';
      7: strJob := '奏鉤돛却';
      8: strJob := '령邏늬와';
      9: strJob := '팎썰';
      end;
   end else if m_Abil.KillPoint <= 60 then begin
      nGrade := 4;
      strFame := '일족돨';
      case m_btJob of              //직업변경
      0,5: strJob := '읫훙';
      1,6: strJob := '뼙減可';
      2,7: strJob := '錦契훙 ';
      3,8: strJob := '聃쥣';
      4,9: strJob := '댕可';
      end;
   end else if m_Abil.KillPoint <= 80 then begin
      nGrade := 5;
      strFame := '쌤놔돨';
      case m_btJob of             //직업변경
      0,5: strJob := '읫훙';
      1,6: strJob := '뼙減可';
      2,7: strJob := '錦契훙 ';
      3,8: strJob := '聃쥣';
      4,9: strJob := '댕可';
      end;
   end else if m_Abil.KillPoint <= 100 then begin
      nGrade := 6;
      strFame := '膽汲돨';
      case m_btJob of               //직업변경
      0,5: strJob := '읫훙';
      1,6: strJob := '뼙減可';
      2,7: strJob := '錦契훙 ';
      3,8: strJob := '聃쥣';
      4,9: strJob := '댕可';
      end;
   end else if m_Abil.KillPoint <= 120 then begin
      nGrade := 7;
      strFame := '六督돨';
      case m_btJob of                //직업변경
      0,5: strJob := '嶠却';
      1,6: strJob := '減却';
      2,7: strJob := '돛훙';
      3,8: strJob := '궜';
      4,9: strJob := '淋可';
      end;
   end else if m_Abil.KillPoint <= 140 then begin
      nGrade := 8;
      strFame := '肝뻑短돨';
      case m_btJob of
      0,5: strJob := '嶠却 ';
      1,6: strJob := '減却';
      2,7: strJob := '돛훙';
      3,8: strJob := '궜';
      4,9: strJob := '淋可';
      end;
   end else if m_Abil.KillPoint <= 160 then begin
      nGrade := 9;
      strFame := '唐돛돠돨';
      case m_btJob of            //직업변경
      0,5: strJob := '嶠却 ';
      1,6: strJob := '減却';
      2,7: strJob := '돛훙';
      3,8: strJob := '궜';
      4,9: strJob := '淋可';
      end;
   end else if m_Abil.KillPoint <= 180 then begin
      nGrade := 10;
      strFame := '퓻袒돨';
      case m_btJob of                  //직업변경
      0,5: strJob := '舅와';
      1,6: strJob := '鳩훙';
      2,7: strJob := '鉤훙';
      3,8: strJob := '뱍훙';
      4,9: strJob := '匡却';
      end;
   end else if m_Abil.KillPoint <= 200 then begin
      nGrade := 11;
      strFame := '퓻볜돨';
      case m_btJob of                    //직업변경
      0,5: strJob := '舅와';
      1,6: strJob := '鳩훙';
      2,7: strJob := '鉤훙';
      3,8: strJob := '뱍훙';
      4,9: strJob := '匡却';
      end;
   end else if m_Abil.KillPoint <= 220 then begin
      nGrade := 12;
      strFame := '츠例돨';
      case m_btJob of                //직업변경
      0,5: strJob := '舅와';
      1,6: strJob := '鳩훙';
      2,7: strJob := '鉤훙';
      3,8: strJob := '뱍훙';
      4,9: strJob := '댕可';
      end;
   end else if m_Abil.KillPoint <= 240 then begin
      nGrade := 13;
      strFame := '꼇형돨';
      case m_btJob of                      //직업변경
      0,5: strJob := '濫';
      1,6: strJob := '鳩훙';
      2,7: strJob := '廬훙';
      3,8: strJob := '루諒';
      4,9: strJob := '냥';
      end;
   end else if m_Abil.KillPoint <= 260 then begin
      nGrade := 14;
      strFame := '떱羚돨 ';
      case m_btJob of                      //직업변경
      0,5: strJob := '濫';
      1,6: strJob := '鳩훙';
      2,7: strJob := '廬훙';
      3,8: strJob := '루諒';
      4,9: strJob := '냉';
      end;
   end else if m_Abil.KillPoint <= 280 then begin
      nGrade := 15;
      strFame := '寬댕돨';
      case m_btJob of                         //직업변경
      0,5: strJob := '濫';
      1,6: strJob := '鳩훙';
      2,7: strJob := '廬훙';
      3,8: strJob := '루諒';
      4,9: strJob := '댕돠';
      end;
   end else if m_Abil.KillPoint <= 300 then begin
      nGrade := 16;
      strFame := '꼇럴돨';
      case m_btJob of                        //직업변경
      0,5: strJob := '加濫';
      1,6: strJob := '랬';
      2,7: strJob := '莖吝';
      3,8: strJob := '갠균';
      4,9: strJob := '遼넣';
      end;
   end else if m_Abil.KillPoint <= 320 then begin
      nGrade := 17;
      strFame := '吝쓴돨';
      case m_btJob of                          //직업변경
      0,5: strJob := '加濫';
      1,6: strJob := '랬';
      2,7: strJob := '莖吝';
      3,8: strJob := '갠균';
      4,9: strJob := '쉿可';
      end;
   end else if m_Abil.KillPoint <= 340 then begin
      nGrade := 18;
      strFame := '밟휠돨';
      case m_btJob of                         //직업변경
      0,5: strJob := '加濫';
      1,6: strJob := '랬';
      2,7: strJob := '莖吝';
      3,8: strJob := '갠균';
      4,9: strJob := '벌可';
      end;
   end else if m_Abil.KillPoint <= 360 then begin
      nGrade := 19;
      strFame := '밟휠돨';
      //선택사항 적용예정
      case m_btJob of                              //직업변경
      0,5: strJob := '加濫';
      1,6: strJob := '랬';
      2,7: strJob := '莖吝';
      3,8: strJob := '갠균';
      4,9: strJob := '렘狼';
      end;
   end else begin
      nGrade := 20;
      strFame := '離퓻돨';
      //선택사항 적용예정
      case m_btJob of                              //직업변경
      0,5: strJob := '加濫';
      1,6: strJob := '랬';
      2,7: strJob := '莖吝';
      3,8: strJob := '갠균';
      4,9: strJob := '렘狼';
      end;
   end;
   SendMsg(Self,RM_TOSENDMSG, 0, 2, 0, 0, IntToStr(nGrade));
   Result := strFame + ' ' + strJob;

end;


procedure TPlayObject.SendLogon; //004D677C
var
  MessageBodyWL:TMessageBodyWL;
  nRecog:Integer;

  SetItem: pTSetItems;
  I, k: Integer;
  sSendMsg, sStr: string;
begin
  m_DefMsg:=MakeDefaultMsg(SM_LOGON,Integer(Self),m_nCurrX,m_nCurrY,MakeWord(m_btDirection,m_nLight));
  MessageBodyWL.lParam1:=GetFeatureToLong();
  MessageBodyWL.lParam2:=m_nCharStatus;
  if m_boAllowGroup then MessageBodyWL.lTag1 := MakeLong(MakeWord(1, m_btJob), 0)
  else MessageBodyWL.lTag1 := MakeLong(MakeWord(0, m_btJob), 0);
  MessageBodyWL.lTag2:=0;
  SendSocket(@m_DefMsg,EncodeBuffer(@MessageBodyWL,SizeOf(TMessageBodyWL)));

  nRecog:=GetFeatureToLong();
  SendDefMessage(SM_FEATURECHANGED,
                             Integer(Self),
                             LoWord(nRecog),
                             HiWord(nRecog),
                             GetFeatureEx,
                             '');

  sSendMsg := '';
  for I := 0 to g_SetItemsList.Count - 1 do begin
    SetItem := g_SetItemsList[I];
    if SetItem.HideValue then
      Continue;
    sStr := '';
    for k := Low(SetItem.Items) to High(SetItem.Items) do begin
      if SetItem.Items[k] <> '' then begin
        sStr := sStr + IntToStr(k) + '.' + SetItem.Items[k] + '/';
      end;
    end;
    if sStr = '' then Continue;
    sStr := sStr + ';';
    for k := Low(SetItem.Value) to High(SetItem.Value) do begin
      if SetItem.Value[k] > 0 then begin
        sStr := sStr + IntToStr(k) + '.' + IntToStr(SetItem.Value[k]) + '/';
      end;
    end;
    if Length(sStr) < 4 then Continue;
    sSendMsg := sSendMsg + EncodeString(sStr) + '/'
  end;
  if sSendMsg <> '' then begin
    m_DefMsg := MakeDefaultMsg(SM_SETITEMS, 0, 0, 0, 0);
    SendSocket(@m_DefMsg, sSendMsg);
  end;

  if g_sHintData <> '' then begin
    m_DefMsg := MakeDefaultMsg(SM_HINTDATA, g_nHintDataLen, 0, 0, 0);
    SendSocket(@m_DefMsg, g_sHintData);
  end;
  SendCompoundInfos;
end;

procedure TPlayObject.SendCompoundInfos;       //아이템합성
var
  i: Integer;
  sSENDMSG: string;
  pCompoundInfos: pTCompoundInfos;
begin
  sSENDMSG := EncodeBuffer(PAnsiChar(@g_Config.vCompoundSet), SizeOf(TCompoundSet)) + '/';
  for i := 0 to g_CompoundInfoList.Count - 1 do
  begin
    pCompoundInfos := pTCompoundInfos(g_CompoundInfoList.Objects[i]);
    if (pCompoundInfos = nil) then
      Continue;
    sSENDMSG := sSENDMSG + EncodeString(g_CompoundInfoList.Strings[i]) + '/';
    sSENDMSG := sSENDMSG + EncodeBuffer(PAnsiChar(pCompoundInfos), SizeOf(TCompoundInfos)) + '/';
  end;
  if sSENDMSG <> '' then
    SendDefMessage(SM_COMPOUNDINFOS, 0, 0, 0, 0, sSENDMSG);
end;

procedure TPlayObject.SendServerConfig;
var
  nRecog,nParam:Integer;
  nRunHuman,nRunMon,nRunNpc,nWarRunAll:Integer;
  ClientConf:TClientConf;
  sMsg:String;
begin
  if m_nSoftVersionDateEx = 0 then exit;
    
  nRunHuman:=0;
  nRunMon:=0;
  nRunNpc:=0;
  nWarRunAll:=0;

  if g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) then begin
    nRunHuman:=1;
    nRunMon:=1;
    nRunNpc:=1;
    nWarRunAll:=1;
  end else begin
    if g_Config.boRunHuman or m_PEnvir.Flag.boRUNHUMAN then nRunHuman:=1;
    if g_Config.boRunMon or m_PEnvir.Flag.boRUNMON then nRunMon:=1;
    if g_Config.boRunNpc then nRunNpc:=1;
    if g_Config.boWarDisHumRun then nWarRunAll:=1;

  end;
  ClientConf:=g_Config.ClientConf;
  
  ClientConf.boRunHuman:=nRunHuman = 1;
  ClientConf.boRunMon:=nRunMon = 1;
  ClientConf.boRunNpc:=nRunNpc = 1;
  ClientConf.boWarRunAll:=nWarRunAll = 1;
 // ClientConf.wSpellTime:=g_Config.dwMagicHitIntervalTime + 300;
 // ClientConf.wHitIime:=g_Config.dwHitIntervalTime + 500;

  sMsg:=EncodeBuffer(@ClientConf,SizeOf(ClientConf));
  nRecog:=MakeLong(MakeWord(nRunHuman,nRunMon),MakeWord(nRunNpc,nWarRunAll));
  nParam:=MakeWord(5,0);
  SendDefMessage(SM_SERVERCONFIG,nRecog,nParam,0,0,sMsg);
end;

procedure TPlayObject.SendServerStatus;
begin
  if m_btPermission < 10 then exit;
  SysMsg(IntToStr(CalcFileCRC(Application.ExeName)),c_Red,t_Hint);
end;

function TBaseObject.CretInNearXY(TargeTBaseObject:TBaseObject; nX,
  nY: Integer): Boolean; //004C36CC
var
  I: Integer;
  nCX,nCY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
begin
  Result:=False;
  if m_PEnvir = nil then begin
    MainOutMessage('CretInNearXY nil PEnvir');
    exit;
  end;

    for nCX:= nX -1 to nX + 1 do begin
      for nCY:= nY -1 to nY + 1  do begin
        if m_PEnvir.GetMapCellInfo(nCX,nCY,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject:=MapCellInfo.ObjList.Items[i];
            if OSObject.btType = OS_MOVINGOBJECT then begin
              BaseObject:=TBaseObject(OSObject.CellObj);
              if BaseObject <> nil then begin
                if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then begin
                  Result:=True;
                  exit;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
end;

//004D112C
procedure TPlayObject.SendUseitems;
var
  i:Integer;
  Item:TItem;
  sSendMsg:String;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin
  sSendMsg:='';
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if m_UseItems[i].wIndex > 0 then begin
      Item:=UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if Item <> nil then begin
        Item.GetStandardItem(ClientItem.S);
        opt := Item.GetItemAddValue(@m_UseItems[i],ClientItem.S);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(Item,Item.Name);
        if m_UseItems[I].btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[I].MakeIndex, m_UseItems[I].wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

        ClientItem.Dura:=m_UseItems[i].Dura;
        ClientItem.DuraMax:=m_UseItems[i].DuraMax;
        ClientItem.MakeIndex:=m_UseItems[i].MakeIndex;
        ClientItem.UpgradeOpt := opt;
        sSendMsg:=sSendMsg + IntToStr(i) + '/' + EncodeBuffer(@ClientItem,SizeOf(TClientItem)) + '/';
      end;
    end;
  end;
  if sSendMsg <> '' then begin
    m_DefMsg:=MakeDefaultMsg(SM_SENDUSEITEMS,0,0,0,0);
    SendSocket(@m_DefMsg,sSendMsg);
  end;
end;

procedure TPlayObject.SendUseMagic;//004D1418
var
  I           :Integer;
  sSendMsg    :String;
  UserMagic   :pTUserMagic;
  ClientMagic :TClientMagic;
begin
  sSendMsg:='';
  for I :=0 to m_MagicList.Count -1 do begin
    UserMagic:=m_MagicList.Items[I];
    ClientMagic.Key      := Chr(UserMagic.btKey);
    ClientMagic.Level    := UserMagic.btLevel;
    ClientMagic.CurTrain := UserMagic.nTranPoint;
    ClientMagic.Def      := UserMagic.MagicInfo^;
    sSendMsg:=sSendMsg + EncodeBuffer(@ClientMagic,SizeOf(TClientMagic)) + '/';
  end;
  if sSendMsg <> '' then begin
    m_DefMsg:=MakeDefaultMsg(SM_SENDMYMAGIC,0,0,0,m_MagicList.Count);
    SendSocket(@m_DefMsg,sSendMsg);
  end;
end;

function TPlayObject.ClientChangeDir(wIdent:Word;nX, nY, nDir: Integer{;var dwDelayTime:LongWord}): Boolean;//4CAEB8
var
  dwCheckTime:LongWord;
  nMagLevel, nRate:Integer;
  UserMagic: pTUserMagic;
begin
  Result:=False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) then exit;//렝쮸

  if (nX = m_nCurrX) and (nY = m_nCurrY) then begin
    m_btDirection:=nDir;
    if Walk(RM_TURN) then begin
      Result:=True;
      if (m_wStatusArrValue[81] > 0) and (not m_boSunchunUse) then begin
        m_boSunchunUse := True;
      end;
    end;
  end;
end;

function TPlayObject.ClientSitDownHit(nX, nY, nDir: Integer): Boolean;//004CC248
var
  dwCheckTime:LongWord;
begin
  Result:=False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE{5}]{0x6A} <> 0) then exit;//렝쮸

  SendRefMsg (RM_SITDOWN, 0, 0, 0, 0, '');
  Result:=True;
end;


procedure TPlayObject.ClientOpenDoor(nX,nY:Integer);//004DABD4
var
  Door:pTDoorInfo;
  Castle:TUserCastle;
begin
  Door:=m_PEnvir.GetDoor(nX,nY);
  if Door = nil then exit;
  Castle:=g_CastleManager.IsCastleEnvir(m_PEnvir);
  if (Castle = nil) or
     (Castle.m_DoorStatus <> Door.Status) or
     (m_btRaceServer <> RC_PLAYOBJECT) or
     Castle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then begin

    UserEngine.OpenDoor(m_PEnvir,nX,nY);
  end;
end;



procedure TPlayObject.ClientGetTopInfo(ProcessMsg: pTProcessMessage);
var
  nPage, nCount, nUserPage: Integer;
  nIndex: Integer;
  TopInfo: TClientTopInfo;
  I, n: Integer;
  sSendMsg: string;
  nBack: Byte;
  boFind: Boolean;
begin
  nIndex := ProcessMsg.nParam1;
  nUserPage := ProcessMsg.nParam2;
  nPage := 0;
  sSendMsg := '';
  nBack := 0;
  if ProcessMsg.wParam = 1 then begin
    nBack := 1;
    sSendMsg := EncodeString('탤츰攣瞳岬劤샀諒콱뻘청唐構踪');
    if nIndex in [Low(g_TopInfo)..High(g_TopInfo)] then begin
      if g_TopInfo[nIndex] <> nil then begin
        nCount := Length(g_TopInfo[nIndex]);
        if nCount > 0 then begin
          nPage := nCount div 20;
          if nCount mod 20 > 0 then
            Inc(nPage);
          nUserPage := 0;
          n := 0;
          boFind := False;
          SafeFillChar(TopInfo, SizeOf(TopInfo), #0);
          for I := Low(g_TopInfo[nIndex]) to High(g_TopInfo[nIndex]) do begin
            if n > High(TClientTopInfo) then begin
              if boFind then
                Break;
              n := 0;
              Inc(nUserPage);
              SafeFillChar(TopInfo, SizeOf(TopInfo), #0);
            end;
            TopInfo[n] := g_TopInfo[nIndex][I];
            if (not boFind) and (g_TopInfo[nIndex][I].sChrName = m_sCharName) then begin
              nBack := 0;
              boFind := True;
            end;
            Inc(n);
          end;
          if boFind then
            sSendMsg := EncodeBuffer(@TopInfo[0], SizeOf(TClientTopInfo));
        end;
      end;

    end;
  end
  else begin
    if nIndex in [Low(g_TopInfo)..High(g_TopInfo)] then begin
      if g_TopInfo[nIndex] <> nil then begin
        nCount := Length(g_TopInfo[nIndex]);
        if nCount > 0 then begin
          nPage := nCount div 20;
          if nCount mod 20 > 0 then
            Inc(nPage);
          if nUserPage < 0 then
            nUserPage := 0;
          if nUserPage > nPage then
            nUserPage := nPage;
          SafeFillChar(TopInfo, SizeOf(TopInfo), #0);
          for I := (nUserPage * 20) to (nUserPage * 20 + High(TClientTopInfo)) do begin
            if I > High(g_TopInfo[nIndex]) then
              break;
            TopInfo[I - nUserPage * 20] := g_TopInfo[nIndex][I];
          end;
          sSendMsg := EncodeBuffer(@TopInfo[0], SizeOf(TClientTopInfo));
        end;
      end;
    end;
  end;
  m_DefMsg := MakeDefaultMsg(SM_GETTOPINFO, nIndex, nUserPage, nPage, nBack);
  SendSocket(@m_DefMsg, sSendMsg);
end;


procedure TPlayObject.ClientGetRockPapers(ProcessMsg: pTProcessMessage);
var
  nRate, nMode, nGold: Integer;
  nIndex: Integer;
  TopInfo: TClientTopInfo;
  I, n: Integer;
  sSendMsg: string;
  nBack: Byte;
  boFind: Boolean;
begin
  nRate := ProcessMsg.nParam1;
  nMode := ProcessMsg.nParam2;
  nGold := StrToInt(DecodeString(ProcessMsg.sMsg));
  if nMode = 2 then begin  //이겼다면
   // if IncGold(nGold * nRate) then begin
    //  GoldChanged;
      if g_boGameLogGold then
        AddGameDataLog('49' +  #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(m_nGold) + #9 +
          '1' + #9 +
          GetGoldStr(nGold * nRate) + #9 + '[숏독柯庫꼈/端]');
  //  end;
  end else begin
    if nMode = 4 then begin  //다시배팅
      if m_nGold >= nGold then begin
      //  DecGold(nGold);
      //  GoldChanged();
        if g_boGameLogGold then
          AddGameDataLog('49' +  #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_nGold) + #9 +
            '1' + #9 +
            GetGoldStr(nGold) + #9 + '[숏독柯庫꼈/路劤尻鬧]');
      end else begin
       SysMsg('쏜귑꼇璃。', c_Red, t_Hint);
       SendMsg(Self, RM_ROCKPAPERS, 0, 0, 0, 0, '');
      end;
    end;
  end;
  if nMode > 0 then begin
    case nMode of
     3: SendRefMsg(RM_10205, 0, m_nCurrX, m_nCurrY, 125,'0');   //가위바위보 비김
     1: SendRefMsg(RM_10205, 0, m_nCurrX, m_nCurrY, 126,'0');   //가위바위보 졌음
     2: SendRefMsg(RM_10205, 0, m_nCurrX, m_nCurrY, 127,'0');   //가위바위보 이김
    end;
  end;
end;

procedure TPlayObject.ClientAlive(ProcessMsg: pTProcessMessage);
var
  i: Integer;
  UserItem: PTUserItem;
  Stditem: TItem;
  Castle: TUserCastle;
begin
  if m_boGhost or (not m_boDeath) then exit;
  case ProcessMsg.nParam1 of
    1: begin     //마을에서 부활
       m_boDeath := False;
       if (not m_PEnvir.Flag.boFight3Zone) then begin
          Castle := g_CastleManager.InCastleWarArea(Self);
          if (Castle <> nil) and Castle.m_boUnderWar then begin  //공성중일때
            if Castle.IsMember(Self) then begin    //공성중일때 성문파가 아닌경우
              BaseObjectMove(Castle.GetATMapName,IntToStr(Castle.GetATHomeX),IntToStr(Castle.GetATHomeY));
            end else begin //공성중인 수성문파(성주인)
              BaseObjectMove(Castle.GetMapName,IntToStr(Castle.GetHomeX),IntToStr(Castle.GetHomeY));
            end;
          end else begin
            if PKLevel < 2 then begin
               BaseObjectMove(m_sHomeMap,IntToStr(m_nHomeX),IntToStr(m_nHomeY));
            end else begin
               BaseObjectMove(g_Config.sRedHomeMap,IntToStr(g_Config.nRedHomeX),IntToStr(g_Config.nRedHomeY));
            end;
          end;
          m_WAbil.HP := Round(m_WAbil.MaxHP * 0.10);
          SendMsg(Self,RM_ABILITY,0,0,0,0,'');
          SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX,m_nCurrY, 0, '');
       end else begin
         if (m_Abil.HP <= 0) and (m_nFightZoneDieCount < 3) then begin    //죽은 경우
           m_Abil.HP:=m_Abil.MaxHP;
           m_Abil.MP:=m_Abil.MaxMP;
           m_boDieInFight3Zone:=True;
         end else begin
           m_WAbil.HP := Round(m_WAbil.MaxHP * 0.10);
           m_nFightZoneDieCount:=0;
         end;
         MapRandomMove(m_PEnvir.sMapName,0);
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX,m_nCurrY, 0, '');
       end;
      end;
    2: begin //부활주문서
        if (not m_PEnvir.Flag.boNOREVIVAL) then begin
          for I := m_ItemList.Count - 1 downto 0 do begin
            UserItem := m_ItemList[I];
            if UserItem <> nil then begin
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if (StdItem <> nil) and (StdItem.StdMode = 2) and (StdItem.Shape = 14) then begin
                m_ItemList.Delete(I);
                m_WAbil.HP:=m_WAbil.MaxHP;
                m_WAbil.MP:=m_WAbil.MaxMP;
                m_boDeath := False;
                SendMsg(self,RM_ABILITY,0,0,0,0,'');
                SendRefMsg(RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_RELIVE, '');
                SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX,m_nCurrY, 0, '');
                if (Stditem.NeedIdentify = 1) then
                  AddGameDataLog('11' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[陋구]');
                SendDelItems(UserItem);
                Dispose(UserItem);
                exit;
              end;
            end;
          end;
          SysMsg('膠틔꼇닸瞳。', c_Red, t_Hint);
        end else begin
          SysMsg('뎠품뒈暠轟랬릿삶。',c_RedWhite,t_Hint);
        end;
      end;
  end;
end;

procedure TPlayObject.ClientHeroAI(nMode: Integer);
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  if THeroObject(m_MyHero).m_btAiMode <> nMode then begin
    THeroObject(m_MyHero).m_btAiMode := nMode;
    SendDefMessage(SM_HEROAIMODE, 0, THeroObject(m_MyHero).m_btAiMode, 0, 0, '')
  end;
end;
procedure TPlayObject.ClientHeroCall();      //소환
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  THeroObject(m_MyHero).m_boHeroCall := True;
  THeroObject(m_MyHero).m_dwCallTargetTick := GetTickCount;
  THeroObject(m_MyHero).m_TargetCret := nil;
  THeroObject(m_MyHero).DelTargetCreat;
end;
procedure TPlayObject.ClientHeroBackCall();    //주인뒤로
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  if (THeroObject(m_MyHero).m_btStatus = 1) then Exit;
  THeroObject(m_MyHero).m_boHeroBackCall := True;
  THeroObject(m_MyHero).m_dwCallTargetTick := GetTickCount;
  THeroObject(m_MyHero).m_TargetCret := nil;
  THeroObject(m_MyHero).DelTargetCreat;
end;
procedure TPlayObject.ClientHeroMasterDefen();
var
  List: Tlist;
  I: Integer;
  cret: TBaseObject;
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) {or (m_LastHiter = nil) }then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;

  list := TList.Create;
  m_PEnvir.GetRangeBaseObject (Self.m_nCurrX, Self.m_nCurrY, 9, TRUE, list);
  for i:=0 to list.Count-1 do begin
    cret := TBaseObject(list.Items[i]);
    if (cret.m_btRaceServer <> RC_PLAYOBJECT) and (cret.m_TargetCret = Self) and (cret.m_btRaceServer >= RC_ANIMAL) then begin
      if IsProperTarget(cret) then
        cret.m_TargetCret := m_MyHero;
    end;
  end;
  list.Free;

end;

procedure TPlayObject.ClientAddAutoItem(nItemIdx: Integer; sMsg: String);
var
  I: Integer;
  bo19:Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
  StdItem: TItem;
begin
  bo19:=False;
  UserItem:=nil;
  if m_boDeath or m_boGhost or (m_MyHero = nil) or m_boWaitHeroDate then begin
    SendDefMessage(SM_AUTOADDITEM_FAIL, 0, 0, 0, 0, '');
  end else begin
    if Pos(' ',sMsg) >= 0 then
    GetValidStr3(sMsg,sMsg,[' ']);

    for I := m_MyHero.m_ItemList.Count - 1 downto 0 do begin
      if m_MyHero.m_ItemList.Count <= 0 then Break;
      UserItem := m_MyHero.m_ItemList.Items[I];
      if UserItem = nil then Continue;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);

      sUserItemName := '';
      sUserItemName := FilterShowName(StdItem.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName,sMsg) = 0) then begin
        if (THeroObject(m_MyHero).m_AutoItem.Count < 2) then begin
          THeroObject(m_MyHero).m_AutoItem.Add(UserItem);
          m_MyHero.m_ItemList.Delete(I);
          m_MyHero.WeightChanged();
          SendAddHeroAuto(UserItem);
          SendDefMessage(SM_AUTOADDITEM_OK, 0, 0, 0, 0, '');
        end else begin
          SendDefMessage(SM_AUTOADDITEM_FAIL, 0, 0, 0, 0, '');
        end;
        bo19 := True;
        break;
      end;
    end;
  end;
  if not bo19 then SendDefMessage(SM_AUTOADDITEM_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientDelAutoItem(nItemIdx: Integer; sMsg: String);
var
  I: Integer;
  bo19:Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
  StdItem: TItem;
begin
  bo19:=False;
  UserItem:=nil;
  if m_boWaitHeroDate or m_boGhost or (m_MyHero = nil) then begin
    SendDefMessage(SM_AUTODELITEM_FAIL, 0, 0, 0, 0, '');
  end else begin
    for I := 0 to m_MyHero.m_AutoItem.Count - 1 do begin
      UserItem := m_MyHero.m_AutoItem.Items[I];
      if UserItem = nil then  Continue;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);

      sUserItemName := '';
      sUserItemName := FilterShowName(StdItem.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin
        if THeroObject(m_MyHero).IsEnoughBag then begin
          THeroObject(m_MyHero).m_ItemList.Add(UserItem);
          THeroObject(m_MyHero).SendAddItem(UserItem);
          THeroObject(m_MyHero).WeightChanged();
          m_MyHero.m_AutoItem.Delete(I);
          SendDefMessage(SM_AUTODELITEM_OK, 0, 0, 0, 0, '');
        end else begin
          SendAddHeroAuto(UserItem);
          SendDefMessage(SM_AUTODELITEM_FAIL,0,0,0,0,'');
        end;
        bo19:=True;
        break;
      end;
    end;
  end;
  if not bo19 then SendDefMessage(SM_AUTODELITEM_FAIL,0,0,0,0,'');
end;


procedure TPlayObject.ClientTakeOnItems(btWhere: Byte; nItemIdx: integer; sItemName: String;iex:integer);//004DAC70
var
  I,n14,n18,K ,G: Integer;
  UserItem,TakeOffItem:pTUserItem;
  StdItem,StdItem20,StdItem2 ,StdItemOff:TItem;
  StdItem58:TStdItem;
  sUserItemName:String;
  stditemname:string;
  boot:Boolean;
  boFind: Boolean;
  label FailExit;
begin
  StdItem:=nil;
  UserItem:=nil;
  boFind := False;
  n14:=-1;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      sUserItemName := '';
      sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if not (StdItem.StdMode in [2,46]) then begin

      if (StdItem.Reserved and 16 <> 0) then begin
        stditemname:= FilterStdShowName(StdItem,StdItem.Name);
        if (self.m_btJob in [g_Bonze,g_BonzeUp]) then begin         //승려
          if self.m_WAbil.Level >= 80 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '60');
          end else if self.m_WAbil.Level >= 70 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '50');
          end else if self.m_WAbil.Level >= 60 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '40');
          end else if self.m_WAbil.Level >= 50 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '30');
          end else if self.m_WAbil.Level >= 40 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '20');
          end else if self.m_WAbil.Level >= 30 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '10');
          end else begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '00');
          end;
        end else begin
          if self.m_WAbil.Level >= 80 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '6');
          end else if self.m_WAbil.Level >= 70 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '5');
          end else if self.m_WAbil.Level >= 60 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '4');
          end else if self.m_WAbil.Level >= 50 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '3');
          end else if self.m_WAbil.Level >= 40 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '2');
          end else if self.m_WAbil.Level >= 30 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '1');
          end else begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName);
          end;
        end;
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      end;

      if (StdItem.Reserved and 32 <> 0) then begin
        stditemname:= FilterStdShowName(StdItem,StdItem.Name);
        if (self.m_btJob = Jwarr) or (self.m_btJob = JUpwarr) then
          UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '1');
        if (self.m_btJob = Jwizard) or (self.m_btJob = JUpwiz) then
          UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '2');
        if (self.m_btJob = Jtaos) or (self.m_btJob = JUptao) then
          UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '3');
        if (self.m_btJob = JAssassin) or (self.m_btJob = jUpAssa) then                       //자객
          UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '4');
        if (self.m_btJob = jBonze) or (self.m_btJob = jUpBoz) then                         //승려
          UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '5');
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      end;
      end;

      if StdItem <> nil then begin
        if CompareText(sUserItemName,sItemName) = 0 then begin
          n14:=i;
          boFind := True;
          break;
        end;
      end;
    end;
    UserItem:=nil;
  end;
  n18:=0;
  if (StdItem <> nil) and (UserItem <> nil) and boFind then begin
    if CheckUserItems(btWhere,StdItem) then begin
      StdItem.GetStandardItem(StdItem58);
      StdItem.GetItemAddValue(UserItem,StdItem58);

      if CheckTakeOnItems(btWhere,StdItem58) and CheckItemBindUse(UserItem) then begin  //아이템 착용
        TakeOffItem:=nil;
      if btWhere in [0..High(THumanUseItems){13}] then begin  //아이템 착용

        if m_UseItems[btWhere].wIndex > 0 then begin       //이미 착용하고 있음.
          StdItem20:=UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);

          if (StdItem20 <> nil) and
             (StdItem20.StdMode in [15,22,23,24,26]) then begin    //미지템   takeon
            if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0)then begin        //벗을 수 없는 아이템
              SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
              n18:=-4;
              goto FailExit;
            end;
          end;
          if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0)then begin  //벗을 수 없는 아이템
            SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
            n18:=-4;
            goto FailExit;
          end; //004DAE78
          if (StdItem20.Reserved and 4) <> 0 then begin       //절대로 벗지 못하는 아이템
            SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
            n18:=-4;
            goto FailExit;
          end;
          if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin     //벗을 수 없는 아이템
            SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
            goto FailExit;
          end;
          New(TakeOffItem);
          TakeOffItem^:=m_UseItems[btWhere];

          StdItemOff := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);

        end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin


        m_UseItems[btWhere]:=UserItem^;
        DelBagItem(n14);
        if TakeOffItem <> nil then begin
          AddItemToBag(TakeOffItem,boot);
          if boot then
          SendAddItem(TakeOffItem,0);
          if g_FunctionNPC <> nil then begin
               g_FunctionNPC.GotoLable(Self,'@TakeOffItem('+StdItemOff.Name+')',False);
          end;
          if (m_btJob in [3,8]) and (StdItemOff.StdMode = 99 ) and (m_MagicWindbladeSkill <> nil) and m_boUseWindblade then begin  //풍검술
             WindbladeOnOff(FALSE);
             SendSocket(nil,'+UWB');
          end;
        end;
        RecalcAbilitys();
        SendMsg(Self,RM_ABILITY,0,0,0,0,'');
        SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
        SendDefMessage(SM_TAKEON_OK,GetFeatureToLong,GetFeatureEx,0,0,'');
        FeatureChanged();
        if (iex = 1) then begin
          ClientQueryBagItems(VerInfoStr4);
        end;

        if g_FunctionNPC <> nil then begin
           g_FunctionNPC.GotoLable(Self,'@TakeOnItem('+ sUserItemName +')',False);
        end;
        n18:=1;
      end;
      end else n18:=-1; //004DAFA0
    end else n18:=-1; //004DAFA9
  end; //004DAFB0
  FailExit:
  if n18 <= 0 then
    SendDefMessage(SM_TAKEON_FAIL,n18,0,0,0,'');

end;

procedure TPlayObject.ClientTakeOffItems(btWhere: Byte; nItemIdx: integer; sItemName: String;iex:integer);//004DB01C   아이템 벗음
var
  n10,I:Integer;
  StdItem,StdItem2:TItem;
  UserItem:pTUserItem;
  sUserItemName:String;
  boot:Boolean;
label FailExit;
begin
  n10:=0;
  if (not m_boDealing) and (not m_boRentaling) and (btWhere < High(THumanUseItems)+1){(btWhere < 15)} then begin     //아이템 갯수?
    if m_UseItems[btWhere].wIndex > 0 then begin
      if m_UseItems[btWhere].MakeIndex = nItemIdx then begin
        StdItem:=UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);

        if (StdItem <> nil) and
           (StdItem.StdMode in [15,22,23,24,26]) then begin       //미지템  takeoff
          if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0)then begin    //벗을 수 없는 아이템
            SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
            n10:=-4;
            goto FailExit;
          end;
        end;
        if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0)then begin       //벗을 수 없는 아이템
          SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
          n10:=-4;
          goto FailExit;
        end;
        if (StdItem.Reserved and 4) <> 0 then begin            //절대로 벗지 못하는 아이템
          SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
          n10:=-4;
          goto FailExit;
        end;
        if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then begin
          SysMsg(g_sCanotTakeOffItem,c_Red,t_Hint);
          goto FailExit;
        end;


        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if m_UseItems[btWhere].btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex, m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);

        if CompareText(sUserItemName,sItemName) = 0 then begin
          New(UserItem);
          UserItem^:=m_UseItems[btWhere];
          if AddItemToBag(UserItem,boot) then begin
            m_UseItems[btWhere].wIndex:=0;
            if boot then
            SendAddItem(UserItem,0);

            if (m_btJob in [3,8]) and (StdItem.StdMode = 99 ) and (m_MagicWindbladeSkill <> nil) and m_boUseWindblade then begin  //풍검술
              WindbladeOnOff(FALSE);
              SendSocket(nil,'+UWB');
            end;
            RecalcAbilitys();
            SendMsg(Self,RM_ABILITY,0,0,0,0,'');
            SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
            SendDefMessage(SM_TAKEOFF_OK,GetFeatureToLong,GetFeatureEx,0,0,'');
            FeatureChanged();

            if g_FunctionNPC <> nil then begin
               g_FunctionNPC.GotoLable(Self,'@TakeOffItem('+sUserItemName+')',False);
            end;
          end else begin
            Dispose(UserItem);
            n10:=-3;
          end;
        end;
      end; //004DB26F
    end else n10:=-2; //004DB25F
      
  end else n10:=-1; //004DB268

  FailExit://004DB26F
  if n10 <= 0 then
    SendDefMessage(SM_TAKEOFF_FAIL,n10,0,0,0,'');
end;

procedure TPlayObject.ClientNewHeroCreate(nMerchant:integer; sData: string);
var
  Data, sChrName, sHair, sJob, sSex: string;
  sMsg: string;
  Merchant: TMerchant;
begin
  sMsg := '';
  Data := sData;
  Data := GetValidStr3(Data, sChrName, ['/']);
  Data := GetValidStr3(Data, sHair, ['/']);
  Data := GetValidStr3(Data, sJob, ['/']);
  Data := GetValidStr3(Data, sSex, ['/']);

  if (m_sHeroCharName = '') then begin
    if (m_sTempHeroName = '') then begin
      m_sTempHeroName := sChrName;
      sMsg := '/' + sHair + '/' + sJob + '/' + sSex;
      Merchant := UserEngine.FindMerchant(TObject(nMerchant));
      if Merchant <> nil then
      FrontEngine.AddToLoadHeroRcdList(Self, Merchant, l_Create, sMsg);    //나노제한
    end else begin
      m_sTempHeroName := '';
      m_sHeroCharName := '';
    end;
  end;
end;

procedure TPlayObject.ClientHeroTurn(nX, nY: Integer; nDir: Byte); //방향턴
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  if (THeroObject(m_MyHero).m_btStatus = 1) then Exit;   //휴식상태면 안된다.
  if (nX = m_MyHero.m_nCurrX) and (nY = m_MyHero.m_nCurrY) then begin
    m_MyHero.m_btDirection := nDir;
    m_MyHero.SendRefMsg(RM_TURN, nDir, m_MyHero.m_nCurrX, m_MyHero.m_nCurrY, 0, '');
  end;
end;

procedure TPlayObject.ClientHeroProtect(nX, nY: Integer); //이동 / 공격
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  if (THeroObject(m_MyHero).m_btStatus = 1) then Exit;   //휴식상태면 안된다.
  THeroObject(m_MyHero).m_boProtectStatus := not THeroObject(m_MyHero).m_boProtectStatus;
  THeroObject(m_MyHero).m_TargetCret := nil;
  THeroObject(m_MyHero).DelTargetCreat;
  if THeroObject(m_MyHero).m_boProtectStatus then begin
    THeroObject(m_MyHero).m_nProtectTargetX := nX;
    THeroObject(m_MyHero).m_nProtectTargetY := nY;
  end else begin
    THeroObject(m_MyHero).m_nProtectTargetX := -1;
    THeroObject(m_MyHero).m_nProtectTargetY := -1;
  end;
end;

procedure TPlayObject.ClientHeroSpell(BaseObject: TBaseObject; tx, ty, MagNum: Integer);     //영웅무공
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  if (THeroObject(m_MyHero).m_btStatus = 1) then Exit;   //휴식상태면 안된다.

  THeroObject(m_MyHero).m_boSpellTarget := True;
  if THeroObject(m_MyHero).MagicAttackTarget(BaseObject, tx, ty, MagNum ) then begin
    THeroObject(m_MyHero).m_boSpellTarget := False;
  end;

end;

procedure TPlayObject.ClientHeroTarget(BaseObject: TBaseObject; nX, nY: Integer);
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or (m_MyHero = nil) then Exit;
  if (m_MyHero <> nil) and (m_MyHero.m_boDeath or m_MyHero.m_boGhost) then Exit;
  if (THeroObject(m_MyHero).m_btStatus = 1) then Exit;   //휴식상태면 안된다.
  if (BaseObject <> nil) and IsProperTarget(BaseObject) then begin
    if (abs(m_nCurrX - BaseObject.m_nCurrX) <= 12) and (abs(m_nCurrY - BaseObject.m_nCurrY) <= 12) then begin
      THeroObject(m_MyHero).m_boTarget := True;
      THeroObject(m_MyHero).SetTargetCreat(BaseObject);
    end;
  end;
end;

procedure TPlayObject.ClientHeroLogOn(nType: Byte);
var
  nSec: Integer;
  UserOpenInfo: pTUserOpenInfo;
begin
  if m_boWaitHeroDate or m_boGhost or m_boDeath or m_PEnvir.m_boNoRecallHero then Exit;
  if (m_sHeroCharName <> '') and (m_MyHero = nil) then begin
    if m_PEnvir.m_boNoRecallHero then begin
      SysMsg('뎠품뒈暠쐐岺梁뻥亶衿。', c_Green, t_Hint);
      Exit;
    end;
    if (m_GroupOwner <> nil) and (m_GroupOwner.m_boCheckHero) then begin
      SysMsg('뎠품莉뚠친駕쐐岺梁뻥亶衿。', c_BlueWhite, t_Hint);
      Exit;
    end;
    if (nType = 1) then begin
        FrontEngine.AddToLoadHeroRcdList(Self, nil, l_Load);   //나노제한
    end else begin
      if (GetTickCount - m_dwRecallHeroTick > g_Config.nRecallHeroTime * 1000) then begin
        m_dwRecallHeroTick := GetTickCount;
        FrontEngine.AddToLoadHeroRcdList(Self, nil, l_Load);     //나노제한
      end else begin
        SysMsg(Format(g_Config.sRecallHeroHint, [g_Config.nRecallHeroTime]), c_Red, t_Hint);
      end;
    end;
  end;
end;


procedure TPlayObject.RecalcHeroAddAbilitys();//영웅 버프
var
  str:string;
  btJob: byte;
  btLevel: Integer;
begin
   if (m_MyHero <> nil) and (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) and (not THeroObject(m_MyHero).m_boHeroLogOut) then begin
     btJob := THeroObject(m_MyHero).m_btJob;
     btLevel := THeroObject(m_MyHero).m_Abil.Level;
     str := '';
     case btJob of
       0: begin  //영웅 전사
           if m_MyHero.m_btLimitLevel <> 1 then begin
             if btLevel >= 10 then begin
               m_nPowerRate5 := 100 + btLevel div 10 + (m_MyHero.m_nHeroGrade);    //공력
             end else
             m_nPowerRate5 := 100 + 1 + btLevel div 10;   //공격력
             m_wStatusArrValue[85] := 5 + (btLevel div 10) * (m_MyHero.m_nHeroGrade);  //최대HP상승
           end else begin
             m_nPowerRate5 := 100 + 1;
             m_wStatusArrValue[85] := 5;
           end;
           str := str + 'MAXHP +' + IntToStr(m_wStatusArrValue[85]) + '\묑샌 ' + IntToStr(m_nPowerRate5 - 100);
         end;
       1: begin //영웅 술사
           if m_MyHero.m_btLimitLevel <> 1 then begin
             m_nKillMonExpRate9 := 100 + 1 + btLevel div 10;
             m_wStatusArrValue[86] := 5 + (btLevel div 10) * (m_MyHero.m_nHeroGrade);  //최대MP상승
           end else begin
             m_nKillMonExpRate9 := 100 + 1;
             m_wStatusArrValue[86] := 5;
           end;
           str := str + 'MAXMP +' + IntToStr(m_wStatusArrValue[86]) + '\쒔駱令 + ' + IntToStr(m_nKillMonExpRate9 - 100) + '%';
         end;
       2: begin //영웅 도사
           if m_MyHero.m_btLimitLevel <> 1 then begin
             if btLevel >= 10 then begin
               m_nPowerRate5 := 100 + btLevel div 10 + (m_MyHero.m_nHeroGrade);    //공력
             end else
             m_nPowerRate5 := 100 + 1 + btLevel div 10;   //공격력
             m_wStatusArrValue[87] := 5 + (btLevel div 10) * (m_MyHero.m_nHeroGrade);  //체력회복
           end else begin
             m_nPowerRate5 := 100 + 1;
             m_wStatusArrValue[87] := 5;
           end;
           str := str + '餉環寧 +' + IntToStr(m_wStatusArrValue[87]) + '%\묑샌 ' + IntToStr(m_nPowerRate5 - 100);
         end;
       3: begin  //영웅 자객
           if m_MyHero.m_btLimitLevel <> 1 then begin
             m_wStatusArrValue[88] := 1 + btLevel div 10;    //정확
             m_wStatusArrValue[89] := 5 + (btLevel div 10) * (m_MyHero.m_nHeroGrade);  //마력회복
           end else begin
             m_wStatusArrValue[88] := 1;
             m_wStatusArrValue[89] := 5;
           end;
           str := str + '침랬뿟릿 +' + IntToStr(m_wStatusArrValue[89]) + '%\硫횅 ' + IntToStr(m_wStatusArrValue[88]);
         end;
     end;
     SendMsg(self,RM_BUFF, 115, 0, 44, 1, '[ 亶衿BUFF ]\' + str); //영웅 버프
   end else begin
     m_wStatusArrValue[85] := 0;
     m_wStatusArrValue[86] := 0;
     m_wStatusArrValue[87] := 0;
     m_wStatusArrValue[88] := 0;
     m_wStatusArrValue[89] := 0;
     m_nPowerRate5 := 100;
     m_nKillMonExpRate9 := 100;
     SendMsg(self,RM_BUFF, 115, 0, 44, 0, ''); //영웅 버프
   end;
   RecalcAbilitys;
   SendMsg(Self,RM_ABILITY,0,0,0,0,'');
   SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
end;

procedure TPlayObject.ClientHeroLogOut(BaseObject: TBaseObject);
begin
  if m_boWaitHeroDate or m_boGhost then Exit;
  if (m_sHeroCharName <> '') and (m_MyHero <> nil) and (BaseObject = m_MyHero) then begin
    if (m_MyHero.m_boDeath) or (GetTickCount - m_dwRecallHeroTick > g_Config.nRecallHeroTime * 1000) then begin
      m_dwRecallHeroTick := GetTickCount;
      THeroObject(m_MyHero).LogOut;
    end else begin
      SysMsg(Format(g_Config.sRecallHeroHint, [g_Config.nRecallHeroTime]), c_Red, t_Hint);
    end;

  end;
end;


procedure TPlayObject.ClientMasterBagToHeroBag(nItemIdx: Integer; sItemName: string);    //주인 > 영웅 가방으로
var
  I: Integer;
  UserItem: pTUserItem;
  sUserItemName: string;
  boot: boolean;
  StdItem: TItem;
begin
  if m_boWaitHeroDate or m_boGhost or (m_MyHero = nil) then begin
    SendDefMessage(SM_MASTERBAGTOHEROBAG_FAIL, 0, 0, 0, 0, '');
  end else begin
    if THeroObject(m_MyHero).IsEnoughBag then begin
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];
        if UserItem.MakeIndex = nItemIdx then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          sUserItemName := '';
          sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
          if UserItem.btValue[11] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);


          if CompareText(sUserItemName, sItemName) = 0 then begin
            THeroObject(m_MyHero).m_ItemList.Add(UserItem);
            THeroObject(m_MyHero).SendAddItem(UserItem);
            m_ItemList.Delete(I);
            WeightChanged();
            THeroObject(m_MyHero).WeightChanged();
            SendDefMessage(SM_MASTERBAGTOHEROBAG_OK, 0, 0, 0, 0, '');

            break;
          end;
        end;
      end;
    end else begin
      SendDefMessage(SM_MASTERBAGTOHEROBAG_FAIL, 0, 0, 0, 0, '');
    end;
  end;
end;

procedure TPlayObject.ClientHeroBagToMasterBag(nItemIdx: Integer; sItemName: string);     //영웅 > 주인 가방으로
var
  I: Integer;
  UserItem: pTUserItem;
  sUserItemName: string;
  boot: boolean;
  StdItem: TItem;
begin
  if m_boWaitHeroDate or m_boGhost or (m_MyHero = nil) then begin
    SendDefMessage(SM_HEROBAGTOMASTERBAG_FAIL, 0, 0, 0, 0, '');
  end else begin
    if IsEnoughBag then begin
      for I := 0 to m_MyHero.m_ItemList.Count - 1 do begin
        UserItem := m_MyHero.m_ItemList.Items[I];
        if UserItem.MakeIndex = nItemIdx then begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          sUserItemName := '';
          sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
          if UserItem.btValue[11] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
          if sUserItemName = '' then
            sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);


          if CompareText(sUserItemName, sItemName) = 0 then begin
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem, 1);
            WeightChanged();
            m_MyHero.m_ItemList.Delete(I);
            m_MyHero.WeightChanged();
            SendDefMessage(SM_HEROBAGTOMASTERBAG_OK, 0, 0, 0, 0, '');

            break;
          end;
        end;
      end;
    end;
    SendDefMessage(SM_HEROBAGTOMASTERBAG_FAIL, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientHeroStorageItem(NPC: TObject;         //주인 >> 영웅여관    //창고
  nItemIdx: Integer; sMsg: String; nMode:Integer); //004DC2B8
var
  Merchant:TMerchant;
  I:Integer;
  UserItem:pTUserItem;
  bo19:Boolean;
  StdItem:TItem;
  sUserItemName:String;
begin
  bo19:=False;
  UserItem:=nil;

  if Pos(' ',sMsg) >= 0 then
    GetValidStr3(sMsg,sMsg,[' ']);
  if m_boWaitHeroDate or m_boGhost or (m_MyHero = nil) then begin
    SendDefMessage(SM_HERO_STORAGE_FAIL,0,0,0,0,'');
    exit;
  end;
  for i := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then break;
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);

    sUserItemName := '';
    sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName,sMsg) = 0) then begin
      if (nMode = 1) then begin
        if THeroObject(m_MyHero).m_StorageItemList.Count < STORAGELIMIT then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          if not StdItem.boCanStore or (UserItem.btValue[19] = 1) then begin    //대여템 여관 금지
           SendDefMessage(SM_HERO_STORAGE_FAIL,0,0,0,0,'');
           exit;
          end;
          THeroObject(m_MyHero).m_StorageItemList.Add(UserItem);
          THeroObject(m_MyHero).SendAddStorage(UserItem);
          m_ItemList.Delete(I);
          WeightChanged();
          SendDefMessage(SM_HERO_STORAGE_OK,0,0,0,0,'');
          //004DC55E
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('48' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+IntToStr(UserItem.Amount)+')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_MyHero.m_sCharName  + #9 + '[ 亶衿교관 ]');
        end else begin
          SendDefMessage(SM_HERO_STORAGE_FULL,0,0,0,0,'');
        end;
        bo19:=True;
      end else begin
        Merchant:=UserEngine.FindMerchant(NPC);
        if (Merchant <> nil) and
         (Merchant.m_boStorage) and
         (((Merchant.m_PEnvir = m_PEnvir) and
         (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
         (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
        if THeroObject(m_MyHero).m_StorageItemList.Count < STORAGELIMIT then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          if not StdItem.boCanStore or (UserItem.btValue[19] = 1) then begin    //대여템 여관 금지
           SendDefMessage(SM_HERO_STORAGE_FAIL,0,0,0,0,'');
           exit;
          end;
          THeroObject(m_MyHero).m_StorageItemList.Add(UserItem);
          THeroObject(m_MyHero).SendAddStorage(UserItem);
          m_ItemList.Delete(I);
          WeightChanged();
          SendDefMessage(SM_HERO_STORAGE_OK,0,0,0,0,'');
          //004DC55E
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('48' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+IntToStr(UserItem.Amount)+')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_MyHero.m_sCharName  + #9 + '[ 亶衿교관 ]');
        end else begin
          SendDefMessage(SM_HERO_STORAGE_FULL,0,0,0,0,'');
        end;
        bo19:=True;
        end;
      end;
      break;
    end;
  end;
  if not bo19 then SendDefMessage(SM_HERO_STORAGE_FAIL,0,0,0,0,'');
end;


procedure TPlayObject.ClientHeroTakeBackStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: String; nMode:Integer);  //여관        //창고
var
  Merchant:TMerchant;
  I:Integer;
  UserItem:pTUserItem;
  bo19:Boolean;
  StdItem:TItem;
  sUserItemName:String;
begin
  bo19:=False;
  UserItem:=nil;
  if m_boWaitHeroDate or m_boGhost or (m_MyHero = nil) then begin
    SendDefMessage(SM_HERO_TAKEBACKSTORAGEITEM_FAIL,0,0,0,0,'');
    Exit;
  end;
  for I := 0 to m_MyHero.m_StorageItemList.Count - 1 do begin
    UserItem:=m_MyHero.m_StorageItemList.Items[I];

    sUserItemName := '';
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin

      if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
        if (nMode = 1) then begin
          if IsEnoughBag then begin
            StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

            if (UserItem.btValue[19] = 2) then begin  //반짝 여관
              if (UserItem.MaxDate < DateTimeToUnix(now)) then begin
                m_MyHero.m_StorageItemList.Delete(I);
                Dispose(UserItem);
                SysMsg('膠틔"'+ StdItem.Name +'"凜법퍅랍굳쓱爻',c_Red,t_Hint);       //창고
                exit;
              end;
            end;
            if (UserItem.wIndex > 0) and (UserItem.btValue[19] > 2) and (UserItem.MaxDate < DateTimeToUnix(now)) then begin//봉인
              UserItem.btValue[19] := 0;
              UserItem.MaxDate := 0;
              SysMsg(StdItem.Name +'돨룐丹퍅쇌돕퍅죄。',c_Red,t_Hint);
            end;

            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            WeightChanged();
            m_MyHero.m_StorageItemList.Delete(I);
            SendDefMessage(SM_HERO_TAKEBACKSTORAGEITEM_OK,nItemIdx,0,0,0,'');
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('47' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_MyHero.m_sCharName  + #9 + '[亶衿교관 꿴冷]');
          end else begin
            THeroObject(m_MyHero).SendAddStorage(UserItem);
            SendDefMessage(SM_HERO_TAKEBACKSTORAGEITEM_FULLBAG,0,0,0,0,'');
          end;
          bo19:=True;
        end else begin
          Merchant := UserEngine.FindMerchant(NPC);
          if (Merchant <> nil) and
           (Merchant.m_boStorage) and
           (((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC))then begin
          if IsEnoughBag then begin
            StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            WeightChanged();
            m_MyHero.m_StorageItemList.Delete(I);
            SendDefMessage(SM_HERO_TAKEBACKSTORAGEITEM_OK,nItemIdx,0,0,0,'');
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('47' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_MyHero.m_sCharName  + #9 + '[亶衿교관 꿴冷]');
          end else begin
            THeroObject(m_MyHero).SendAddStorage(UserItem);
            SendDefMessage(SM_HERO_TAKEBACKSTORAGEITEM_FULLBAG,0,0,0,0,'');
          end;
          bo19:=True;
          end;
        end;
      end else begin
        THeroObject(m_MyHero).SendAddStorage(UserItem);
        SysMsg(g_sCanotGetItems,c_Red,t_Hint);
      end;
      break;
    end;
  end;
  if not bo19 then SendDefMessage(SM_HERO_TAKEBACKSTORAGEITEM_FAIL,0,0,0,0,'');
end;


procedure TPlayObject.ClientaddBundleItems(mode,MaxAmount:integer;ItemIdx:String);  //물약 겹치는 부분
var
 I,II,minc,dinc,inde,modeidx:Integer;
 MUItem,DUItem:PTUserItem;
 mItemIdx,dItemIdx:Integer;
 stre:string;
begin
  if ItemIdx = '' then Exit;
  minc := -1;
  dinc := -1;
  ItemIdx := GetValidStr3(ItemIdx, stre, ['/']);
  dItemIdx := strtoint(ItemIdx);
  mItemIdx := StrToInt(stre);
  if mode in [0,1,3,45,46,49] then modeidx := MaxAmount;       //물약 개수 20개
  for I := 0 to m_ItemList.Count - 1 do begin
    MUItem:=m_ItemList.Items[i];
    if (MUItem = nil) then Continue;
    if (MUItem <> nil) and (MUItem.MakeIndex = mItemIdx) and (minc < 0) then begin
     minc := I;
    end;
  end;
  for II := 0 to m_ItemList.Count - 1 do begin
    DUItem:=m_ItemList.Items[ii];
    if (DUItem = nil) then Continue;
    if (DUItem <> nil) and (DUItem.MakeIndex = DItemIdx)  and (dinc < 0) then begin
     dinc := II;
    end;
  end;
  if (minc >= 0) and (dinc >= 0) then begin
    if (PTUserItem(m_ItemList.Items[dinc]).Amount + PTUserItem(m_ItemList.Items[minc]).Amount <= modeidx) then begin
      Inc(PTUserItem(m_ItemList.Items[dinc]).Amount,PTUserItem(m_ItemList.Items[minc]).Amount);
      SendAddItemmode(m_ItemList.Items[dinc],0);
      m_ItemList.Delete(minc);
    end else begin
      inde := (PTUserItem(m_ItemList.Items[dinc]).Amount + PTUserItem(m_ItemList.Items[minc]).Amount) -modeidx;
      PTUserItem(m_ItemList.Items[dinc]).Amount := modeidx;
      PTUserItem(m_ItemList.Items[minc]).Amount := inde;
      SendAddItemmode(PTUserItem(m_ItemList.Items[dinc]),0);
      SendAddItemmode(PTUserItem(m_ItemList.Items[minc]),0);
    end;
  end;
end;


procedure TPlayObject.ClientaddBundleStorageItems(mode,MaxAmount:integer;ItemIdx:String); //물약2
var
 I,II,minc,dinc,inde,modeidx:Integer;
 MUItem,DUItem:PTUserItem;
 mItemIdx,dItemIdx:Integer;
 stre:string;
begin
  modeidx := -1;
  if ItemIdx = '' then Exit;
  minc := -1;
  dinc := -1;
  ItemIdx := GetValidStr3(ItemIdx, stre, ['/']);
  dItemIdx := strtoint(ItemIdx);
  mItemIdx := StrToInt(stre);
  if mode in [0,1,3,45,46,49] then modeidx := MaxAmount;       //물약 개수 20개
  for I := 0 to m_StorageItemList.Count - 1 do begin
    MUItem:=m_StorageItemList.Items[i];
    if (MUItem = nil) then Continue;
    if (MUItem <> nil) and (MUItem.MakeIndex = mItemIdx) and (minc < 0) then begin
     minc := I;
    end;
  end;
  for II := 0 to m_StorageItemList.Count - 1 do begin
    DUItem:=m_StorageItemList.Items[ii];
    if (DUItem = nil) then Continue;
    if (DUItem <> nil) and (DUItem.MakeIndex = DItemIdx)  and (dinc < 0) then begin
     dinc := II;
    end;
  end;
  if (minc >= 0) and (dinc >= 0) then begin
    if (PTUserItem(m_StorageItemList.Items[dinc]).Amount + PTUserItem(m_StorageItemList.Items[minc]).Amount <= modeidx) then begin
      Inc(PTUserItem(m_StorageItemList.Items[dinc]).Amount,PTUserItem(m_StorageItemList.Items[minc]).Amount);
      SendAddStorageMode(m_StorageItemList.Items[dinc],0);
      m_StorageItemList.Delete(minc);
    end else begin
      inde := (PTUserItem(m_StorageItemList.Items[dinc]).Amount + PTUserItem(m_StorageItemList.Items[minc]).Amount) -modeidx;
      PTUserItem(m_StorageItemList.Items[dinc]).Amount := modeidx;
      PTUserItem(m_StorageItemList.Items[minc]).Amount := inde;
      SendAddStorageMode(PTUserItem(m_StorageItemList.Items[dinc]),0);
      SendAddStorage(PTUserItem(m_StorageItemList.Items[minc]));
    end;
  end;
end;

procedure TPlayObject.ClientUseItems(nItemIdx: Integer; sItemName: String);//004DB3B0
  function GetUnbindItemName(nShape:Integer):String; //004E4214
  var
    I: Integer;
  begin
    Result:='';
    for I := 0 to g_UnbindList.Count - 1 do begin
      if Integer(g_UnbindList.Objects[I]) = nShape then begin
        Result:=g_UnbindList.Strings[I];
        break;
      end;
    end;
  end;
  function GetUnBindItems(sItemName:String;nCount:Integer):Boolean; //004DB2DC
  var
    I: Integer;
    UserItem:pTUserItem;
    boot:Boolean;
  begin
    Result:=False;
    for I := 0 to nCount - 1 do begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName,UserItem) then begin
        AddItemToBag(UserItem,boot);   //물약
        if m_btRaceServer = RC_PLAYOBJECT then
          if boot then
          SendAddItem(UserItem,1);
        Result:=True;
      end else begin
        Dispose(UserItem);
        break;
      end;
    end;
  end;


  procedure ChangeItemHero(UserItem: pTUserItem; Hero:THeroObject; btMethod: Byte);
  begin
    UserItem.btValue[19] := 0;

    UserItem.btValue[0] := Hero.m_btGender;
    UserItem.btValue[1] := Hero.m_Abil.Level;
    UserItem.btValue[2] := Hero.m_btJob;
    UserItem.btValue[3] := Hero.GetUseMagicCount;
    UserItem.btValue[4] := Hero.m_nHeroGrade;
    UserItem.btValue[5] := Hero.m_btLimitLevel;
    UserItem.btValue[11] := 1;
    //전사 3 7 12 25 26 38
    //술사 1 5 9 10 11 22 23 24 31 32 33 48
    //도사 2 4 6 13 14 15 28 29 36 40
    //자객 59 60 61 63 69 70
    if Hero.m_btJob = 0 then begin        //직업변경
      UserItem.btValue[6] := Hero.GetUseMagicStatus(3);
      UserItem.btValue[7] := Hero.GetUseMagicStatus(7);
      UserItem.btValue[8] := Hero.GetUseMagicStatus(12);
      UserItem.btValue[9] := Hero.GetUseMagicStatus(25);
      UserItem.btValue[10] := Hero.GetUseMagicStatus(26);
      UserItem.btValue[12] := Hero.GetUseMagicStatus(38);
      UserItem.btValue[13] := 0;
      UserItem.btValue[14] := 0;
      UserItem.btValue[15] := 0;
      UserItem.btValue[16] := 0;
      UserItem.btValue[17] := 0;
      UserItem.btValue[18] := 0;
    end;
    if Hero.m_btJob = 1 then begin         //직업변경
      UserItem.btValue[6] := Hero.GetUseMagicStatus(1);
      UserItem.btValue[7] := Hero.GetUseMagicStatus(5);
      UserItem.btValue[8] := Hero.GetUseMagicStatus(9);
      UserItem.btValue[9] := Hero.GetUseMagicStatus(10);
      UserItem.btValue[10] := Hero.GetUseMagicStatus(11);
      UserItem.btValue[12] := Hero.GetUseMagicStatus(22);
      UserItem.btValue[13] := Hero.GetUseMagicStatus(23);
      UserItem.btValue[14] := Hero.GetUseMagicStatus(24);
      UserItem.btValue[15] := Hero.GetUseMagicStatus(31);
      UserItem.btValue[16] := Hero.GetUseMagicStatus(32);
      UserItem.btValue[17] := Hero.GetUseMagicStatus(33);
      UserItem.btValue[18] := Hero.GetUseMagicStatus(48);
    end;
    if Hero.m_btJob = 2 then begin            //직업변경
      UserItem.btValue[6] := Hero.GetUseMagicStatus(2);
      UserItem.btValue[7] := Hero.GetUseMagicStatus(4);
      UserItem.btValue[8] := Hero.GetUseMagicStatus(6);
      UserItem.btValue[9] := Hero.GetUseMagicStatus(13);
      UserItem.btValue[10] := Hero.GetUseMagicStatus(14);
      UserItem.btValue[12] := Hero.GetUseMagicStatus(15);
      UserItem.btValue[13] := Hero.GetUseMagicStatus(28);
      UserItem.btValue[14] := Hero.GetUseMagicStatus(29);
      UserItem.btValue[15] := Hero.GetUseMagicStatus(36);
      UserItem.btValue[16] := Hero.GetUseMagicStatus(40);
      UserItem.btValue[17] := 0;
      UserItem.btValue[18] := 0;
    end;
    if Hero.m_btJob = 3 then begin               //직업변경
      UserItem.btValue[6] := Hero.GetUseMagicStatus(59);
      UserItem.btValue[7] := Hero.GetUseMagicStatus(60);
      UserItem.btValue[8] := Hero.GetUseMagicStatus(61);
      UserItem.btValue[9] := Hero.GetUseMagicStatus(63);
      UserItem.btValue[10] := Hero.GetUseMagicStatus(69);
      UserItem.btValue[12] := Hero.GetUseMagicStatus(70);
      UserItem.btValue[13] := 0;
      UserItem.btValue[14] := 0;
      UserItem.btValue[15] := 0;
      UserItem.btValue[16] := 0;
      UserItem.btValue[17] := 0;
      UserItem.btValue[18] := 0;
    end;
    UserItem.MaxDate    := 0;
    UserItem.DuraMax    := 0;
    UserItem.Amount     := 0;
    UserItem.Dura       := 0;
  end;

  function GetHeroItems(sItemName:String; Hero: THeroObject):Boolean;
  var
    I: Integer;
    UserItem:pTUserItem;
    StdItem:TItem;
    boot:Boolean;
  begin
    Result:=False;
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName,UserItem) then begin
      ChangeItemHero (UserItem, Hero, 2);

      if ItemUnit.AddCustomItemName(UserItem.MakeIndex,UserItem.wIndex, Hero.m_sCharName) then begin
       ItemUnit.SaveCustomItemName();

        AddItemToBag(UserItem,boot);
        if m_btRaceServer = RC_PLAYOBJECT then
          if boot then
          SendAddItem(UserItem,1);
        Result:=True;
      end;
    end else begin
      Dispose(UserItem);
    end;
  end;
var
  I          :Integer;
  boEatOK    :Boolean;
  UserItem   :pTUserItem;
  StdItem    :TItem;
  UserItem34 :TUserItem;
  PetMobName, PetName, sTempStr2, sTempStr3  :String;
  idx,idx2   :Integer;
begin
  boEatOK:=False;
  StdItem:=nil;
  if m_boCanUseItem and (not m_boStore) then begin   //개인상점
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem:=m_ItemList.Items[I];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then begin
        UserItem34:=UserItem^;
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then begin
          if not m_PEnvir.AllowStdItems(Stditem.Name) then begin    //사용금지1
              SysMsg(format(g_sCanotMapUseItemMsg, [StdItem.Name]), c_Red, t_Hint);
              break;
          end;
          if StdItem.boOnlyHero then begin
            SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '늪膠틔怜콘亶衿꼽콘賈痰。');
            SysMsg('늪膠틔怜콘亶衿꼽콘賈痰。', c_Red, t_Hint);
            Break;
          end;
          case StdItem.StdMode of
            0,1,3: begin //물약
                if EatItems(StdItem,UserItem) then begin
                  if (UserItem.Amount > StdItem.MaxAmount) then begin  //물약 버그
                    Dispose(UserItem);
                    m_ItemList.Delete(I);
                    boEatOK:=True;
                  end else begin
                    if (UserItem.Amount > 1) then begin
                      Dec(UserItem.Amount,1);
                      SendAddItemmode(UserItem,3);  //물약
                      boEatOK:=True;
                    end else begin
                      Dispose(UserItem);
                      m_ItemList.Delete(I);
                      boEatOK:=True;
                    end;
                  end;
                end;
              break;
            end;
            2: begin //환템
              if EatItems(StdItem,UserItem) then begin
                Dispose(UserItem);
                m_ItemList.Delete(I);
                boEatOK:=True;
              end;
              break;
            end;
            4: begin //무공책
            if not m_boDeath then begin
              if ReadBook(StdItem) then begin
                Dispose(UserItem);
                m_ItemList.Delete(I);
                boEatOK:=True;
                if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting) then begin
                  ThrustingOnOff(True);
                  SendSocket(nil,'+LNG');
                end;
                if (m_MagicBanwolSkill <> nil) and (not m_boUseHalfMoon) then begin
                  HalfMoonOnOff(True);
                  SendSocket(nil,'+WID');
                end;
              end;
            end;
            end;
            8: begin
              case StdItem.Shape of
                0: begin  //혈룡상자
                  if not m_boDeath then begin
                    Dispose(UserItem);
                    FrmDB.GetDiceGameItems(Self);
                    m_ItemList.Delete(I);
                    boEatOK:=True;
                  end;
                end;
                1: begin  //경매권
                  if not m_boDeath then begin
                    Dispose(UserItem);
                    SendDefMessage(SM_ONAUCTION, 0, 0, 0, 0, '');
                    m_ItemList.Delete(I);
                    boEatOK:=True;
                  end;
                end;
              end;
            end;
            9: begin //영물알
             if not m_boDeath then begin
               idx :=0;
               idx2 := 0;
               idx := FrmDB.LoadPetidx(m_sCharName);
               idx2 := FrmDB.LoadPetNumberidx(m_sCharName, StdItem.Shape);
               if idx < g_Config.PetLimitIdx then begin
                 if idx2 < 1 then begin
                   Dispose(UserItem);
                   m_ItemList.Delete(I);
                   PetMobName:='';
                   PetName:='';
                   sTempStr2 := '';
                   Case StdItem.Shape of
                     0: begin
                       PetMobName := '(쥣膠)괜굔儡';
                       PetName := '괜굔儡';
                     end;
                     1: begin
                       PetMobName := '(쥣膠)鬼샷';
                       PetName := '鬼샷';
                     end;
                     2: begin
                       PetMobName := '(쥣膠)빻챔';
                       PetName := '빻챔';
                     end;
                     3: begin
                       PetMobName := '(쥣膠)太胎쑹쥣';
                       PetName := '太胎쑹쥣';
                     end;
                     4: begin
                       PetMobName := '(쥣膠)겜柰儡';
                       PetName := '겜柰儡';
                     end;
                     5: begin
                       PetMobName := '(쥣膠)笭훙';
                       PetName := '笭훙';
                     end;
                     6: begin
                       PetMobName := '(쥣膠)鬼붚챔';
                       PetName := '鬼붚챔';
                     end;
                     7: begin
                       PetMobName := '(쥣膠)鬼붚질';
                       PetName := '鬼붚질';
                     end;
                     8: begin
                       PetMobName := '(쥣膠)꽈뎔';
                       PetName := '꽈뎔';
                     end;
                     9: begin
                       PetMobName := '(쥣膠)汽훙';
                       PetName := '汽훙';
                     end;
                     10: begin
                       PetMobName := '(쥣膠)행鵠';
                       PetName := '행鵠';
                     end;
                     11: begin
                       PetMobName := '(쥣膠)븝綾';
                       PetName := '븝綾';
                     end;
                   end;
                   if StdItem.AC > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(110) + '.' + IntToStr(StdItem.AC) + ',';
                   if StdItem.AC2 > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(111) + '.' + IntToStr(StdItem.AC2) + ',';
                   if StdItem.MAC > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(112) + '.' + IntToStr(StdItem.MAC) + ',';
                   if StdItem.MAC2 > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(113) + '.' + IntToStr(StdItem.MAC2) + ',';
                   if StdItem.DC > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(114) + '.' + IntToStr(StdItem.DC) + ',';
                   if StdItem.DC2 > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(115) + '.' + IntToStr(StdItem.DC2) + ',';
                   if StdItem.MC > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(116) + '.' + IntToStr(StdItem.MC) + ',';
                   if StdItem.MC2 > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(117) + '.' + IntToStr(StdItem.MC2) + ',';
                   if StdItem.SC > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(118) + '.' + IntToStr(StdItem.SC) + ',';
                   if StdItem.SC2 > 0 then
                     sTempStr2 := sTempStr2 + IntToStr(119) + '.' + IntToStr(StdItem.SC2) + ',';

                   if FrmDB.PetInfoSaveDB(m_sUserID,m_sCharName,PetMobName,PetName,StdItem.Shape,StdItem.DuraMax,StdItem.AniCount,StdItem.Reserved,StdItem.Source,sTempStr2) then begin
                     FrmDB.GetPetInfo(Self);
                     SysMsg('콱뜩돨죄쥣膠' + PetName + '，헝객 E 숩꿴였쥣膠돨야竟橄昑。',c_Red,t_Hint);
                   end;
                   boEatOK:=True;
                 end else begin
                   SysMsg('콱꼇콘谿珂삿돤2몸宮谿돨쥣膠。',c_Red,t_Hint);
                 end;
               end else begin
                 SysMsg('콱꼇콘疼삿돤쥣膠죄。',c_Red,t_Hint);
               end;
             end;
            end;

            14: begin   //영웅 봉인주
                if not m_boDeath then begin
                  if (m_sHeroCharName = '') then begin
                    if (m_MyHero = nil) then begin
                      if UserItem.btValue[11] = 1 then
                        m_sHeroCharName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                      SendDefMessage(SM_HEROINFO, 0, 0, 0, BoolToInt(m_sHeroCharName <> ''), '');
                      ItemUnit.DelCustomItemName(UserItem.MakeIndex,UserItem.wIndex);
                      UserItem.btValue[11]:=0;
                      Dispose(UserItem);
                      m_ItemList.Delete(I);
                      boEatOK:=True;
                    end;
                  end else begin
                    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '亶衿실ダ맡뿐極掠碩켑뿟찾杰鹿콱꼇콘썩역亶衿돨룐丹。');
                  end;
                end;
            end;
            18: begin   //영웅 봉인서
              if not m_boDeath then begin
                if (not m_boWaitHeroDate) and (m_MyHero <> nil) and (not m_MyHero.m_boDeath) and (not m_MyHero.m_boGhost) then begin
                  if THeroObject(m_MyHero).GetCheckUseItem then begin
                    Dispose(UserItem);
                    m_ItemList.Delete(I);
                    GetHeroItems('룐丹瀧', THeroObject(m_MyHero));
                    THeroObject(m_MyHero).LogOut;
                    m_sHeroCharName := '';
                    SendDefMessage(SM_HEROINFO, 0, 0, 0, BoolToInt(m_sHeroCharName <> ''), '');
                    boEatOK:=True;
                  end else begin
                    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '흔벎亶衿누淪膠틔샀교관、꾑욋櫓唐膠틔，橙轟랬룐丹。');
                  end;
                end else begin
                  SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '怜唐瞳梁뻥亶衿돨헙워苟꼽콘賈痰。 ');
                end;
              end;
            end;

            31: begin //묶음 아이템
            if not m_boDeath then begin
              if StdItem.AniCount = 0 then begin
                if (m_ItemList.Count + 1 -1) <= MAXBAGITEM then begin
                  Dispose(UserItem);
                  m_ItemList.Delete(I);
                  GetUnBindItems(GetUnbindItemName(StdItem.Shape),6);
                  boEatOK:=True;
                end;
              end else begin
                if UseStdmodeFunItem(StdItem) then begin
                  if not (StdItem.AniCount = 200) then begin //사제 스승 경험치
                   Dispose(UserItem);
                   m_ItemList.Delete(I);
                   boEatOK:=True;
                  end;
                end;
              end;
            end;
            end;
          end;
        end;
        break;
      end;
  end;
  end else begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotUseItemMsg);
  end;
  if boEatOK then begin
    WeightChanged();
    SendDefMessage(SM_EAT_OK,0,0,0,0,'');
      //004DB73F
    if StdItem.NeedIdentify = 1 then
      AddGameDataLog('11' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem34.Amount) +')' + #9 +
                     IntToStr(UserItem34.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[陋구]');
  end else begin
    SendDefMessage(SM_EAT_FAIL,0,0,0,0,'');
  end;
      
end;
function TPlayObject.UseStdmodeFunItem(StdItem: TItem):Boolean;
begin
  Result:=False;
  if g_FunctionNPC <> nil then begin
    g_FunctionNPC.GotoLable(Self,'@StdModeFunc' + IntToStr(StdItem.AniCount),False);
    Result:=True;
  end;    
end;


procedure TPlayObject.ClientGetButchItem(BaseObject: TBaseObject; nX, nY ,btDir: Integer{;btDir: Byte});//004DB7E0
var
  n10,n14:Integer;
  cret: TObject;
begin
  if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then begin
    if m_PEnvir.IsValidObject(nX,nY,2,BaseObject) then begin
      if BaseObject.m_boDeath and (not BaseObject.m_boSkeleton) and (BaseObject.m_boAnimal) then begin
        n10:=Random(16) + 5;
        n14:=Random(201) + 100;
        Dec(BaseObject.m_nBodyLeathery,n10);
        Dec(BaseObject.m_nMeatQuality,n14);
        if BaseObject.m_nMeatQuality < 0 then BaseObject.m_nMeatQuality:=0;
        if BaseObject.m_nBodyLeathery <= 0 then begin
          if (BaseObject.m_btRaceServer >= RC_ANIMAL) and (BaseObject.m_btRaceServer < RC_MONSTER) then begin
            BaseObject.m_boSkeleton:=True;
            ApplyMeatQuality();
            BaseObject.SendRefMsg(RM_SKELETON,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,'');
          end;
          if not TakeBagItems(BaseObject) then begin
            SysMsg(sYouFoundNothing,c_Red,t_Hint);
          end;
          BaseObject.m_nBodyLeathery:=50;
        end; //004DB945
        m_dwDeathTick:=GetTickCount();
      end;
    end; //004DB953
    m_btDirection:=btDir;
  end;
  SendRefMsg(RM_BUTCH,m_btDirection,m_nCurrX,m_nCurrY,0,'');
end;

procedure TPlayObject.ClientChangeMagicKey(nSkillIdx, nKey: integer); //004DB9A4
var
  I: Integer;
  UserMagic:pTUserMagic;
begin
  for I := 0 to m_MagicList.Count - 1 do begin
    UserMagic:=m_MagicList.Items[i];
    if UserMagic.MagicInfo.wMagicId = nSkillIdx then begin
      UserMagic.btKey:=nKey;
      break;
    end;
  end;
end;

procedure TPlayObject.ClientGroupClose; //004C3C10
begin
  m_boAllowGroup:=False;
  if m_GroupOwner = nil then begin
    exit;
  end;
  m_GroupOwner.DelMember(Self);

  if g_FunctionNPC <> nil then
    g_FunctionNPC.GotoLable(Self,'@GroupClose',False);
end;

procedure TPlayObject.ClientCreateGroup(ProcessMsg: pTProcessMessage); //004DCCB4    그룹 만들기
var
  PlayObject:TPlayObject;
  ItemClass: Boolean;
  GroupHero: Boolean;
  tempstr, tempstr2: string;
  sHumName:String;
begin
  ItemClass := Boolean(ProcessMsg.nParam1);
  GroupHero := Boolean(ProcessMsg.nParam2);
  sHumName := Trim(ProcessMsg.sMsg);
  m_GroupClass := ItemClass;
  m_boCheckHero := GroupHero;
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if m_GroupOwner <> nil then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-1,0,0,0,'');
    exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or PlayObject.m_boGhost then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-2,0,0,0,'');
    exit;
  end;

  if (PlayObject.m_PEnvir.Flag.boDEATHMATCH) or (m_PEnvir.Flag.boDEATHMATCH) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-7,0,0,0,'');
    exit;
  end;

  if (m_PEnvir.Flag.boNotGroup) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-7,0,0,0,'');
    exit;
  end;
  if (PlayObject.m_PEnvir.Flag.boNotGroup) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-8,0,0,0,'');
    exit;
  end;

  if (PlayObject.m_PEnvir.Flag.nMAPGROUP <> m_PEnvir.Flag.nMAPGROUP) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-6,0,0,0,'');
    exit;
  end;

  if (PlayObject.m_GroupOwner <> nil) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-3,0,0,0,'');
    exit;
  end;
  if (not PlayObject.m_boAllowGroup) then begin
    SendDefMessage(SM_CREATEGROUP_FAIL,-4,0,0,0,'');
    exit;
  end;

  if (PlayObject.m_boCheckGroup) then begin
    if ItemClass then
      tempstr := g_sGroupItemClass2
    else
      tempstr := g_sGroupItemClass1;
    if GroupHero then
      tempstr2 := g_sGroupHero1
    else
      tempstr2 := g_sGroupHero2;
    if PlayObject.AddCheckMsg(Format(g_sGroupCheckMsg, [m_sCharName, m_Abil.Level, tempstr, tempstr2]), tmc_Group, Self, 62) <> nil then begin
      SendDefMessage(SM_CREATEGROUP_FAIL, 1, 0, 0, 0, '');
      SysMsg(PlayObject.m_sCharName + '鉞堉談慄§窈',c_BlueGreen,t_Hint);
    end
    else begin
      SendDefMessage(SM_CREATEGROUP_FAIL, 2, 0, 0, 0, '');
      SysMsg(PlayObject.m_sCharName + '앳없속흙鬼莉。',c_BlueGreen,t_Hint);
    end;
    Exit;
  end;
  m_boCheckHero := GroupHero;
  m_GroupClass := ItemClass;
  m_GroupMembers.Clear;
  m_GroupOwner := Self;
  m_GroupMembers.AddObject (sHumName, PlayObject);
  SendGroupMembers(Self);
  m_GroupMembers.AddObject (m_sCharName, self);
  PlayObject.JoinGroup(Self);
  SendGroupMembers(PlayObject);
  m_boAllowGroup := True;
  PlayObject.m_boAllowGroup := TRUE;
  PlayObject.SendDefMessage (SM_CREATEGROUP_OK, 0, 0, 0, 0, '');

  if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self,'@GroupCreate',False);
end;

procedure TPlayObject.AddGroupMember(PlayObject: TPlayObject);
begin
  if m_GroupOwner <> nil then begin   //그룹이 결성되어있는 (초대)
    if (not PlayObject.m_boAllowGroup) then begin    //내가 그룹 거부중이다.
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
      Exit;
    end;
    if m_GroupOwner <> Self then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
      Exit;
    end;
    if (PlayObject.m_PEnvir.Flag.boDEATHMATCH) or (m_PEnvir.Flag.boDEATHMATCH) then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -9, 0, 0, 0, '');
      Exit;
    end;
    if (PlayObject.m_PEnvir.Flag.boNotGroup) then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -9, 0, 0, 0, '');
      Exit;
    end;
    if (m_PEnvir.Flag.boNotGroup) then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -10, 0, 0, 0, '');
      Exit;
    end;
    if (PlayObject.m_PEnvir.Flag.nMAPGROUP <> m_PEnvir.Flag.nMAPGROUP) then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -8, 0, 0, 0, '');
      Exit;
    end;
    if (m_PEnvir.m_boGROUPCOUNT) and ((m_GroupMembers.Count + 1) > m_PEnvir.m_nGROUPCOUNT) then begin
      SendDefMessage(SM_GROUPADDMEM_FAIL,-6,0,0,0,'');
      exit;
    end;
    if (m_GroupMembers.Count + 1) > g_Config.nGroupMembersMax then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, ''); //full
      Exit;
    end;
    if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boGhost or m_boGhost then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
      Exit;
    end;
    if (PlayObject.m_GroupOwner <> nil) then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //이미 다른 그룹이다.
      Exit;
    end;
    if IsGroupMember(PlayObject) then begin
      PlayObject.SendDefMessage (SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, ''); //이미 있다.. 사람이;
      Exit;
    end;
    if (PlayObject.m_PEnvir.m_boGROUPCOUNT) and (m_GroupMembers.Count >= PlayObject.m_PEnvir.m_nGROUPCOUNT) then begin
      SendDefMessage(SM_GROUPADDMEM_FAIL,-7,0,0,0,'');
      exit;
    end;

    m_GroupMembers.AddObject(PlayObject.m_sCharName, PlayObject);
    PlayObject.JoinGroup(Self);
    SendGroupMembers(PlayObject);

    if g_FunctionNPC <> nil then
    g_FunctionNPC.GotoLable(Self,'@GroupCreate',False);
  end
  else begin       //그룹 처음 결정
    if (not PlayObject.m_boAllowGroup) then begin    //상대가 그룹 거부중
      PlayObject.SendDefMessage (SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
      Exit;
    end;
    if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boGhost or m_boGhost then begin      //상대가 없거나 나이거나,,
      PlayObject.SendDefMessage (SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      Exit;
    end;
    if (PlayObject.m_PEnvir.Flag.boDEATHMATCH) or (m_PEnvir.Flag.boDEATHMATCH) then begin   //상대가 데스매치이거나 내가 데스매치
      PlayObject.SendDefMessage (SM_CREATEGROUP_FAIL, -7, 0, 0, 0, '');
      exit;
    end;
    if (PlayObject.m_PEnvir.Flag.boNotGroup) then begin
      PlayObject.SendDefMessage(SM_CREATEGROUP_FAIL,-7,0,0,0,'');
      exit;
    end;
    if (m_PEnvir.Flag.boNotGroup) then begin
      PlayObject.SendDefMessage(SM_CREATEGROUP_FAIL,-8,0,0,0,'');
      exit;
    end;
    if (PlayObject.m_PEnvir.Flag.nMAPGROUP <> m_PEnvir.Flag.nMAPGROUP) then begin       //지역이 다르다거나.
      PlayObject.SendDefMessage (SM_CREATEGROUP_FAIL, -6, 0, 0, 0, '');
      exit;
    end;
    if (PlayObject.m_GroupOwner <> nil) then begin      //상대가 그룹을 이미 맺고있다.
      PlayObject.SendDefMessage (SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
      Exit;
    end;
    m_GroupMembers.Clear;
    m_GroupOwner := Self;
    m_GroupMembers.AddObject(m_sCharName, Self);
    SendGroupMembers(Self);
    m_GroupMembers.AddObject(PlayObject.m_sCharName, PlayObject);
    PlayObject.JoinGroup(Self);
    SendGroupMembers(PlayObject);
    m_boAllowGroup := True;
    PlayObject.m_boAllowGroup := True;
    SendDefMessage(SM_CREATEGROUP_OK, 0, 0, 0, 0, '');

    if g_FunctionNPC <> nil then
    g_FunctionNPC.GotoLable(Self,'@GroupCreate',False);
  end;
end;

procedure TPlayObject.ClientAddGroupMember(sHumName: String); //004DCE48
var
  PlayObject:TPlayObject;
  i: integer;
  tempstr, tempstr2: String;
begin
  PlayObject:=UserEngine.GeTPlayObject(sHumName);

  if m_GroupOwner <> Self then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-1,0,0,0,'');
    exit;
  end;

  if (PlayObject.m_PEnvir.Flag.boDEATHMATCH) or (m_PEnvir.Flag.boDEATHMATCH) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-9,0,0,0,'');
    exit;
  end;
  if (m_PEnvir.Flag.boNotGroup) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-9,0,0,0,'');
    exit;
  end;
  if (PlayObject.m_PEnvir.Flag.boNotGroup) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-10,0,0,0,'');
    exit;
  end;
  if (PlayObject.m_PEnvir.Flag.nMAPGROUP <> m_PEnvir.Flag.nMAPGROUP) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-8,0,0,0,'');
    exit;
  end;

  if (m_PEnvir.m_boGROUPCOUNT) and ((m_GroupMembers.Count + 1) > m_PEnvir.m_nGROUPCOUNT) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-6,0,0,0,'');
    exit;
  end;

  if (m_GroupMembers.Count + 1) > g_Config.nGroupMembersMax then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-5,0,0,0,'');
    exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath  or PlayObject.m_boGhost then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-2,0,0,0,'');
    exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-3,0,0,0,'');
    exit;
  end;
  if (not PlayObject.m_boAllowGroup) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-4,0,0,0,'');
    exit;
  end;

  if (PlayObject.m_PEnvir.m_boGROUPCOUNT) and (m_GroupMembers.Count >= PlayObject.m_PEnvir.m_nGROUPCOUNT) then begin
    SendDefMessage(SM_GROUPADDMEM_FAIL,-7,0,0,0,'');
    exit;
  end;

  for i := 0 to m_GroupMembers.Count - 1 do begin // 버그패치
      // 중복 확인
      if (m_GroupMembers.Objects[i] = nil ) then
      begin
         MainOutMessage('댄轎：莉逃路릿。');
      end
      else
      begin
         if CompareText(TBaseObject(m_GroupMembers.Objects[i]).m_sCharName, PlayObject.m_sCharName) = 0 then begin
            SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, ''); //이미 있음
            exit;
         end;
      end;
   end;

   if (PlayObject.m_boCheckGroup) then begin
    if m_GroupClass then
      tempstr := g_sGroupItemClass2
    else
      tempstr := g_sGroupItemClass1;
    if m_boCheckHero then
      tempstr2 := g_sGroupHero1
    else
      tempstr2 := g_sGroupHero2;
    if PlayObject.AddCheckMsg(Format(g_sGroupCheckMsg, [m_sCharName, m_Abil.Level, tempstr, tempstr2]), tmc_Group, Self, 32) <> nil then begin
      SendDefMessage(SM_CREATEGROUP_FAIL, 1, 0, 0, 0, '');
      SysMsg(PlayObject.m_sCharName + '鉞堉談慄§窈',c_BlueGreen,t_Hint);
    end
    else begin
      SendDefMessage(SM_CREATEGROUP_FAIL, 2, 0, 0, 0, '');
      SysMsg(PlayObject.m_sCharName + '앳없속흙鬼莉。',c_BlueGreen,t_Hint);
    end;
    Exit;
  end;
  m_GroupMembers.AddObject(sHumName, PlayObject);
  PlayObject.JoinGroup(Self);
  SendGroupMembers(PlayObject);
end;

procedure TPlayObject.ClientDelGroupMember(sHumName: String); //004DCFB8
var
  PlayObject:TPlayObject;
begin
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject = nil then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL,-2,0,0,0,'');
    exit;
  end;
  if not IsGroupMember(PlayObject) then begin
    SendDefMessage(SM_GROUPDELMEM_FAIL,-3,0,0,0,'');
    exit;
  end;
  DelMember(PlayObject);
  SendDefMessage(SM_GROUPDELMEM_OK,0,0,0,0,sHumName);

  if g_FunctionNPC <> nil then
    g_FunctionNPC.GotoLable(Self,'@GroupDelMember',False);
end;



procedure TPlayObject.ClientRentalTry(sHumName: String); //004DD0A8         //대여
var
  BaseObject:TBaseObject;
  idx1,idx2:integer;
begin
  if m_boRentaling or m_boStore then exit;
  if GetTickCount - m_RentalLastTick < g_Config.dwTryRentalTime{3000} then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sPleaseTryRentalLaterMsg);
    exit;
  end;

  if not m_boCanRental then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotTryRentalMsg);
    exit;
  end;
  BaseObject:=GetPoseCreate();
  if (BaseObject <> nil) and (BaseObject <> self) then begin
    if (BaseObject.GetPoseCreate = Self) and (not BaseObject.m_boRentaling) then begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
        idx1 := FrmDB.LoadRentalidx(BaseObject.m_sCharName);  //상대방 빌린 갯수
        idx2 := FrmDB.LoadOwneridx(m_sCharName);   //내가 빌려준 갯수
        if ((idx1 <= 0) and (idx2 <= 0)) then begin
          if (BaseObject.m_boAllowRental and TPlayObject(BaseObject).m_boCanRental) then begin
            TPlayObject(Self).OpenRentalDlg(BaseObject,0);
            TPlayObject(BaseObject).OpenRentalDlg(Self,1);
          end else begin //004DD1CC
            SysMsg(g_sPoseDisableDealMsg,c_Red,t_Hint);
          end;
        end else begin
          SysMsg('怜콘슥弄寧숭膠틔。',c_Red,t_Hint);
        end;
      end;

    end else begin //004DD1E0
      SendDefMessage(SM_RENTALTRY_FAIL,0,0,0,0,'');
    end;

  end else begin //004DD1F9
      SendDefMessage(SM_RENTALTRY_FAIL,0,0,0,0,'');
  end;
    
end;

procedure TPlayObject.ClientCheckMsg(tClass: TCheckMsgClass; AddPointer: Pointer; nSelect: Integer);
var
  PlayObject: TPlayObject;
begin
  try
    PlayObject := TPlayObject(AddPointer);
    if (PlayObject <> nil) and (not PlayObject.m_boGhost) then begin
      if PlayObject.m_nCheckMsgArr[tClass] > 0 then
        Dec(PlayObject.m_nCheckMsgArr[tClass]);

      if m_boGhost or (nSelect = -1) then
        exit;
      if tClass = tmc_Group then begin
        case nSelect of
          0: PlayObject.SysMsg(Format('%s앳없속흙莉廉。', [m_sCharName]), c_BlueGreen, t_Hint);
          1: PlayObject.AddGroupMember(Self);
        end;
      end
      else if tClass = tmc_Guild then begin
     {   case nSelect of
          0: PlayObject.SysMsg(Format(g_sGuildIsCheckMsgNo, [m_sCharName]), c_red, t_Hint);
          1: PlayObject.GuildAddMember(Self);
        end;    }
      end
      else if tClass = tmc_Friend then begin
       { case nSelect of
          0: PlayObject.SysMsg(Format(g_sFriendIsCheckMsgNo, [m_sCharName]), c_red, t_Hint);
          1: PlayObject.SetFriend(Self);
        end; }
      end
      else if tClass = tmc_Deal then begin
     {   case nSelect of
          0: PlayObject.SysMsg(Format(g_sDealIsCheckMsgNo, [m_sCharName]), c_red, t_Hint);
          1: PlayObject.SetDeal(Self);
        end;  }
      end
      else if tClass = tmc_Time then begin
        case nSelect of
          0: PlayObject.SysMsg(Format('[%s]앳없쌈肝侶숭膠틔。', [m_sCharName]), c_red, t_Hint);
          1: g_FunctionNPC.GotoLable(PlayObject, '@LoginTimeItem' + IntToStr(n_sLoginCount - 1), False );
        end;
      end;
    end;
  except
    on E: Exception do begin
      MainOutMessage(E.Message);
      MainOutMessage('[Exception] TPlayObject.ClientCheckMsg');
    end;

  end;
end;

procedure TPlayObject.ClientGetCheckMsg(ProcessMsg: pTProcessMessage);
var
  Msg: pTCheckMsg;
  i: Integer;
  CheckMsg: pTCheckMsg;
  nSelect: Integer;
begin
  CheckMsg := pTCheckMsg(ProcessMsg.nParam1);
  nSelect := ProcessMsg.wParam;
  if m_CheckMsgList.Count > 0 then begin
    for i := 0 to m_CheckMsgList.Count - 1 do begin
      Msg := m_CheckMsgList.Items[i];
      if (Msg <> nil) and (Msg = CheckMsg) then begin
        ClientCheckMsg(Msg.tClass, msg.AllPurpose, nSelect);
        DisPose(Msg);
        m_CheckMsgList.Delete(i);
        break;
      end;
    end;
  end;
end;


procedure TPlayObject.ClientDealTry(sHumName: String); //004DD0A8         //거래
var
  BaseObject:TBaseObject;
begin
  if g_Config.boDisableDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sDisableDealItemsMsg);
    exit;
  end;
  if m_boDealing or m_boStore then exit;
  if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime{3000} then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sPleaseTryDealLaterMsg);
    exit;
  end;

  if not m_boCanDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sCanotTryDealMsg);
    exit;
  end;  
  BaseObject:=GetPoseCreate();
  if (BaseObject <> nil) and (BaseObject <> self) then begin
    if (BaseObject.GetPoseCreate = Self) and (not BaseObject.m_boDealing) then begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
        if (BaseObject.m_boAllowDeal and TPlayObject(BaseObject).m_boCanDeal) then begin
          BaseObject.SysMsg(m_sCharName + g_sOpenedDealMsg,c_Green,t_Hint);
          SysMsg(BaseObject.m_sCharName + g_sOpenedDealMsg,c_Green,t_Hint);
          TPlayObject(Self).OpenDealDlg(BaseObject);
          TPlayObject(BaseObject).OpenDealDlg(Self);
        end else begin //004DD1CC
          SysMsg(g_sPoseDisableDealMsg,c_Red,t_Hint);
        end;
      end;

    end else begin //004DD1E0
      SendDefMessage(SM_DEALTRY_FAIL,0,0,0,0,'');
    end;

  end else begin //004DD1F9
      SendDefMessage(SM_DEALTRY_FAIL,0,0,0,0,'');
  end;
    
end;


procedure TPlayObject.ClientAddDealItem(nItemIdx: integer; sItemName: String; nAmount:Integer); //004DD79C  //거래 //물약
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  sUserItemName:String;
  UserItem2:pTUserItem;
  StdItem:TItem;
begin
  if (m_DealCreat = nil) or (not m_boDealing) then exit;
  if Pos(' ',sItemName) >= 0 then begin //粮롸膠틔츰냔(斤숭膠틔돨츰냔빈충속죄賈痰늴鑒)
    GetValidStr3(sItemName,sItemName,[' ']);
  end;
  bo11:=False;
  if not m_DealCreat.m_boDealOK then begin
    for I := 0 to m_Itemlist.Count - 1 do begin
      if m_ItemList.Count <= 0 then Break;       //물약
      UserItem:=m_Itemlist.Items[i];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := FilterStdShowName(StdItem,sUserItemName);

        if (CompareText(sUserItemName,sItemName) = 0) and
           (m_DealItemList.Count < 10) then begin    //거래 아이템 갯수

        if StdItem <> nil then begin
          if (not StdItem.boCanTrade) or (UserItem.btValue[19] > 0) then begin //반짝 대여템 봉인 아이템 거래 불가
           SendDefMessage(SM_DEALADDITEM_FAIL,0,0,0,0,'');
           SendMsg(Self,RM_MENU_OK,0,integer(Self),0,0, StdItem.Name + '角寧숭轟랬슥弄돨膠틔。');
           exit;
          end;
        end;
          if (UserItem.Amount > nAmount) then begin
            New(UserItem2);
            if UserEngine.CopyToUserItemFromName2(UserEngine.GetStdItem(UserItem.wIndex).Name,UserItem2,UserItem,nAmount) then begin     //물약
             m_DealItemList.Add(UserItem2);
             TPlayObject(Self).SendAddDealItem(UserItem2);
             dec(UserItem.Amount,nAmount);
            end else begin
             Dispose(UserItem2);
            end;
          end else begin
            m_DealItemList.Add(UserItem);
            m_Itemlist.Delete(i);
            TPlayObject(Self).SendAddDealItem(UserItem);
          end;

          bo11:=True;
          break;
        end;
      end;
    end;
  end; //004DDAA7
  if not bo11 then
    SendDefMessage(SM_DEALADDITEM_FAIL,0,0,0,0,'');
end;



procedure TPlayObject.ClientDelDealItem(nItemIdx: integer; sItemName: String); //거래
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  sUserItemName:String;
  StdItem: TItem;
begin

  if g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL,0,0,0,0,'');
    exit;
  end;

  if (m_DealCreat = nil) or (not m_boDealing) then exit;

  if Pos(' ',sItemName) >= 0 then begin //粮롸膠틔츰냔(斤숭膠틔돨츰냔빈충속죄賈痰늴鑒)
    GetValidStr3(sItemName,sItemName,[' ']);
  end;

  bo11:=False;
  if not m_DealCreat.m_boDealOK then begin
    for I := 0 to m_DealItemList.Count - 1 do begin
      if m_DealItemList.Count <= 0 then Break;  //물약
      UserItem:=m_DealItemList.Items[i];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := FilterStdShowName(StdItem,sUserItemName);

        if CompareText(sUserItemName,sItemName) = 0 then begin
          m_Itemlist.Add(UserItem);
          TPlayObject(Self).SendDelDealItem(UserItem);
          m_DealItemList.Delete(i);
          bo11:=True;
          break;
        end;
      end;
    end;
  end; //004DDAA7
  if not bo11 then
    SendDefMessage(SM_DEALDELITEM_FAIL,0,0,0,0,'');
end;

procedure TPlayObject.ClientDelDealItem2(nItemIdx: integer; sItemName: String); //거래
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  sUserItemName:String;
  StdItem: TItem;
begin
  
  if g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sDealItemsDenyGetBackMsg2);
    SendDefMessage(SM_DEALDELITEM_FAIL,0,0,0,0,'');
    exit;
  end;

  if (m_DealCreat = nil) or (not m_boDealing) then exit;

  if Pos(' ',sItemName) >= 0 then begin
    GetValidStr3(sItemName,sItemName,[' ']);
  end;

  bo11:=False;
  if not m_DealCreat.m_boDealOK then begin
    for I := 0 to m_DealItemList.Count - 1 do begin
      if m_DealItemList.Count <= 0 then Break;  //물약
      UserItem:=m_DealItemList.Items[i];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin

        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := FilterStdShowName(StdItem,sUserItemName);

        if CompareText(sUserItemName,sItemName) = 0 then begin
          m_Itemlist.Add(UserItem);
          TPlayObject(Self).SendDelDealItem(UserItem);
          m_DealItemList.Delete(i);
          bo11:=True;
          break;
        end;
      end;
    end;
  end; //004DDAA7
  if not bo11 then
    SendDefMessage(SM_DEALDELITEM_FAIL,0,0,0,0,'');
end;

procedure TPlayObject.ClientCancelDeal;//004DD450       //거래
begin
  DealCancel();
end;

procedure TPlayObject.ClientChangeDealGold(nGold: Integer); //004DDB04    //거래
var
  bo09:Boolean;
begin

  //쐐岺혤쀼렴흙슥弄으코돨쏜귑
  if (m_nDealGolds > 0) and g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL,0,0,0,0,'');
    exit;
  end;
  
  if nGold < 0 then begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL,m_nDealGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
    exit;
  end;
  bo09:=False;
  if (m_DealCreat <> nil) and (GetPoseCreate = m_DealCreat) then begin
    if not m_DealCreat.m_boDealOK then begin
      if (m_nGold + m_nDealGolds) >= nGold then begin
       // m_nGold:=(m_nGold + m_nDealGolds) - nGold;
        IncGold(m_nDealGolds);
        DecGold(nGold);
        m_nDealGolds:=nGold;
        SendDefMessage(SM_DEALCHGGOLD_OK,m_nDealGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
        TPlayObject(m_DealCreat).SendDefMessage(SM_DEALREMOTECHGGOLD,m_nDealGolds,0,0,0,'');
        m_DealCreat.m_DealLastTick:=GetTickCount();
        bo09:=True;
        m_DealLastTick:=GetTickCount();
      end; //004DDC50
    end;
  end;
  if not bo09 then begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL,m_nDealGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
  end;
    
end;

procedure TPlayObject.ClientDealEnd;//004DDC8C      //물약       //거래
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  StdItem:TItem;
  PlayObject:TPlayObject;
  boot:Boolean;
begin
  m_boDealOK:=True;
  if m_DealCreat = nil then exit;
  if ((GetTickcount - m_DealLastTick) < g_Config.dwDealOKTime{1000}) or ((GetTickcount - m_DealCreat.m_DealLastTick) < g_Config.dwDealOKTime{1000}) then begin
    SysMsg(g_sDealOKTooFast,c_Red,t_Hint);
    DealCancel();
    exit;
  end;
  if m_DealCreat.m_boDealOK then begin
    bo11:=True;
    if (MAXBAGITEM - m_ItemList.Count) < m_DealCreat.m_DealItemList.Count  then begin
      bo11:=False;
      SysMsg(g_sYourBagSizeTooSmall,c_Red,t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_DealCreat.m_nDealGolds then begin
      SysMsg(g_sYourGoldLargeThenLimit,c_Red,t_Hint);
      bo11:= False;
    end;
    if (MAXBAGITEM - m_DealCreat.m_ItemList.Count) < m_DealItemList.Count then begin
      SysMsg(g_sDealHumanBagSizeTooSmall,c_Red,t_Hint);
      bo11:=False;
    end;
    if (m_DealCreat.m_nGoldMax - m_DealCreat.m_nGold) < m_nDealGolds then begin
      SysMsg(g_sDealHumanGoldLargeThenLimit,c_Red,t_Hint);
      bo11:= False;
    end;
    if bo11 then begin
      for I := 0 to m_DealItemList.Count - 1 do begin
        UserItem:=m_DealItemList.Items[i];
        if UserItem = nil then Continue;
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          m_DealCreat.AddItemToBag(UserItem,boot);
          if boot then
          TPlayObject(m_DealCreat).SendAddItem(UserItem,1);
        if StdItem <> nil then begin
       //   if not IsCheapStuff(StdItem.StdMode) then begin
            //004DDF49
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')'+ #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_DealCreat.m_sCharName + #9 + '[슥弄]');
        //  end;
        end;          
      end; //004DDF5A
      if m_nDealGolds > 0 then begin
      //  Inc(m_DealCreat.m_nGold,m_nDealGolds);
        m_DealCreat.IncGold(m_nDealGolds);
        m_DealCreat.GoldChanged();
            //004DE05E
          if g_boGameLogGold then
            AddGameDataLog('8' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(m_nGold) + #9 +
                     '1' + #9 +
                     m_DealCreat.m_sCharName + #9 + '[슥弄]');
      end;
      for I := 0 to m_DealCreat.m_DealItemList.Count - 1 do begin
        UserItem:=m_DealCreat.m_DealItemList.Items[i];
        if UserItem = nil then Continue;
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

          AddItemToBag(UserItem,boot);
          if boot then
          TPlayObject(Self).SendAddItem(UserItem,1);

        if StdItem <> nil then begin
       //   if not IsCheapStuff(StdItem.StdMode) then begin
            //004DE217
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' +  #9 +
                     m_DealCreat.m_sMapName + #9 +
                     IntToStr(m_DealCreat.m_nCurrX) + #9 +
                     IntToStr(m_DealCreat.m_nCurrY) + #9 +
                     m_DealCreat.m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_sCharName + #9 + '[슥弄]');
       //   end;
        end;          
      end; //004DDF5A
      if m_DealCreat.m_nDealGolds > 0 then begin
       // Inc(m_nGold,m_DealCreat.m_nDealGolds);
        IncGold(m_DealCreat.m_nDealGolds);
        GoldChanged();
            //004DE36E
          if g_boGameLogGold then
            AddGameDataLog('8' +  #9 +
                     m_DealCreat.m_sMapName + #9 +
                     IntToStr(m_DealCreat.m_nCurrX) + #9 +
                     IntToStr(m_DealCreat.m_nCurrY) + #9 +
                     m_DealCreat.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(m_DealCreat.m_nGold) + #9 +
                     '1' + #9 +
                     m_sCharName + #9 + '[슥弄]');
      end;
      //004DE37
      PlayObject:=TPlayObject(m_DealCreat);
      PlayObject.SendDefMessage(SM_DEALSUCCESS,0,0,0,0,'');
      PlayObject.SysMsg(g_sDealSuccessMsg,c_Green,t_Hint);
      PlayObject.m_DealCreat:=nil;
      PlayObject.m_boDealing:=False;
      PlayObject.m_DealItemList.Clear;
      PlayObject.m_nDealGolds:=0;
      PlayObject.m_boDealOK:=False;

      SendDefMessage(SM_DEALSUCCESS,0,0,0,0,'');
      SysMsg(g_sDealSuccessMsg,c_Green,t_Hint);
      m_DealCreat:=nil;
      m_boDealing:=False;
      m_DealItemList.Clear;
      m_nDealGolds:=0;
      m_boDealOK:=False;
    end else begin //004DE42F
      DealCancel();
    end;
  end else begin //004DE439
    SysMsg(g_sYouDealOKMsg,c_Green,t_Hint);
    m_DealCreat.SysMsg(g_sPoseDealOKMsg,c_Green,t_Hint);
  end;
end;


{----------------------------------}


procedure TPlayObject.ClientAddRentalItem(nItemIdx: integer; sItemName: String; nAmount,nDay:Integer); //004DD79C  //대여//물약
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  sUserItemName:String;
  UserItem2:pTUserItem;
  StdItem:TItem;
begin
  if (m_RentalCreat = nil) or (not m_boRentaling) then exit;
  if Pos(' ',sItemName) >= 0 then begin //粮롸膠틔츰냔(斤숭膠틔돨츰냔빈충속죄賈痰늴鑒)
    GetValidStr3(sItemName,sItemName,[' ']);
  end;
  bo11:=False;
  if not m_RentalCreat.m_boRentalOK then begin
    for I := 0 to m_Itemlist.Count - 1 do begin
      if m_ItemList.Count <= 0 then Break;       //물약
      UserItem:=m_Itemlist.Items[i];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := FilterStdShowName(StdItem,sUserItemName);

        if (CompareText(sUserItemName,sItemName) = 0) and
           (m_RentalItemList.Count < 1) then begin    //대여 아이템 갯수

          if StdItem <> nil then begin
            if not (StdItem.StdMode in [5,6,90,99,12,10,11,15,19,20,21,22,23,24,26,62,64]) then begin  //대여 기간적용
             SendDefMessage(SM_RENTALADDITEM_FAIL,0,0,0,0,'');
             SendMsg(Self,RM_MENU_OK,0,integer(Self),0,0, StdItem.Name + '角寧숭轟랬理썼돨膠틔。');
             exit;
            end;
            if (CanRentalItem(StdItem.Name)) or (not StdItem.boCanTrade) or (UserItem.btValue[19] > 0) or (StdItem.StdMode = 14) then begin //대여템 봉인 반짝 대여불가 설정
             SendDefMessage(SM_RENTALADDITEM_FAIL,0,0,0,0,'');
             SendMsg(Self,RM_MENU_OK,0,integer(Self),0,0, StdItem.Name + '角寧숭轟랬理썼돨膠틔。');
             exit;
            end;
          end;

          if (nDay > 0) and (nDay < 31) then begin
            m_nRentalDay := nDay;
            SendDefMessage(SM_RENTALCHGDAY_OK,m_nRentalDay,0,0,0,'');
            TPlayObject(m_RentalCreat).SendDefMessage(SM_RENTALREMOTECHGDAY,m_nRentalDay,0,0,0,'');
          end else begin
            SendDefMessage(SM_RENTALADDITEM_FAIL,0,0,0,0,'');
            SendDefMessage(SM_RENTALCHGDAY_FAIL,m_nRentalDay,0,0,0,'');
            SysMsg('理줏돨퍅掘離睦1莖。',c_RedWhite,t_Hint);
            exit;
          end;

          if (UserItem.Amount > nAmount) then begin
            New(UserItem2);
            if UserEngine.CopyToUserItemFromName2(UserEngine.GetStdItem(UserItem.wIndex).Name,UserItem2,UserItem,nAmount) then begin     //물약
             m_RentalItemList.Add(UserItem2);
             TPlayObject(Self).SendAddRentalItem(UserItem2);
             dec(UserItem.Amount,nAmount);
            end else begin
             Dispose(UserItem2);
            end;
          end else begin
            m_RentalItemList.Add(UserItem);
            m_Itemlist.Delete(i);
            TPlayObject(Self).SendAddRentalItem(UserItem);
          end;

          bo11:=True;
          break;
        end;
      end;
    end;
  end; //004DDAA7
  if not bo11 then
    SendDefMessage(SM_RENTALADDITEM_FAIL,0,0,0,0,'');
end;



procedure TPlayObject.ClientDelRentalItem(nItemIdx: integer; sItemName: String);   //대여
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  sUserItemName:String;
  StdItem: TItem;
begin
  
  if g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_RENTALDELITEM_FAIL,0,0,0,0,'');
    exit;
  end;

  if (m_RentalCreat = nil) or (not m_boRentaling) then exit;

  if Pos(' ',sItemName) >= 0 then begin //粮롸膠틔츰냔(斤숭膠틔돨츰냔빈충속죄賈痰늴鑒)
    GetValidStr3(sItemName,sItemName,[' ']);
  end;

  bo11:=False;
  if not m_RentalCreat.m_boRentalOK then begin
    for I := 0 to m_RentalItemList.Count - 1 do begin
      if m_RentalItemList.Count <= 0 then Break;  //물약
      UserItem:=m_RentalItemList.Items[i];
      if UserItem = nil then Continue;
      if UserItem.MakeIndex = nItemIdx then begin

        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := FilterStdShowName(StdItem,sUserItemName);

        if CompareText(sUserItemName,sItemName) = 0 then begin
          m_Itemlist.Add(UserItem);
          TPlayObject(Self).SendDelRentalItem(UserItem);
          m_RentalItemList.Delete(i);
          bo11:=True;
          break;
        end;
      end;
    end;
  end; //004DDAA7
  if not bo11 then
    SendDefMessage(SM_RENTALDELITEM_FAIL,0,0,0,0,'');
end;



procedure TPlayObject.ClientCancelRental;//004DD450         //대여
begin
  RentalCancel();
end;

procedure TPlayObject.ClientChangeRentalGold(nGold: Integer); //004DDB04    //대여
var
  bo09:Boolean;
begin

  //쐐岺혤쀼렴흙슥弄으코돨쏜귑
  if (m_nRentalGolds > 0) and g_Config.boCanNotGetBackDeal then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_RENTALDELITEM_FAIL,0,0,0,0,'');
    exit;
  end;
  
  if nGold < 0 then begin
    SendDefMessage(SM_RENTALCHGGOLD_FAIL,m_nRentalGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
    exit;
  end;
  bo09:=False;
  if (m_RentalCreat <> nil) and (GetPoseCreate = m_RentalCreat) then begin
    if not m_RentalCreat.m_boRentalOK then begin
      if (m_nGold + m_nRentalGolds) >= nGold then begin
       // m_nGold:=(m_nGold + m_nRentalGolds) - nGold;
        IncGold(m_nRentalGolds);
        DecGold(nGold);
        m_nRentalGolds:=nGold;
        SendDefMessage(SM_RENTALCHGGOLD_OK,m_nRentalGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
        TPlayObject(m_RentalCreat).SendDefMessage(SM_RENTALREMOTECHGGOLD,m_nRentalGolds,0,0,0,'');
        m_RentalCreat.m_RentalLastTick:=GetTickCount();
        bo09:=True;
        m_RentalLastTick:=GetTickCount();
      end; //004DDC50
    end;
  end;
  if not bo09 then begin
    SendDefMessage(SM_RENTALCHGGOLD_FAIL,m_nRentalGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
  end;

end;

procedure TPlayObject.ClientRentalEnd;//004DDC8C      //물약        //대여
var
  I: Integer;
  bo11:Boolean;
  UserItem:pTUserItem;
  StdItem:TItem;
  PlayObject:TPlayObject;
  boot:Boolean;
  nDateNow2: Integer;
begin
  m_boRentalOK:=True;
  if m_RentalCreat = nil then exit;
  if ((GetTickcount - m_RentalLastTick) < g_Config.dwRentalOKTime{1000}) or ((GetTickcount - m_RentalCreat.m_RentalLastTick) < g_Config.dwRentalOKTime{1000}) then begin
    SysMsg(g_sDealOKTooFast,c_Red,t_Hint);
    RentalCancel();
    exit;
  end;
  if m_RentalCreat.m_boRentalOK then begin
    bo11:=True;
    if (MAXBAGITEM - m_ItemList.Count) < m_RentalCreat.m_RentalItemList.Count  then begin
      bo11:=False;
      SysMsg(g_sYourBagSizeTooSmall,c_Red,t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_RentalCreat.m_nRentalGolds then begin
      SysMsg(g_sYourGoldLargeThenLimit,c_Red,t_Hint);
      bo11:= False;
    end;
    if (MAXBAGITEM - m_RentalCreat.m_ItemList.Count) < m_RentalItemList.Count then begin
      SysMsg(g_sDealHumanBagSizeTooSmall,c_Red,t_Hint);
      bo11:=False;
    end;
    if (m_RentalCreat.m_nGoldMax - m_RentalCreat.m_nGold) < m_nRentalGolds then begin
      SysMsg(g_sDealHumanGoldLargeThenLimit,c_Red,t_Hint);
      bo11:= False;
    end;



    if bo11 then begin
      for I := 0 to m_RentalItemList.Count - 1 do begin
        UserItem:=m_RentalItemList.Items[i];
        if UserItem = nil then Continue;
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

        FrmDB.RentalItem(UserItem,m_RentalCreat.m_sCharName,m_sCharName,m_nRentalDay);

        if (StdItem.StdMode in [5,6,90,99,12,10,11,15,19,20,21,22,23,24,26,62,64]) then begin  //대여 기간적용
          nDateNow2:=DateTimeToUnix(IncDay(now(), m_nRentalDay ));
          UserItem.MaxDate := nDateNow2;
          UserItem.btValue[19]:=1;
          StdItem.Owner := m_sCharName;
        end;
          m_RentalCreat.AddItemToBag(UserItem,boot);
          if boot then
          TPlayObject(m_RentalCreat).SendAddItem(UserItem,1);

        if StdItem <> nil then begin
       //   if not IsCheapStuff(StdItem.StdMode) then begin
            //004DDF49
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('29' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_RentalCreat.m_sCharName + #9 + '[놔理-澗돕]');
       //   end;
        end;          
      end; //004DDF5A
      if m_nRentalGolds > 0 then begin
     //   Inc(m_RentalCreat.m_nGold,m_nRentalGolds);
        m_RentalCreat.IncGold(m_nRentalGolds);
        m_RentalCreat.GoldChanged();
            //004DE05E
          if g_boGameLogGold then
            AddGameDataLog('29' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(m_nRentalGolds) + #9 +
                     '1' + #9 +
                     m_RentalCreat.m_sCharName + #9 + '[놔理-澗돕]');
      end;
      for I := 0 to m_RentalCreat.m_RentalItemList.Count - 1 do begin
        UserItem:=m_RentalCreat.m_RentalItemList.Items[i];
        if UserItem = nil then Continue;
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

        FrmDB.RentalItem(UserItem,m_sCharName,m_RentalCreat.m_sCharName, m_RentalCreat.m_nRentalDay);

        if (StdItem.StdMode in [5,6,90,99,12,10,11,15,19,20,21,22,23,24,26,62,64]) then begin  //대여 기간적용
          nDateNow2:=DateTimeToUnix(IncDay(now(), m_RentalCreat.m_nRentalDay ));
          UserItem.MaxDate := nDateNow2;
          UserItem.btValue[19]:=1;
          StdItem.Owner := m_RentalCreat.m_sCharName;
        end;

          AddItemToBag(UserItem,boot);
          if boot then
          TPlayObject(Self).SendAddItem(UserItem,1);
        if StdItem <> nil then begin
        //  if not IsCheapStuff(StdItem.StdMode) then begin
            //004DE217
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('29' +  #9 +
                     m_RentalCreat.m_sMapName + #9 +
                     IntToStr(m_RentalCreat.m_nCurrX) + #9 +
                     IntToStr(m_RentalCreat.m_nCurrY) + #9 +
                     m_RentalCreat.m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     m_sCharName + #9 + '[놔理-理놔]');
        //  end;
        end;
      end; //004DDF5A
      if m_RentalCreat.m_nRentalGolds > 0 then begin
       // Inc(m_nGold,m_RentalCreat.m_nRentalGolds);
        IncGold(m_RentalCreat.m_nRentalGolds);
        GoldChanged();
            //004DE36E
          if g_boGameLogGold then
            AddGameDataLog('29' +  #9 +
                     m_RentalCreat.m_sMapName + #9 +
                     IntToStr(m_RentalCreat.m_nCurrX) + #9 +
                     IntToStr(m_RentalCreat.m_nCurrY) + #9 +
                     m_RentalCreat.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(m_RentalCreat.m_nRentalGolds) + #9 +
                     '1' + #9 +
                     m_sCharName + #9 + '[놔理-理놔]');
      end;
      //004DE37
      PlayObject:=TPlayObject(m_RentalCreat);
      PlayObject.SendDefMessage(SM_RENTALSUCCESS,0,0,0,0,'');
      PlayObject.SysMsg(g_sDealSuccessMsg,c_Green,t_Hint);
      PlayObject.m_RentalCreat:=nil;
      PlayObject.m_boRentaling:=False;
      PlayObject.m_RentalItemList.Clear;
      PlayObject.m_nRentalGolds:=0;
      PlayObject.m_nRentalDay :=0;
      PlayObject.m_boRentalOK:=False;

      SendDefMessage(SM_RENTALSUCCESS,0,0,0,0,'');
      SysMsg(g_sDealSuccessMsg,c_Green,t_Hint);
      m_RentalCreat:=nil;
      m_boRentaling:=False;
      m_RentalItemList.Clear;
      m_nRentalGolds:=0;
      m_nRentalDay:=0;
      m_boRentalOK:=False;
    end else begin //004DE42F
      RentalCancel();
    end;
  end else begin //004DE439
    SysMsg(g_sYouDealOKMsg,c_Green,t_Hint);
    m_RentalCreat.SysMsg(g_sPoseDealOKMsg,c_Green,t_Hint);
  end;
end;


//==================================================================


procedure TPlayObject.ClientStartStore(sMsg: string; nItemCount: Integer);    //개인상점
var
  I: Integer;
  sData,sData2: string;
  ItemIndex: TItemIndex;
  UserItem: pTUserItem;
  sUserItemName: string;
  StoreServerItem: pTStoreServerItem;
  n1C, nCount: Integer;

begin
  if m_boStore or m_boDeath or m_boGhost then Exit;

  if not m_PEnvir.m_boOpenStore then begin
    SendDefMessage(SM_SENDSTARTSTORE_FAIL, 0, 0, 0, 0, '');
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '뎠품혐堵쐐岺賈痰絹運');
    Exit;
  end;

  if g_Config.boSafeCanStore then begin
    if not InSafeZone then begin
      SendDefMessage(SM_SENDSTARTSTORE_FAIL, 0, 0, 0, 0, '');
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, '뎠품혐堵쐐岺겠覡。');
      Exit;
    end;
  end;
  if g_Config.boOpenStoreCheckLevel then begin
    if m_WAbil.Level < g_Config.nOpenStoreCheckLevel then begin
      SendDefMessage(SM_SENDSTARTSTORE_FAIL, 0, 0, 0, 0, '');
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, IntToStr(g_Config.nOpenStoreCheckLevel) + '된섬鹿毆탓鹿賈痰絹源┙碧');
      Exit;
    end;
  end;

  GetBackStoreItems();

  n1C := 0;
  nCount := 0;
  while True do begin
    if (sMsg = '') then Break;
    sMsg := GetValidStr3(sMsg, sData, ['/']);
    sMsg := GetValidStr3(sMsg, sData2, ['/']);
    m_sStoreName := sData2;
    if sData <> '' then begin
      DecodeBuffer(sData, @ItemIndex, SizeOf(TItemIndex));
      if ItemIndex.ItemName = '' then Continue;
      for I := 0 to m_ItemList.Count - 1 do begin
        UserItem := m_ItemList.Items[I];

        sUserItemName := '';
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if (CompareText(ItemIndex.ItemName, sUserItemName) = 0) and (ItemIndex.MakeIndex = UserItem.MakeIndex) then begin
          n1C := -1;

          if ItemIndex.Price <= 0 then begin
            n1C := -1;
            break;
          end;

          New(StoreServerItem);
          StoreServerItem.btSellType := ItemIndex.btSellType;
          StoreServerItem.UserItem := UserItem^;
          StoreServerItem.Price := ItemIndex.Price;
          m_StoreItemList.Add(StoreServerItem);
          n1C := 0;
          Inc(nCount);
          Break;
        end;
      end;
      if n1C < 0 then Break;
    end else Break;
  end;

  if (n1C < 0) or (nCount <> nItemCount) then begin
    GetBackStoreItems();
    SendDefMessage(SM_SENDSTARTSTORE_FAIL, 0, 0, 0, 0, '');
  end else begin
    m_boStore := True;
    if m_TargetCret <> nil then begin
      if m_TargetCret.m_TargetCret = Self then m_TargetCret.DelTargetCreat;
      m_TargetCret := nil;
    end;
    SendDefMessage(SM_SENDSTARTSTORE_OK, 0, 0, 0, 0, '');
    SendRefMsg(RM_SENDSTORE, m_btDirection, m_nCurrX, m_nCurrY, Integer(m_boStore), '');
    RefShowName;
  end;
end;

procedure TPlayObject.ClientQueryUserStoreState(PlayObject: TPlayObject; nX, nY: Integer);  //개인상점
  function FindBagItem(nMakeIndex: Integer): Integer;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := -1;
    for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
      UserItem := PlayObject.m_ItemList.Items[I];
      if UserItem.MakeIndex = nMakeIndex then begin
        Result := I;
        Break;
      end;
    end;
  end;
var
  I: Integer;
  UserState: TUserStoreStateInfo;
  Item: TItem;
  StdItem: TItem;
  StdItem24: TStdItem;
  sUserItemName: string;
  StoreServerItem: pTStoreServerItem;
  UserItem: TUserItem;
  StoreItem: TStoreItem;
  opt: integer;
begin
  if not TPlayObject(PlayObject).m_boStore or m_boDeath or m_boGhost then Exit;

  if (not CretInNearXY(PlayObject, nX, nY)) or (PlayObject.m_btRaceServer <> RC_PLAYOBJECT) then Exit;

  FillChar(UserState, SizeOf(TUserStoreStateInfo), #0);
  UserState.UserName := PlayObject.m_sCharName;
  UserState.NAMECOLOR := GetCharColor(PlayObject);
  UserState.RecogId := Integer(PlayObject);

  for I := 0 to PlayObject.m_StoreItemList.Count - 1 do begin
    StoreServerItem := pTStoreServerItem(PlayObject.m_StoreItemList.Items[I]);
    UserItem := StoreServerItem.UserItem;
    if (UserItem.wIndex > 0) and (FindBagItem(UserItem.MakeIndex) >= 0) then begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem = nil then Continue;

      StdItem.GetStandardItem(StdItem24);
      opt := StdItem.GetItemAddValue(@UserItem, StdItem24);

      Move(StdItem24, StoreItem.Item.S, SizeOf(TStdItem));

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      StoreItem.Item.s.Name := sUserItemName;
      StoreItem.Item.MakeIndex := UserItem.MakeIndex;
      StoreItem.Item.Dura := UserItem.Dura;
      StoreItem.Item.DuraMax := UserItem.DuraMax;
      StoreItem.btSellType := StoreServerItem.btSellType;
      StoreItem.Item.Amount := UserItem.Amount;
      StoreItem.Item.UpgradeOpt := opt;

      StoreItem.Item.s.Price := StoreServerItem.Price;
      UserState.UseItems[I] := StoreItem;
    end;
  end;

  m_DefMsg := MakeDefaultMsg(SM_USERSTOREITEMS, 0, 0, 0, 0);
  SendSocket(@m_DefMsg, EncodeBuffer(@UserState, SizeOf(TUserStoreStateInfo)));
end;

procedure TPlayObject.ClientBuySroreItem(PlayObject: TPlayObject; sMsg: string);    //개인상점
  function FindBagItem(nMakeIndex: Integer): Integer;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := -1;
    for I := 0 to PlayObject.m_ItemList.Count - 1 do begin
      UserItem := PlayObject.m_ItemList.Items[I];
      if UserItem.MakeIndex = nMakeIndex then begin
        Result := I;
        Break;
      end;
    end;
  end;
var
  I, nIndex: Integer;
  sItemName: string;
  sMakeIndex: string;
  nMakeIndex: Integer;
  sUserItemName: string;
  StdItem: TItem;
  StdItem24: TStdItem;
  StoreServerItem: pTStoreServerItem;
  UserItem: TUserItem;
  Item: pTUserItem;
  ClientItem: TClientItem;
  sSENDTEST: string;
  n1C: Integer;
  btSellType: Integer;
  opt: integer;
begin
  if Self = PlayObject then Exit;

  if UserEngine.GetPlayObject(PlayObject) <> PlayObject then Exit;
  if (PlayObject.m_btRaceServer <> RC_PLAYOBJECT) or (not TPlayObject(PlayObject).m_boStore) then begin
    m_DefMsg := MakeDefaultMsg(SM_SENDBUYSTOREITEM_FAIL, -4, 0, 0, 0);
    SendSocket(@m_DefMsg, '');
    Exit;
  end;
  Item := nil;
  n1C := -2;
  sMsg := GetValidStr3(sMsg, sItemName, ['/']);
  sMsg := GetValidStr3(sMsg, sMakeIndex, ['/']);
  nMakeIndex := Str_ToInt(sMakeIndex, -1);
  nIndex := FindBagItem(nMakeIndex);
  if (sItemName <> '') and (nMakeIndex > 0) and (nIndex >= 0) then begin
    Item := PlayObject.m_ItemList.Items[nIndex];
    for I := 0 to PlayObject.m_StoreItemList.Count - 1 do begin
      StoreServerItem := pTStoreServerItem(PlayObject.m_StoreItemList.Items[I]);
      UserItem := StoreServerItem.UserItem;
      if (UserItem.wIndex > 0) and (StoreServerItem.Price > 0) then begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then Continue;

        StdItem.GetStandardItem(StdItem24);
        opt := StdItem.GetItemAddValue(@UserItem, StdItem24);

        Move(StdItem24, ClientItem.S, SizeOf(TStdItem));


        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem24.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        ClientItem.S.Name := sUserItemName;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.Amount := UserItem.Amount;
        ClientItem.UpgradeOpt := opt;
        if (CompareText(ClientItem.S.Name, sItemName) = 0) and (nMakeIndex = UserItem.MakeIndex) then begin
          btSellType := StoreServerItem.btSellType;
          case StoreServerItem.btSellType of
            0:begin
             if (TPlayObject(PlayObject).m_nGold + StoreServerItem.Price) <= g_Config.nHumanMaxGold then begin
              if m_nGold >= StoreServerItem.Price then begin
                if (m_boStore = False) then begin
                  if IsEnoughBag then begin
                   if not CanConsignItem(StdItem.name) and not CanRentalItem(StdItem.Name) and StdItem.boCanTrade and (UserItem.btValue[19] = 0) then begin
                    DecGold(StoreServerItem.Price);
                    TPlayObject(PlayObject).IncGold(StoreServerItem.Price);
                    GoldChanged;
                    TPlayObject(PlayObject).GoldChanged;


                   if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('35' +  #9 +
                                 m_sMapName + #9 +
                                 IntToStr(m_nCurrX) + #9 +
                                 IntToStr(m_nCurrY) + #9 +
                                 m_sCharName + #9 +
                                 StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                                 IntToStr(UserItem.MakeIndex) + #9 +
                                 '1' + #9 +
                                 IntToStr(StoreServerItem.Price) + #9 +
                                 PlayObject.m_sCharName + #9 + '[몸훙絹 뭔찜(쏜귑)]');

                    m_ItemList.Add(Item);
                    SendAddItem(Item,1);
                    m_DefMsg := MakeDefaultMsg(SM_DELSTOREITEM, 0, 0, 0, 0);
                    sSENDTEST := EncodeBuffer(@ClientItem, SizeOf(TClientItem));
                    SendSocket(@m_DefMsg, sSENDTEST);
                    TPlayObject(PlayObject).SendSocket(@m_DefMsg, sSENDTEST);
                    TPlayObject(PlayObject).SysMsg('膠틔"' + sItemName + '"綠簡놔。 (뭔찜훙: ' + m_sCharName + ')', c_BlueWhite, t_Hint);

                    PlayObject.m_ItemList.Delete(nIndex);
                    PlayObject.m_StoreItemList.Delete(I);
                    Dispose(StoreServerItem);
                    n1C := 0;
                    Break;
                   end else n1C := -7;
                  end else n1C := -3;
                 end else n1C := -5;
                end else n1C := -1;
              end else n1C := -4;
            end;
            1:begin
             if (TPlayObject(PlayObject).m_nGameGold + StoreServerItem.Price) <= 2000000 then begin
              if m_nGameGold >= StoreServerItem.Price then begin
               if (m_boStore = False) then begin
                if IsEnoughBag then begin
                 if not CanConsignItem(StdItem.name) and not CanRentalItem(StdItem.Name) and StdItem.boCanTrade and (UserItem.btValue[19] = 0) then begin
                    DecGameGold(StoreServerItem.Price);
                    TPlayObject(PlayObject).IncGameGold(StoreServerItem.Price);
                    GameGoldChanged;
                    TPlayObject(PlayObject).GameGoldChanged;


                    if StdItem.NeedIdentify = 1 then
                      AddGameDataLog('35' +  #9 +
                                 m_sMapName + #9 +
                                 IntToStr(m_nCurrX) + #9 +
                                 IntToStr(m_nCurrY) + #9 +
                                 m_sCharName + #9 +
                                 StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                                 IntToStr(UserItem.MakeIndex) + #9 +
                                 '1' + #9 +
                                 IntToStr(StoreServerItem.Price) + #9 +
                                 PlayObject.m_sCharName + #9 + '[몸훙絹 뭔찜(듐환)]');

                    m_ItemList.Add(Item);
                    SendAddItem(Item,1);

                    m_DefMsg := MakeDefaultMsg(SM_DELSTOREITEM, 0, 0, 0, 0);
                    sSENDTEST := EncodeBuffer(@ClientItem, SizeOf(TClientItem));
                    SendSocket(@m_DefMsg, sSENDTEST);
                    TPlayObject(PlayObject).SendSocket(@m_DefMsg, sSENDTEST);
                    TPlayObject(PlayObject).SysMsg('膠틔"' + sItemName + '"綠簡놔。 (뭔찜훙: ' + m_sCharName + ')', c_BlueWhite, t_Hint);


                    PlayObject.m_ItemList.Delete(nIndex);
                    PlayObject.m_StoreItemList.Delete(I);
                    Dispose(StoreServerItem);
                    n1C := 0;
                    Break;
                  end else n1C := -7;
                 end else n1C := -3;
                end else n1C := -5;
               end else n1C := -1;
              end else n1C := -6;
            end;

          end;

        end;
      end;
    end;
  end;
  if n1C = 0 then begin
    m_DefMsg := MakeDefaultMsg(SM_SENDBUYSTOREITEM_OK, 0, 0, btSellType, 0);
    SendSocket(@m_DefMsg, '');
  end else begin
    m_DefMsg := MakeDefaultMsg(SM_SENDBUYSTOREITEM_FAIL, n1C, 0, btSellType, 0);
    SendSocket(@m_DefMsg, '');
  end;
end;


procedure TPlayObject.ClientCancelStore;     //개인상점
begin
  StoreCancel();
end;

procedure TPlayObject.ClientCancelEx;//환전 취소
begin
  ExChangeCancel();
end;

procedure TPlayObject.ClientChangeExRate(); //환전 시세
begin
   SendDefMessage(SM_EXCHGRATE,g_Config.nExChangeGoldRate ,0,0,0, FloatToStr(g_Config.nExChangeGameGoldRate));
end;


procedure TPlayObject.ClientChangeExGold(nGold: Integer); //환전   (금전 - 밀환)
begin
  if nGold < 10000 then begin  //만전 이상부터
    SendDefMessage(SM_EXCHGGOLD_FAIL,m_nExGameGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
    exit;
  end;
  if (m_nGold + m_nExGameGolds) >= nGold then begin
      m_nCGolds := nGold;
    //  m_nGold:=(m_nGold + m_nExGameGolds) - nGold;
      IncGold(m_nExGameGolds);
      DecGold(nGold);
      m_nExGameGolds:= Round(nGold * g_Config.nExChangeGameGoldRate);
      SendDefMessage(SM_EXCHGGOLD_OK,m_nExGameGolds,LoWord(m_nGold),HiWord(m_nGold),0,'');
  end;
end;

procedure TPlayObject.ClientChangeExGameGold(nGold: Integer); //환전  (밀환 - 금전)
begin
  if nGold < 0 then begin
    SendDefMessage(SM_EXCHGGAMEGOLD_FAIL,m_nExGolds,LoWord(m_nGameGold),HiWord(m_nGameGold),0,'');
    exit;
  end;
  if (m_nGameGold + m_nExGolds) >= nGold then begin
     m_nCGameGolds := nGold;
     m_nGameGold:=(m_nGameGold + m_nExGolds) - nGold;
     m_nExGolds:=(nGold * g_Config.nExChangeGoldRate);
     SendDefMessage(SM_EXCHGGAMEGOLD_OK,m_nExGolds,LoWord(m_nGameGold),HiWord(m_nGameGold),0,'');
  end;
end;

procedure TPlayObject.ClientExEnd;      //환전 완료
var
 bo11: boolean;
begin
  bo11:=True;
  if (m_nGoldMax - m_nGold) < m_nExGolds then begin
     SysMsg(g_sYourGoldLargeThenLimit,c_Red,t_Hint);
     bo11:=FALSE;
     exit;
  end;
  if (2000000 - m_nGameGold) < m_nExGameGolds then begin
     SysMsg(g_sYourGameGoldLargeThenLimit,c_Red,t_Hint);
     bo11:=FALSE;
     exit;
  end;
  if bo11 then begin
   if m_nExGolds > 0 then begin
    // Inc(m_nGold,m_nExGolds);
     IncGold(m_nExGolds);
     GoldChanged();
     if g_boGameLogGold then
         AddGameDataLog('28' +  #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                sSTRING_GOLDNAME + #9 +
                IntToStr(m_nGold) + #9 +
                '1' + #9 +
                 m_sCharName + #9 + '[뚝뻣]');
   end;

   if m_nExGameGolds > 0 then begin
     Inc(m_nGameGold,m_nExGameGolds);
     GoldChanged();
     if g_boGameLogGold then
         AddGameDataLog('28' +  #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                sSTRING_GAMEGOLDNAME + #9 +
                IntToStr(m_nGameGold) + #9 +
                '1' + #9 +
                 m_sCharName + #9 + '[뚝뻣]');
   end;
  end else begin
    ExChangeCancel;
  end;

  SendDefMessage(SM_EXSUCCESS,0,0,0,0,'');
  SysMsg('뚝뻣綠쒔供냥。',c_Green,t_Hint);
  m_nExGolds := 0;
  m_nExGameGolds := 0;
  m_nCGolds := 0;
  m_nCGameGolds := 0;
end;

procedure TPlayObject.ServerGetMakeItemSel (npcid: TObject; itemname: string);        //제조스쳐
var
   Merchant:TMerchant;
begin
   Merchant := UserEngine.FindMerchant (npcid);
   if Merchant <> nil then begin
      if (Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX-m_nCurrX) <= 15) and (abs(Merchant.m_nCurrY-m_nCurrY) <= 15) then begin
         Merchant.SayMakeItemMaterials (self, itemname);
      end;
   end;
end;

procedure TPlayObject.ServerGetMakeItem (npcid: TObject; itemname: string);       //제조스쳐
var
   Merchant:TMerchant;
begin
   Merchant := UserEngine.FindMerchant (npcid);
   if Merchant <> nil then begin
      if (Merchant.m_PEnvir = m_PEnvir) and (abs(Merchant.m_nCurrX-m_nCurrX) <= 15) and (abs(Merchant.m_nCurrY-m_nCurrY) <= 15) then begin
         Merchant.UserManufactureItem (self, itemname);
      end;
   end;
end;


procedure TPlayObject.ClientOpenGuildDlg;//004DE8E0
var
  I: Integer;
  sC:String;
begin
  if m_MyGuild <> nil then begin
    sC:=TGuild(m_MyGuild).sGuildName + #13 + ' ' + #13;
    if m_nGuildRankNo = 1 then begin
      sC:=sC + '1' + #13;
    end else begin
      sC:=sC + '0' + #13;
    end;
    sC:=sC + '<契삔무멩>' + #13;
    for I := 0 to TGuild(m_MyGuild).NoticeList.Count - 1 do begin
      if length(sC) > 5000 then break;
      sC:=sC + TGuild(m_MyGuild).NoticeList.Strings[I] + #13;
    end;    // for
    sC:=sC + '<둔뚤契삔>' + #13;
    for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do begin
      if length(sC) > 5000 then break;
      sC:=sC + TGuild(m_MyGuild).GuildWarList.Strings[I] + #13;
    end;    // for
    sC:=sC + '<젬촉契삔>' + #13;
    for I := 0 to TGuild(m_MyGuild).GuildAllList.Count - 1 do begin
      if length(sC) > 5000 then break;
      sC:=sC + TGuild(m_MyGuild).GuildAllList.Strings[I] + #13;
    end;    // for
    m_DefMsg:=MakeDefaultMsg(SM_OPENGUILDDLG,0,0,0,TGuild(m_MyGuild).nGuildMode);
    SendSocket(@m_DefMsg,EncodeString(sC));
  end else begin
    SendDefMessage(SM_OPENGUILDDLG_FAIL,0,0,0,0,'');
  end;
    
end;

procedure TPlayObject.ClientGuildHome;//004DEBDC
begin
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildMemberList;//004DEBF0
var
  GuildRank:pTGuildRank;
  I,II:Integer;
  sSendMsg:String;
begin
  if m_MyGuild = nil then exit;
  for I:=0 to TGuild(m_MyGuild).m_RankList.Count -1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    sSendMsg:=sSendMsg + '#' + IntToStr(GuildRank.nRankNo) + '/*' +  GuildRank.sRankName + '/';
    for II := 0 to GuildRank.MemberList.Count - 1 do begin
      if length(sSendMsg) > 5000 then break;
      sSendMsg:=sSendMsg + GuildRank.MemberList.Strings[II] + '/';
    end;
  end;
  m_DefMsg:=MakeDefaultMsg(SM_SENDGUILDMEMBERLIST,0,0,0,1);
  SendSocket(@m_DefMsg,EncodeString(sSendMsg));
end;

procedure TPlayObject.ClientGuildAddMember(sHumName: String);//004DEDB4
var
  nC:integer;
  PlayObject:TPlayObject;
begin
  nC:=1;
  if IsGuildMaster then begin     //문주만 사용가능
    PlayObject:=UserEngine.GeTPlayObject(sHumName);    //대상지정
    if PlayObject <> nil then begin
      if PlayObject.GetPoseCreate = Self then begin   //마주보고있다.
        if PlayObject.m_boAllowGuild then begin  //가입 허용
          if not TGuild(m_MyGuild).IsMember(sHumName) then begin    //가입문파 없을 때
            if (PlayObject.m_MyGuild = nil) and (TGuild(m_MyGuild).m_RankList.Count < 400) then begin   //인원 제한
              TGuild(m_MyGuild).AddMember(PlayObject);          //새 맵버를 문파에 가입시킴
              UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
              PlayObject.m_MyGuild:=m_MyGuild;
              PlayObject.m_sGuildRankName:=TGuild(m_MyGuild).GetRankName(PlayObject,PlayObject.m_nGuildRankNo);
              PlayObject.RefShowName();
              PlayObject.SysMsg(TGuild(m_MyGuild).sGuildName +' 속흙죄契삔。' + ' 斂撚: ' + PlayObject.m_sGuildRankName ,c_Green,t_Hint);
              PlayObject.RecalcGuildLevelAbilitys(0); //문파성장
              PlayObject.SendRefMsg(RM_USERMARK, 0, PlayObject.GetObjectMark, PlayObject.m_btColumn, PlayObject.m_btJob, '');  //문파 마크
              nC:=0;
            end else nC:=4;
          end else nC:=3;
        end else begin //004DEEFD
          nC:=5;
          PlayObject.SysMsg('藁놔契삔呵겨。 헝쇱꿴츱즈角뤠角[@' + g_GameCommand.LETGUILD.sCmd + ']。',c_Red,t_Hint);
        end;
      end else nC:=2; //004DEF15 '
    end else nC:=2;//004DEF1E
  end;//004DEF25
  if nC = 0 then begin
    SendDefMessage(SM_GUILDADDMEMBER_OK,0,0,0,0,'');
  end else begin
    SendDefMessage(SM_GUILDADDMEMBER_FAIL,nC,0,0,0,'');
  end;
end;


procedure TPlayObject.ClientGuildDelMember(sHumName: String);//004DEFB8
var
  nC:integer;
  s14:String;
  PlayObject:TPlayObject;
begin
  nC:=1;
  if IsGuildMaster then begin
    if TGuild(m_MyGuild).IsMember(sHumName) then begin
      if m_sCharName <> sHumName then begin
        if TGuild(m_MyGuild).DelMember(sHumName) then begin
          PlayObject:=UserEngine.GeTPlayObject(sHumName);
          if PlayObject <> nil then begin
            PlayObject.m_MyGuild:=nil;
            PlayObject.RefRankInfo(0,'');
            PlayObject.RefShowName();//10/31
            SendRefMsg(RM_USERMARK, 0, GetObjectMark, m_btColumn, m_btJob, '');  //문파 마크
            PlayObject.RecalcGuildLevelAbilitys(0); //문파성장
          end;//004DF078
          UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
          nC:=0;
        end else nC:=4;//004DF0A8
      end else begin //004DF0B4
        nC:=3;
        s14:=TGuild(m_MyGuild).sGuildName;
        if TGuild(m_MyGuild).CancelGuld(sHumName) then begin
          g_GuildManager.DelGuild(s14);
          UserEngine.SendServerGroupMsg(SS_206,nServerIndex,s14);
          m_MyGuild:=nil;
          RefRankInfo(0,'');
          RefShowName();//10/31
          SendRefMsg(RM_USERMARK, 0, GetObjectMark, m_btColumn, m_btJob, '');  //문파 마크
          SysMsg('契삔' + s14 + '굳썩⊙匣',c_Red,t_Hint);
          RecalcGuildLevelAbilitys(0); //문파성장
          nC:=0;
        end
      end;
    end else nC:=2;
  end;//004DF15C

  if nC = 0 then begin
    SendDefMessage(SM_GUILDDELMEMBER_OK,0,0,0,0,'');
  end else begin
    SendDefMessage(SM_GUILDDELMEMBER_FAIL,nC,0,0,0,'');
  end;

end;

procedure TPlayObject.ClientGuildUpdateNotice(sNotict: String);//004DF1EC
var
  sC:String;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then exit;
  TGuild(m_MyGuild).NoticeList.Clear;
  while (sNotict <> '') do begin
    sNotict:=GetValidStr3(sNotict,sC,[#$D]);
    TGuild(m_MyGuild).NoticeList.Add(sC);
  end;    // while
  TGuild(m_MyGuild).SaveGuildInfoFile();
  UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildUpdateRankInfo(sRankInfo: String);//004DF2E8
var
  nC:Integer;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then exit;
  nC:=TGuild(m_MyGuild).UpdateRank(sRankInfo);
  if nC = 0 then begin
    UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
    ClientGuildMemberList();
  end else begin
    if nC <= -2 then begin
      SendDefMessage(SM_GUILDRANKUPDATE_FAIL,nC,0,0,0,'');
    end;
  end;
end;

procedure TPlayObject.ClientGuildAlly;//004DF3AC
var
  n8:Integer;
  BaseObjectC:TBaseObject;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::ClientGuildAlly';
begin
try
  n8:= -1;
  BaseObjectC:=GetPoseCreate();
  if (BaseObjectC <> nil) and
     (BaseObjectC.m_MyGuild <> nil) and
     (BaseObjectC.m_btRaceServer = RC_PLAYOBJECT) and
     (BaseObjectC.GetPoseCreate = Self) then begin
    if TGuild(BaseObjectC.m_MyGuild).m_boEnableAuthAlly then begin
      if BaseObjectC.IsGuildMaster and IsGuildMaster then begin
        if TGuild(m_MyGuild).IsNotWarGuild(TGuild(BaseObjectC.m_MyGuild)) and
           TGuild(BaseObjectC.m_MyGuild).IsNotWarGuild(TGuild(m_MyGuild)) then begin

          TGuild(m_MyGuild).AllyGuild(TGuild(BaseObjectC.m_MyGuild));
          TGuild(BaseObjectC.m_MyGuild).AllyGuild(TGuild(m_MyGuild));

          TGuild(m_MyGuild).SendGuildMsg(TGuild(BaseObjectC.m_MyGuild).sGuildName + ' 綠쒔宅콱돨契삔써냥젬촉。');
          TGuild(BaseObjectC.m_MyGuild).SendGuildMsg(TGuild(m_MyGuild).sGuildName + ' 綠쒔宅콱돨契삔써냥젬촉。');
          TGuild(m_MyGuild).RefMemberName;
          TGuild(BaseObjectC.m_MyGuild).RefMemberName;
          UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
          UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(BaseObjectC.m_MyGuild).sGuildName);
          n8:=0;
        end else n8:= -2;
      end else n8:= -3;
    end else n8:= -4;//004DF57C
  end;
  if n8 = 0 then begin
    SendDefMessage(SM_GUILDMAKEALLY_OK,0,0,0,0,'');
  end else begin
    SendDefMessage(SM_GUILDMAKEALLY_FAIL,n8,0,0,0,'');
  end;
except
  on e: Exception do begin
    MainOutMessage(sExceptionMsg);
    MainOutMessage(E.Message);
  end;
end;
end;

procedure TPlayObject.ClientGuildBreakAlly(sGuildName: String);//004DF604
var
  n10:Integer;
  Guild:TGuild;
begin
  n10:= -1;
  if not IsGuildMaster() then exit;
  Guild:=g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then begin
    if TGuild(m_MyGuild).IsAllyGuild(Guild) then begin
      TGuild(m_MyGuild).DelAllyGuild(Guild);
      Guild.DelAllyGuild(TGuild(m_MyGuild));
      TGuild(m_MyGuild).SendGuildMsg(Guild.sGuildName +  ' 綠쒔宅콱돨契삔썩뇜죄젬촉。');
      Guild.SendGuildMsg(TGuild(m_MyGuild).sGuildName +  ' 綠쒔宅콱돨契삔썩뇜죄젬촉。');
      TGuild(m_MyGuild).RefMemberName();
      Guild.RefMemberName();
      UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
      UserEngine.SendServerGroupMsg(SS_207,nServerIndex,Guild.sGuildName);
      n10:=0;
    end else n10:= -2;
  end else n10:= -3; //004DF750
  if n10 = 0 then begin
    SendDefMessage(SM_GUILDBREAKALLY_OK,0,0,0,0,'');
  end else begin
    SendDefMessage(SM_GUILDMAKEALLY_FAIL,0,0,0,0,'');
  end;
    
    
end;
procedure TPlayObject.RecalcAdjusBonus();
   procedure AdjustAb (abil: byte; val: word; var lov, hiv: Word);
   var
      lo, hi: byte;
      i: integer;
   begin
      lo := Lobyte(abil);
      hi := Hibyte(abil);
      lov := 0; hiv := 0;
      for i:=1 to val do begin
         if lo + 1 < hi then begin
           Inc(lo);
           Inc(lov);
         end else begin
           Inc(hi);
           Inc(hiv);
         end;
      end;
   end;
var
  BonusTick:pTNakedAbility;
  NakedAbil:pTNakedAbility;
   adc, amc, asc, aac, amac: integer;
   ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
begin
  BonusTick:=nil;
  NakedAbil:=nil;
  case m_btJob of
    jWarr, jUpWarr: begin
      BonusTick:=@g_Config.BonusAbilofWarr;
      NakedAbil:=@g_Config.NakedAbilofWarr;
    end;
    jWizard, jUpWiz: begin
      BonusTick:=@g_Config.BonusAbilofWizard;
      NakedAbil:=@g_Config.NakedAbilofWizard;
    end;
    jTaos, jUpTao: begin
      BonusTick:=@g_Config.BonusAbilofTaos;
      NakedAbil:=@g_Config.NakedAbilofTaos;
    end;
    jAssassin, jUpAssa: begin
      BonusTick:=@g_Config.BonusAbilofAssassin;
      NakedAbil:=@g_Config.NakedAbilofAssassin;      //자객  //비연자객
    end;
    jBonze, jUpBoz: begin
      BonusTick:=@g_Config.BonusAbilofBonze;
      NakedAbil:=@g_Config.NakedAbilofBonze;
    end;
  end;


      adc := m_BonusAbil.DC div BonusTick.DC;
      amc := m_BonusAbil.MC div BonusTick.MC;
      asc := m_BonusAbil.SC div BonusTick.SC;
      aac := m_BonusAbil.AC div BonusTick.AC;
      amac := m_BonusAbil.MAC div BonusTick.MAC;


      AdjustAb (NakedAbil.DC, adc, ldc, hdc);
      AdjustAb (NakedAbil.MC, amc, lmc, hmc);
      AdjustAb (NakedAbil.SC, asc, lsc, hsc);
      AdjustAb (NakedAbil.AC, aac, lac, hac);
      AdjustAb (NakedAbil.MAC, amac, lmac, hmac);
      //lac  := 0;  hac := aac;
      //lmac := 0;  hmac := amac;
      
      m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC) + ldc,HiWord(m_WAbil.DC) + hdc);
      m_WAbil.MC:=MakeLong(LoWord(m_WAbil.MC) + lmc,HiWord(m_WAbil.MC) + hmc);
      m_WAbil.SC:=MakeLong(LoWord(m_WAbil.SC) + lsc,HiWord(m_WAbil.SC) + hsc);
      m_WAbil.AC:=MakeLong(LoWord(m_WAbil.AC) + lac,HiWord(m_WAbil.AC) + hac);
      m_WAbil.MAC:=MakeLong(LoWord(m_WAbil.MAC) + lmac,HiWord(m_WAbil.MAC) + hmac);

      m_WAbil.MaxHP:=_MIN(High(Word),m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP);
      m_WAbil.MaxMP:=_MIN(High(Word),m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP);
//      m_btSpeedPoint:=m_btSpeedPoint + m_BonusAbil.Speed div BonusTick.Speed;
//      m_btHitPoint:=m_btHitPoint + m_BonusAbil.Hit div BonusTick.Hit;
end;
procedure TPlayObject.ClientAdjustBonus(nPoint: Integer; sMsg: String);//004DF804
var
  BonusAbil:TNakedAbility;
  nTotleUsePoint:Integer;
begin
  FillChar(BonusAbil,SizeOf(TNakedAbility),#0);
  DecodeBuffer(sMsg,@BonusAbil,SizeOf(TNakedAbility));

  nTotleUsePoint := BonusAbil.DC +
                  BonusAbil.MC +
                  BonusAbil.SC +
                  BonusAbil.AC +
                  BonusAbil.MAC +
                  BonusAbil.HP +
                  BonusAbil.MP +
                  BonusAbil.Hit +
                  BonusAbil.Speed +
                  BonusAbil.X2;

  if (nPoint + nTotleUsePoint > g_Config.nBonusPointHack) then begin    //보너스포인트 핵
    MainOutMessage('[賈痰렷랬넋埼]쉽쟨생롸: ' + GetGoldStr(nPoint)
                  + ' 실ッ : ' + m_sCharName + ' ID : ' + m_sUserID + ' [IP : ' + m_sIPaddr + ']');
    FillChar(m_BonusAbil,SizeOf(TNakedAbility),#0);
    m_nBonusPoint := 0;
    nPoint := 0;
  end;
  if (nPoint + nTotleUsePoint) = m_nBonusPoint then begin
    m_nBonusPoint:=nPoint;
    Inc(m_BonusAbil.DC,BonusAbil.DC);
    Inc(m_BonusAbil.MC,BonusAbil.MC);
    Inc(m_BonusAbil.SC,BonusAbil.SC);
    Inc(m_BonusAbil.AC,BonusAbil.AC);
    Inc(m_BonusAbil.MAC,BonusAbil.MAC);
    Inc(m_BonusAbil.HP,BonusAbil.HP);
    Inc(m_BonusAbil.MP,BonusAbil.MP);
    Inc(m_BonusAbil.Hit,BonusAbil.Hit);
    Inc(m_BonusAbil.Speed,BonusAbil.Speed);
    Inc(m_BonusAbil.X2,BonusAbil.X2);

    RecalcAbilitys();
    SendMsg(Self,RM_ABILITY,0,0,0,0,'');
    SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  end else begin
    SysMsg('悧쉽쟨생롸令뵨퀭渴흙돨令꼇攣횅。',c_Red,t_Hint);
  end;

  if m_nBonusPoint > g_Config.nBonusPointHack then begin       //보너스포인트 핵
    FillChar(m_BonusAbil,SizeOf(TNakedAbility),#0);
    MainOutMessage('[賈痰렷랬넋埼]쉽쟨생롸: ' + GetGoldStr(m_nBonusPoint)
                  + ' 실ッ : ' + m_sCharName + ' ID : ' + m_sUserID + ' [IP : ' + m_sIPaddr + ']');
    m_nBonusPoint := 0;
    nPoint := 0;
  end;
end;

procedure TPlayObject.ClientSendFriendsList(PlayObject:TPlayObject);
var
  sMsg,sMsgo: String;
  FriendObject: TPlayObject;
  Friend: ptClientFriends;
  I: Integer;
  DBM: TADOQuery;
begin
  sMsg := '';

  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  sMsg := 'SELECT * FROM TBL_FRIEND Where FLD_CHAR='''+PlayObject.m_sCharName+''' ORDER BY FLD_ID';
  DBM.SQL.Clear;
  DBM.SQL.Add(sMsg);
  DBM.Open;
  sMsg := '';

  new(Friend);
  for I := 0 to DBM.RecordCount do begin
    if DBM.eof then break;

    Friend.Id := DBM.FieldByName('FLD_ID').AsInteger;
    Friend.Name :=  DBM.FieldByName('FLD_PERSON').AsString;
    FriendObject := UserEngine.GetPlayObject(Friend.Name);
    if FriendObject <> nil then begin
      sMsg := Friend.Name + '/1/' + sMsg;
    end else begin
      sMsg := Friend.Name + '/0/' + sMsg;
    end;
    DBM.Next;
  end;
  Dispose(Friend);
  DBM.Close;
  if sMsg <> '' then SendDefMsg(Self, SM_FRIEND_LOGIN, 0, 1, 0, 1, sMsg);     //미사용
end;

procedure TPlayObject.ClientFriendStatusChanged(sPlayerName: String; onin:byte);
begin
  SendDefMsg(Self, SM_FRIEND_LOGIN, 0, onin, 0, 0, sPlayerName);    //나의 접속상태 상대방에게 알리기
end;

procedure TPlayObject.ClientFriendChangeState(PlayObject:TPlayObject; Online: Boolean = True);
var
  sMsg,sMsgo: String;
  FriendObject: TPlayObject;
  I: Integer;
  DBM: TADOQuery;
begin
  sMsg := '';

  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  sMsg := 'SELECT * FROM TBL_FRIEND Where FLD_PERSON='''+PlayObject.m_sCharName+''' ORDER BY FLD_ID';
  DBM.SQL.Clear;
  DBM.SQL.Add(sMsg);
  DBM.Open;
  sMsg := '';
  sMsgo := '';

  for I := 0 to DBM.RecordCount do begin
    if DBM.eof then break;
    FriendObject := UserEngine.GetPlayObject(DBM.FieldByName('FLD_CHAR').AsString);
    if FriendObject <> nil then begin
      if Online then FriendObject.ClientFriendStatusChanged(PlayObject.m_sCharName, 1)
      else FriendObject.ClientFriendStatusChanged(PlayObject.m_sCharName, 0);
    end;
    DBM.Next;
  end;
  DBM.Close;
end;

procedure TPlayObject.ClientAddFriend(sPlayerName:String);
var
  DBM: TADOCommand;
begin
  SendDefMsg(Self, SM_FRIEND_LOGIN, 0, 1, 0, 2, sPlayerName);    //친구추가
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'INSERT INTO TBL_FRIEND (FLD_CHAR,FLD_PERSON) values (:FLD_CHAR, :FLD_PERSON)';
  DBM.Parameters.ParamByName('FLD_CHAR').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_PERSON').Value := sPlayerName;
  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.ClientDelFriend(sPlayerName:String);
var
  DBM: TADOCommand;
begin
  SendDefMsg(Self, SM_FRIEND_LOGIN, 0, 1, 0, 3, sPlayerName);  //친구삭제
  // Delete from sql
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'DELETE FROM TBL_FRIEND WHERE FLD_CHAR = :FLD_CHAR and FLD_PERSON = :FLD_PERSON';
  DBM.Parameters.ParamByName('FLD_CHAR').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_PERSON').Value := sPlayerName;
  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.ClientReqAddFriend(sPlayerName:String);
var
  FriendObject: TPlayObject;
  DBM: TADOQuery;
begin
  if sPlayerName = Self.m_sCharName then begin
    SendDefMessage(SM_FRIEND_RESULT, 0, 1, 0, 0, '');  //자기자신
    exit;
  end;

  FrmDB.UseSQL();
  DBM := FrmDB.Query;
  DBM.Close;
  DBM.SQL.Clear;
  DBM.SQL.Add('SELECT * FROM TBL_FRIEND WHERE FLD_CHAR = :FLD_CHAR and FLD_PERSON = :FLD_PERSON');
  DBM.Parameters.ParamByName('FLD_CHAR').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_PERSON').Value := sPlayerName;
  DBM.Open;

  if DBM.RecordCount > 0 then begin
    SendDefMessage(SM_FRIEND_RESULT, 0, 2, 0, 0, sPlayerName);  //이미등록
  end else begin
    FriendObject := UserEngine.GeTPlayObject(sPlayerName);
    if FriendObject <> nil then begin
      Self.ClientAddFriend(sPlayerName);
    end else begin
      SendDefMessage(SM_FRIEND_RESULT, 0, 3, 0, 0, sPlayerName);    //접속
    end;
  end;
  DBM.Close;
end;


procedure TPlayObject.PetSummon(PlayObject:TPlayObject; PetID:integer);   //영물
var
  sMsg,sMsgo: String;
  I: Integer;
  DBM: TADOQuery;
  PetInfo: TPetInfo;
begin
  sMsg := '';

  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  sMsg := 'SELECT * FROM TBL_PET WHERE FLD_ID = ' +inttostr(PetID);
  DBM.SQL.Clear;
  DBM.SQL.Add(sMsg);
  DBM.Open;
  sMsg := '';
  sMsgo := '';

  for I := 0 to DBM.RecordCount do begin
    if DBM.eof then break;

    PetInfo.EndTime := UnixToDateTime(strtoint(DBM.FieldByName('FLD_END').AsString));
    PetInfo.Period := DBM.FieldByName('FLD_PERIOD').AsInteger;

    if (PetInfo.Period = 1) and (PetInfo.EndTime < now) then begin
        FrmDB.DeletePet(PlayObject, PetID);
    end else begin
      m_sPetName := DBM.FieldByName('FLD_PETNAME').AsString;
      m_nPetEatRage := DBM.FieldByName('FLD_EATRAGE').AsInteger;
      MakePet(DBM.FieldByName('FLD_PETMOBNAME').AsString);
      PetAbility(m_sPetName, DBM.FieldByName('FLD_ABILITY').AsString, True);
      SendDefMessage(SM_NOTSUMMONPET,0,0,0,0,'');
    end;
    DBM.Next;
  end;
  DBM.Close;

end;

procedure TPlayObject.NotPetSummon();   //영물
var
  I: Integer;
begin
  if m_PetList.Count > 0 then begin
    SendDefMessage(SM_SUMMONPET,0,0,0,0,'');
    for i:=m_PetList.Count -1 downto 0 do begin
        TPetObject(m_PetList.Items[i]).Die;
        Break;
    end;
  end;
end;

procedure TPlayObject.NotPetSummon2(sMonName:String);   //영물
var
  I: Integer;
begin
  if m_PetList.Count > 0 then begin
    if m_sPetName = sMonName then begin
      SendDefMessage(SM_SUMMONPET,0,0,0,0,'');
      for i:=m_PetList.Count -1 downto 0 do begin
         TPetObject(m_PetList.Items[i]).Die;
         Break;
      end;
    end;
  end;
end;

procedure TPlayObject.ClientReqDelFriend(sPlayerName:String);
begin
  if fLover.GetLoverName <> sPlayerName then begin    //연인 스쳐 친구 삭제 안되게
    Self.ClientDelFriend(sPlayerName);
  end else begin
    BoxMsg('콱꼇콘잼삯。', 0);
  end;
end;

procedure TPlayObject.ClientFriendChange(ProcessMsg: pTProcessMessage);
begin
  if m_boGhost then exit;
  case ProcessMsg.wParam of
    0: ClientReqAddFriend(DecodeString(ProcessMsg.sMsg));
    1: ClientReqDelFriend(DecodeString(ProcessMsg.sMsg));
  end;
end;

procedure TPlayObject.ClientGetSayItem(ProcessMsg: pTProcessMessage);
var
  UserItem: pTUserItem;
  nID, ItemIndex: Integer;
  Item:TItem;
  sSendMsg:String;
  ClientItem:TClientItem;
  opt: integer;
  StdItem:TStdItem;
  sUserItemName, stditemname: string;
begin
  sSendMsg:='';
  nID := ProcessMsg.nParam2;
  ItemIndex := ProcessMsg.nParam1;
  UserItem := GetSayitem(nID);
  if (UserItem <> nil) and (UserItem.MakeIndex = ItemIndex) then begin
    Item:=UserEngine.GetStdItem(UserItem.wIndex);

    if not (Item.StdMode in [2,46]) then begin

      if (Item.Reserved and 16 <> 0) then begin
        stditemname:= FilterStdShowName(Item,Item.Name);
        if (self.m_btJob in [g_Bonze,g_BonzeUp]) then begin         //승려
          if self.m_WAbil.Level >= 80 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '60');
          end else if self.m_WAbil.Level >= 70 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '50');
          end else if self.m_WAbil.Level >= 60 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '40');
          end else if self.m_WAbil.Level >= 50 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '30');
          end else if self.m_WAbil.Level >= 40 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '20');
          end else if self.m_WAbil.Level >= 30 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '10');
          end else begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '00');
          end;
        end else begin
          if self.m_WAbil.Level >= 80 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '6');
          end else if self.m_WAbil.Level >= 70 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '5');
          end else if self.m_WAbil.Level >= 60 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '4');
          end else if self.m_WAbil.Level >= 50 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '3');
          end else if self.m_WAbil.Level >= 40 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '2');
          end else if self.m_WAbil.Level >= 30 then begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName + '1');
          end else begin
            UserItem.wIndex:=UserEngine.GetStdItemIdx(StdItemName);
          end;
        end;
        Item:=UserEngine.GetStdItem(UserItem.wIndex);
      end;

      if (Item.Reserved and 32 <> 0) then begin
        stditemname := FilterStdShowName(Item,Item.Name);
        if (self.m_btJob in [g_Warrior,g_WarriorUp]) then
          UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '1');
        if (self.m_btJob in [g_Wizard,g_WizardUp])then
          UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '2');
        if (self.m_btJob in [g_Monk,g_MonkUp]) then
          UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '3');
        if (self.m_btJob in [g_Assassin,g_AssassinUp]) then                     //자객
          UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '4');
        if (self.m_btJob in [g_Bonze,g_BonzeUp]) then                         //승려
          UserItem.wIndex:=UserEngine.GetStdItemIdx(stditemname + '5');
        Item:=UserEngine.GetStdItem(UserItem.wIndex);
      end;
    end;

    if Item <> nil then begin
      Item.GetStandardItem(ClientItem.S);
      opt := Item.GetItemAddValue(UserItem, ClientItem.S);

      sUserItemName := '';
      sUserItemName := FilterStdShowName(Item,Item.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := FilterStdShowName(Item,sUserItemName);

      ClientItem.Dura:=UserItem.Dura;
      ClientItem.DuraMax:=UserItem.DuraMax;
      ClientItem.MakeIndex:=UserItem.MakeIndex;
      ClientItem.Amount := UserItem.Amount;
      ClientItem.UpgradeOpt := opt;
      sSendMsg:= EncodeBuffer(@ClientItem,SizeOf(TClientItem));
    end;
    m_DefMsg := MakeDefaultMsg(SM_GETSAYITEM, ItemIndex, nID, 0, 0);
    SendSocket(@m_DefMsg, sSendMsg);
  end;
end;



function TPlayObject.GetAllowGroupReCall: Integer;//천지합일
begin
  Result:=0;
  if m_boAllowGroupReCall then begin
   Result:=1;
  end;
end;


procedure TPlayObject.ServerGetMentorRequest(ReqType: integer; ReqSeq: integer; ReqRe: integer; Master:String);      //사제 스쳐
var
  cert: TPlayObject;
  Target: TPlayObject;
  ListCount: integer;
  msgstr: string;
  Date: string;
  str: string;
  CheckResult: integer;
begin
  cert := UserEngine.GetPlayObject(Master);

  // 타겟이 없거나 , 마주보고 있지 않거나 , 인간이 아니면 나간다.
  if (cert = nil) or (cert.m_btRaceServer <> RC_PLAYOBJECT) or (cert.m_sMapName <> Self.m_sMapName) then begin
    BoxMsg('뚤렘꼇瞳谿寧몸뒈暠區 ', 0);
    Exit;
  end;

  // human 으로 타입 바꿈
  Target := TPlayObject(cert);

  // 조건체크
  case ReqType of
    RsState_Master: // 사제의 경우 조건 체크
    begin
      if (Self.m_WAbil.Level >= g_Config.nMasterLevel) and (ReqRe = 0) then begin //제자 본인
        SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_HighLevelMe, g_Config.nMasterLevel, '');
        Exit;
      end;
      if (Target.m_WAbil.Level < g_Config.nMasterLevel) and (ReqRe = 0) then begin //스승 상대
        SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_LessLevelOther,
          g_Config.nMasterLevel, Target.m_sCharName);
        Exit;
      end;
      // 교제가능 조건 체크 (체크 순서 조정)
      CheckResult := Self.fMentor.GetEnableJoin(ReqType);
      if CheckResult = 2 then begin
        //이미 교제중인 사람이 있음
        SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_FullUser, 0, m_sCharName);
        Exit;
      end else if CheckResult <> 0 then begin
        Exit;
      end;

      // 상대방의 교제가능상태 체크
      if not Target.fMentor.EnableJoinMentor  and (ReqRe = 0) then begin
        SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_RejectOther,
          0, Target.m_sCharName);
        Exit;
      end;

      if (UnixToDateTime(Self.ServerGetMentorDBDate) >= now) and (ReqRe = 0) then begin
        SendDefMessage(SM_LM_RESULT, Self.ServerGetMentorDBDate , ReqType, Error_RejectMeBroken, 0 ,  Self.m_sCharName);
        Exit;
      end;

      if (UnixToDateTime(Target.ServerGetMentorDBDate) >= now) then begin
        SendDefMessage(SM_LM_RESULT, Target.ServerGetMentorDBDate , ReqType, Error_RejectBroken, 0 ,  Target.m_sCharName);
        Exit;
      end;

    end;

    else
      Exit;
  end;

  // 참여 시퀀스 변화 ...
  case ReqSeq of
    RsReq_None: ; // 기본상태
    RsReq_WantToJoinOther: // 누구에게 참가신청을 함
    begin
      if not Self.fMentor.GetEnableJoinReq(ReqType) then begin
        // 내가 상대방에게 참여할수 없는 상태이다.
        SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_DontJoin,
          0, Target.m_sCharName);
      end else begin
        // 참여가능한지 검토
        CheckResult := Target.fMentor.GetEnableJoin(ReqType);
        if CheckResult = 1 then begin
          //교제가능 상태가 아님
          SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_RejectOther,
            0, Target.m_sCharName);
        end else if CheckResult = 2 then begin
          //이미 교제중인 사람이 있음
          SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_FullUserOther,
            0, Target.m_sCharName);
        end else if CheckResult = 0 then begin
          // 상대방이 다른 요구를 받고 있는상태가 아니면
          if Target.fMentor.ReqSequence = RsReq_None then begin
            // 누군가 신청했다고 알림
            target.SendDefMessage(SM_LM_REQUEST, 0, ReqType,
              RsReq_WhoWantJoin, 0, Self.m_sCharName + '/' + Target.m_sCharName);
            // 나는 대답을 기다리는 상태이고
            Self.fMentor.ReqSequence   := RsReq_WaitAnser;
            // 상대방은 대답을 해줘야 하는 상태
            Target.fMentor.ReqSequence := RsReq_WhoWantJoin;
          end else begin
            // 상대방이 현재 다른 응답 상태이다.
            SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_DontJoin,
              0, Target.m_sCharName);
          end;
        end;

      end;
    end;
    RsReq_AloowJoin: // 참가를 허락함
    begin
      if Target.fMentor.ReqSequence = RsReq_WaitAnser then begin
        // 타겟을 등록한다.
        Date := '';
        Self.fMentor.ReqSequence := RsREq_None;
        self.fMentor.Add(Self.m_sCharName, Target.m_sCharName, ReqType,
          Target.m_WAbil.Level, Target.m_btJob, 1 , 1, Date);
        msgstr := Self.fMentor.GetListmsg(ReqType, listCount);
        SendDefMessage(SM_ME_LIST, 0, ListCount, 0, 0, msgstr);
        SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_SuccessJoin,
          0, Target.m_sCharName);
        if g_ManageNPC <> nil then begin
          g_ManageNPC.GotoLable(Self,'@Mentor',False);
        end;

        Self.ServerSetMentorDBAdd(Self.m_sCharName , Target.m_sCharName , IntToStr(ReqType),  Date, 1);


        // 자신을 타겟에 등록한다.
        Target.fMentor.ReqSequence := RsREq_None;
        Target.fMentor.Add(Target.m_sCharName, Self.m_sCharName,
          ReqType, Self.m_WAbil.Level, Self.m_btJob, 0 , 1, Date);
        msgstr := Target.fMentor.GetListmsg(ReqType, listCount);
        Target.SendDefMessage(SM_ME_LIST, 0, ListCount, 0, 0, msgstr);
        Target.SendDefMessage(SM_LM_RESULT, 0, ReqType,
          Error_SuccessJoined, 0, Self.m_sCharName);
        Target.RecalcPupilAbilitys(0);



        Target.ServerSetMentorDBAdd(Target.m_sCharName , Self.m_sCharName , IntToStr(ReqType),  Date, 0);

      end else begin
        // 상대방이 현재 다른 응답 상태이다. 따라서 취소시킨다.
        self.fMentor.ReqSequence := RsReq_None;
        target.fMentor.ReqSequence := RsReq_None;
      end;
    end;
    RsReq_DenyJoin: // 참가를 거절함
    begin
      self.fMentor.ReqSequence := RsReq_None;
      target.fMentor.ReqSequence := RsReq_None;

      target.SendDefMessage(SM_LM_RESULT, 0, ReqType, Error_DenyJoin, 0,
        Self.m_sCharName);
    end;
    RsReq_Cancel: // 취소
    begin
      self.fMentor.ReqSequence := RsReq_None;
      target.fMentor.ReqSequence := RsReq_None;
    end;
  end;

end;

//사제 삭제
procedure TPlayObject.ServerGetMentorDelete(ReqType: integer; OtherName: string);        //사제 스쳐 정상 해제
var
 Hum :  TPlayObject;
begin
  if ReqType = RsState_Master then begin
    MentorShipDeleteOther(ReqType, OtherName , 1);
    hum := UserEngine.GetPlayObject(OtherName);
    if hum <> nil then begin
      hum.MentorShipDeleteOther(ReqType, m_sCharName, 3);
    end else begin
      ServerSetMentorDBChange(m_sCharName , OtherName , RsState_MasterEnd , 3);     //사제 스쳐 정상 해제
    end;
  end;
end;

//사제 삭제
procedure TPlayObject.ServerGetMentorDelete2(ReqType: integer; OtherName: string);         //사제 스쳐 레벨 높아 해제
var
 Hum :  TPlayObject;
begin
  if ReqType = RsState_Master then begin
    MentorShipDeleteOther2(ReqType, OtherName);
    hum := UserEngine.GetPlayObject(OtherName);
    if hum <> nil then begin
      hum.MentorShipDeleteOther2(ReqType, m_sCharName);
    end else begin
      ServerSetMentorDBChange(m_sCharName , OtherName , RsState_MasterEnd , 1);        //사제 스쳐 레벨 높아 해제
    end;
  end;
end;





//연인옵션변경
procedure TPlayObject.ServerGetRelationOptionChange(OptionType: integer;        //연인 스쳐사망
  Enable: integer);
begin

  case OptionType of
    1: begin // 연인일 경우에
      // 이전의 상태의 반전을 한다.
      if 1 = Self.fLover.GetEnable(RsState_Lover) then
        Self.fLover.SetEnable(RsState_Lover, 0)
      else
        Self.fLover.SetEnable(RsState_Lover, 1);
      SendDefMessage(SM_LM_OPTION, 0, OPtionType,
        Self.flover.GetEnable(RsState_Lover), 0, '');
    end;
    2: begin // 사제일 경우에         //사제 스쳐
      // 이전의 상태의 반전을 한다.
      if 1 = Self.fMentor.GetEnable(RsState_Master) then
        Self.fMentor.SetEnable(RsState_Master, 0)
      else
        Self.fMentor.SetEnable(RsState_Master, 1);
      SendDefMessage(SM_LM_OPTION, 0, OPtionType,
        Self.fMentor.GetEnable(RsState_Master), 0, '');
    end;

  end;
end;

//연인 관계 요청
procedure TPlayObject.ServerGetRelationRequest(ReqType: integer; ReqSeq: integer);      //연인 스쳐사망
var
  cert: TPlayObject;
  Target: TPlayObject;
  ListCount: integer;
  msgstr: string;
  Date: string;
  str: string;
  CheckResult: integer;
begin
  // 앞에 있는 상대를 얻는다.
  cert := PlayGetPoseCreate;
  // 타겟이 없거나 , 마주보고 있지 않거나 , 인간이 아니면 나간다.
  if (cert = nil) or (cert.PlayGetPoseCreate <> Self) or
    (cert.m_btRaceServer <> RC_PLAYOBJECT) then begin
    BoxMsg('崗렘狼충뚤충籃淪。', 0);
    Exit;
  end;

  // human 으로 타입 바꿈
  Target := TPlayObject(cert);

  // 조건체크
  case ReqType of
    RsState_Lover: // 연인의 경우 조건 체크
    begin
      // 자신의 레벨체크
      if Self.m_WAbil.Level < 22 then begin
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_LessLevelMe, 0, '');
        Exit;
      end;
      // 상대방의 레벨 체크
      if Target.m_WAbil.Level < 22 then begin
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_LessLevelOther,
          0, Target.m_sCharName);
        Exit;
      end;
      // 상대방과의 성별 체크
      if Self.m_btGender = Target.m_btGender then begin
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_EqualSex, 0, '');
        Exit;
      end;
      // 교제가능 조건 체크 (체크 순서 조정)
      CheckResult := Self.fLover.GetEnableJoin(ReqType);
      if CheckResult = 1 then begin
        //교제가능 상태가 아님
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_RejectMe, 0, '');
        Exit;
      end else if CheckResult = 2 then begin
        //이미 교제중인 사람이 있음
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_FullUser, 0, m_sCharName);
        Exit;
      end else if CheckResult <> 0 then begin
        Exit;
      end;
      // 나의 교제가능 상태 체크
      if not Self.fLover.EnableJoinLover then begin
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_RejectMe, 0, '');
        Exit;
      end;
      // 상대방의 교제가능상태 체크
      if not Target.fLover.EnableJoinLover then begin
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_RejectOther,
          0, Target.m_sCharName);
        Exit;
      end;
    end;
      // 연인이 아닐경우의 조건체크
    else
      Exit;
  end;

  // 참여 시퀀스 변화 ...
  case ReqSeq of
    RsReq_None: ; // 기본상태
    RsReq_WantToJoinOther: // 누구에게 참가신청을 함
    begin
      if not Self.fLover.GetEnableJoinReq(ReqType) then begin
        // 내가 상대방에게 참여할수 없는 상태이다.
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_DontJoin,
          0, Target.m_sCharName);
      end else begin
        // 참여가능한지 검토
        CheckResult := Target.fLover.GetEnableJoin(ReqType);
        if CheckResult = 1 then begin
          //교제가능 상태가 아님
          SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_RejectOther,
            0, Target.m_sCharName);
        end else if CheckResult = 2 then begin
          //이미 교제중인 사람이 있음
          SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_FullUser,
            0, Target.m_sCharName);
        end else if CheckResult = 0 then begin
          // 상대방이 다른 요구를 받고 있는상태가 아니면
          if Target.fLover.ReqSequence = RsReq_None then begin
            // 누군가 신청했다고 알림
            target.SendDefMessage(SM_LM_REQUEST, 0, ReqType,
              RsReq_WhoWantJoin, 0, Self.m_sCharName + '/' + Target.m_sCharName);
            // 나는 대답을 기다리는 상태이고
            Self.fLover.ReqSequence   := RsReq_WaitAnser;
            // 상대방은 대답을 해줘야 하는 상태
            Target.flover.ReqSequence := RsReq_WhoWantJoin;
          end else begin
            // 상대방이 현재 다른 응답 상태이다.
            SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_DontJoin,
              0, Target.m_sCharName);
          end;
        end;

      end;
    end;
    RsReq_AloowJoin: // 참가를 허락함
    begin
      if Target.fLover.ReqSequence = RsReq_WaitAnser then begin
        // 타겟을 등록한다.
        Date := '';
        Self.fLover.ReqSequence := RsREq_None;
        self.flover.Add(Self.m_sCharName, Target.m_sCharName, ReqType,
          Target.m_WAbil.Level, Target.m_btGender, Date, '');
        msgstr := Self.fLover.GetListmsg(ReqType, listCount);
        SendDefMessage(SM_LM_LIST, 0, ListCount, 0, 0, msgstr);
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_SuccessJoin,
          0, Target.m_sCharName);

        // 자신을 타겟에 등록한다.
        Target.fLover.ReqSequence := RsREq_None;
        Target.flover.Add(Target.m_sCharName, Self.m_sCharName,
          ReqType, Self.m_WAbil.Level, Self.m_btGender, Date, '');
        msgstr := Target.fLover.GetListmsg(ReqType, listCount);
        Target.SendDefMessage(SM_LM_LIST, 0, ListCount, 0, 0, msgstr);
        Target.SendDefMessage(SM_LM_RESULT, 0, ReqType,
          RsError_SuccessJoined, 0, Self.m_sCharName);



        Self.ServerSetRelationDBAdd(Self.m_sCharName , Target.m_sCharName , IntToStr(ReqType), IntToStr(Target.m_Abil.Level), IntToStr(Target.m_btGender), Date);
        Target.ServerSetRelationDBAdd(Target.m_sCharName , Self.m_sCharName , IntToStr(ReqType), IntToStr(Self.m_Abil.Level), IntToStr(Self.m_btGender), Date);

        // 주변에 외치기
        str := '훑죠龍붕！ "' + m_sCharName + '" 뵨 "' +
          target.m_sCharName + '" 냥槨죄뤼펄，毒儉쳬겜庫貌일！';
        UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, 255, 253, '♡' + str);


        //로그남김
       { AddUserLog('47'#9 + //연인_   //LastLogNumber
          m_sMapName + ''#9 + IntToStr(m_nCurrX) + ''#9 + IntToStr(m_nCurrY) +
          ''#9 + m_sCharName + ''#9 + '0'#9 + '0'#9 + '0'#9 +  //맺음:0
          target.m_sCharName);   }

      end else begin
        // 상대방이 현재 다른 응답 상태이다. 따라서 취소시킨다.
        self.fLover.ReqSequence := RsReq_None;
        SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_CancelJoin, 0,
          Target.m_sCharName);

        target.fLover.ReqSequence := RsReq_None;
        Target.SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_CancelJoin,
          0, Self.m_sCharName);
      end;
    end;
    RsReq_DenyJoin: // 참가를 거절함
    begin
      self.fLover.ReqSequence := RsReq_None;
      SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_CancelJoin,
        0, Target.m_sCharName);

      target.fLover.ReqSequence := RsReq_None;
      target.SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_DenyJoin, 0,
        Self.m_sCharName);
    end;
    RsReq_Cancel: // 취소
    begin
      self.fLover.ReqSequence := RsReq_None;
      SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_CancelJoin,
        0, Target.m_sCharName);

      target.fLover.ReqSequence := RsReq_None;
      target.SendDefMessage(SM_LM_RESULT, 0, ReqType, RsError_CancelJoin,
        0, Self.m_sCharName);
    end;
  end;

end;


// 연인 삭제
procedure TPlayObject.ServerGetRelationDelete(ReqType: integer; OtherName: string);         //연인 스쳐사망
var
  svidx: integer;
  hum:   TPlayObject;
  cert:  TPlayObject;
  strPayment: string;
begin
  //연인 관계일 경우...
  if ReqType = RsState_Lover then begin
    // 앞에 있는 상대를 얻는다.
    cert := PlayGetPoseCreate;
    // 타겟이 없거나 , 마주보고 있지 않거나 , 인간이 아니면 나간다.
    if (cert = nil) or (cert.PlayGetPoseCreate <> Self) or
      (cert.m_btRaceServer <> RC_PLAYOBJECT) then begin
      BoxMsg('흔벎狼썩뇜뤼펄밑溝，狼宅뚤렘충뚤충였淪。 ', 0);
      Exit;
    end;

    // human 으로 타입 바꿈
    hum := TPlayObject(cert);
    if hum = nil then
      exit;

    // 상대방이 나의 연인인지 체크
    if not ((hum.fLover.GetLoverName = m_sCharName) and
      (fLover.GetLoverName = hum.m_sCharName)) then begin
      BoxMsg('뚤렘꼇角콱돨졔훙。', 0);
      Exit;
    end;

    // 위자료 낼 돈이 있는지 확인
    if m_nGold < COMPENSATORY_PAYMENT then begin
      strPayment := IntToStr(COMPENSATORY_PAYMENT div 10000);
      BoxMsg('잼삯矜狼連마' + strPayment + '쏜귑돨癎崎롤。', 0);
      exit;
    end;

    //-------------------
    //연인 해제 확인
    hum.SendDefMessage(SM_LM_DELETE_REQ, 0, 0, 0, 0, m_sCharName);
    /////////////////////
    exit;
    //-------------------
  end;

  if RelationShipDeleteOther(ReqType, OtherName) then begin
    hum := UserEngine.GetPlayObject(OtherName);
    if hum <> nil then begin
      hum.RelationShipDeleteOther(ReqType, m_sCharName);
    end;

  end else begin
    SendDefMessage(SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
  end;

end;


procedure TPlayObject.ServerGetRelationDeleteRequestOk(ReqType: integer;        //연인 스쳐사망
  OtherName: string);
var
  svidx: integer;
  hum:   TPlayObject;
  cert:  TPlayObject;
  strPayment: string;
begin
  //연인 관계일 경우...
  if ReqType = RsState_Lover then begin
    // 앞에 있는 상대를 얻는다.
    cert := PlayGetPoseCreate;
    // 타겟이 없거나 , 마주보고 있지 않거나 , 인간이 아니면 나간다.
    if (cert = nil) or (cert.PlayGetPoseCreate <> Self) or
      (cert.m_btRaceServer <> RC_PLAYOBJECT) then begin
      BoxMsg('흔벎狼썩뇜뤼펄밑溝，狼宅뚤렘충뚤충였淪。', 0);
      Exit;
    end;

    // human 으로 타입 바꿈
    hum := TPlayObject(cert);
    if hum = nil then
      exit;

    // 상대방이 나의 연인인지 체크
    if not ((hum.fLover.GetLoverName = m_sCharName) and
      (fLover.GetLoverName = hum.m_sCharName)) then begin
      BoxMsg('뚤렘꼇角콱돨갖훙。', 0);
      Exit;
    end;

    // 위자료 낼 돈이 있는지 확인
    if m_nGold < COMPENSATORY_PAYMENT then begin
      strPayment := IntToStr(COMPENSATORY_PAYMENT div 10000);
      BoxMsg('잼삯矜狼連마 ' + strPayment + '쏜귑돨롤痰。', 0);
      exit;
    end;
  end;

  if RelationShipDeleteOther(ReqType, OtherName) then begin

    if ReqType = RsState_Lover then begin
      //위자료 지불
      if m_nGold >= COMPENSATORY_PAYMENT then begin
        DecGold(COMPENSATORY_PAYMENT);
        GoldChanged;
      end;
      //상태 변경(둔화)
      MakePosion(POISON_SLOWDOWN, 3, 1);
      //HP, MP 변경(50%)
      m_WAbil.HP := _MAX(1, m_WAbil.HP div 2);
      m_WAbil.MP := _MAX(1, m_WAbil.MP div 2);

      //충격 메시지
      SysMsg('콱綠쒔돨잼삯죄，잼삯돨댔샌賈콱돨橄昑슉됴。', c_Red, t_Hint);

      //로그남김
     { AddUserLog('47'#9 + //연인_   //LastLogNumber
        m_sMapName + ''#9 + IntToStr(m_nCurrX) + ''#9 + IntToStr(m_nCurrY) + ''#9 +
        m_sCharName + ''#9 + '0'#9 + '0'#9 + '2'#9 +  //해제:2
        OtherName);     }
    end;

    hum := UserEngine.GetPlayObject(OtherName);
    if hum <> nil then begin
      if hum.RelationShipDeleteOther(ReqType, m_sCharName) then begin
        if ReqType = RsState_Lover then begin
          //위자료 지불
          if hum.m_nGold >= COMPENSATORY_PAYMENT then begin
            hum.DecGold(COMPENSATORY_PAYMENT);
            hum.GoldChanged;
          end;
          //상태 변경(둔화)
          hum.MakePosion(POISON_SLOWDOWN, 3, 1);
          //HP, MP 변경(50%)
          hum.m_WAbil.HP := _MAX(1, hum.m_WAbil.HP div 2);
          hum.m_WAbil.MP := _MAX(1, hum.m_WAbil.MP div 2);

          //충격 메시지
          hum.SysMsg(
            '콱綠쒔돨잼삯죄，잼삯돨댔샌賈콱돨橄昑슉됴。',
            c_Red,t_Hint);

          //로그남김
         { AddUserLog('47'#9 + //연인_   //LastLogNumber
            hum.m_sMapName + ''#9 + IntToStr(hum.m_nCurrX) + ''#9 +
            IntToStr(hum.m_nCurrY) + ''#9 + hum.m_sCharName + ''#9 + '0'#9 +
            '0'#9 + '2'#9 +  //해제:2
            m_sCharName);   }
        end;
      end;
    end;

  end else begin
    SendDefMessage(SM_LM_RESULT, ReqType, RsError_DontDelete, 0, 0, OtherName);
  end;
end;

procedure TPlayObject.ServerGetRelationDeleteRequestFail(ReqType: integer;     //연인 스쳐사망
  OtherName: string);
var
  hum: TPlayObject;
begin
  hum := UserEngine.GetPlayObject(OtherName);
  if hum = nil then
    exit;

  //교제 거부 메시지
  hum.SysMsg(m_sCharName + '앳없잼삯。', c_RedWhite, t_Hint);
end;

procedure TPlayObject.ServerSetRelationDBAdd(Character, Other, State, level, Sex, Date: string);     //연인 스쳐사망
var
  DBM: TADOCommand;
begin

  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'INSERT INTO TBL_RELATION (FLD_CHARACTER,FLD_OTHER,FLD_STATE,FLD_LEVEL,FLD_GENDER,FLD_DATE) values (:FLD_CHARACTER, :FLD_OTHER, :FLD_STATE, :FLD_LEVEL, :FLD_GENDER, :FLD_DATE)';
  DBM.Parameters.ParamByName('FLD_CHARACTER').Value := Character;
  DBM.Parameters.ParamByName('FLD_OTHER').Value := Other;
  DBM.Parameters.ParamByName('FLD_STATE').Value := State;

  DBM.Parameters.ParamByName('FLD_LEVEL').Value := level;
  DBM.Parameters.ParamByName('FLD_GENDER').Value := Sex;

  DBM.Parameters.ParamByName('FLD_DATE').Value := Date;
  DBM.Execute;
  DBM.CommandText := '';

end;

procedure TPlayObject.ServerGetRelationDBGetList();
var
  sMsg : string;
  I: Integer;
  DBM: TADOQuery;
   msgstr  : string;
   ListCnt : integer;
   str     : string;
   datastr : string;
   tempstr : string;
   _Name   : string;
   _State  : string;
   _Level  : string;
   _Sex    : string;
   _Date   : string;

   hum : TPlayObject;
   svidx: integer;
   lovername : string;
begin

  sMsg := '';

  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  sMsg := 'SELECT * FROM TBL_RELATION Where FLD_CHARACTER='''+Self.m_sCharName+''' ORDER BY FLD_ID';
  DBM.SQL.Clear;
  DBM.SQL.Add(sMsg);
  DBM.Open;
  sMsg := '';

  for I := 0 to DBM.RecordCount do begin
    if DBM.eof then break;

    _Name :=  DBM.FieldByName('FLD_OTHER').AsString;
    _State := DBM.FieldByName('FLD_STATE').AsString;
    _Level := DBM.FieldByName('FLD_LEVEL').AsString;
    _Sex := DBM.FieldByName('FLD_GENDER').AsString;
    _Date := DBM.FieldByName('FLD_DATE').AsString;

    case StrToInt(_State) of
      rsState_Lover   :// 연인
        begin
        FLover.Add( Self.m_sCharName , _Name , StrToInt(_State) , StrToInt(_Level) , StrToInt(_Sex) , _Date , GetCharMapInfo(_Name) );
        end;
      RsState_LoverEnd:// 연인탈퇴
        begin
        SendDefMessage (SM_LM_RESULT, 0,rsState_Lover, RsError_SuccessDelete, 0, _Name);
            // DB에서 삭제한다.
        SendMsg (Self,RM_LM_DBDELETE,0,0,0,0,_Name);
        end;
     end;

     msgstr := Self.fLover.GetListmsg( StrToInt(_State) , ListCnt );
     if ( ListCnt > 0 ) then begin
        SendDefMessage (SM_LM_LIST, 0, ListCnt, 0, 0, msgstr);
     end;

     //최초 접속시 연인에게도 보냄(sonmg)

      lovername := fLover.GetLoverName;
      hum := UserEngine.GetPlayObject(lovername);
      if hum <> nil then begin
         if hum.fLover.GetLoverName <> '' then begin
            hum.SysMsg(m_sCharName + '攣뇹黨뒈暠' + GetCharMapInfo(m_sCharName) + '뇹。', c_Green,t_Hint);
            SysMsg(hum.m_sCharName + '攣뇹黨뒈暠' + GetCharMapInfo(hum.m_sCharName) + '뇹。', c_Green,t_Hint);

            //2005 빼빼로 이벤트
            GetObjectEventEffect;
            hum.GetObjectEventEffect;
         end;
      end;

      ClientQueryUserName(self, m_nCurrX, m_nCurrY);   //연인 표시


    DBM.Next;
  end;
  DBM.Close;
end;

procedure TPlayObject.ServerSetRelationDBDelete(body : String);    //연인 스쳐
var
  DBM: TADOCommand;
begin
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'DELETE FROM TBL_RELATION WHERE FLD_CHARACTER = :FLD_CHARACTER and FLD_OTHER = :FLD_OTHER';
  DBM.Parameters.ParamByName('FLD_CHARACTER').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_OTHER').Value := body;
  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.ServerSetRelationDBChange(Name,State : String);    //연인 스쳐
var
  DBM: TADOCommand;
begin
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'UPDATE TBL_RELATION SET FLD_STATE=:FLD_STATE WHERE FLD_CHARACTER = :FLD_CHARACTER and FLD_OTHER = :FLD_OTHER';
  DBM.Parameters.ParamByName('FLD_STATE').Value := State;
  DBM.Parameters.ParamByName('FLD_CHARACTER').Value := Name;
  DBM.Parameters.ParamByName('FLD_OTHER').Value := Self.m_sCharName;
  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.ServerSetMentorDBAdd(Character, Other, State, Date: string; mode: byte);     //사제 스쳐사망
var
  DBM: TADOCommand;
begin

  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'INSERT INTO TBL_MENTOR (FLD_CHARACTER,FLD_OTHER,FLD_STATE,FLD_DATE,FLD_MODE) values (:FLD_CHARACTER, :FLD_OTHER, :FLD_STATE, :FLD_DATE, :FLD_MODE)';

  DBM.Parameters.ParamByName('FLD_CHARACTER').Value := Character;
  DBM.Parameters.ParamByName('FLD_OTHER').Value := Other;
  DBM.Parameters.ParamByName('FLD_STATE').Value := State;
  DBM.Parameters.ParamByName('FLD_DATE').Value := Date;
  DBM.Parameters.ParamByName('FLD_MODE').Value := mode;

  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.ServerGetMentorDBGetList();  //사제 스쳐
var
  sMsg : string;
  I: Integer;
  DBM: TADOQuery;
  msgstr  : string;
  ListCnt : integer;
  str     : string;
  datastr : string;
  tempstr : string;

  _Name   : string;
  _State  : string;
  _Date   : string;
  _Mode   : Byte;

   hum : TPlayObject;
   svidx: integer;
begin
  sMsg := '';

  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  sMsg := 'SELECT * FROM TBL_MENTOR Where FLD_CHARACTER='''+Self.m_sCharName+''' ORDER BY FLD_ID';

  DBM.SQL.Clear;
  DBM.SQL.Add(sMsg);
  DBM.Open;
  sMsg := '';

  for I := 0 to DBM.RecordCount do begin
    if DBM.eof then break;
    _Name :=  DBM.FieldByName('FLD_OTHER').AsString;
    _State := DBM.FieldByName('FLD_STATE').AsString;
    _Date := DBM.FieldByName('FLD_DATE').AsString;
    _Mode := DBM.FieldByName('FLD_MODE').AsInteger;

    case StrToInt(_State) of
      rsState_Master   :// 사제
        begin
          if _Mode = 1 then begin     //스승일 경우
            hum := UserEngine.GetPlayObject(_Name);
            if hum <> nil then begin //제자 접속 해있다
              if hum.fMentor.GetMentorName <> '' then begin
                hum.FMentor.Change( Self.m_sCharName , Self.m_Abil.Level , Self.m_btJob , 1);
                FMentor.Add( Self.m_sCharName , hum.m_sCharName , StrToInt(_State) , hum.m_Abil.Level , hum.m_btJob , 1 , 1, _Date);

                msgstr := hum.FMentor.GetListmsg( StrToInt(_State) , ListCnt );
                if ( ListCnt > 0 ) then begin
                  hum.SendDefMessage (SM_ME_INFO, 0, ListCnt, 0, 0, msgstr);
                end;
              end;
            end else begin
               FMentor.Add( Self.m_sCharName , _Name , StrToInt(_State) , 0 , 0 , 1 , 0, _Date);
            end;
            if g_ManageNPC <> nil then begin
              g_ManageNPC.GotoLable(Self,'@Mentor',False);
            end;

          end else begin     //제자일 경우
            hum := UserEngine.GetPlayObject(_Name);
            if hum <> nil then begin //제자 접속 해있다
              if hum.fMentor.GetMentorName <> '' then begin
                hum.FMentor.Change( Self.m_sCharName , Self.m_Abil.Level , Self.m_btJob, 1);
                FMentor.Add( Self.m_sCharName , hum.m_sCharName , StrToInt(_State) , hum.m_Abil.Level, hum.m_btJob , 0 , 1, _Date);

                msgstr := hum.FMentor.GetListmsg( StrToInt(_State) , ListCnt );
                if ( ListCnt > 0 ) then begin
                  hum.SendDefMessage (SM_ME_INFO, 0, ListCnt, 0, 0, msgstr);
                end;
              end;
            end else begin
               FMentor.Add( Self.m_sCharName , _Name , StrToInt(_State) , 0 , 0 , 0 , 0, _Date);
            end;
            //제자 버프
             RecalcPupilAbilitys(0);
          end;
        end;
      RsState_MasterEnd:// 사제탈퇴
        begin
          if ( UniXToDateTime(StrToInt(_Date)) <= Now) then begin
              // DB에서 삭제한다.
            SendMsg (Self,RM_ME_DBDELETE,0,0,0,0,_Name);
          end;
        end;
     end;

     msgstr := Self.FMentor.GetListmsg( StrToInt(_State) , ListCnt );
     if ( ListCnt > 0 ) then begin
        SendDefMessage (SM_ME_LIST, 0, ListCnt, 0, 0, msgstr);
     end;



     DBM.Next;
    end;
    DBM.Close;
end;

procedure TPlayObject.ServerSetMentorDBDelete(body : String);    //사제 스쳐
var
  DBM: TADOCommand;
begin
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'DELETE FROM TBL_MENTOR WHERE FLD_CHARACTER = :FLD_CHARACTER and FLD_OTHER = :FLD_OTHER';
  DBM.Parameters.ParamByName('FLD_CHARACTER').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_OTHER').Value := body;
  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.ServerSetMentorDBChange(Taget, Name : String ; State ,date : integer );    //사제 스쳐
var
  DBM: TADOCommand;
begin
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;

  DBM.CommandText := 'UPDATE TBL_MENTOR SET FLD_STATE=:FLD_STATE , FLD_DATE=:FLD_DATE  WHERE FLD_CHARACTER = :FLD_CHARACTER and FLD_OTHER = :FLD_OTHER';

  DBM.Parameters.ParamByName('FLD_STATE').Value := State;
  DBM.Parameters.ParamByName('FLD_DATE').Value := DateTimeToUnix(IncDay(now(), date));

  DBM.Parameters.ParamByName('FLD_CHARACTER').Value := Taget;
  DBM.Parameters.ParamByName('FLD_OTHER').Value := Name ;

  DBM.Execute;
  DBM.CommandText := '';
end;




function TPlayObject.ServerGetMentorDBDate: integer;  //사제 스쳐
var
  sMsg : string;
  I: Integer;
  DBM: TADOQuery;
  _Date   : string;
begin
  sMsg := '';
  Result := 0;
  _Date := '0';
  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  sMsg := 'SELECT * FROM TBL_MENTOR Where FLD_CHARACTER='''+Self.m_sCharName+''' ORDER BY FLD_ID';

  DBM.SQL.Clear;
  DBM.SQL.Add(sMsg);
  DBM.Open;
  sMsg := '';

  for I := 0 to DBM.RecordCount do begin
    if DBM.eof then break;

    _Date := DBM.FieldByName('FLD_DATE').AsString;
   DBM.Next;
  end;
  DBM.Close;
  Result:= StrToInt(_Date);
end;



procedure TPlayObject.RecalcPupilAbilitys(Up:integer);//제자 버프
var
  str:string;
begin
   case Up of
     0: begin
       str := '';
       case m_btJob of
        0,5 : begin                     //직업변경
          m_wStatusArrValue[47] := 4;    //전사
          str := str + '묑샌 0-4 ';
        end;
        1,6 : begin
          m_wStatusArrValue[49] := 3;    //술사
          str := str + '침랬 0-3 ';
        end;
        2,7 : begin
          m_wStatusArrValue[50] := 2;    //도사
          str := str + '돛減 0-2 ';
        end;
        3,8 : begin
          m_wStatusArrValue[48] := 2;    //자객
          str := str + '묑샌 2-2 ';
        end;
        4,9 : begin      //승려 스승의가호
          m_wStatusArrValue[47] := 2;
          m_wStatusArrValue[50] := 2;
          str := str + '묑샌 0-2、침랬 0-2 ';
        end;
       end;
       m_wStatusArrValue[45] := Round(m_Abil.MaxHP * 0.1);  //체력
       m_wStatusArrValue[46] := Round(m_Abil.MaxMP * 0.1);  //마력
       m_wStatusArrValue[51] := 1;                          //행운

       str := str + '餉篁덧◐㎎ⓙ +10% 妗頓 +1';

       SendMsg(self,RM_BUFF, 30, 0, 30, 1, '[ 일可돨瓜拮 ]\'+str); //스승의가호 버프
     end;
     1: begin
      if m_wStatusArrValue[45] > 0 then begin
       m_wStatusArrValue[45] := 0;
       m_wStatusArrValue[46] := 0;
       m_wStatusArrValue[47] := 0;
       m_wStatusArrValue[48] := 0;
       m_wStatusArrValue[49] := 0;
       m_wStatusArrValue[50] := 0;
       m_wStatusArrValue[51] := 0;
       SendMsg(self,RM_BUFF, 30, 0, 30, 0, ''); //스승의가호 버프
      end;
     end;
   end;
   RecalcAbilitys;
   SendMsg(Self,RM_ABILITY,0,0,0,0,'');
   SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
end;

procedure TPlayObject.RecalcGroupAbilitys();//그룹버프
var
  str:string;
begin
  str := '';
  if m_GroupOwner <> nil then begin
   // if m_GroupOwner.m_boCheckHero then begin      //영웅 해제 일때 버프를 준다.

      m_wStatusArrValue[102] := g_Config.nGroupBuffHp;    //MAXHP
      str := str + 'MAXHP +' + IntToStr(g_Config.nGroupBuffHp) + '\';
      m_wStatusArrValue[103] := g_Config.nGroupBuffRecHp;    //체력회복
      str := str + '餉環寧 +' + IntToStr(g_Config.nGroupBuffRecHp) + '%\';
      m_nKillMonExpRate10 := 100 + g_Config.nGroupBuffExp;      //경험치
      str := str + '쒔駱令 +' + IntToStr(g_Config.nGroupBuffExp) + '%\';
      m_nPowerRate6 := 100 + g_Config.nGroupBuffPo;            //공격력
      str := str + '묑샌제 +' + IntToStr(g_Config.nGroupBuffPo) + '%\';
      SendMsg(self, RM_BUFF, 116, 0, 106, 1, '[莉뚠BUFF]\'+ str); //그룹 버프

   {  SendMsg(self, RM_BUFF, 116, 0, 106, 1, '[그룹버프 - 영웅해제]\'+ str); //그룹 버프
      if m_MyHero <> nil then begin THeroObject(m_MyHero).LogOut; end;
    end else begin  //버프를 주지 않거나 해제한다.
      m_wStatusArrValue[102] := 0;
      m_wStatusArrValue[103] := 0;
      m_nKillMonExpRate10 := 100;
      m_nPowerRate6 := 100;
      SendMsg(self, RM_BUFF, 116, 0, 106, 0, ''); //그룹 버프
    end;   }
  end else begin
    m_wStatusArrValue[102] := 0;
    m_wStatusArrValue[103] := 0;
    m_nKillMonExpRate10 := 100;
    m_nPowerRate6 := 100;
    SendMsg(self, RM_BUFF, 116, 0, 106, 0, ''); //그룹 버프
  end;
  RecalcAbilitys;
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
end;

procedure TPlayObject.RecalcGuildLevelAbilitys(Up:integer);//문파성장
var
  str:string;
begin
  case Up of
   0: begin
     if m_MyGuild <> nil then begin
       m_wStatusArrValue[40] := (TGuild(m_MyGuild).nGrowHP * 20);
       m_wStatusArrValue[41] := (TGuild(m_MyGuild).nGrowMP * 20);
       m_nKillMonExpRate6 := 100 + (TGuild(m_MyGuild).nGrowEXP * 4);
       m_wStatusArrValue[42] := (TGuild(m_MyGuild).nGrowAC * 2);
       m_wStatusArrValue[43] := (TGuild(m_MyGuild).nGrowMAC * 2);
       if (TGuild(m_MyGuild).nGrowLuck) > 4 then
         m_wStatusArrValue[44] := (TGuild(m_MyGuild).nGrowLuck div 5);
       if (TGuild(m_MyGuild).nGrowPower) > 0 then
        m_nPowerRate4 := 100 + (TGuild(m_MyGuild).nGrowPower + 5);
     end else begin
       m_wStatusArrValue[40] := 0;
       m_wStatusArrValue[41] := 0;
       m_nKillMonExpRate6 := 100 ;
       m_wStatusArrValue[42] := 0;
       m_wStatusArrValue[43] := 0;
       m_wStatusArrValue[44] := 0;
       m_nPowerRate4 := 100;
       SendMsg(self, RM_BUFF, 42, 0, 507, 0, ''); //문파성장 버프
     end;
   end;
   1: begin
     if m_MyGuild <> nil then begin
        m_wStatusArrValue[40] := (TGuild(m_MyGuild).nGrowHP * 20);
     end;
   end;
   2: begin
     if m_MyGuild <> nil then begin
        m_wStatusArrValue[41] := (TGuild(m_MyGuild).nGrowMP * 20);
     end;
   end;
   3: begin
     if m_MyGuild <> nil then begin
       m_nKillMonExpRate6 := 100 + (TGuild(m_MyGuild).nGrowEXP * 4);
     end;
   end;
   4: begin
     if m_MyGuild <> nil then begin
        m_wStatusArrValue[42] := (TGuild(m_MyGuild).nGrowAC * 2);
     end;
   end;
   5: begin
     if m_MyGuild <> nil then begin
        m_wStatusArrValue[43] := (TGuild(m_MyGuild).nGrowMAC * 2);
     end;
   end;
   6: begin
     if m_MyGuild <> nil then begin
       if (TGuild(m_MyGuild).nGrowPower) > 0 then
        m_nPowerRate4 := 100 + (TGuild(m_MyGuild).nGrowPower + 5);
     end;
   end;
   7: begin
     if m_MyGuild <> nil then begin
       if (TGuild(m_MyGuild).nGrowLuck) > 4 then
         m_wStatusArrValue[44] := (TGuild(m_MyGuild).nGrowLuck div 5);
     end;
   end;
  end;
  RecalcAbilitys;
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  if m_Abil.HP > m_Abil.MaxHP then m_Abil.HP:=m_Abil.MaxHP;
  if m_Abil.MP > m_Abil.MaxMP then m_Abil.MP:=m_Abil.MaxMP;

  if (TGuild(m_MyGuild).nGrowHP > 0) or (TGuild(m_MyGuild).nGrowMP > 0) or (TGuild(m_MyGuild).nGrowEXP > 0) or (TGuild(m_MyGuild).nGrowAC > 0)
    or (TGuild(m_MyGuild).nGrowMAC > 0) or (TGuild(m_MyGuild).nGrowPower > 0) or (TGuild(m_MyGuild).nGrowLuck > 4) then begin

   str := '';
   if TGuild(m_MyGuild).nGrowHP > 0 then
   str := 'HP ' + str + IntToStr(TGuild(m_MyGuild).nGrowHP * 20) + ' ';
   if TGuild(m_MyGuild).nGrowMP > 0 then
   str := 'MP ' + str + IntToStr(TGuild(m_MyGuild).nGrowMP * 20) + ' ';
   if TGuild(m_MyGuild).nGrowEXP > 0 then
   str := '쒔駱令 ' + str + IntToStr(TGuild(m_MyGuild).nGrowEXP * 4) + '% ';
   if TGuild(m_MyGuild).nGrowAC > 0 then
   str := '렝徒 ' + str + IntToStr(TGuild(m_MyGuild).nGrowAC * 2) + ' ';
   if TGuild(m_MyGuild).nGrowMAC > 0 then
   str := '침랬렝徒 ' + str + IntToStr(TGuild(m_MyGuild).nGrowMAC * 2) + ' ';
   if TGuild(m_MyGuild).nGrowPower > 0 then
   str := '묑샌제 ' + str + IntToStr(TGuild(m_MyGuild).nGrowPower + 5) + '% ';
   if TGuild(m_MyGuild).nGrowLuck > 4 then
   str := '妗頓 ' + str + IntToStr(TGuild(m_MyGuild).nGrowLuck div 5)+ ' ';

   str := str + '+';

   SendMsg(self, RM_BUFF, 42, 0, 507, 1, '[ 契삔BUFF ]\'+ str); //문파성장 버프
  end;
end;

procedure TPlayObject.SendAdjustBonus; //004DA9E4
var
  sSendMsg:String;
  OldPoint:Integer;
  //NakedAbil:TNakedAbility;
begin
  if m_nBonusPoint > g_Config.nBonusPointHack then begin  //보너스포인트 핵
    MainOutMessage('[賈痰렷랬넋埼]쉽쟨생롸: ' + GetGoldStr(m_nBonusPoint)
                  + ' 실ッ : ' + m_sCharName + ' ID : ' + m_sUserID + ' [IP : ' + m_sIPaddr + ']');
    FillChar(m_BonusAbil,SizeOf(TNakedAbility),#0);
    m_nBonusPoint := 0;
  end;
  m_DefMsg:=MakeDefaultMsg(SM_ADJUST_BONUS,m_nBonusPoint,0,0,0);
  sSendMsg:='';
  case m_btjob of
    jWarr, jUpWarr: sSendMsg:=
                 EncodeBuffer(@g_Config.BonusAbilofWarr,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@m_BonusAbil,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@g_Config.NakedAbilofWarr,SizeOf(TNakedAbility));
    jWizard, jUpWiz: sSendMsg:=
                 EncodeBuffer(@g_Config.BonusAbilofWizard,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@m_BonusAbil,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@g_Config.NakedAbilofWizard,SizeOf(TNakedAbility));
    jTaos, jUpTao: sSendMsg:=
                 EncodeBuffer(@g_Config.BonusAbilofTaos,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@m_BonusAbil,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@g_Config.NakedAbilofTaos,SizeOf(TNakedAbility));
    jAssassin, jUpAssa: sSendMsg:=
                 EncodeBuffer(@g_Config.BonusAbilofAssassin,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@m_BonusAbil,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@g_Config.NakedAbilofAssassin,SizeOf(TNakedAbility));            //자객  //비연자객
    jBonze, jUpBoz: sSendMsg:=
                 EncodeBuffer(@g_Config.BonusAbilofBonze,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@m_BonusAbil,SizeOf(TNakedAbility)) + '/' +
                 EncodeBuffer(@g_Config.NakedAbilofBonze,SizeOf(TNakedAbility));
  end;    // case
  SendSocket(@m_DefMsg,sSendMsg);
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean; //004C3CA0
begin
  Result:=False;
  if (m_nCurrX -1 <= BaseObject.m_nCurrX) and
     (m_nCurrX +1 >= BaseObject.m_nCurrX) and
     (m_nCurrY -1 <= BaseObject.m_nCurrY) and
     (m_nCurrY +1 >= BaseObject.m_nCurrY) and
     ((m_nCurrX <> BaseObject.m_nCurrX) or
     (m_nCurrY <> BaseObject.m_nCurrY)) then begin
    Result:=True;
    if ((m_nCurrX -1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then begin
      btDir:=DR_LEFT;
      exit;
    end;
    if ((m_nCurrX +1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then begin
      btDir:=DR_RIGHT;
      exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir:=DR_UP;
      exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir:=DR_DOWN;
      exit;
    end;
    if ((m_nCurrX -1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir:=DR_UPLEFT;
      exit;
    end;
    if ((m_nCurrX +1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then begin
      btDir:=DR_UPRIGHT;
      exit;
    end;
    if ((m_nCurrX -1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir:=DR_DOWNLEFT;
      exit;
    end;
    if ((m_nCurrX +1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then begin
      btDir:=DR_DOWNRIGHT;
      exit;
    end;
    btDir:=0;
  end;
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; nRange: Integer; var btDir: Byte): Boolean;
var
  nX, nY: Integer;
begin
  Result := False;
  btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX, BaseObject.m_nCurrY);
  if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, nRange, nX, nY) then begin
    Result := BaseObject = TBaseObject(m_PEnvir.GetMovingObject(nX, nY, True));
  end;
end;

function TBaseObject.TargetInSpitRange(BaseObject: TBaseObject;var btDir: Byte): Boolean; //004C3E68
var
  nX,nY:Integer;
begin
  Result:=False;
  if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 2) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 2) then begin
    nX:=BaseObject.m_nCurrX - m_nCurrX;
    nY:=BaseObject.m_nCurrY - m_nCurrY;
    if (abs(nX) <= 1) and (abs(nY) <= 1) then begin
      GetAttackDir(BaseObject,btDir);
      Result:=True;
      exit;
    end;
    Inc(nX,2);
    Inc(nY,2);
    if ((nX >= 0) and (nX <= 4)) and ((nY >= 0) and (nY <= 4)) then begin
      btDir:=GetNextDirection(m_nCurrX,m_nCurrY,BaseObject.m_nCurrX,BaseObject.m_nCurrY);
      if g_Config.SpitMap[btDir,nY,nX] = 1 then
        Result:=True;
    end;

  end;

end;

//004BF6F0
function TBaseObject.RecalcBagWeight:Integer;   //물약 무게
var
  I: Integer;
  UserItem:PTUserItem;
  StdItem:TItem;
begin
  Result:=0;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      if (StdItem.StdMode in [0,1,3]) then //물약 무게  //겹치기
        inc(Result,(StdItem.Weight * UserItem.Amount))
      else
      if (StdItem.StdMode = 45) then //물약 무게  //겹치기
        inc(Result,(StdItem.Weight * UserItem.Amount) div 2)
      else
        Inc(Result,StdItem.Weight);
    end;
  end;
end;
//004BFD50
procedure TBaseObject.RecalcHitSpeed;
 function CheckWeapon():Boolean;  //체크
  var
    AmuletStdItem:TItem;
  begin
    Result:=False;
    if self.m_UseItems[U_WEAPON].wIndex > 0 then begin
      AmuletStdItem:=UserEngine.GetStdItem(self.m_UseItems[U_WEAPON].wIndex);
      if (AmuletStdItem <> nil) and ((AmuletStdItem.StdMode = 99)) then Result:=True;
    end;
  end;
var
  I: Integer;
  UserMagic:pTUserMagic;
  BonusTick:pTNakedAbility;
begin
  BonusTick:=nil;
  case m_btJob of
    jWarr, jUpWarr: BonusTick:=@g_Config.BonusAbilofWarr;
    jWizard, jUpWiz: BonusTick:=@g_Config.BonusAbilofWizard;
    jTaos, jUpTao: BonusTick:=@g_Config.BonusAbilofTaos;
    jAssassin, jUpAssa: BonusTick:=@g_Config.BonusAbilofAssassin;  //자객    //비연자객
    jBonze, jUpBoz: BonusTick:=@g_Config.BonusAbilofBonze;
  end;
  m_btHitPoint:=DEFHIT + m_BonusAbil.Hit div BonusTick.Hit;

  case m_btJob of
    jTaos,jAssassin, jUpTao, jUpAssa: m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed + 3;  //도사, 자객은 기본 민첩이 높다.
    else m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed;
  end;

  case m_btJob of
    jAssassin, jUpAssa: m_btHitPoint:=DEFHIT + m_BonusAbil.Hit div BonusTick.Hit + 2;  //자객 은 기본 정확이 7.
    jBonze, jUpBoz : m_btHitPoint:=DEFHIT + m_BonusAbil.Hit div BonusTick.Hit + 3;  //승려는 기본 정
    else m_btHitPoint:=DEFHIT + m_BonusAbil.Hit div BonusTick.Hit;
  end;

  m_nHitPlus:=0;
  m_nHitDouble:=0;
  
  m_MagicOneSwordSkill  := nil;          //외수검법
  m_MagicPowerHitSkill  := nil;
  m_MagicGukCheSkill    := nil;   //격체전공
  m_AssassinHitSkill    := nil;  //절명검법
  m_MagicHemorrhageSkill:= nil;  //혈풍격

  m_MagicWindBladeSkill := nil;       //풍검술
  m_MagicErgumSkill     := nil;
  m_MagicBanwolSkill    := nil;
  m_MagicTaguSkill      := nil;
  m_MagicFireSwordSkill := nil;
  m_MagicDeathSwordSkill:= nil;
  m_MagicCrsSkill       := nil;
  m_MagicNanCrsSkill    := nil;     //난화혈풍참
  m_MagicCrsBongskill   := nil;
  m_MagicTwnHitSkill    := nil;        //쌍룡참
  m_MagicThunderShaolin := nil;
  m_MagicFireShaolin    := nil;
  m_MagicVampSkill      := nil;       //흡기
  m_MagicChunMuSkill    := nil;
  for I := 0 to m_MagicList.Count - 1 do begin
    UserMagic:=m_MagicList.Items[i];
    case UserMagic.wMagIdx of
      SKILL_ONESWORD: begin  //외수검법
        m_MagicOneSwordSkill:=UserMagic;
        if UserMagic.btLevel > 0 then begin
          m_btHitPoint:=m_btHitPoint + ROUND(9/3* UserMagic.btLevel);
        end;
      end;
      SKILL_GUKCHE: begin  //격체전공 - 승려
        m_MagicGukCheSkill:=UserMagic;
        if UserMagic.btLevel > 0 then begin
          m_btHitPoint:=m_btHitPoint + ROUND(3 * UserMagic.btLevel);
          m_btSpeedPoint:=m_btSpeedPoint + ROUND(3/3* UserMagic.btLevel);
        end;
      end;
      SKILL_YEDO: begin //예도검법
        m_MagicPowerHitSkill:=UserMagic;
        if UserMagic.btLevel > 0 then begin
          m_btHitPoint:=m_btHitPoint + ROUND(3/3* UserMagic.btLevel);
        end;
        m_nHitPlus:=DEFHIT + UserMagic.btLevel;
        m_btAttackSkillCount:=7 - UserMagic.btLevel;
        m_btAttackSkillPointCount:=Random(m_btAttackSkillCount);
      end;
      SKILL_ERGUM: begin //어검술
        m_MagicErgumSkill:=UserMagic;
      end;
      SKILL_BANWOL: begin //반월검법
        m_MagicBanwolSkill:=UserMagic;
      end;
      SKILL_FIRESWORD: begin //염화결
        m_MagicFireSwordSkill:=UserMagic;
        if (m_wStatusTimeArr[STATE_WINDMOON] > 0) then
         m_nHitDouble:= 4 + UserMagic.btLevel * 5  //염화결 강화
        else
         m_nHitDouble:= 4 + UserMagic.btLevel * 3;    //+40% ~ +160%
      end;

      SKILL_DEATHHIT: begin //살생도
        m_MagicDeathSwordSkill:=UserMagic;
        m_nHitDouble:= 4 + UserMagic.btLevel * 4;
      end;

      SKILL_WINDBLADE: begin //풍검술
        m_MagicWindbladeSkill:=UserMagic;
        m_nHitDouble:= 4 + UserMagic.btLevel * 4;
      end;
      SKILL_ILKWANG: begin //일광검법
        m_MagicOneSwordSkill:=UserMagic;
        if UserMagic.btLevel > 0 then begin
          m_btHitPoint:=m_btHitPoint + ROUND(8/3* UserMagic.btLevel);
        end;
      end;
      SKILL_CROSSMOON{34}: begin     //광풍참
        m_MagicCrsSkill:=UserMagic;
        m_nHitPlus:=DEFHIT + UserMagic.btLevel;
      end;
      SKILL_NANHWA{131}: begin    //난화혈풍참
        m_MagicNanCrsSkill:=UserMagic;
        m_nHitPlus:=DEFHIT + UserMagic.btLevel;
      end;

      SKILL_CROSSBONG: begin     //회풍천봉법
        m_MagicCrsBongskill:=UserMagic;
        m_nHitPlus:=DEFHIT + UserMagic.btLevel;
      end;

      SKILL_TWINBLADE: begin      //쌍룡참
        m_MagicTwnHitSkill:=UserMagic;
        m_nHitPlus:=UserMagic.btLevel;
      end;
      SKILL_TAGUBONG: begin //타구봉법 - 승려
        m_MagicTaguSkill:=UserMagic;
        m_nHitPlus:=DEFHIT + UserMagic.btLevel;
      end;
      SKILL_THUNDERSHAILIN: begin      //뇌룡봉법
        m_MagicThunderShaolin:=UserMagic;
        m_nHitPlus:=DEFHIT * (UserMagic.btLevel + 1) * 2;
      end;
      SKILL_FIRESHAOLIN: begin      //천화봉법
        m_MagicFireShaolin:=UserMagic;
        m_nHitPlus:=DEFHIT * (UserMagic.btLevel + 1) * 2;
        m_nHitDouble:= 4 + UserMagic.btLevel * 3;
      end;
      SKILL_JEOLMYEONG: begin //절명검법
        m_AssassinHitSkill:=UserMagic;
        m_nHitPlus := DEFHIT + ((2 + UserMagic.btLevel) * 5);      //파워 5, 8, 11, 14
        m_btAssassinHitCount := 7 + Random(11) - UserMagic.btLevel;
        m_btAssassinHitPointCount := Random(m_btAssassinHitCount);
      end;

      SKILL_VAMPMANA: begin //흡기
        m_MagicVampSkill:=UserMagic;
        m_btManaEaterCount := 9 + Random(15) - UserMagic.btLevel;
        m_btManaEaterPointCount := Random(m_btManaEaterCount);
      end;
      SKILL_CHENMU : begin         //천무
        m_MagicChunMuSkill := UserMagic;
        m_nHitPlus := 10 + UserMagic.btLevel * 10;
        m_nHitDouble := 6 + UserMagic.btLevel * 10;
      end;
      SKILL_BLOODWIND: begin //혈풍격
        if CheckWeapon then begin
          m_MagicHemorrhageSkill:=UserMagic;
          m_nHitPlus := 4 + UserMagic.btLevel * 4;
          m_btHemorrhageCount := 7 + Random(15) - UserMagic.btLevel;
          m_btHemorrhagePointCount := Random(m_btHemorrhageCount);
        end;
      end;

    end;
  end;
end;
//004BFFD0
procedure TBaseObject.AddItemSkill(nIndex: Integer);
var
  Magic      :pTMagic;
  UserMagic  :pTUserMagic;
begin
  Magic:=nil;
  case nIndex of
    1: Magic:=UserEngine.FindMagic(g_Config.sFireBallSkill);
    2: Magic:=UserEngine.FindMagic(g_Config.sHealSkill);
  end;
  if Magic <> nil then begin
    if not IsTrainingSkill(Magic.wMagicId) then begin
      New(UserMagic);
      UserMagic.MagicInfo  := Magic;
      UserMagic.wMagIdx    := Magic.wMagicId;
      UserMagic.btKey      := 0;
      UserMagic.btLevel    := 1;
      UserMagic.nTranPoint := 0;
      m_MagicList.Add(UserMagic);
      if m_btRaceServer = RC_PLAYOBJECT then begin
        TPlayObject(Self).SendAddMagic(UserMagic);
      end;
    end;
  end;
end;

function TBaseObject.AddToMap: Boolean; //004BA5E4
var
  Point:Pointer;
begin
  Point:=m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
  if Point <> nil then Result:=True
  else Result:=False;
  if not m_boFixedHideMode then
    SendRefMsg(RM_TURN,m_btDirection,m_nCurrX,m_nCurrY,0,'');
end;

function TBaseObject.CanAttack(BaseObject: TBaseObject; nRange: Integer; var btDir: Byte): Boolean;     //영웅전사          CanAttack
var
  I: Integer;
  nX, nY: Integer;
begin
  Result := False;
  btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX, BaseObject.m_nCurrY);
  for I := 1 to nRange do begin
    if not m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, I, nX, nY) then Break;
    if (BaseObject.m_nCurrX = nX) and (BaseObject.m_nCurrY = nY) then begin
      Result := True;
      Break;
    end;
  end;
end;

procedure TBaseObject.AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word;
  nDir: Integer);//004C2C50
  function GetMagicSpell(UserMagic:pTUserMagic):Integer;
  begin
    Result:=ROUND(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1));
  end;
  //嶠포薨똔阮
  procedure CheckWeaponUpgradeStatus(UserItem:pTUserItem); //004C27C0
  begin
    //if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < 20 then begin
    if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < g_Config.nUpgradeWeaponMaxPoint then begin
      case UserItem.btValue[10] of
        1: UserItem.wIndex:=0;
        10..13: UserItem.btValue[0]:=UserItem.btValue[0] + UserItem.btValue[10] - 9;
        20..23: UserItem.btValue[1]:=UserItem.btValue[1] + UserItem.btValue[10] - 19;
        30..33: UserItem.btValue[2]:=UserItem.btValue[2] + UserItem.btValue[10] - 29;
      end;
    end else UserItem.wIndex:=0;
    UserItem.btValue[10]:=0;
  end;
  procedure CheckWeaponUpgrade(); //004C2854
  var
    UseItems:TUserItem;
    PlayObject:TPlayObject;
    StdItem:TItem;
  begin
    if m_UseItems[U_WEAPON].btValue[10] > 0 then begin
      UseItems:=m_UseItems[U_WEAPON];
      CheckWeaponUpgradeStatus(@m_UseItems[U_WEAPON]);
      if m_UseItems[U_WEAPON].wIndex = 0 then begin
        SysMsg(g_sTheWeaponBroke,c_Red,t_Hint);
        PlayObject:=TPlayObject(Self);
        PlayObject.SendDelItems(@UseItems);
        //PlayObject.StatusChanged;
        SendRefMsg(RM_BREAKWEAPON,0,0,0,0,'');
        StdItem:=UserEngine.GetStdItem(UseItems.wIndex);
        //004C29E0
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('21' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     //UserEngine.GetStdItemName(UseItems.wIndex) + #9 +
                     StdItem.Name + #9 +
                     IntToStr(UseItems.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[薨똘㎞]');
        FeatureChanged();
      end else begin
        SysMsg(sTheWeaponRefineSuccessfull,c_Green,t_Hint);
        PlayObject:=TPlayObject(Self);
        PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
        StdItem:=UserEngine.GetStdItem(UseItems.wIndex);
        //004C2B14
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('20' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     //UserEngine.GetStdItemName(UseItems.wIndex) + #9 +
                     StdItem.Name + #9 +
                     IntToStr(UseItems.MakeIndex) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[薨떨묘]');
        RecalcAbilitys();
        SendMsg(Self,RM_ABILITY,0,0,0,0,'');
        SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
      end;
    end;
  end;
var
  AttackTarget :TBaseObject;
  boPowerHit   :Boolean;
  boFireHit    :Boolean;
  boDeathHit   :Boolean;
  boCrsHit     :Boolean;
  boNanCrsHit  :Boolean;
  bo41         :Boolean;
  bo43         :Boolean;
  wIdent       :Word;
  nCheckCode   :Integer;
  StdItem      :TItem;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::AttackDir Code: %d';
begin //004C2C50
  nCheckCode:=0;
try
  if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) then begin //곕墩
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicBanwolSkill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicBanwolSkill));
      HealthSpellChanged();
    end else wHitMode:=RM_HIT;
  end;

  if (wHitMode = 15) and (m_MagicWindbladeSkill <> nil) then begin //풍검술 마약 사용 량
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicWindbladeSkill.MagicInfo.btDefSpell );//+ GetMagicSpell(m_MagicWindbladeSkill));
      HealthSpellChanged();
    end else wHitMode:=RM_HIT;
  end;

  if (wHitMode = 25) and (m_MagicTaguSkill <> nil) then begin //타구봉법 - 승려
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicTaguSkill.MagicInfo.btDefSpell );//+ GetMagicSpell(m_MagicWindbladeSkill));
      HealthSpellChanged();
    end else wHitMode:=RM_HIT;
  end;

  if (wHitMode = 8) and (m_MagicCrsSkill <> nil) then begin     //광풍참
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicCrsSkill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicCrsSkill));
      HealthSpellChanged();
    end else wHitMode:=RM_HIT;
  end;
  if (wHitMode = 29) and (m_MagicCrsBongskill <> nil) then begin //난화혈풍참
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicCrsBongskill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicCrsBongskill));
      HealthSpellChanged();
    end else wHitMode:=RM_HIT;
  end;

  if (wHitMode = 9) and (m_MagicTwnHitSkill <> nil)then begin       //쌍룡참
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicTwnHitSkill.MagicInfo.btDefSpell + GetMagicSpell(m_MagicTwnHitSkill));
      HealthSpellChanged;
    end else wHitMode := RM_HIT;  //마력없음...
  end;

  if (wHitMode = 26) and (m_MagicThunderShaolin <> nil)then begin       //뇌룡봉법
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicThunderShaolin.MagicInfo.btDefSpell);//+ GetMagicSpell(m_MagicThunderShaolin));
      HealthSpellChanged;
    end else wHitMode := RM_HIT;  //마력없음...
  end;

  if (wHitMode = 27) and (m_MagicFireShaolin <> nil)then begin       //천화봉법
    if m_WAbil.MP > 0 then begin
      DamageSpell(m_MagicFireShaolin.MagicInfo.btDefSpell);//+ GetMagicSpell(m_MagicFireShaolin));
      HealthSpellChanged;
    end else wHitMode := RM_HIT;  //마력없음...
  end;

  nCheckCode:=4;
  m_btDirection:=nDir;
  if TargeTBaseObject = nil then begin
    nCheckCode:=41;
    AttackTarget:=GetPoseCreate();
  end else AttackTarget:=TargeTBaseObject;
  if (AttackTarget <> nil) and (m_UseItems[U_WEAPON].wIndex > 0) then begin
    nCheckCode:=42;
    if m_btRaceServer = RC_PLAYOBJECT then
    CheckWeaponUpgrade();
  end;
  nCheckCode:=5;
  boPowerHit:=m_boPowerHit;
  boFireHit:=m_boFireHitSkill;
  boDeathHit:=m_boDeathHitSkill;
  boCrsHit:=m_boCrsHitkill;
  boNanCrsHit:=m_boNanCrsHitkill;
  bo41:=m_bo41kill;
  bo43:=m_bo43kill;
  if not (wHitMode in [13,17]) then begin//발도술
    if _Attack(wHitMode,AttackTarget) then begin
    nCheckCode:=6;
    SetTargetCreat(AttackTarget); //$FFF2
    nCheckCode:=7;
    end;
  end;
  if ((m_btRaceServer = RC_DARKCLONE) or ((m_btRaceServer = RC_HEROOBJECT) and (m_btJob = 3))) then begin  //열화신 분신 공격 형태 (좌 우)     //직업변경
    StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
    if (m_btMask = 0) and ((m_UseItems[U_WEAPON].wIndex = 0) or (StdItem.StdMode = 99)) then begin
      if Random(2) = 0 then wIdent:=RM_HITLEFT
      else wIdent:=RM_HIT;
    end else begin
        wIdent:=RM_HIT;
    end;
  end else
  wIdent:=RM_HIT;
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
    case wHitMode of
      0: wIdent:=RM_HITLEFT;     //왼쪽
      1: wIdent:=RM_HIT;
      2: wIdent:=RM_HEAVYHIT;
      3: wIdent:=RM_BIGHIT;
      4: if m_MagicErgumSkill <> nil then wIdent:=RM_LONGHIT;
      5: if m_MagicBanwolSkill <> nil then wIdent:=RM_WIDEHIT;
      6: if boPowerHit then wIdent:=RM_POWERHIT;   //예도검법
      7: if boFireHit then wIdent:=RM_FIREHIT;
      8: if m_MagicCrsSkill <> nil then wIdent:=RM_CRSHIT;          //광풍참
      9: if m_MagicTwnHitSkill <> nil then wIdent:=RM_TWINHIT;      //쌍룡참
      10: if boDeathHit then wIdent:=RM_DEATHHIT; //살생도
      13: wIdent:=RM_BALDO2;    //발도술
      15: if m_MagicWindbladeSkill <> nil then wIdent:=RM_WBHIT;    //풍검술
      17: wIdent:=RM_BALDO;    //발도술
      18: if m_MagicWindbladeSkill <> nil then wIdent:=RM_WBHIT2;    //풍검술
      20: wIdent:=RM_FISHING1;    //낚시 시작
      21: wIdent:=RM_FISHING2;    //낚시 끝

      22: wIdent := RM_CPOWERHIT; //천무
      23: wIdent := RM_CFIREHIT; //천무
      24: wIdent := RM_BOW; //궁수 기본
      25: if m_MagicTaguSkill <> nil then wIdent:=RM_TAGUHIT;          //타구봉법
      26: if m_MagicThunderShaolin <> nil then wIdent:=RM_THUNDERHIT;  //뇌룡봉법
      27: if m_MagicFireShaolin <> nil then wIdent:=RM_FIRESHAOLIN;    //천화봉법
      28: if m_MagicCrsBongskill <> nil then wIdent:=RM_CRBHIT;   //회풍천봉법
      29: if m_MagicNanCrsSkill <> nil then wIdent:=RM_NANCRSHIT;    //난화혈풍참
    end;
  end;
  nCheckCode:=8;
  SendAttackMsg(wIdent,m_btDirection,m_nCurrX,m_nCurrY);
  if (wIdent = RM_WBHIT) and (m_btRaceServer = RC_HEROOBJECT) and (m_btJob = 3) then begin //영웅자객    //직업변경
    StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
    if (StdItem.StdMode = 99) then begin
      SendAttackMsg(RM_WBHIT2, m_btDirection, m_nCurrX, m_nCurrY);
    end else SendAttackMsg(RM_WBHIT, m_btDirection, m_nCurrX, m_nCurrY);
  end;

  nCheckCode:=9;
  if m_wStatusTimeArr[STATE_ASSTRANSPARENT] > 0 then  //월영술 및 열화신 공격시.. 풀림
  m_wStatusTimeArr[STATE_ASSTRANSPARENT]:=1;

  if m_wStatusTimeArr[STATE_PENETRATE] > 0 then    //망자의옷
    m_wStatusTimeArr[STATE_PENETRATE]:=1;

  if m_wStatusTimeArr[STATE_YEONGMU] > 0 then  //월영무 공격시.. 풀림
   m_wStatusTimeArr[STATE_YEONGMU]:=1;

except
  on e: Exception do begin
    MainOutMessage(format(sExceptionMsg,[nCheckCode]));
    MainOutMessage(E.Message);
  end;
end;
end;

procedure TBaseObject.CheckPKStatus;//004BC83C
begin
  if m_boPKFlag and ((GetTickCount - m_dwPKTick) > g_Config.dwPKFlagTime{60 * 1000}) then begin
    m_boPKFlag:=False;
    RefNameColor();
  end;
end;

procedure TBaseObject.DamageSpell(nSpellPoint: Integer); //004BE50C
begin
  if nSpellPoint > 0 then begin
    if (m_WAbil.MP - nSpellPoint) > 0 then
      Dec(m_WAbil.MP,nSpellPoint)
    else m_WAbil.MP:=0;
  end else begin
    if (m_WAbil.MP - nSpellPoint) < m_WAbil.MaxMP then
      Dec(m_WAbil.MP,nSpellPoint)
    else m_WAbil.MP:=m_WAbil.MaxMP;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    if m_wStatusTimeArr[STATE_THUNDERWAVE] <> 0 then begin
      if m_WAbil.MP <= 50 then begin
        m_wStatusTimeArr[STATE_THUNDERWAVE]:=1;
      end;
    end;
  end;
end;

//004BF520
procedure TBaseObject.DecPKPoint(nPoint: Integer);
var
  nC:Integer;
begin
  nC:=PKLevel();
  Dec(m_nPkPoint,nPoint);
  if m_nPkPoint < 0 then m_nPkPoint:=0;
  if (PKLevel <> nC) and (nC > 0 ) and (nC <= 2)then begin
    RefNameColor();
  end;
end;


function TBaseObject.CheckPrivateClean(): Boolean;   //정화술
begin
   Result := False;
   if m_wStatusTimeArr[POISON_DECHEALTH] <> 0 then begin
      Result := True;
   end;
   if m_wStatusTimeArr[POISON_DAMAGEARMOR] <> 0 then begin
      Result := True;
   end;
   if m_wStatusTimeArr[POISON_STONE] <> 0 then begin
      Result := True;
   end;
   if m_wStatusTimeArr[POISON_STUN] <> 0 then begin
      Result := True;
   end;
   if m_wStatusTimeArr[POISON_FREEZE] <> 0 then begin
      Result := True;
   end;
   if m_wStatusTimeArr[POISON_SLOWDOWN] <> 0 then begin
      Result := True;
   end;
end;
//004C01B8
procedure TBaseObject.DelItemSkill(nIndex: Integer);
  procedure DeleteSkill(sSkillName:String); //004C00B8
  var
    I: Integer;
    UserMagic:pTUserMagic;
    PlayObject:TPlayObject;
  begin
    for I := 0 to m_MagicList.Count - 1 do begin
      UserMagic:=m_MagicList.Items[i];
      if UserMagic.MagicInfo.sMagicName = sSkillName then begin
        PlayObject:=TPlayObject(Self);
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        m_MagicList.Delete(i);
        break;
      end;
    end;
  end;
begin
  if m_btRaceServer <> RC_PLAYOBJECT then exit; //등선 화염장 회복술 사라지는 버그
  case nIndex of
    1: begin
       if (m_btJob <> jWizard) and (m_btJob <> jUpWiz) then
       DeleteSkill(g_Config.sFireBallSkill)
    end;
    2: begin
       if (m_btJob <> jTaos) and (m_btJob <> jUpTao) then
       DeleteSkill(g_Config.sHealSkill)
    end;
  end;
end;

//004C39E8
procedure TBaseObject.DelMember(BaseObject: TBaseObject);
var
  I: Integer;
  PlayObject:TPlayObject;
  GroupOwner: TPlayObject;
begin
  if m_GroupOwner <> BaseObject then begin
    for I := 0 to m_GroupMembers.Count - 1 do begin
      if m_GroupMembers.Objects[i] = BaseObject then begin
        BaseObject.LeaveGroup();
        TPlayObject(BaseObject).RecalcGroupAbilitys;
        m_GroupMembers.Delete(i);
        TPlayObject(BaseObject).RecalcGroupAbilitys;
        break;
      end;
    end;
    PlayObject := TPlayObject(Self);
    if not PlayObject.CancelGroup then begin
      PlayObject.SendDefMsg(Self, SM_GROUPCANCEL, 1, 0, 0, 0, '');
      PlayObject.RecalcGroupAbilitys;
    end;
  end else begin//004C3A65
    if m_GroupMembers.Count > 0 then begin
      GroupOwner := TPlayObject(m_GroupMembers.Objects[0]);
      GroupOwner.LeaveGroup();
      m_GroupMembers.Delete(0);
      m_GroupOwner := nil;
      GroupOwner.RecalcGroupAbilitys;
    end;
    if m_GroupMembers.Count > 0 then begin
      GroupOwner := TPlayObject(m_GroupMembers.Objects[0]);
      GroupOwner.m_GroupMembers.Assign(m_GroupMembers);
      GroupOwner.m_GroupClass := m_GroupClass;
      GroupOwner.m_boCheckHero := m_boCheckHero;
      m_GroupMembers.Clear;
      for i := 0 to GroupOwner.m_GroupMembers.Count - 1 do begin
        PlayObject := TPlayObject(GroupOwner.m_GroupMembers.Objects[i]);
        if PlayObject <> nil then begin
          PlayObject.ChangeGroup(GroupOwner);
          PlayObject.RecalcGroupAbilitys;
        end;
      end;
      if not GroupOwner.CancelGroup then begin
        GroupOwner.SendDefMsg(GroupOwner, SM_GROUPCANCEL, 1, 0, 0, 0, '');
      end;
    end;
  end;
end;

procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer); //004C17B4
var
  nDura,nDuraPoint:Integer;
  PlayObject:TPlayObject;
  StdItem:TItem;
begin
  //Fixed routine, few minor mistakes.
  if not m_boCanLooseDura then exit;
  if m_UseItems[U_WEAPON].wIndex <= 0 then exit;

  StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);

  nDura:=m_UseItems[U_WEAPON].Dura;
  nDuraPoint:=Round(nDura / 1000);

  Dec(nDura,nWeaponDamage);
  if nDura <= 0 then begin
    nDura:=0;
    m_UseItems[U_WEAPON].Dura:=nDura;
    SendMsg(Self,RM_DURACHANGE,U_WEAPON,m_UseItems[U_WEAPON].Dura,m_UseItems[U_WEAPON].DuraMax,0,'');
    if m_btRaceServer = RC_PLAYOBJECT then begin
      PlayObject:=TPlayObject(Self);
      StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      PlayObject.SysMsg(StdItem.Name+' 돨넣씹綠痰쐴。',c_Red,t_Hint);  //무기 내구 0 메시지
    end;
    RecalcAbilitys();
    SendMsg(Self,RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self,RM_SUBABILITY, 0, 0, 0, 0, '');
  end else begin //004C199D
    m_UseItems[U_WEAPON].Dura:=nDura;
  end;
  if (nDura / 1000) <> nDuraPoint then begin
    SendMsg(Self,RM_DURACHANGE,U_WEAPON,m_UseItems[U_WEAPON].Dura,m_UseItems[U_WEAPON].DuraMax,0,'');
  end;
end;

procedure TBaseObject.GetAccessory(UserItem: TUserItem;var AddAbility: TAddAbility); //004C0EBC                 //ApplyItemParameters
var
  Item:TItem;
  StdItem:TStdItem;
begin
  Item:=UserEngine.GetStdItem(UserItem.wIndex);
  if Item = nil then exit;
  Item.GetItemAddValue(@UserItem, StdItem);

  case Item.StdMode of
    5, 6, 7, 99, 90: begin   //ITEM_WEAPON   무기
        AddAbility.nHitSpeed := AddAbility.nHitSpeed + ItemUnit.RealAttackSpeed( StdItem.AtkSpd );

        Inc(AddAbility.btLuck,LoWord(StdItem.AC));
        Inc(AddAbility.btUnLuck,LoWord(StdItem.MAC));

        AddAbility.wHitPoint:= AddAbility.wHitPoint + StdItem.Accurate;    //무기 정확
        AddAbility.wTox:= AddAbility.wTox + StdItem.Tox;                   //무기 중독 판정
        AddAbility.wSlowDown:= AddAbility.wSlowDown + StdItem.SlowDown;    //무기 둔화 판정

        if StdItem.Source in [1..10] then
          AddAbility.btWeaponStrong := StdItem.Source;  //무기의 강도, 강도가 높으면 잘
    end;
    10, 11, 12: begin      //옷
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.btLuck := AddAbility.btLuck + StdItem.Source;              //옷 행운
        AddAbility.wAntiPoison := AddAbility.wAntiPoison + StdItem.ToxAvoid;  //옷 중독저항
        AddAbility.wAntiMagic := AddAbility.wAntiMagic + StdItem.MagAvoid;    //옷 마법저항

        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;   //옷 민첩
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;      //옷 정확

        AddAbility.wHealthRecover := AddAbility.wHealthRecover + StdItem.RecHp;
        AddAbility.wSpellRecover := AddAbility.wSpellRecover + StdItem.RecMp;
    end;
    15: begin    //투구
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;      //투구 정확
        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;   //투구 민첩
        AddAbility.wAntiPoison := AddAbility.wAntiPoison + StdItem.ToxAvoid;  //투구 중독저항
        AddAbility.wAntiMagic := AddAbility.wAntiMagic + StdItem.MagAvoid;    //투구 마법저항
    end;
    19: begin//목걸이19
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

       // AddAbility.btUnLuck := AddAbility.btUnLuck + HiWord(StdItem.AC);    //목걸이 저주
        AddAbility.btLuck := AddAbility.btLuck + StdItem.Source;       //목걸이 행운
        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;   //목걸이 민첩
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;    //목걸이 정확
        AddAbility.wTox:= AddAbility.wTox + StdItem.Tox;                    //목걸이 중독
        AddAbility.wSlowDown:= AddAbility.wSlowDown + StdItem.SlowDown;     //목걸이 둔화
        AddAbility.wAntiMagic := AddAbility.wAntiMagic + StdItem.MagAvoid;  //목걸이 마법저항
        AddAbility.nHitSpeed := AddAbility.nHitSpeed + StdItem.AtkSpd;      //목걸이 공격속도
    end;
    20: begin//목걸이20
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;   //목걸이 민첩
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;    //목걸이 정확

        AddAbility.wTox:= AddAbility.wTox + StdItem.Tox;                    //목걸이 중독
        AddAbility.wSlowDown:= AddAbility.wSlowDown + StdItem.SlowDown;     //목걸이 둔화
        AddAbility.wAntiMagic := AddAbility.wAntiMagic + StdItem.MagAvoid;  //목걸이 마법저항
        AddAbility.nHitSpeed := AddAbility.nHitSpeed + StdItem.AtkSpd;      //목걸이 공격속도
    end;
    21: begin//목걸이21
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.wHealthRecover := AddAbility.wHealthRecover + StdItem.RecHp;  //목걸이 체회복
        AddAbility.wSpellRecover := AddAbility.wSpellRecover + StdItem.RecMp;   //목걸이 마회복

        AddAbility.nHitSpeed := AddAbility.nHitSpeed + StdItem.AtkSpd;      //목걸이 공격속도
        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;   //목걸이 민첩
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;    //목걸이 정확
        AddAbility.wTox:= AddAbility.wTox + StdItem.Tox;                    //목걸이 중독
        AddAbility.wSlowDown:= AddAbility.wSlowDown + StdItem.SlowDown;     //목걸이 둔화
        AddAbility.wAntiMagic := AddAbility.wAntiMagic + StdItem.MagAvoid;  //목걸이 마법저항
    end;
    22: begin  //반지     //반지22
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.nHitSpeed := AddAbility.nHitSpeed + StdItem.AtkSpd;        //공속
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;      //정확
        AddAbility.wTox:= AddAbility.wTox + StdItem.Tox;                      //중독
        AddAbility.wSlowDown:= AddAbility.wSlowDown + StdItem.SlowDown;       //둔화
    end;
    23: begin  //반지23
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.wAntiPoison := AddAbility.wAntiPoison + StdItem.ToxAvoid;             //중독저항
        AddAbility.wPoisonRecover := AddAbility.wPoisonRecover + StdItem.Source;      //중독회복

        AddAbility.nHitSpeed := AddAbility.nHitSpeed + StdItem.AtkSpd;        //공속
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;      //정확
        AddAbility.wTox:= AddAbility.wTox + StdItem.Tox;                      //중독
        AddAbility.wSlowDown:= AddAbility.wSlowDown + StdItem.SlowDown;       //둔화
    end;
    24, 26: begin         //팔찌26
        if StdItem.Source in [1..10] then
          AddAbility.btWeaponStrong := StdItem.Source;  //무기의 강도, 강도가 높으면 잘
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;   //민첩
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;    //정확
    end;
    62: begin //신발
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.nHitSpeed := AddAbility.nHitSpeed + StdItem.AtkSpd;

        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;
        Inc(AddAbility.HandWeight,StdItem.Source);
        Inc(AddAbility.WearWeight,StdItem.WearWeight); //착용 무게
    end;
    63: begin //수호석
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        AddAbility.btLuck := AddAbility.btLuck + StdItem.Source;
    end;
    64: begin //벨트
        AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
        AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));

        Inc(AddAbility.Weight, StdItem.Source);

        AddAbility.wSpeedPoint := AddAbility.wSpeedPoint + StdItem.Agility;
        AddAbility.wHitPoint := AddAbility.wHitPoint + StdItem.Accurate;
        AddAbility.wAntiPoison := AddAbility.wAntiPoison + StdItem.ToxAvoid;
    end;
    else begin
      AddAbility.wAC:=MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.AC),HiWord(AddAbility.wAC) + HiWord(StdItem.AC));
      AddAbility.wMAC:=MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.MAC),HiWord(AddAbility.wMAC) + HiWord(StdItem.MAC));
    end;
  end;
  AddAbility.wDC:=MakeLong(LoWord(AddAbility.wDC) + LoWord(StdItem.DC),HiWord(AddAbility.wDC) + HiWord(StdItem.DC));
  AddAbility.wMC:=MakeLong(LoWord(AddAbility.wMC) + LoWord(StdItem.MC),HiWord(AddAbility.wMC) + HiWord(StdItem.MC));
  AddAbility.wSC:=MakeLong(LoWord(AddAbility.wSC) + LoWord(StdItem.SC),HiWord(AddAbility.wSC) + HiWord(StdItem.SC));
  AddAbility.wHP := AddAbility.wHP + StdItem.HpAdd;
  AddAbility.wMP := AddAbility.wMP + StdItem.MpAdd;
  case Item.StdMode of
    5, 6, 90, 99, 12, 10, 11, 15: begin   //ITEM_WEAPON
  if StdItem.btValue[18] > 0 then begin  //각성 단계 표시
    if StdItem.btValue[12] = 1 then    //용맹
    AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]),
            HiWord(AddAbility.wDC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]));
    if StdItem.btValue[12] = 2 then    //마성
    AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]),
            HiWord(AddAbility.wMC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]));
    if StdItem.btValue[12] = 3 then    //선계
    AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]),
            HiWord(AddAbility.wSC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]));
    if StdItem.btValue[12] = 4 then    //수호
    AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]),
            HiWord(AddAbility.wAC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]));
    if StdItem.btValue[12] = 5 then   //제마
    AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]),
            HiWord(AddAbility.wMAC) + LoWord(StdItem.btValue[13]) + LoWord(StdItem.btValue[14]) + LoWord(StdItem.btValue[15]) + LoWord(StdItem.btValue[16]) + LoWord(StdItem.btValue[17]));
    if StdItem.btValue[12] = 6 then begin    //육체
      AddAbility.wHP := AddAbility.wHP + StdItem.btValue[13] + StdItem.btValue[14] + StdItem.btValue[15] + StdItem.btValue[16] + StdItem.btValue[17];
      AddAbility.wMP := AddAbility.wMP + StdItem.btValue[13] + StdItem.btValue[14] + StdItem.btValue[15] + StdItem.btValue[16] + StdItem.btValue[17];
    end;
  end;
  end;
  end;
end;
//004BF180

function TBaseObject.GetCharColor(BaseObject:TBaseObject): Byte;  //사북문 이름 색
var
  n10:Integer;                     //케릭터 이름 색
  nCheckCode:Integer;
  Castle:TUserCastle;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::GetCharColor CheckCode=%d';
begin
  nCheckCode:=0;
  Result:=BaseObject.GetNamecolor();
  try
  if BaseObject.m_PEnvir.Flag.boDEATHMATCH then begin   //데스매치
    Result:=m_btNameColor;
    exit;
  end;

  if BaseObject.m_PEnvir.Flag.boPKZONE then begin
    Result:=69;
    exit;
  end;

  nCheckCode:=1;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_CLONE) or (BaseObject.m_btRaceServer = RC_DARKCLONE) or
     (BaseObject.m_btRaceServer = RC_BONZECLONE) then begin
    if BaseObject.PKLevel < 2 then begin   //흰둥이=0(또는 노랭이=1) 인 경우
      if BaseObject.m_boPKFlag then Result:=g_Config.btPKFlagNameColor;//$2F   //갈색계열
      nCheckCode:=2;
      n10:=GetGuildRelation(Self,BaseObject);
      nCheckCode:=3;
      case n10 of
        1,3: Result:=g_Config.btAllyAndGuildNameColor;//$B4;     //푸른계열 (우리편)
        2: Result:=g_Config.btWarGuildNameColor;//$45;      //푸른계열 (우리편)
      end;
      if BaseObject.m_PEnvir.Flag.boFight3Zone then begin       //문파 대련장 안에 있음
        if m_MyGuild = BaseObject.m_MyGuild then     //같은편
        Result:=g_Config.btAllyAndGuildNameColor//$B4  //푸른계열
        else
        Result:=g_Config.btWarGuildNameColor//$45;        //주황색계열
      end;

      if BaseObject.m_PEnvir.Flag.VailantZone then begin       //용맹의전장 안에 있음
        if m_MyGuild = BaseObject.m_MyGuild then     //같은편
        Result:=g_Config.btAllyAndGuildNameColor//$B4  //푸른계열
        else
        Result:=g_Config.btWarGuildNameColor//$45;        //주황색계열
      end;
    end;

    nCheckCode:=4;
    Castle:=g_CastleManager.InCastleWarArea(BaseObject);

    if (Castle <> nil) and Castle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin //공성전 지역
      nCheckCode:=5;
      Result:=g_Config.btInFreePKAreaNameColor;//$DD;   //적도아니고 우리편도 아니면 녹색으로 보인다.
      m_boGuildWarArea:=True;       //공성전 지역
      nCheckCode:=6;
      if (m_MyGuild = nil) then exit;
      if Castle.IsMasterGuild(TGuild(m_MyGuild)) then begin  //사북문파일경우
        nCheckCode:=7;
        if (m_MyGuild = BaseObject.m_MyGuild) or  //상대가 같은문 또는 동맹문
           (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then begin    // 2003/06/12 수성 문파 뿐만 아니라 수성문파 연합 문파인경우도 해당되도록 수정
          nCheckCode:=8;
          Result:=g_Config.btAllyAndGuildNameColor//$B4;   //푸른계열 (우리편)
        end else begin //004BF2A8
          nCheckCode:=9;
          Result:=g_Config.btCatleWarGuildNameColor; //$45;   //공격하고 있는 문파, 적
          nCheckCode:=10;
        end;
      end else begin //004BF2CE  //성을 공격하는 입장(공성 또는 공성동맹)
        nCheckCode:=11;
        if (m_MyGuild = BaseObject.m_MyGuild) or      //상대가 나랑문파가 같거나 내동맹일 경우
          (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then begin        //우리 문파가 공격하고 있음
          nCheckCode:=12;
          Result:=g_Config.btCatleWarGuildNameColor//$B4;     //우리편
        end else begin
          nCheckCode:=13;
          if Castle.IsMember(BaseObject) then begin    //사북문파이다
            nCheckCode:=14;
            Result:=g_Config.btAllyAndGuildNameColor;    //성을 차지한 문파는 적으로 보인다.
            nCheckCode:=15;
          end else begin
            Result:=g_Config.btCatleWarGuildNameColor//$B4;     //우리편
          end;
        end; //004BF379
      end;
    end;
    exit;
  end;
  if BaseObject.m_btRaceServer = RC_HEROOBJECT then begin   //영웅
    if BaseObject.PKLevel < 2 then begin
      if BaseObject.m_boPKFlag then Result := g_Config.btPKFlagNameColor; //$2F
    end;
  end else begin    //몬스터
    if ( BaseObject.m_btRaceServer = RC_CLONE ) or ( BaseObject.m_btRaceServer = RC_DARKCLONE ) or ( BaseObject.m_btRaceServer = RC_BONZECLONE )  then begin
       if (BaseObject.m_Master <> nil ) and (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT ) then begin
           Result := BaseObject.m_Master.GetNamecolor;
       end;
    end else begin
      if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) then begin
        Result:=g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
      end;
    end;
    if BaseObject.m_boCrazyMode then Result:=$F9;        //red 폭주상태
    if BaseObject.m_boHallucMode then Result:=$FD; //Hallucination      //violet 곱게미친상태 (색깔조정)
    if BaseObject.m_boHolySeize then Result:=$7D;     //결계
  end;
  except
    MainOutMessage(Format(sExceptionMsg, [nCheckCode]));
  end;
end;
function TBaseObject.GetLevelExp(nLevel:Integer):LongWord;//004BEDC8
begin
  if nLevel <= MAXLEVEL{51} then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      Result := g_Config.dwNeedExps[nLevel];
    end else begin
      Result := g_Config.dwHeroNeedExps[nLevel];
    end;
  end else begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      Result:=g_Config.dwNeedExps[High(g_Config.dwNeedExps)];
    end else begin
      Result := g_Config.dwHeroNeedExps[High(g_Config.dwHeroNeedExps)];
    end;
  end;
end;

function TBaseObject.GetGuldLevelExp(nLevel:Integer):Integer;//문파성장
begin
  if nLevel <= MAXGUILDLEVEL{45} then begin
    Result:=g_Config.dwNeedGuldExps[nLevel]
  end else begin
    Result:=g_Config.dwNeedGuldExps[High(g_Config.dwNeedGuldExps)];
  end;
end;

//004BF144
function  TBaseObject.GetNamecolor():Byte;
var
 Castle:TUserCastle;
begin
  Result:=m_btNameColor;
  if PKLevel = 1 then Result:=g_Config.btPKLevel1NameColor;//$FB;     //yellow
  if PKLevel >= 2 then Result:= g_Config.btPKLevel2NameColor;//$F9;    //red
  Castle:=g_CastleManager.IsMasterCastleMember(Self); //정복자 확인
  if Castle <> nil then begin
    if PKLevel = 1 then Result:=g_Config.btPKLevel1NameColor
    else//$FB;
    if PKLevel >= 2 then Result:= g_Config.btPKLevel2NameColor
    else//$F9;
    Result:= g_Config.btKingCatleGuildNameColor;   //정복자 이름색
  end else begin
    Castle:=g_CastleManager.CastleMember(Self, '낡沽'); //사북성
    if Castle <> nil then begin
      if PKLevel = 1 then Result:=g_Config.btPKLevel1NameColor
      else//$FB;
      if PKLevel >= 2 then Result:= g_Config.btPKLevel2NameColor
      else//$F9;
      Result:= g_Config.btCatleGuildNameColor;
    end else begin
      Castle:=g_CastleManager.CastleMember(Self, '켓찮'); //남만성
      if Castle <> nil then begin
        if PKLevel = 1 then Result:=g_Config.btPKLevel1NameColor
        else//$FB;
        if PKLevel >= 2 then Result:= g_Config.btPKLevel2NameColor
        else//$F9;
        Result:= g_Config.btNamCatleGuildNameColor;
      end;
    end;
  end;
end;

procedure TBaseObject.HearMsg(sMsg: String);//004BB2A0
begin
  if sMsg <> '' then
  SendMsg(nil,RM_HEAR,0,g_Config.btHearMsgFColor,g_Config.btHearMsgBColor,0,sMsg);
end;

function TBaseObject.InSafeArea():Boolean;//004BEF8C
var
  I: Integer;
  StartPoint:pTStartPoint;
begin
  Result := False;
  g_StartPoint.Lock;
  try
    for I := 0 to g_StartPoint.Count - 1 do begin
      StartPoint:=g_StartPoint.Items[I];
      if StartPoint.Envir = m_PEnvir then begin
        if (abs(m_nCurrX - StartPoint.nX) <= 60) and (abs(m_nCurrY - StartPoint.nY) <= 60) then begin
          Result:=True;
          break;
        end;
      end;
    end;
  finally
    g_StartPoint.UnLock;
  end;
end;

procedure TBaseObject.MonsterRecalcAbilitys;
var
  n8:Integer;
begin
  if (m_btRaceServer = MONSTER_ANGEL) or (m_btRaceServer = MONSTER_DARKANGEL) or (m_btRaceServer = RC_CLONE) or (m_btRaceServer = RC_DARKCLONE) or
      (m_btRaceServer = RC_BONZECLONE)
  then Exit;

  n8:=0;
  if (m_btRaceServer = MONSTER_WHITESKELETON) or
     (m_btRaceServer = MONSTER_ELFMONSTER) or
     (m_btRaceServer = JIN_WHITESKELETON) or                                                      
     (m_btRaceServer = MONSTER_ELFWARRIOR) then begin

    m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC),HiWord(m_Abil.DC));

    m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC),ROUND((m_btSlaveExpLevel * 0.1 + 0.3) * 3.0 * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));

    n8:=n8 + ROUND((m_btSlaveExpLevel * 0.1 + 0.3) * m_Abil.MaxHP) * m_btSlaveExpLevel;
    n8:=n8 + m_Abil.MaxHP;
    if m_btSlaveExpLevel > 0 then begin m_WAbil.MaxHP:=n8
    end else m_WAbil.MaxHP:=m_Abil.MaxHP;

    if m_wStatusArrValue[0] > 0 then   //무극 파괴
    m_WAbil.DC := MakeLong( LoWord(m_WAbil.DC),  _MIN( 255 , HiWord(m_WAbil.DC) +  m_wStatusArrValue[0]) );

    if m_wStatusTimeArr[STATE_BLOODWATER] > 0 then begin //혈룡수
      if m_wStatusArrValue[15] > 0 then  //혈룡수 파괴
       m_WAbil.DC := MakeLong( LoWord(m_WAbil.DC), _MIN( 255 , HiWord(m_WAbil.DC) +  m_wStatusArrValue[15]) );
      if m_wStatusArrValue[4] > 0 then  //혈룡수 체력
       m_WAbil.MaxHP:=_MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[4]);
      if m_wStatusArrValue[8] > 0 then   //혈룡수 방어
       m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC), _MIN( 255 , HiWord(m_WAbil.AC) + m_wStatusArrValue[8]) );
      if m_wStatusArrValue[27] > 0 then //혈룡수 마항
       m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC), _MIN( 255 ,HiWord(m_WAbil.MAC) + m_wStatusArrValue[27]));
    end;
  end else begin //004BEA85
     n8:=m_Abil.MaxHP;
     m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC),HiWord(m_Abil.DC));
     m_WAbil.DC:=MakeLong(LoWord(m_WAbil.DC),ROUND(m_btSlaveExpLevel * 2 + HiWord(m_WAbil.DC)));
     n8:=n8 + ROUND(m_Abil.MaxHP * 0.15) * m_btSlaveExpLevel;
     m_WAbil.MaxHP:=_MIN(ROUND(m_Abil.MaxHP + m_btSlaveExpLevel * 60),n8);
  end;
end;


 
procedure TBaseObject.MonsterRecalcAbilitys2;
begin
  if (m_btRaceServer = MONSTER_WHITESKELETON) or
     (m_btRaceServer = JIN_WHITESKELETON) or
     (m_btRaceServer = MONSTER_ELFMONSTER) or
     (m_btRaceServer = MONSTER_ELFWARRIOR) or
     (m_btRaceServer = RC_CLONE) or
     (m_btRaceServer = RC_DARKCLONE) or
     (m_btRaceServer = RC_BONZECLONE)
     then Exit;

  if (m_btRaceServer = MONSTER_ANGEL) or (m_btRaceServer = MONSTER_DARKANGEL) then begin

    m_WAbil.MC:=MakeLong(LoWord(m_WAbil.MC),HiWord(m_Abil.MC));
    if m_wStatusTimeArr[STATE_BLOODWATER{10 0x72}] > 0 then begin //혈룡수
      if m_wStatusArrValue[1] > 0 then   //혈룡수 마법
       m_WAbil.MC := MakeLong( LoWord(m_WAbil.MC), _MIN( 255 , HiWord(m_WAbil.MC) +  m_wStatusArrValue[1]) );
      if m_wStatusArrValue[2] > 0 then   //혈룡수 도력
       m_WAbil.SC := MakeLong( LoWord(m_WAbil.SC), _MIN( 255 , HiWord(m_WAbil.SC) +  m_wStatusArrValue[2]) );
      if m_wStatusArrValue[4] > 0 then  //혈룡수 체력
       m_WAbil.MaxHP:=_MIN(High(Word),m_WAbil.MaxHP + m_wStatusArrValue[4]);
      if m_wStatusArrValue[8] > 0 then   //혈룡수 방어
       m_WAbil.AC  := MakeLong(LoWord(m_WAbil.AC), _MIN( 255 ,HiWord(m_WAbil.AC) + m_wStatusArrValue[8]));
      if m_wStatusArrValue[27] > 0 then //혈룡수 마항
       m_WAbil.MAC  := MakeLong(LoWord(m_WAbil.MAC), _MIN( 255 ,HiWord(m_WAbil.MAC) + m_wStatusArrValue[27]));
    end;

  end;
end;


procedure TPlayObject.ShowMapInfo(sMap,sX,sY:String);
var
  Map:TEnvirnoment;
  nX,nY:Integer;
  MapCellInfo:pTMapCellinfo;
begin
  nX:=Str_ToInt(sX,0);
  nY:=Str_ToInt(sY,0);
  if (sMap <> '') and (nX >= 0) and (nY >= 0)then begin
    Map:=g_MapManager.FindMap(sMap);
    if Map <> nil then begin
      if Map.GetMapCellInfo(nX,nY,MapCellInfo) then begin
        SysMsg('Cell Flag: ' + IntToStr(MapCellInfo.chFlag),c_Green,t_Hint);
        if MapCellInfo.ObjList <> nil then begin
          SysMsg('Cell Count: ' + IntToStr(MapCellInfo.ObjList.Count),c_Green,t_Hint);
        end;
      end else begin
        SysMsg('Failed to get cell information for map: ' + sMap ,c_Red,t_Hint);
      end;
    end;
  end else begin
    SysMsg('Usage: @' + g_GameCommand.MAPINFO.sCmd + ' <MAP> <X> <Y>',c_Green,t_Hint);
  end;
end;



procedure TBaseObject.SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: String); //004B84FC
var
  SendMessage:pTSendMessage;
begin
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then begin
        New(SendMessage);
        SendMessage.wIdent         :=wIdent;
        SendMessage.wParam         :=wParam;
        SendMessage.nParam1        :=lParam1;
        SendMessage.nParam2        :=lParam2;
        SendMessage.nParam3        :=lParam3;
        SendMessage.dwDeliveryTime :=0;
        SendMessage.BaseObject       :=BaseObject;
        if sMsg <> '' then begin
          try
            GetMem(SendMessage.Buff,Length(sMsg) + 1);
            Move(sMsg[1],SendMessage.Buff^,Length(sMsg) + 1);
          except
            SendMessage.Buff:=nil;
          end;
        end else begin
          SendMessage.Buff:=nil;
        end;
        m_MsgList.Insert(0,SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
end;

procedure TBaseObject.SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: String);//004B865C
var
  SendMessage:pTSendMessage;
begin
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then begin
        New(SendMessage);
        SendMessage.wIdent         :=wIdent;
        SendMessage.wParam         :=wParam;
        SendMessage.nParam1        :=nParam1;
        SendMessage.nParam2        :=nParam2;
        SendMessage.nParam3        :=nParam3;
        SendMessage.dwDeliveryTime :=0;
        SendMessage.BaseObject     :=BaseObject;
        SendMessage.boLateDelivery :=False;
        if sMsg <> '' then begin
          try
            GetMem(SendMessage.Buff,Length(sMsg) + 1);
            Move(sMsg[1],SendMessage.Buff^,Length(sMsg) + 1);
          except
            SendMessage.Buff:=nil;
          end;
        end else begin
          SendMessage.Buff:=nil;
        end;
        m_MsgList.Add(SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
end;

procedure TBaseObject.DelaySendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: String;dwDelay:LongWord);//004B865C
var
  SendMessage:pTSendMessage;
begin
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then begin
        New(SendMessage);
        SendMessage.wIdent         :=wIdent;
        SendMessage.wParam         :=wParam;
        SendMessage.nParam1        :=nParam1;
        SendMessage.nParam2        :=nParam2;
        SendMessage.nParam3        :=nParam3;
        SendMessage.dwDeliveryTime :=GetTickCount + dwDelay;
        SendMessage.BaseObject     :=BaseObject;
        SendMessage.boLateDelivery :=False;
        if sMsg <> '' then begin
          try
            GetMem(SendMessage.Buff,Length(sMsg) + 1);
            Move(sMsg[1],SendMessage.Buff^,Length(sMsg) + 1);
          except
            SendMessage.Buff:=nil;
          end;
        end else begin
          SendMessage.Buff:=nil;
        end;
        m_MsgList.Add(SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
end;

procedure TBaseObject.SendDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: String;
  dwDelay: LongWord);//004B87C4
var
  SendMessage:pTSendMessage;
begin
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then begin
        New(SendMessage);
        SendMessage.wIdent         :=wIdent;
        SendMessage.wParam         :=wParam;
        SendMessage.nParam1        :=lParam1;
        SendMessage.nParam2        :=lParam2;
        SendMessage.nParam3        :=lParam3;
        SendMessage.dwDeliveryTime :=GetTickCount + dwDelay;
        SendMessage.BaseObject     :=BaseObject;
        SendMessage.boLateDelivery :=True;
        if sMsg <> '' then begin
          try
            GetMem(SendMessage.Buff,Length(sMsg) + 1);
            Move(sMsg[1],SendMessage.Buff^,Length(sMsg) + 1);
          except
            SendMessage.Buff:=nil;
          end;
        end else begin
          SendMessage.Buff:=nil;
        end;
        m_MsgList.Add(SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
end;

procedure TBaseObject.SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: String;
  dwDelay: LongWord);//004B8930
var
  SendMessage:pTSendMessage;
  i:integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i:=0;
    while (True) do begin
      if m_MsgList.Count <= i then break;
      SendMessage:=m_MsgList.Items[i];
      if (SendMessage.wIdent = wIdent) and (SendMessage.nParam1 = lParam1) then begin
        m_MsgList.Delete(i);
        if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendDelayMsg(BaseObject,wIdent,wParam,lParam1,lParam2,lParam3,sMsg,dwDelay);
end;

procedure TBaseObject.SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: String);//004B8A7C
var
  SendMessage:pTSendMessage;
  i:Integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    i:=0;
    while (True) do begin
      if m_MsgList.Count <= i then break;
      SendMessage:=m_MsgList.Items[i];
      if SendMessage.wIdent = wIdent then begin
        m_MsgList.Delete(i);
        if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject,wIdent,wParam,lParam1,lParam2,lParam3,sMsg);
end;

procedure TBaseObject.SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: String);//004B8A7C
var
  SendMessage:pTSendMessage;
  i:Integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i:=0;
    while (True) do begin
      if m_MsgList.Count <= i then break;
      SendMessage:=m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_TURN) or
         (SendMessage.wIdent = CM_WALK) or
         (SendMessage.wIdent = CM_DOWN) or   //월영술
         (SendMessage.wIdent = CM_SITDOWN) or
         (SendMessage.wIdent = CM_HORSERUN) or
         (SendMessage.wIdent = CM_SPEEDRUN) or //경신보
         (SendMessage.wIdent = CM_DOWNRUN) or //경신보
         (SendMessage.wIdent = CM_RUN) or
         (SendMessage.wIdent = CM_HIT) or
         (SendMessage.wIdent = CM_HITLEFT) or  //왼쪽
         (SendMessage.wIdent = CM_HEAVYHIT) or
         (SendMessage.wIdent = CM_BIGHIT) or
         (SendMessage.wIdent = CM_POWERHIT) or
         (SendMessage.wIdent = CM_WBHIT) or     //풍검술
         (SendMessage.wIdent = CM_WBHIT2) or   //풍검술
         (SendMessage.wIdent = CM_LONGHIT) or
         (SendMessage.wIdent = CM_TAGUHIT) or
         (SendMessage.wIdent = CM_WIDEHIT) or
         (SendMessage.wIdent = CM_BALDO) or  //발도술
         (SendMessage.wIdent = CM_BALDO2) or  //발도술
         (SendMessage.wIdent = CM_FISHING1) or  //낚시 시작
         (SendMessage.wIdent = CM_FISHING2) or  //낚시 끝
         (SendMessage.wIdent = CM_DEATHHIT) or   //살생도
         (SendMessage.wIdent = CM_CPOWERHIT) or
         (SendMessage.wIdent = CM_CFIREHIT) or
         (SendMessage.wIdent = CM_FIREHIT) then begin
        m_MsgList.Delete(i);
        if SendMessage.Buff <> nil then FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject,wIdent,wParam,lParam1,lParam2,lParam3,sMsg);
end;

function TBaseObject.GetMessage(Msg:pTProcessMessage): Boolean;//004B8BA4($FFFF)
var
  I:Integer;
  SendMessage:pTSendMessage;
begin
  Result:=False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    I:=0;
    Msg.wIdent:=0;
    while m_MsgList.Count > I do begin
      SendMessage:=m_MsgList.Items[I];
      if (SendMessage.dwDeliveryTime <> 0) and (GetTickCount < SendMessage.dwDeliveryTime)then begin
        Inc(I);
        Continue;
      end;
      m_MsgList.Delete(I);
      Msg.wIdent:=SendMessage.wIdent;
      Msg.wParam:=SendMessage.wParam;
      Msg.nParam1:=SendMessage.nParam1;
      Msg.nParam2:=SendMessage.nParam2;
      Msg.nParam3:=SendMessage.nParam3;
      Msg.BaseObject:=SendMessage.BaseObject;
      Msg.dwDeliveryTime:=SendMessage.dwDeliveryTime;
      Msg.boLateDelivery:=SendMessage.boLateDelivery;
      if SendMessage.Buff <> nil then begin
        Msg.sMsg:=StrPas(SendMessage.Buff);
        FreeMem(SendMessage.Buff);
      end else begin
        Msg.sMsg:='';
      end;
      Dispose(SendMessage);
      Result:=True;
      break;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TBaseObject.GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY,nRage: Integer; rList: TList):Boolean;//004B8D2C
var
  III: Integer;
  x,y: Integer;
  nStartX,nStartY,nEndX,nEndY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::GetMapBaseObjects';
begin
  Result:=False;
  if rList = nil then exit;
  try
    nStartX:=nX - nRage;
    nEndX:=nX + nRage;
    nStartY:=nY - nRage;
    nEndY:=nY + nRage;
    for x:= nStartX to nEndX do begin
      for y := nStartY to nEndY do begin
        if tEnvir.GetMapCellInfo(x,y,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
            OSObject:=MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
              BaseObject:=TBaseObject(OSObject.CellObj);
              if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                rList.Add(BaseObject);
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
  Result:=True;
end;

// 대각선 방향의 맵에서 생물체 얻어내기.
function  TBaseObject.GetObliqueMapBaseObjects (penv: TEnvirnoment; x, y, area, dir: integer; rlist: TList): Boolean;
var
	 i, j, k, stx, sty, enx, eny: integer;
   cret: TBaseObject;
   MapCellInfo: pTMapCellinfo;
   OSObject:pTOSObject;
begin
   Result := FALSE;
   if rlist = nil then exit;
   try
      case dir of
      1:
         begin
            stx := x-area -area;
            enx := x+area;
            sty := y-area;
            eny := y+area +area;
         end;
      3:
         begin
            stx := x-area -area;
            enx := x+area;
            sty := y-area -area;
            eny := y+area;
         end;
      5:
         begin
            stx := x-area;
            enx := x+area +area;
            sty := y-area -area;
            eny := y+area;
         end;
      7:
         begin
            stx := x-area;
            enx := x+area +area;
            sty := y-area;
            eny := y+area +area;
         end;
      else
         //방향이 대각선이 아닐때...
         exit;
      end;//case

      for i:=stx to enx do begin
         for j:=sty to eny do begin
            if ((dir in [3,7]) and (abs((x-i)-(y-j)) <= area)) or
               ((dir in [1,5]) and (abs((x-i)+(y-j)) <= area)) then begin
               if penv.GetMapCellInfo (i, j, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
                  for k:=MapCellInfo.ObjList.Count-1 downto 0 do begin
                     OSObject:=MapCellInfo.ObjList.Items[k];
                     if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                        cret := TBaseObject(OSObject.CellObj);
                        if (cret <> nil) and (not cret.m_boDeath) and (not cret.m_BoGhost) then begin
                           rlist.Add (cret);
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
   except
      MainOutMessage ('[TBaseObject] GetObliqueMapBaseObjects exception');
   end;
   Result := TRUE;
end;

procedure TBaseObject.SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: String);//004B8EBC
var
  II,nC: Integer;
  nCX,nCY,nLX,nLY,nHX,nHY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::SendRefMsg Name = %s';
begin
  if m_PEnvir = nil then begin
    MainOutMessage(m_sCharName + ' SendRefMsg nil PEnvir ' + IntToStr(wIdent));
    exit;
  end;

  if m_boObMode or m_boFixedHideMode then begin
  try
    SendMsg(Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg);
  except
    MainOutMessage(format(sExceptionMsg,[m_sCharName]));
    MainOutMessage('Please contact thedeath and tell him you saw msg number 1 '+ m_sCharName + ' '+ IntToStr(wIdent));
  end;
    exit;
  end;

  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if ((GetTickCount - m_SendRefMsgTick) >= 500) or (m_VisibleHumanList.Count = 0) then begin
      m_SendRefMsgTick:=GetTickCount();
      m_VisibleHumanList.Clear;
      nLX:=m_nCurrX - g_Config.nSendRefMsgRange{12};
      nHX:=m_nCurrX + g_Config.nSendRefMsgRange{12};
      nLY:=m_nCurrY - g_Config.nSendRefMsgRange{12};
      nHY:=m_nCurrY + g_Config.nSendRefMsgRange{12};
      for nCX:= nLX to nHX do begin
        for nCY:= nLY to nHY do begin
            if m_PEnvir.GetMapCellInfo(nCX,nCY,MapCellInfo) then begin
              if MapCellInfo.ObjList <> nil then begin
                for II := MapCellInfo.ObjList.Count - 1 downto 0 do begin
                  OSObject:=MapCellInfo.ObjList.Items[II];
                  if OSObject <> nil then begin
                    if OSObject.btType = OS_MOVINGOBJECT then begin
                      if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then begin
                        try
                          DisPose(OSObject);
                          MapCellInfo.ObjList.Delete(II);
                          if MapCellInfo.ObjList.Count <= 0 then begin
                            FreeAndNil(MapCellInfo.ObjList);
                            break;
                          end;
                        except
                          MainOutMessage(format(sExceptionMsg,[m_sCharName]));
                          MainOutMessage('Please contact thedeath and tell him you saw msg number 2 '+ m_sCharName + ' '+ IntToStr(wIdent));
                        end;
                      end else begin//004B90A4
                        try
                          BaseObject:=TBaseObject(OSObject.CellObj);
                          if (BaseObject <> nil)and not BaseObject.m_boGhost then begin
                            if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                              BaseObject.SendMsg(Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg);
                              m_VisibleHumanList.Add(BaseObject);
                            end else //004B9125
                            if BaseObject.m_boWantRefMsg then begin
                              if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) then begin
                                BaseObject.SendMsg(Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg);
                                m_VisibleHumanList.Add(BaseObject);
                              end;
                            end;
                          end;
                        except
                          on e: Exception do begin
                            MapCellInfo.ObjList.Delete(II);
                            if MapCellInfo.ObjList.Count <= 0 then begin
                              FreeAndNil(MapCellInfo.ObjList);
                            end;
                            MainOutMessage(format(sExceptionMsg,[m_sCharName]));
                            MainOutMessage(E.Message);
                          end;
                        end;
                      end;
                    end;
                  end;
                end; //for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
              end; //if MapCellInfo.ObjList <> nil then begin
            end; //if PEnvir.GetMapCellInfo(nC,n10,MapCellInfo) then begin
        end;
      end;
      exit;
    end; //004B91FC

    for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
    try
      BaseObject:=TBaseObject(m_VisibleHumanList.Items[nC]);
    except
      MainOutMessage(format(sExceptionMsg,[m_sCharName]));
      MainOutMessage('Please contact thedeath and tell him you saw msg number 4 '+ m_sCharName + ' '+ IntToStr(wIdent));
    end;
      if BaseObject.m_boGhost then Continue;
  try
      if (BaseObject.m_PEnvir = m_PEnvir) and
         (abs(BaseObject.m_nCurrX - m_nCurrX) < 11) and
         (abs(BaseObject.m_nCurrY - m_nCurrY) < 11) then begin
        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
          BaseObject.SendMsg(Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg);
        end else
        if BaseObject.m_boWantRefMsg then begin
          if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) then begin
            BaseObject.SendMsg(Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg);
          end;
        end; //if BaseObject.m_boWantRefMsg then begin
      end; //if (BaseObject.m_PEnvir = m_PEnvir) and
  except
    MainOutMessage(format(sExceptionMsg,[m_sCharName]));
    MainOutMessage('Please contact thedeath and tell him you saw msg number 3 '+ m_sCharName + ' '+ IntToStr(wIdent));
  end;
    end; //for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendDefMsg(BaseObject: TBaseObject; wIdent: Word;
  Recog: Integer; Param, tag, Series: Word; sMsg: string);
var
  SendMessage: pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then begin
      New(SendMessage);
      SendMessage.wIdent := RM_DEFMESSAGE;
      SendMessage.wParam := wIdent;
      SendMessage.nParam1 := Recog;
      SendMessage.nParam2 := Param;
      SendMessage.nParam3 := MakeLong(tag, Series);
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := False;
      if sMsg <> '' then begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end
      else begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendDefSocket(BaseObject: TBaseObject; wIdent: Word;
  Recog: Integer; Param, tag, Series: Word; sMsg: string);
var
  SendMessage: pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then begin
      New(SendMessage);
      SendMessage.wIdent := RM_DEFSOCKET;
      SendMessage.wParam := wIdent;
      SendMessage.nParam1 := Recog;
      SendMessage.nParam2 := Param;
      SendMessage.nParam3 := MakeLong(tag, Series);
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := False;
      if sMsg <> '' then begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end
      else begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendDelayRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg: String;dwDelay:LongWord);//004B8EBC
var
  II,nC: Integer;
  nCX,nCY,nLX,nLY,nHX,nHY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::SendDelayRefMsg Name = %s';
begin
  if m_PEnvir = nil then begin
    MainOutMessage(m_sCharName + ' SendDelayRefMsg nil PEnvir ' + IntToStr(wIdent));
    exit;
  end;
  if m_boObMode or m_boFixedHideMode then begin
  try
    DelaySendMsg (Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg,dwDelay);
  except
    MainOutMessage(format(sExceptionMsg,[m_sCharName]));
    MainOutMessage('Please contact thedeath and tell him you saw msg number 1-1 '+ m_sCharName + ' '+ IntToStr(wIdent));
  end;
    exit;
  end;

  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if ((GetTickCount - m_SendRefMsgTick) >= 500) or (m_VisibleHumanList.Count = 0) then begin
      m_SendRefMsgTick:=GetTickCount();
      m_VisibleHumanList.Clear;
      nLX:=m_nCurrX - g_Config.nSendRefMsgRange{12};
      nHX:=m_nCurrX + g_Config.nSendRefMsgRange{12};
      nLY:=m_nCurrY - g_Config.nSendRefMsgRange{12};
      nHY:=m_nCurrY + g_Config.nSendRefMsgRange{12};
      for nCX:= nLX to nHX do begin
        for nCY:= nLY to nHY do begin
            if m_PEnvir.GetMapCellInfo(nCX,nCY,MapCellInfo) then begin
              if MapCellInfo.ObjList <> nil then begin
                for II := MapCellInfo.ObjList.Count - 1 downto 0 do begin
                  OSObject:=MapCellInfo.ObjList.Items[II];
                  if OSObject <> nil then begin
                    if OSObject.btType = OS_MOVINGOBJECT then begin
                      if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then begin
                        try
                          DisPose(OSObject);
                          MapCellInfo.ObjList.Delete(II);
                          if MapCellInfo.ObjList.Count <= 0 then begin
                            FreeAndNil(MapCellInfo.ObjList);
                            break;
                          end;
                        except
                          MainOutMessage(format(sExceptionMsg,[m_sCharName]));
                          MainOutMessage('Please contact thedeath and tell him you saw msg number 2-1 '+ m_sCharName + ' '+ IntToStr(wIdent));
                        end;
                      end else begin//004B90A4
                        try
                          BaseObject:=TBaseObject(OSObject.CellObj);
                          if (BaseObject <> nil)and not BaseObject.m_boGhost then begin
                            if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                              BaseObject.DelaySendMsg (Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg,dwDelay);
                              m_VisibleHumanList.Add(BaseObject);
                            end else //004B9125
                            if BaseObject.m_boWantRefMsg then begin
                              if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) then begin
                                BaseObject.DelaySendMsg (Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg,dwDelay);
                                m_VisibleHumanList.Add(BaseObject);
                              end;
                            end;
                          end;
                        except
                          on e: Exception do begin
                            MapCellInfo.ObjList.Delete(II);
                            if MapCellInfo.ObjList.Count <= 0 then begin
                              FreeAndNil(MapCellInfo.ObjList);
                            end;
                            MainOutMessage(format(sExceptionMsg,[m_sCharName]));
                            MainOutMessage(E.Message);
                          end;
                        end;
                      end;
                    end;
                  end;
                end; //for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
              end; //if MapCellInfo.ObjList <> nil then begin
            end; //if PEnvir.GetMapCellInfo(nC,n10,MapCellInfo) then begin
        end;
      end;
      exit;
    end; //004B91FC

    for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
    try
      BaseObject:=TBaseObject(m_VisibleHumanList.Items[nC]);
    except
      MainOutMessage(format(sExceptionMsg,[m_sCharName]));
      MainOutMessage('Please contact thedeath and tell him you saw msg number 4-1 '+ m_sCharName + ' '+ IntToStr(wIdent));
    end;
      if BaseObject.m_boGhost then Continue;
  try
      if (BaseObject.m_PEnvir = m_PEnvir) and
         (abs(BaseObject.m_nCurrX - m_nCurrX) < 11) and
         (abs(BaseObject.m_nCurrY - m_nCurrY) < 11) then begin
        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
          BaseObject.DelaySendMsg (Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg,dwDelay);
        end else
        if BaseObject.m_boWantRefMsg then begin
          if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) then begin
            BaseObject.DelaySendMsg (Self,wIdent,wParam,nParam1,nParam2,nParam3,sMsg,dwDelay);
          end;
        end; //if BaseObject.m_boWantRefMsg then begin
      end; //if (BaseObject.m_PEnvir = m_PEnvir) and
  except
    MainOutMessage(format(sExceptionMsg,[m_sCharName]));
    MainOutMessage('Please contact thedeath and tell him you saw msg number 3-1 '+ m_sCharName + ' '+ IntToStr(wIdent));
  end;
    end; //for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;


procedure TBaseObject.UpdateVisibleGay(BaseObject:TBaseObject);//004B939C
var
  I                 :Integer;
  boIsVisible       :Boolean;
  VisibleBaseObject :pTVisibleBaseObject;
begin
  boIsVisible:=False;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_Master <> nil) then
    m_boIsVisibleActive:=True;//흔벎角훙膠샀괜괜橙零TRUE
  for I := 0 to m_VisibleActors.Count - 1 do begin
    VisibleBaseObject:=m_VisibleActors.Items[i];
    if VisibleBaseObject.BaseObject = BaseObject then begin
      VisibleBaseObject.nVisibleBFlag:=1;
      boIsVisible:=True;
      break;
    end;
  end;

  if boIsVisible then exit;
  New(VisibleBaseObject);
  VisibleBaseObject.nVisibleBFlag := 2;
  VisibleBaseObject.BaseObject   := BaseObject;
  m_VisibleActors.Add(VisibleBaseObject);
end;

procedure TBaseObject.UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);//004B94FC
var
  I: Integer;
  boIsVisible:Boolean;
  VisibleMapItem:pTVisibleMapItem;
begin
  boIsVisible:=False;
  for I := 0 to m_VisibleItems.Count - 1 do begin
    VisibleMapItem:=m_VisibleItems.Items[i];
    if VisibleMapItem.MapItem = MapItem then begin
      VisibleMapItem.nVisibleFlag:=1;
      boIsVisible:=True;
      break;
    end;
  end;
  if boIsVisible then exit;
    New(VisibleMapItem);
    VisibleMapItem.nVisibleFlag:=2;
    VisibleMapItem.nX:=wX;
    VisibleMapItem.nY:=wY;
    VisibleMapItem.MapItem:=MapItem;
    VisibleMapItem.sName:=MapItem.Name;
    VisibleMapItem.wLooks:=MapItem.Looks;
    m_VisibleItems.Add(VisibleMapItem);
end;

procedure TBaseObject.UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject); //004B95D0
var
  I: Integer;
  boIsVisible:Boolean;
  Event:TEvent;
begin
  boIsVisible:=False;
  for I := 0 to m_VisibleEvents.Count - 1 do begin
    Event:=m_VisibleEvents.Items[i];
    if Event = MapEvent then begin
      Event.nVisibleFlag:=1;
      boIsVisible:=True;
      break;
    end;
  end;
  if boIsVisible then exit;
  TEvent(MapEvent).nVisibleFlag:=2;
  TEvent(MapEvent).m_nX:=wX;
  TEvent(MapEvent).m_nY:=wY;
  m_VisibleEvents.Add(MapEvent);
end;
function TBaseObject.IsVisibleHuman: Boolean;
var
  I:Integer;
  VisibleBaseObject:pTVisibleBaseObject;
begin
  Result:=False;
  for I := 0 to m_VisibleActors.Count - 1 do begin
    VisibleBaseObject:=m_VisibleActors.Items[i];
    if (VisibleBaseObject.BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (VisibleBaseObject.BaseObject.m_Master <> nil) then begin
      Result:=True;
      break;
    end;
  end;
end;

procedure TBaseObject.SearchViewRange;//004B966C
var
  I           :Integer;
  nStartX     :Integer;
  nEndX       :Integer;
  nStartY     :Integer;
  nEndY       :Integer;
  n18         :Integer;
  n1C         :Integer;
  nIdx        :Integer;
  n24         :Integer;
  MapCellInfo :pTMapCellinfo;
  OSObject    :pTOSObject;
  BaseObject  :TBaseObject;
  VisibleBaseObject:pTVisibleBaseObject;
  nCheckCode       :Integer;
ResourceString
  sExceptionMsg1 = '[Exception] TBaseObject::SearchViewRange Code:%d';
  sExceptionMsg2 = '[Exception] TBaseObject::SearchViewRange 1-%d %s %s %d %d %d';

begin
  nCheckCode:=0;
  if m_PEnvir = nil then begin
    MainOutMessage('SearchViewRange nil PEnvir');
    exit;
  end;
  nCheckCode:=1;
  n24:=0;
  m_boIsVisibleActive:=False;//邱零槨FALSE
  try
    nCheckCode:=4;
    for I := 0 to m_VisibleActors.Count - 1 do begin
      pTVisibleBaseObject(m_VisibleActors.Items[I]).nVisibleBFlag:=0;
    end;
    nCheckCode:=5;
  except
    MainOutMessage(format(sExceptionMsg1,[nCheckCode]));
    KickException();
  end;
  nCheckCode:=6;

  nStartX :=m_nCurrX - m_nViewRange;
  nEndX   :=m_nCurrX + m_nViewRange;
  nStartY :=m_nCurrY - m_nViewRange;
  nEndY   :=m_nCurrY + m_nViewRange;
  try
    nCheckCode:=7;
    for n18:= nStartX to nEndX do begin
      nCheckCode:=8;
      for n1C:= nStartY to nEndY  do begin
        nCheckCode:=9;
        if m_PEnvir.GetMapCellInfo(n18,n1C,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          nCheckCode:=10;
          n24:=1;
          nIdx:=0;
          while (True) do begin
            nCheckCode:=11;
            if (MapCellInfo.ObjList.Count <= 0) then begin //영물테스트
              nCheckCode := 111;
              FreeAndNil(MapCellInfo.ObjList);
              Break;
            end;
            if MapCellInfo.ObjList.Count <= nIdx then break;    //004B9858
              OSObject:=MapCellInfo.ObjList.Items[nIdx];
              nCheckCode:=12;
              if OSObject <> nil then begin
                nCheckCode:=13;
                if OSObject.btType = OS_MOVINGOBJECT then begin   // 잔상 검사하여 지운다.
                  nCheckCode:=14;
                  if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then begin
                    Dispose(OSObject);
                    MapCellInfo.ObjList.Delete(nIdx);
                    if MapCellInfo.ObjList.Count > 0 then Continue;
                    FreeAndNil(MapCellInfo.ObjList);
                    break;
                  end; //004B9907
                  nCheckCode:=15;
                  BaseObject:=TBaseObject(OSObject.CellObj);
                  if BaseObject <> nil then begin
                    nCheckCode:=16;
                    if (not BaseObject.m_boGhost) and (not BaseObject.m_boFixedHideMode) and (not BaseObject.m_boObMode) then begin
                      nCheckCode:=17;
                      if (m_btRaceServer < RC_ANIMAL) or       //몹이 아니거나
                        (m_Master <> nil) or            //주인이 있거나
                        m_boCrazyMode or                  //폭주상태거나
                        m_boNastyMode or
                        m_boHallucMode or //Hallucination
                        m_boWantRefMsg or                   //메세지가 필요함
                        ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or        //주인있는 몹은 다 본다.(사람처럼 간주)
                        (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin        //사람은 다 본다
                        nCheckCode:=18;
                        UpdateVisibleGay(BaseObject);
                        nCheckCode:=19;
                      end;
                    end;
                  end;
                end;
              end;
            Inc(nIdx);
          end;
        end;
      end;
    end;
  except
    on e: Exception do begin

      MainOutMessage(format(sExceptionMsg2,[n24,m_sCharName,m_sMapName,m_nCurrX,m_nCurrY,nCheckCode]));
      {
      MainOutMessage(m_sCharName + ',' +
                     m_sMapName + ',' +
                     IntToStr(m_nCurrX) + ',' +
                     IntToStr(m_nCurrY) + ',' +
                     ' SearchViewRange 1-' +
                     IntToStr(n24));
      }
      MainOutMessage(E.Message);
      KickException();
    end;
  end;

  nCheckCode:=40;
  n24:=2;
  try
    n18:=0;
    while (True) do begin
      if m_VisibleActors.Count <= n18 then break;
      nCheckCode:=41;
      VisibleBaseObject:=m_VisibleActors.Items[n18];
      nCheckCode:=42;
      if VisibleBaseObject.nVisibleBFlag = 0 then begin
        nCheckCode:=43;
        m_VisibleActors.Delete(n18);
        nCheckCode:=48;
        Dispose(VisibleBaseObject);
        nCheckCode:=49;
        Continue;
      end;
      nCheckCode:=50;
      Inc(n18);
    end;
  except
    on e: Exception do begin
      MainOutMessage(format(sExceptionMsg2,[n24,m_sCharName,m_sMapName,m_nCurrX,m_nCurrY,nCheckCode]));
    {MainOutMessage(m_sCharName + ',' +
                   m_sMapName + ',' +
                   IntToStr(m_nCurrX) + ',' +
                   IntToStr(m_nCurrY) + ',' +
                   ' SearchViewRange 2');}
      KickException();
    end;
  end;
end;

function TBaseObject.GetFeatureToLong: Integer; //004BA23C    //말
begin
  Result:=GetFeature(nil);
end;

function TBaseObject.GetFeatureEx():Word;
begin
  if m_boOnHorse then begin
    Result:=MakeWord(m_btHorseType + 1,m_btDressEffType);
  end else begin
    Result:=MakeWord(0,m_btDressEffType);
  end;
end;


function TBaseObject.GetFeature(BaseObject: TBaseObject):Integer;//004BA25C
var
  nDress,nWeapon,nHair:Integer;
  StdItem:TItem;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
    nDress:=0;
    //옷
    if m_UseItems[U_DRESS].wIndex > 0 then begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
      if StdItem <> nil then begin
        nDress:=StdItem.Shape * 2;
      end;
    end;
    Inc(nDress,m_btGender);
    nWeapon:=0;
    //무기
    if m_UseItems[U_WEAPON].wIndex > 0 then begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if StdItem <> nil then begin
        nWeapon:=StdItem.Shape * 2;
      end;
    end;
    Inc(nWeapon,m_btGender);
    nHair:=m_btHair;     //헤어  여자도 대머리 가능.
    Result:=MakeHumanFeature(0,nDress,nWeapon,nHair);
    exit;
  end;
  if ( m_btRaceServer = RC_CLONE) or ( m_btRaceServer = RC_DARKCLONE) or ( m_btRaceServer = RC_BONZECLONE ) then begin       // 분신이면 사람의 모습을 내려줌
    Result := MasterFeature;
  end else begin
    Result:=MakeMonsterFeature(m_btRaceImg,m_wAppr);          //몹레이스
  end;
end;

function TBaseObject.GetAddStatus(): Integer;     //문파 마크  개인상점 변신탈 기퍼짐
begin
   Result := MakeLong(MakeWord(GetObjectMark, m_btMask), MakeWord(Integer(m_boStore), m_btHumEffect));
end;

function TBaseObject.GetAddStatus2(): Integer;     //빼빼로  홍보단
begin
   Result := MakeLong(MakeWord(m_btJob, m_WEffect), MakeWord(m_btColumn, m_btEventEffect));
end;


function TBaseObject.GetCharStatus():UINT;//004BA43C       //스테이트
var
  I: Integer;
  nStatus:DWord;
begin
  nStatus:=0;
  for I := Low(TStatusTime) to High(TStatusTime) do begin
    if m_wStatusTimeArr[I] > 0 then begin
      nStatus:=($80000000 shr I) or nStatus;
    end;
  end;
  Result:=(m_nCharStatusEx and $FFFFF) or nStatus;
end;

procedure TBaseObject.AbilCopyToWAbil;//004BA494
begin
  m_WAbil:=m_Abil;
end;

procedure TBaseObject.Initialize;//4BA4B8
var
  I: Integer;
  UserMagic:pTUserMagic;
begin
  AbilCopyToWAbil();
  for I := 0 to m_MagicList.Count - 1 do begin
    UserMagic:=m_MagicList.Items[i];
    if UserMagic.btLevel >= 4 then UserMagic.btLevel:=0;
  end;
  m_boAddtoMapSuccess:=True;
  if m_PEnvir.CanWalk(m_nCurrX,m_nCurrY,True) and AddToMap() then
    m_boAddtoMapSuccess:=False;
  m_nCharStatus:=GetCharStatus();
  AddBodyLuck(0);
  LoadSayMsg();
  if g_Config.boMonSayMsg then MonsterSayMsg(nil,s_MonGen);
end;
//==============================
//혤돤밍膠綱뺐斤口죗깊
procedure TBaseObject.LoadSayMsg();
var
  I: Integer;
begin
  for I := 0 to g_MonSayMsgList.Count - 1 do begin
    if CompareText(g_MonSayMsgList.Strings[I],m_sCharName) = 0 then begin
      m_SayMsgList:=TList(g_MonSayMsgList.Objects[I]);
      break;
    end;
  end;
end;
procedure TBaseObject.Disappear(); //004BA580
begin

end;

procedure TBaseObject.FeatureChanged;//004BA58C
begin
  SendRefMsg(RM_USERMASK,0,m_btMask,m_btHumEffect,m_btEventEffect,IntToStr(m_WEffect));   //변신탈  //기퍼짐
  SendRefMsg(RM_USERMARK,0,GetObjectMark,m_btColumn,m_btJob,'');  //문파 마크  //빼빼로
  SendRefMsg(RM_FEATURECHANGED,GetFeatureEx,GetFeatureToLong,0,0,'');
end;

procedure TBaseObject.StatusChanged();//004BA5B4
begin
  SendRefMsg(RM_CHARSTATUSCHANGED, m_nHitSpeed,m_nCharStatus, 0, 0, '');

end;

procedure TBaseObject.DisappearA(); //004BA65C
begin
  if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then DelMapCount;  //관리자시스템
  SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');            //확인
end;

procedure  TBaseObject.KickException; //004BA6A8
var
  PlayObject:TPlayObject;
begin
   if m_btRaceServer = RC_PLAYOBJECT then begin
      m_sMapName := g_Config.sHomeMap;
      m_nCurrX := g_Config.nHomeX;
      m_nCurrY := g_Config.nHomeY;
      PlayObject:= TPlayObject(self);
      PlayObject.m_boEmergencyClose := TRUE;
   end else begin  //
      m_boDeath:=True;
      m_dwDeathTick:=GetTickCount;
      MakeGhost;
   end;
end;

function TBaseObject.Walk(nIdent:Integer):Boolean;//004BA724
var
  I: Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  GateObj:pTGateObj;
  bo1D:Boolean;
  Event:TEvent;
  PlayObject:TPlayObject;
  nCheckCode:Integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::Walk  CheckCode:%d %s %s %d:%d';
begin
  Result:=True;
  nCheckCode:= -1;
  if m_PEnvir = nil then begin
    MainOutMessage('Walk nil PEnvir');
    exit;
  end;
  try
    nCheckCode:=1;
    bo1D:=m_PEnvir.GetMapCellInfo(m_nCurrX,m_nCurrY,MapCellInfo);
    GateObj:=nil;
    Event:=nil;
    nCheckCode:=2;
    if bo1D and (MapCellInfo.ObjList <> nil)then begin
      for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
        OSObject:=MapCellInfo.ObjList.Items[i];
        if OSObject.btType = OS_GATEOBJECT then begin
         GateObj:=pTGateObj(OSObject.CellObj);
        end;
        if OSObject.btType = OS_EVENTOBJECT then begin
          if TEvent(OSObject.CellObj).m_OwnBaseObject <> nil then
            Event:=TEvent(OSObject.CellObj);
        end;
        if OSObject.btType = OS_MAPEVENT then begin

        end;
        if OSObject.btType = OS_DOOR then begin

        end;
        if OSObject.btType = OS_ROON then begin

        end;
      end;
    end;
    nCheckCode:=3;
    if Event <> nil then begin
      if Event.m_OwnBaseObject.IsProperTarget(Self) then  //FFF4
        SendMsg(Event.m_OwnBaseObject,RM_MAGSTRUCK_MINE,0,Event.m_nDamage,0,0,'');
    end;
    nCheckCode:=4;
    if Result and (GateObj <> nil) then begin
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if m_PEnvir.ArroundDoorOpened(m_nCurrX,m_nCurrY) then begin
          //004BA89E
          if (not TEnvirnoment(GateObj.DEnvir).Flag.boNEEDHOLE) or (g_EventManager.GetEvent(m_PEnvir,m_nCurrX,m_nCurrY,ET_DIGOUTZOMBI) <> nil) then begin
            if nServerIndex = TEnvirnoment(GateObj.DEnvir).nServerIndex then begin
              if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir),GateObj.nDMapX,GateObj.nDMapY) then begin
                Result:=False;
              end;
            end else begin //004BA914
              DisappearA();
              m_bo316:=True;
              PlayObject:=TPlayObject(Self);
              PlayObject.m_sSwitchMapName:=TEnvirnoment(GateObj.DEnvir).sMapName;
              PlayObject.m_nSwitchMapX:=GateObj.nDMapX;
              PlayObject.m_nSwitchMapY:=GateObj.nDMapY;
              PlayObject.m_boSwitchData:=True;
              PlayObject.m_nServerIndex:=TEnvirnoment(GateObj.DEnvir).nServerIndex;
              PlayObject.m_boEmergencyClose:=True;
              PlayObject.m_boReconnection:=True;
            end;
          end;
        end;
      end else Result:=False;
    end else begin  //004BA998
      nCheckCode:=5;
      if Result then begin
        nCheckCode:=6;
        SendRefMsg(nIdent,m_btDirection,m_nCurrX,m_nCurrY,0,'');
      end;
    end;
  except
    on e: Exception do begin
      MainOutMessage(format(sExceptionMsg,[nCheckCode,m_sCharname,m_sMapName,m_nCurrX,m_nCurrY]));
      {MainOutMessage('[Exception] TBaseObject.Walk  CheckCode: ' + IntToStr(nCheckCode) + ' ' +
                    m_sCharname + ' ' +
                    m_sMapName + ' ' +
                    IntToStr(m_nCurrX) + ':' +
                    IntToStr(m_nCurrY));}
      MainOutMessage(E.Message);
    end;
  end;
end;

function TBaseObject.EnterAnotherMap(Envir: TEnvirnoment; nDMapX,
  nDMapY: Integer): Boolean; //004BAADC
var
  I           :Integer;
  MapCellInfo :pTMapCellinfo;
  OldEnvir    :TEnvirnoment;
  nOldX       :Integer;
  nOldY       :Integer;
  Castle      :TUserCastle;
ResourceString
  sExceptionMsg1 = '[Exception] TBaseObject::EnterAnotherMap -> MsgTargetList Clear';
  sExceptionMsg2 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Dispose';
  sExceptionMsg3 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Clear';
  sExceptionMsg4 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleEvents Clear';
  sExceptionMsg5 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Dispose';
  sExceptionMsg6 = '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Clear';
  sExceptionMsg7 = '[Exception] TBaseObject::EnterAnotherMap';
begin
  Result:=False;
  try
    if m_Abil.Level < Envir.nRequestLevel then exit;       //1) 들어 갈 수 있는지, 적합한지
    if Envir.QuestNPC <> nil then TMerchant(Envir.QuestNPC).Click(TPlayObject(Self));
    if Envir.Flag.nNEEDSETONFlag >=  0 then begin
      if GetQuestFalgStatus(Envir.Flag.nNEEDSETONFlag) <> Envir.Flag.nNeedONOFF then exit;
    end;
    if not Envir.GetMapCellInfo(nDMapX,nDMapY,MapCellInfo) then exit;

  {  Castle:=g_CastleManager.IsCastlePalaceEnvir(Envir);          //사북성의 내성인 경우
    if (Castle <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then begin
      if not Castle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then exit;      //들어갈 수 없음.
    end;     }

    if Envir.Flag.boNOHORSE then m_boOnHorse:=False; //탈것
    OldEnvir:=m_PEnvir;
    nOldX:=m_nCurrX;
    nOldY:=m_nCurrY;

    //2) 지금 맵에서 떠남, 변수 초기화
      // 만약 사라지지 않는다면 그냥 나간다.
      // if Disappear(2) = false then   Exit;
    DisappearA();
    try
      m_VisibleHumanList.Clear;
    except
      MainOutMessage(sExceptionMsg1);
    end;
    try
      for I := 0 to m_VisibleItems.Count - 1 do begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end;
    except
      MainOutMessage(sExceptionMsg2);
    end;
    try
      m_VisibleItems.Clear;
    except
      MainOutMessage(sExceptionMsg3);
    end;

    try
      m_VisibleEvents.Clear;
    except
      MainOutMessage(sExceptionMsg4);
    end;
    try
      for I := 0 to m_VisibleActors.Count - 1 do begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
    except
      MainOutMessage(sExceptionMsg5);
    end;
    try
      m_VisibleActors.Clear;
    except
      MainOutMessage(sExceptionMsg6);
    end;
    if (m_btRaceServer = RC_PLAYOBJECT) then
      SendMsg(Self,RM_CLEAROBJECTS,0,0,0,0,'');
    //3) 새맵에 등장
    m_PEnvir:=Envir;
    m_sMapName:=Envir.sMapName;
    m_nCurrX:=nDMapX;
    m_nCurrY:=nDMapY;
    if m_btRaceServer = RC_PLAYOBJECT then
      SendMsg(Self,RM_CHANGEMAP,0,0,0,0,Envir.sMapName);  //맵이동

    if AddToMap() then begin
      m_dwMapMoveTick:=GetTickCount();
      m_bo316:=True;     //WalkTo가 실패하지 않게 하려고..
      Result:=True;
    end else begin
      m_PEnvir:=OldEnvir;           //샐패한경우
      m_nCurrX:=nOldX;
      m_nCurrY:=nOldY;
      m_PEnvir.AddToMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
    end;
    AddMapCount;                 //관리자시스템
    if m_btRaceServer = RC_PLAYOBJECT then begin
      TPlayObject(Self).m_dwIncGamePointTick:=GetTickCount();
      TPlayObject(Self).m_dwIncGameGoldTick:=GetTickCount();
      TPlayObject(Self).m_dwAutoGetExpTick:=GetTickCount();
      TPlayObject(Self).m_dwPCPointTick:=GetTickCount();
    end;
    //문파대전장을 들어가거나 나갈 때       용맹의전장 이름색변경
    if (m_PEnvir.Flag.boFight3Zone and (m_PEnvir.Flag.boFight3Zone <> OldEnvir.Flag.boFight3Zone)) or (m_PEnvir.Flag.VailantZone and (m_PEnvir.Flag.VailantZone <> OldEnvir.Flag.VailantZone)) then
      RefShowName();            //이름 색 변경
  except
    MainOutMessage(sExceptionMsg7);
  end;
end;

procedure TBaseObject.TurnTo(nDir: integer); //004BB048
begin
  m_btDirection:=nDir;
  SendRefMsg(RM_TURN,nDir,m_nCurrX,m_nCurrY,0,'');
end;

procedure TBaseObject.TurnToPet(nDir: integer); //004BB048
begin
  m_btDirection:=nDir;
  Case Random(40) of
    0..9: SendRefMsg(RM_LIGHTING,nDir,m_nCurrX,m_nCurrY,Integer(Self),'');
    10..19: SendRefMsg(RM_LIGHTING_2,nDir,m_nCurrX,m_nCurrY,Integer(Self),'');
    20..29: SendRefMsg(RM_LIGHTING_3,nDir,m_nCurrX,m_nCurrY,Integer(Self),'');
    else begin
      SendRefMsg(RM_TURN,nDir,m_nCurrX,m_nCurrY,0,'');
    end;
  end;
end;


procedure TBaseObject.ProcessSayMsg(sMsg: String);//004BB084
var
  sCharName:String;
begin
  if m_btRaceServer = RC_PLAYOBJECT then begin
    if m_PEnvir.Flag.boDEATHMATCH then sCharName:='엄떱: '
    else
    if m_PEnvir.Flag.boPKZONE then sCharName:='PKZONE: '
    else
     sCharName:=m_sCharName + #9;                  //이름 테두리
  end else begin
    sCharName:=FilterShowName(m_sCharName) + ': ';
  end;
  SendRefMsg(RM_HEAR,0,g_Config.btHearMsgFColor,g_Config.btHearMsgBColor,0, sCharName + sMsg)
end;


procedure TBaseObject.MoveMsg(sMsg: string);    //화면공지
begin
  SendMsg(Self, RM_MOVEMESSAGE, 0, 0, 0, 0, sMsg);
end;

procedure TBaseObject.SysMsg(sMsg:String;MsgColor:TMsgColor;MsgType:TMsgType);//004BB124
var
 PlayObject:TPlayObject;
begin
 PlayObject:=TPlayObject(Self);    //플레이 오브젝트가 본인임을 선택
  if g_Config.boShowPreFixMsg then begin
    case MsgType of
      t_Mon:    sMsg:=g_Config.sMonSayMsgpreFix + sMsg;
      t_Hint:   sMsg:=g_Config.sHintMsgPreFix + sMsg;
      t_GM:     sMsg:=g_Config.sGMRedMsgpreFix + sMsg;
      t_System: sMsg:=g_Config.sSysMsgPreFix + sMsg;
      t_Notice: sMsg:=g_Config.sLineNoticePreFix + sMsg;
      t_Cust:   sMsg:=g_Config.sCustMsgpreFix + sMsg;
      t_Cust1:   sMsg:=g_Config.sCustMsgpreFix + sMsg;
      t_Castle: sMsg:=g_Config.sCastleMsgpreFix + sMsg;
      t_SVN1: begin
        SendMsg(Self,RM_SYSMESSAGE,0,$38,$FF,0,sMsg);
        exit;
      end;
      t_SVN2: begin
        SendMsg(Self,RM_SYSMESSAGE,0,$FF,$DB,0,sMsg);
        exit;
      end;
      t_SVN3: begin
        SendMsg(Self,RM_SYSMESSAGE,0,$FF,$38,0,sMsg);
        exit;
      end;
      t_TN: begin              //장원 외치기
        SendMsg(Self,RM_SYSMESSAGE,0,255,220,0,sMsg);
        exit;
      end;
    end;
  end;

  case MsgColor of
    c_Green: SendMsg(Self,RM_SYSMESSAGE,0,g_Config.btGreenMsgFColor,g_Config.btGreenMsgBColor,0,sMsg);
    c_Blue: SendMsg(Self,RM_SYSMESSAGE,0,g_Config.btBlueMsgFColor,g_Config.btBlueMsgBColor,0,sMsg);
    c_RedWhite: SendMsg(Self,RM_SYSMESSAGE,0,249,255,0,sMsg);
    c_BlueWhite: SendMsg(Self,RM_SYSMESSAGE,0,252,255,0,sMsg);
    c_Pink: SendMsg(Self,RM_SYSMESSAGE,0,255,253,0,sMsg);
    c_BlueGreen: SendMsg(Self,RM_SYSMESSAGE,0,156,255,0,sMsg);
    c_GreenWhite: SendMsg(Self,RM_SYSMESSAGE,0,255,220,0,sMsg);
    c_Green2: SendMsg(Self,RM_SYSMESSAGE,0,255,220 ,0,sMsg);   //장원 외치기
    else begin
     if PlayObject.m_boBanSysMsg then begin
      if MsgType = t_Cust2 then begin     //경매
        SendMsg(Self,RM_SYSMESSAGE,0,255,249,0,sMsg);
      end else
      if MsgType = t_Cust1 then begin    //고성 보라
        SendMsg(Self,RM_SYSMESSAGE,0,g_Config.btCustMsg1FColor,g_Config.btCustMsg1BColor,0,sMsg);
      end else
      if MsgType = t_Cust then begin     //고성 녹색
        SendMsg(Self,RM_SYSMESSAGE,0,g_Config.btCustMsgFColor,g_Config.btCustMsgBColor,0,sMsg);
      end else begin
        SendMsg(Self,RM_SYSMESSAGE,0,g_Config.btRedMsgFColor,g_Config.btRedMsgBColor,0,sMsg);
      end;
     end;
    end;
  end;
end;

procedure TBaseObject.MonsterSayMsg(AttackBaseObject:TBaseObject;MonStatus:TMonStatus);
var
  I: Integer;
  sMsg:String;
  MonSayMsg:pTMonSayMsg;
  sAttackName:String;
begin
  if m_SayMsgList = nil then exit;
  if (m_btRaceServer = RC_PLAYOBJECT) then exit;
  if (AttackBaseObject <> nil) then begin
    if (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (AttackBaseObject.m_Master = nil) then begin
      exit;
    end;
    if AttackBaseObject.m_Master <> nil then sAttackName:=AttackBaseObject.m_Master.m_sCharName
    else sAttackName:=AttackBaseObject.m_sCharName;
  end;
  for I := 0 to m_SayMsgList.Count - 1 do begin
    MonSayMsg:=m_SayMsgList.Items[I];
    sMsg:=AnsiReplaceText(MonSayMsg.sSayMsg,'%s',FilterShowName(m_sCharName));
    sMsg:=AnsiReplaceText(sMsg,'%d',sAttackName);
    if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then begin
      if MonStatus = s_MonGen then begin
        UserEngine.SendBroadCastMsg(sMsg,t_Mon);
        break;
      end;
      if MonSayMsg.Color = c_White then begin
        ProcessSayMsg(sMsg);
      end else begin
        AttackBaseObject.SysMsg(sMsg,MonSayMsg.Color,t_Mon);
      end;
      break;
    end;
  end;
end;
procedure TBaseObject.SendGroupText(sMsg: String);//004BB1CC    //그룹 메시지
var
  I: Integer;
  PlayObject:TPlayObject;
begin
  if g_Config.boShowPreFixMsg then
    sMsg:=g_Config.sGroupMsgPreFix + sMsg;

  if m_GroupOwner <> nil then begin
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do  begin
      PlayObject:=TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);    //플레이 오브젝트가 누구를 대상하는지
      if PlayObject.m_boBanGroupChat then    //그룹메시지 본인만 차단
      PlayObject.SendMsg(Self,RM_GROUPMESSAGE,0,g_Config.btGroupMsgFColor,g_Config.btGroupMsgBColor,0,sMsg);
    end;
  end;
end;



procedure TBaseObject.MakeGhost(); //004BB300
begin
  m_boGhost:=True;
  m_dwGhostTick:=GetTickCount();
  DisappearA();
end;

procedure TBaseObject.ApplyMeatQuality; //004BB32C
var
  I: Integer;
  StdItem:TItem;
  UserItem:pTUseritem;
begin
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[i];
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
      if StdItem.StdMode = 40 then begin
        UserItem.Dura:=m_nMeatQuality;
      end;
    end;
  end;
end;

function TBaseObject.TakeBagItems(BaseObject: TBaseObject): Boolean; //004BB3B0 //가방 아이템 획득
var
  UserItem:pTUseritem;
  PlayObject:TPlayObject;
  boot:Boolean;
begin
  Result:=False;
  while (True) do begin
    if BaseObject.m_ItemList.Count <= 0 then break;
    UserItem:=BaseObject.m_ItemList.Items[0];
    if (UserItem = nil) or (not AddItemToBag(UserItem,boot)) then break;
    if Self is TPlayObject then begin
      PlayObject:=TPlayObject(Self);
      if boot then
      PlayObject.SendAddItem(UserItem,1);
      Result:=True;
    end;
    BaseObject.m_ItemList.Delete(0);
  end;
end;

procedure TBaseObject.ScatterBagItems(ItemOfCreat:TBaseObject); //004BB44C    //몹들 아이템 떨굼
const
  DropWide:Integer = 3;
var
  I,II:Integer;
  UserItem, UserItem1:pTUserItem;
  StdItem:TItem;
  boCanNotDrop, boot, PetEat:Boolean;
  MonDrop:pTMonDrop;
  tCode:integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::ScatterBagItems %d';
begin
  try
    g_MonDropLimitLIst.Lock;
    try
      tCode:=0;
      for I:=m_ItemList.Count - 1 downto 0 do begin
        tCode:=1;
        UserItem:=m_ItemList.Items[I];
        StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
        boCanNotDrop:=False;
        PetEat := False;
        if StdItem <> nil then begin
          for II:= 0 to g_MonDropLimitLIst.Count - 1 do begin
            tCode:=2;
            if CompareText(StdItem.Name,g_MonDropLimitLIst.Strings[II]) = 0 then begin
              MonDrop:=pTMonDrop(g_MonDropLimitLIst.Objects[II]);
              tCode:=3;
              if MonDrop.DateBool and (MonDrop.DateLimit > DateTimeToUnix(now)) then begin
                Inc(MonDrop.nNoDropCount);
                boCanNotDrop:=True;
              end else begin
                if MonDrop.nDropCount < MonDrop.nCountLimit then begin
                  Inc(MonDrop.nDropCount);
                  tCode:=4;
                  g_MonDropLimitLIst.Objects[II]:=TObject(MonDrop);
                end else begin
                  Inc(MonDrop.nNoDropCount);
                  boCanNotDrop:=True;
                end;
              end;
              break;
            end;
          end;
        end;
        tCode:=5;
        if boCanNotDrop then Continue;

        tCode:=6;
        if (ItemOfCreat <> nil) then begin
          if (ItemOfCreat.m_PetList.Count > 0) and (ItemOfCreat.m_btRaceServer in [RC_PLAYOBJECT])
            and (ItemOfCreat.m_GroupOwner = nil) and TPlayObject(ItemOfCreat).PetEatItemOption(StdItem)
            and TPlayObject(ItemOfCreat).IsEnoughBag then begin
            tCode:=7;
            New(UserItem1);
            tCode:=8;
            if UserEngine.CopyToUserItemFromName(StdItem.Name,UserItem1) then begin
              tCode:=9;
              ItemOfCreat.AddItemToBag(UserItem1,boot);
              if boot then
              TPlayObject(ItemOfCreat).SendAddItem(UserItem1,1);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('4' +  #9 +
                                    ItemOfCreat.m_sMapName + #9 +
                                    IntToStr(ItemOfCreat.m_nCurrX) + #9 +
                                    IntToStr(ItemOfCreat.m_nCurrY) + #9 +
                                    ItemOfCreat.m_sCharName + #9 +
                                    StdItem.Name+'('+ IntToStr(UserItem1.Amount) +')' + #9 +
                                    IntToStr(UserItem1.MakeIndex) + #9 +
                                    '1' + #9 +
                                    '0' + #9 + '[쥣膠菱땡歌혤]');
              tCode:=10;
              PetEat := True;
              Dispose(UserItem);
              m_ItemList.Delete(I);
            end else begin
              tCode:=11;
              Dispose(UserItem1);
            end;
            tCode:=12;
          end;
        end;

        
        if not PetEat then begin
          tCode:=13;
          if DropItemDown(UserItem,DropWide,True,ItemOfCreat,Self) then begin
            tCode:=14;
            Dispose(UserItem);
            m_ItemList.Delete(I);
          end;
        end;
      end;
      tCode:=15;
    finally
      g_MonDropLimitLIst.UnLock;
    end;
  except
    MainOutMessage(Format(sExceptionMsg,[tCode]));
  end;
end;

procedure TBaseObject.ScatterGolds(GoldOfCreat:TBaseObject); //004BB63C
  procedure ScatterGold(GoldOfCreat:TBaseObject);
  var
    I, nGold, nError: integer;
    PetEat:Boolean;
    ResourceString
     sExceptionMsg3 = '[Exception] TBaseObject::ScatterGold :: %d 대상 [%s]';
  begin
    nError := 0;
    try
    nError := 1;
    if m_nGold > 0 then begin
      I:=0;
      nError := 2;
      while (True) do begin
        nError := 3;
        if m_nGold > g_Config.nMonOneDropGoldCount then begin
          nGold := g_Config.nMonOneDropGoldCount;
          DecGold(g_Config.nMonOneDropGoldCount);
        end else begin
          nGold := m_nGold;
          m_nGold := 0;
        end;
        nError := 4;
        if nGold > 0 then begin
          PetEat := False;
          nError := 5;
          if (GoldOfCreat <> nil) then begin
            if (GoldOfCreat.m_PetList.Count > 0) and (GoldOfCreat.m_btRaceServer in [RC_PLAYOBJECT])
              and (GoldOfCreat.m_GroupOwner = nil) and ((TPlayObject(GoldOfCreat).g_boItemAll = 1) or (TPlayObject(GoldOfCreat).g_boItemGold = 1))
              and TPlayObject(GoldOfCreat).IncGold (nGold) then begin
              nError := 6;
              GoldOfCreat.GoldChanged;
              PetEat := True;
              if g_boGameLogGold then //004C5E8C
               AddGameDataLog('4' +  #9 +
                     GoldOfCreat.m_sMapName + #9 +
                     IntToStr(GoldOfCreat.m_nCurrX) + #9 +
                     IntToStr(GoldOfCreat.m_nCurrY) + #9 +
                     GoldOfCreat.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nGold) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[쥣膠菱땡歌혤]');
            end;
          end;
          nError := 7;
          if not PetEat then begin
            nError := 8;
            if not DropGoldDown (nGold, TRUE,GoldOfCreat,Self) then begin
              nError := 9;
              IncGold(nGold);
              break;
            end;
          end;
        end else break;
        Inc(I);
        if I >= 17 then break;
      end;
    end;
    except
      MainOutMessage (Format(sExceptionMsg3, [nError, m_sCharName]));
    end;
  end;
var
  nCount, nMyCount, nAddCount: Integer;
  PlayList: array[0..13] of TPlayObject;
  I, PlayCount, nError: Integer;
  GroupObject: TPlayObject;
ResourceString
  sExceptionMsg3 = '[Exception] TBaseObject::ScatterGolds :: %d 대상 [%s]';
begin
   nError := 0;
   try
   if m_nGold > 0 then begin
     nError := 1;
     if (GoldOfCreat <> nil) and (GoldOfCreat.m_GroupOwner <> nil) then begin
       nError := 2;
       PlayCount := 0;
       for i := 0 to GoldOfCreat.m_GroupOwner.m_GroupMembers.Count - 1 do begin
         if PlayCount > High(PlayList) then break;
         GroupObject := TPlayObject(GoldOfCreat.m_GroupOwner.m_GroupMembers.Objects[i]);
         nError := 3;
         if (not GroupObject.m_boGhost) and (GroupObject <> GoldOfCreat) and
            (GroupObject.m_PEnvir = GoldOfCreat.m_PEnvir)  then begin
           PlayList[PlayCount] := GroupObject;
           Inc(PlayCount);
         end;
         nError := 4;
       end;
       nError := 5;
       if PlayCount > 0 then begin
         nCount := m_nGold div (PlayCount + 1);
         nMyCount := m_nGold mod PlayCount;
         nError := 6;
         for i := 0 to PlayCount - 1 do begin
           if GoldOfCreat = PlayList[i] then
             nAddCount := nCount + nMyCount
           else
             nAddCount := nCount;
           nError := 7;
           if PlayList[i].IncGold(nAddCount) then begin
             PlayList[i].GoldChanged;
             if g_boGameLogGold then //004C5E8C
               AddGameDataLog('4' +  #9 +
                     PlayList[i].m_sMapName + #9 +
                     IntToStr(PlayList[i].m_nCurrX) + #9 +
                     IntToStr(PlayList[i].m_nCurrY) + #9 +
                     PlayList[i].m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[莉뚠롸토(歌혤)]');
             //Result := True;
           end else
             Inc(nMyCount, nAddCount);
         end;
         nError := 8;
         nAddCount := nCount + nMyCount;
       end else begin
         nError := 9;
         nAddCount := m_nGold;
       end;
       nError := 10;
       if GoldOfCreat.IncGold(nAddCount) then begin
         if g_boGameLogGold then //004C5E8C
              AddGameDataLog('4' +  #9 +
                     GoldOfCreat.m_sMapName + #9 +
                     IntToStr(GoldOfCreat.m_nCurrX) + #9 +
                     IntToStr(GoldOfCreat.m_nCurrY) + #9 +
                     GoldOfCreat.m_sCharName + #9 +
                     sSTRING_GOLDNAME + #9 +
                     IntToStr(nAddCount) + #9 +
                     '1' + #9 +
                     '0' + #9 + '[莉뚠롸토(歌혤)]');
         GoldOfCreat.GoldChanged;
       end;
       m_nGold := 0;
       nError := 11;
     end else begin
       nError := 12;
       ScatterGold(GoldOfCreat);
     end;
     nError := 13;
     GoldChanged;
   end;
   except
      MainOutMessage (Format(sExceptionMsg3, [nError, m_sCharName]));
   end;
end;

procedure TBaseObject.DropUseItems(BaseObject:TBaseObject; DieFromMob : Boolean); //몹들 드랍
var
  I,nRate:Integer;
  StdItem:TItem;
  DropItemList:TStringList;
  tCode:integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::DropUseItems %d';
begin
  DropItemList:=nil;
  try
    if m_boNoDropUseItem then exit;
    if m_boDropDurg then exit;   //환템 드랍

    if PKLevel > 2 then nRate:=g_Config.nDieRedDropUseItemRate      //아이템 떨군다.
    else nRate:=g_Config.nDieDropUseItemRate;
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if Random(nRate) = 0 then begin
        if (i = U_WEAPON) and (PKLevel < 3) then begin
          if Random(2) = 0 then continue;
        end;
        StdItem:=UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then begin
          if (m_btRaceServer = RC_PLAYOBJECT) then begin
          tCode:=5;
           if InDisableTakeOffList(m_UseItems[I].wIndex) or (not StdItem.boCanDeathDrop) or (m_UseItems[I].btValue[19] > 0) then Continue;
            if DropItemDown(@m_UseItems[I],2,True,BaseObject,Self) then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
              tCode:=6;
                if DropItemList = nil then DropItemList:=TStringList.Create;
                tCode:=7;
                   DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex),TObject(m_UseItems[I].MakeIndex));
              end;
              tCode:=8;
              m_UseItems[I].wIndex:=0;
            end;
          end;
        end;
      end;
    end;
    tCode:=9;
    if DropItemList <> nil then begin
      tCode:=10;
      SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DropItemList),0,0,'');
    end;
    //if DropItemList <> nil then FreeAndNil(DropItemList);
  except
    MainOutMessage(format(sExceptionMsg,[tCode]));
  end;
end;

procedure TBaseObject.Die; //004BBA98
var
  boPK,guildwarkill :Boolean;
  tStr:String;
  tExp:LongWord;
  i:Integer;
  GroupHuman:TPlayObject;
  QuestNPC:TMerchant;
  tCheck:Boolean;
  AttackBaseObject:TBaseObject;
  BaseObject:TBaseObject;
  PlayObject:TPlayObject;
  Castle:TUserCastle;
  lovername: string;
  HeroObject: THeroObject;
  nError:integer;
ResourceString
  sExceptionMsg1 = '[Exception] TBaseObject::Die 1';
  sExceptionMsg2 = '[Exception] TBaseObject::Die 2 :: %d 대상 [$s]';
  sExceptionMsg3 = '[Exception] TBaseObject::Die 3 :: %d 대상 [%s]';
begin
  //004BBABB
  if m_boSuperMan then exit;
  if m_boSupermanItem then exit;
  m_boDeath:=True;
  m_dwDeathTick:=GetTickCount();
  if m_Master <> nil then begin
    m_ExpHitter:=nil;
    m_LastHiter:=nil;
  end;
  m_nIncSpell   :=0;
  m_nIncHealth  :=0;
  m_nIncHealing :=0;
  try
    if (m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter <> nil) then begin    //몹을 죽인 경우.  경험치를 얻는다.(몬스
      if g_Config.boMonSayMsg then MonsterSayMsg(m_LastHiter,s_Die);

      if (m_ExpHitter <> nil) then begin          //경험치를 먹는 사람.. 먼저 때리기 시작한 사람
        if m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT then begin
          if g_FunctionNPC <> nil then
            g_FunctionNPC.GotoLable(TPlayObject(m_ExpHitter),'@OnKillMob('+m_sCharName+')',False);

          tExp:=m_ExpHitter.CalcGetExp(m_Abil.Level,m_dwFightExp);         //몹을죽인자가 사람이다(즉, 나자신)
          if not g_Config.boVentureServer then begin
            HeroObject := THeroObject(TPlayObject(m_ExpHitter).m_MyHero);
             if (HeroObject <> nil) and (not TPlayObject(m_ExpHitter).m_boWaitHeroDate)
              and (TPlayObject(m_ExpHitter).m_PEnvir = TPlayObject(HeroObject).m_PEnvir)
              and (not HeroObject.m_boDeath) and (not HeroObject.m_boGhost) then begin //영웅이 존재하며,
             //  HeroObject.GainExp(tExp);     //영웅 경험치 획
               TPlayObject(m_ExpHitter).GainExp(tExp);    //나 자신이 죽여서 경험치 득
             end else begin
               TPlayObject(m_ExpHitter).GainExp(tExp);
             end;
          end;//004BBBBF


          //맵퀘스트가 있는지
          if m_PEnvir.IsCheapStuff then begin
            if m_ExpHitter.m_GroupOwner <> nil then begin
              for i:= 0 to m_ExpHitter.m_GroupOwner.m_GroupMembers.Count -1 do begin
                GroupHuman:=TPlayObject(m_ExpHitter.m_GroupOwner.m_GroupMembers.Objects[i]);
                if not GroupHuman.m_boDeath and (m_ExpHitter.m_PEnvir = GroupHuman.m_PEnvir) and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (m_ExpHitter = GroupHuman) then begin
                  tCheck:=False;
                end else begin//004BBCB3
                  tCheck:=True;
                end;//004BBCB7
                QuestNPC:=TMerchant(m_PEnvir.GetQuestNPC(GroupHuman,m_sCharName,'',tCheck));
                if QuestNPC <> nil then begin
                  QuestNPC.Click(GroupHuman);
                end;
              end;//004BBD08
            end;//004BBD08
            QuestNPC:=TMerchant(m_PEnvir.GetQuestNPC(m_ExpHitter,m_sCharName,'',False));
            if QuestNPC <> nil then begin
              QuestNPC.Click(TPlayObject(m_ExpHitter));
            end;
          end;
        end else begin;//004BBD5B
          if m_ExpHitter.m_Master <> nil then begin
            if m_ExpHitter.m_btRaceServer = RC_HEROOBJECT then begin //영웅이 몹을 죽였을때
              tExp := m_ExpHitter.m_Master.CalcGetExp(m_Abil.Level, m_dwFightExp);
              if not g_Config.boVentureServer then begin
               // THeroObject(m_ExpHitter).GainExp(tExp);    //영웅 자신이 몹을 죽였을때
                TPlayObject(m_ExpHitter.m_Master).GainExp(tExp);
              end;

              //맵퀘스트가 있는지
              if m_PEnvir.IsCheapStuff then begin
                if TPlayObject(m_ExpHitter.m_Master).m_GroupOwner <> nil then begin
                  for i:= 0 to TPlayObject(m_ExpHitter.m_Master).m_GroupOwner.m_GroupMembers.Count -1 do begin
                    GroupHuman:=TPlayObject(TPlayObject(m_ExpHitter.m_Master).m_GroupOwner.m_GroupMembers.Objects[i]);
                    if not GroupHuman.m_boDeath and (m_ExpHitter.m_PEnvir = GroupHuman.m_PEnvir) and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (abs(m_ExpHitter.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (m_ExpHitter = GroupHuman) then begin
                      tCheck:=False;
                    end else begin//004BBCB3
                      tCheck:=True;
                    end;//004BBCB7
                    QuestNPC:=TMerchant(m_PEnvir.GetQuestNPC(GroupHuman,m_sCharName,'',tCheck));
                    if QuestNPC <> nil then begin
                      QuestNPC.Click(GroupHuman);
                    end;
                   end;//004BBD08
                end;//004BBD08
                QuestNPC:=TMerchant(m_PEnvir.GetQuestNPC(TPlayObject(m_ExpHitter.m_Master),m_sCharName,'',False));
                if QuestNPC <> nil then begin
                  QuestNPC.Click(TPlayObject(m_ExpHitter.m_Master));
                end;
              end;

            end else begin   //if m_ExpHitter.m_btRaceServer = RC_HEROOBJECT then begin //영웅이 몹을 죽였을때
              m_ExpHitter.GainSlaveExp(m_Abil.Level);
              tExp:=m_ExpHitter.m_Master.CalcGetExp(m_Abil.Level,m_dwFightExp);
              if not g_Config.boVentureServer then begin
                TPlayObject(m_ExpHitter.m_Master).GainExp(tExp);
              end;
            end;
          end;
        end;
      end else begin;//004BBDD2
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
          if g_FunctionNPC <> nil then
            g_FunctionNPC.GotoLable(TPlayObject(m_LastHiter),'@OnKillMob('+m_sCharName+')',False);

          tExp:=m_LastHiter.CalcGetExp(m_Abil.Level,m_dwFightExp);
          if not g_Config.boVentureServer then begin
            if TPlayObject(m_LastHiter).m_MyHero <> nil then begin //영웅
              BaseObject := TPlayObject(m_LastHiter).m_MyHero;
             // THeroObject(BaseObject).GainExp(tExp);
              TPlayObject(m_LastHiter).GainExp(tExp);
            end else begin
              TPlayObject(m_LastHiter).GainExp(tExp);
            end;
          end;
        end;//004BBE21
      end;//004BBE21
    end;//004BBE21
    if (g_Config.boMonSayMsg) and (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) then begin
      m_LastHiter.MonsterSayMsg(Self,s_KillHuman);
    end;
    m_Master:=nil;
  except
    on e: Exception do begin
      MainOutMessage (sExceptionMsg1);
      MainOutMessage(E.Message);
    end;
  end;

   if (m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).m_MyHero <> nil) then THeroObject(TPlayObject(Self).m_MyHero).LogOut();      //주인이 죽으면 영웅 로그아웃

   nError:=0;
   try
      nError:=1;
      boPK:=False;
      if (not g_Config.boVentureServer) and (not m_PEnvir.Flag.boFightZone) and (not m_PEnvir.Flag.boFight3Zone)
        and (not m_PEnvir.Flag.boPKZone) and (not m_PEnvir.Flag.VailantZone) then begin
         if (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) and (PKLevel < 2) then begin
//            if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
            if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or (m_LastHiter.m_btRaceServer = RC_NPC) then
               boPK:=True;

            if m_LastHiter.m_Master <> nil then
               if m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT then begin
                  m_LastHiter := m_LastHiter.m_Master;
                  boPK:=True;
               end;
         end;
      end;
      nError:=2;
      if boPK and (m_LastHiter <> nil) then begin
         guildwarkill := FALSE;
         nError:=3;
         if (m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) then begin

            if GetGuildRelation (self, m_LastHiter) = 2 then
               guildwarkill := TRUE;
         end;
         Castle:=g_CastleManager.InCastleWarArea(Self);
         if ((Castle <> nil) and Castle.m_boUnderWar) or (m_boInFreePKArea) then
           guildwarkill := TRUE;


         //=================================================================
         nError:=4;
         if not guildwarkill then begin
           nError:=5;
           if (g_Config.boKillHumanWinLevel or g_Config.boKillHumanWinExp or m_PEnvir.Flag.boPKWINLEVEL or m_PEnvir.Flag.boPKWINEXP) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then begin
             TPlayObject(Self).PKDie(TPlayObject(m_LastHiter));
           end else begin
             nError:=6;
             if not m_LastHiter.IsGoodKilling(self) then begin
               m_LastHiter.IncPkPoint (g_Config.nKillHumanAddPKPoint{100});
               m_LastHiter.SysMsg (format (g_sYouMurderedMsg, [m_sCharName]), c_Red,t_Hint);
               SysMsg(format(g_sYouKilledByMsg,[m_LastHiter.m_sCharName]),c_Red,t_Hint);
               nError:=7;
               /////////////////////////////////////////////////////////
               //연인에게 통보      //연인 스쳐사망
               if TPlayObject(self).fLover <> nil then begin
                 lovername := TPlayObject(self).fLover.GetLoverName;
                 if lovername <> '' then begin
                   PlayObject := UserEngine.GetPlayObject(lovername);
                   if PlayObject <> nil then begin
                     PlayObject.SysMsg(Format(g_sYouLoverKilledByMsg, [m_LastHiter.m_sCharName]),c_Red,t_Hint);
                   end;
                 end;
               end;
               /////////////////////////////////////////////////////////
               nError:=8;
               m_LastHiter.AddBodyLuck (-g_Config.nKillHumanDecLuckPoint{500});
               if PkLevel < 1 then
                 if Random(5) = 0 then
                    m_LastHiter.MakeWeaponUnlock;
               if g_FunctionNPC <> nil then begin
                 g_FunctionNPC.GotoLable(TPlayObject(m_LastHiter),'@OnMurder',False);
                 g_FunctionNPC.GotoLable(TPlayObject(Self),'@Murdered',False);
               end;
             end else begin
               m_LastHiter.SysMsg (g_sYouProtectedByLawOfDefense, c_Green,t_Hint);
               SysMsg(format(g_sYouProtectedByLawOfDefenseKilld,[m_LastHiter.m_sCharName]),c_Green,t_Hint);
             end;
             nError:=9;
             if (not g_Config.boPKServer) then begin
               m_LastHiter.IncKillPoint(1); //킬/데스
               TPlayObject(Self).IncDeathPoint(1); //킬/데스
             end;
           end;
           nError:=10;
           if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then begin
             if m_LastHiter.m_dwPKDieLostExp > 0 then begin
               if m_Abil.Exp >= m_LastHiter.m_dwPKDieLostExp then begin
                 Dec(m_Abil.Exp,m_LastHiter.m_dwPKDieLostExp);
               end else m_Abil.Exp:=0;
             end;
             nError:=11;
             if m_LastHiter.m_nPKDieLostLevel > 0 then begin
               if m_Abil.Level >= m_LastHiter.m_nPKDieLostLevel then begin
                 Dec(m_Abil.Level,m_LastHiter.m_nPKDieLostLevel);
               end else m_Abil.Level:=0;
             end;
           end;
           nError:=12;
         end else begin
           nError:=13;
           if (g_Config.boPKServer) then begin
             m_LastHiter.IncKillPoint(1); //킬/데스
             TPlayObject(Self).IncDeathPoint(1); //킬/데스
           end;
         end;
         nError:=14;
         //=================================================================
      end else begin
         //일반인이 PK범을 죽인 경우
         nError:=15;
         if PkLevel >= 2 then begin
            //---------------------------
            m_LastHiter.IncKillPoint(1); //킬/데스
            TPlayObject(Self).IncDeathPoint(1); //킬/데스
            //---------------------------
         end;

         if (m_PEnvir.Flag.boPKZONE) and (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then begin //사람만 킬데스 피케이존
           m_LastHiter.IncKillPoint(1); //킬/데스
           TPlayObject(Self).IncDeathPoint(1); //킬/데스
         end;

      end;
   except
      MainOutMessage(Format(sExceptionMsg2,[nError, m_sCharName]));
   end;
   nError:=0;
   try
      if (not m_PEnvir.Flag.boFightZone) and  //004BC0C1
         (not m_PEnvir.Flag.boFight3Zone) and
         (not m_PEnvir.Flag.VailantZone) and    //용맹의 전장 아이템 떨구지 않음
         (not m_boAnimal) then begin
         nError:=1;
         // 사람과 몬스터 구별(2004/06/22)
         if m_btRaceServer <> RC_PLAYOBJECT then begin
           nError:=2;
           AttackBaseObject := m_ExpHitter;
           nError:=3;
           if m_ExpHitter <> nil then
             if m_ExpHitter.m_Master <> nil then
               AttackBaseObject := m_ExpHitter.m_Master;
               nError:=4;
         end else begin
           nError:=5;
           AttackBaseObject := m_LastHiter;
           nError:=6;
           if m_LastHiter <> nil then
             if m_LastHiter.m_Master <> nil then
               AttackBaseObject := m_LastHiter.m_Master;
         end;
         {if (m_ExpHitter <> nil) then AttackBaseObject := m_ExpHitter
         else AttackBaseObject := m_LastHiter;
         nError:=2;
         if (AttackBaseObject <> nil) then begin
           nError:=4;
           if (AttackBaseObject.m_Master <> nil) then begin
             nError:=5;
             AttackBaseObject:=m_ExpHitter.m_Master;
             nError:=6;
           end;
         end;  }
         nError:=7;
         if m_btRaceServer <> RC_PLAYOBJECT then begin  //사람이 아니면  (몹들 드랍 부분)
           nError:=8;
           if not (m_btRaceServer in [RC_CLONE, RC_DARKCLONE, RC_BONZECLONE]) then begin //술사 분신 열화신 분신 아니면
            DropUseItems(AttackBaseObject,false);
            nError:=9;
            if (m_Master = nil) and (not m_boNoItem) and (not m_PEnvir.Flag.boNODROPITEM) then
              ScatterBagItems(AttackBaseObject);
              nError:=10;
            if (m_btRaceServer >= RC_ANIMAL) and (m_Master = nil) and (not m_boNoItem) and (not m_PEnvir.Flag.boNODROPITEM) then begin
              nError:=11;
              ScatterGolds(AttackBaseObject);
            end;
           end;
         end else begin //004BC1B0    //사람 드랍 부분)
           nError:=12;
           if (not m_boNoItem) and (not m_PEnvir.Flag.boNODROPITEM) and (not m_PEnvir.Flag.boSAFE) and (not m_PEnvir.Flag.boFightZone) and (not InStartZone) then begin
             if AttackBaseObject <> nil then begin        //사용중인 아이템 떨굴 것인가
               if (g_Config.boKillByHumanDropUseItem and (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT)) then  //사람한테 죽은경우
                  DropUseItems(nil,True);
               if (g_Config.boKillByMonstDropUseItem and (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then   //몹한테 죽은경우
                  DropUseItems(nil,True);
             end else begin
               DropUseItems(nil,True);
             end;        //가방 아이템 떨굴 것인가
             nError:=13;
             if g_Config.boDieScatterBag then ScatterBagItems(nil);
             if g_Config.boDieDropGold then ScatterGolds(nil);
           end;
           AddBodyLuck( -(50 - (50 - m_Abil.Level * 5)));
         end; //004BC211
      end;
      nError:=14;
      if m_PEnvir.Flag.VailantZone then begin     //용맹의전장 안에서 포인트 관련


      end;
      nError:=15;
      if m_PEnvir.Flag.boFight3Zone then begin   //문파 대전 중
         Inc (m_nFightZoneDieCount);       //3번 죽어도 되는 대련인 경우
         if m_MyGuild <> nil then begin
            TGuild(m_MyGuild).TeamFightWhoDead (m_sCharName);   //문파 대전 어서 올리는 포인트
         end;
         nError:=16;
         if (m_LastHiter <> nil) then begin        //점수 계산
            if (m_LastHiter.m_MyGuild <> nil) and (m_MyGuild <> nil) then begin
               TGuild(m_LastHiter.m_MyGuild).TeamFightWhoWinPoint (m_LastHiter.m_sCharName, 100);  //문파 대전 matchpoint 증가, 개인성적 기록
               tStr:=TGuild(m_LastHiter.m_MyGuild).sGuildName + ':' +
                      IntToStr(TGuild(m_LastHiter.m_MyGuild).nContestPoint) + '  ' +
                      TGuild(m_MyGuild).sGuildName + ':' +
                      IntToStr(TGuild(m_MyGuild).nContestPoint);
               UserEngine.CryCry (RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,g_Config.btCryMsgFColor,g_Config.btCryMsgBColor, '- ' + tStr);
            end;
         end;
      end;
      nError:=17;
      if m_btRaceServer = RC_PLAYOBJECT then begin
         if m_LastHiter <> nil then begin
            if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then tStr := m_LastHiter.m_sCharName
            else tStr := '#' + m_LastHiter.m_sCharName;
         end else tStr := '####';
         //004BC523
         AddGameDataLog('19' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     'FZ-' + BoolToIntStr(m_PEnvir.Flag.boFightZone) +
                     '_F3-' + BoolToIntStr(m_PEnvir.Flag.boFight3Zone) + #9 +
                     '0' + #9 +
                     '1' + #9 +
                     tStr + #9 + '[묑샌]');
      end;
      nError:=18;
      {if (m_Master = nil) and (not m_boDelFormMaped) then begin
        m_PEnvir.DelObjectCount(Self);
        m_boDelFormMaped:=True;
      end;  }
      nError:=19;
      SendRefMsg (RM_DEATH, m_btDirection, m_nCurrX, m_nCurrY, 1, '');
   except
      MainOutMessage (Format(sExceptionMsg3, [nError, m_sCharName]));
   end;
end;

function TPlayObject.AddCheckMsg(sMsg: string; tClass: TCheckMsgClass; AddPointer: TPlayObject; AddTime: LongWord): pTCheckMsg;
var
  CheckMsg: pTCheckMsg;
  i: Integer;
begin
  Result := nil;
  if AddPointer.m_nCheckMsgArr[tClass] >= 5 then
    exit;
  if (m_CheckMsgList.Count > 0) then begin
    for i := 0 to m_CheckMsgList.Count - 1 do begin
      CheckMsg := m_CheckMsgList.Items[i];
      if (CheckMsg <> nil) and (CheckMsg.AllPurpose = AddPointer) and (CheckMsg.tClass = tClass) then begin
        exit;
      end;
    end;
  end;
  New(CheckMsg);
  Inc(AddPointer.m_nCheckMsgArr[tClass]);
  CheckMsg.tClass := tClass;
  CheckMsg.AllPurpose := AddPointer;
  CheckMsg.AddTime := GetTickCount + AddTime * 1000;
  m_CheckMsgList.Add(CheckMsg);
  SendDefMsg(Self, SM_CHECKMSG, Integer(CheckMsg), AddTime - 2, 0, Integer(tClass), sMsg);
  Result := CheckMsg;
end;

procedure TPlayObject.PKDie(PlayObject:TPlayObject);
var
  nWinLevel,nLostLevel,nWinExp,nLostExp:Integer;
  boWinLEvel,boLostLevel,boWinExp,boLostExp:Boolean;
begin
  nWinLevel:=g_Config.nKillHumanWinLevel;
  nLostLevel:=g_Config.nKilledLostLevel;
  nWinExp:=g_Config.nKillHumanWinExp;
  nLostExp:=g_Config.nKillHumanLostExp;

  boWinLEvel:=g_Config.boKillHumanWinLevel;
  boLostLevel:=g_Config.boKilledLostLevel;
  boWinExp:=g_Config.boKillHumanWinExp;
  boLostExp:=g_Config.boKilledLostExp;
  
  if m_PEnvir.Flag.boPKWINLEVEL then begin
    boWinLEvel:=True;
    nWinLevel:=m_PEnvir.Flag.nPKWINLEVEL;
  end;
  if m_PEnvir.Flag.boPKLOSTLEVEL then begin
    boLostLevel:=True;
    nLostLevel:=m_PEnvir.Flag.nPKLOSTLEVEL;
  end;
  if m_PEnvir.Flag.boPKWINEXP then begin
    boWinExp:=True;
    nWinExp:=m_PEnvir.Flag.nPKWINEXP;
  end;
  if m_PEnvir.Flag.boPKLOSTEXP then begin
    boLostExp:=True;
    nLostExp:=m_PEnvir.Flag.nPKLOSTEXP;
  end;
  
  if PlayObject.m_Abil.Level - m_Abil.Level > g_Config.nHumanLevelDiffer then begin
    if not PlayObject.IsGoodKilling(self) then begin
      PlayObject.IncPkPoint (g_Config.nKillHumanAddPKPoint{100});
      PlayObject.SysMsg (format(g_sYouMurderedMsg,[m_sCharName]), c_Red,t_Hint);
      SysMsg(format(g_sYouKilledByMsg,[m_LastHiter.m_sCharName]),c_Red,t_Hint);


      PlayObject.AddBodyLuck (-g_Config.nKillHumanDecLuckPoint{500});
      if PkLevel < 1 then
        if Random(5) = 0 then
          PlayObject.MakeWeaponUnlock;

      if g_FunctionNPC <> nil then begin
        g_FunctionNPC.GotoLable(PlayObject,'@OnMurder',False);
        g_FunctionNPC.GotoLable(Self,'@Murdered',False);
      end;
    end else begin
      PlayObject.SysMsg(g_sYouProtectedByLawOfDefense, c_Green,t_Hint);
    end;
    exit;
  end;
  if boWinLEvel then begin
    //Inc(PlayObject.m_Abil.Level,nWinLevel);
    if PlayObject.m_Abil.Level + nWinLevel <= MAXUPLEVEL then begin
      Inc(PlayObject.m_Abil.Level,nWinLevel);
    end else begin
      PlayObject.m_Abil.Level:=MAXUPLEVEL;
    end;
    PlayObject.HasLevelUp(PlayObject.m_Abil.Level - nWinLevel);

    if boLostLevel then begin
      if PKLevel >= 2 then begin
        if m_Abil.Level >= nLostLevel * 2 then
          Dec(m_Abil.Level,nLostLevel * 2);
      end else begin
      if m_Abil.Level >= nLostLevel then
        Dec(m_Abil.Level,nLostLevel);
      end;
    end;

  end;

  if boWinExp then begin
    PlayObject.WinExp(nWinExp);
    if boLostExp then begin
      if m_Abil.Exp >= LongWord(nLostExp) then begin
        if m_Abil.Exp >= LongWord(nLostExp) then begin
          Dec(m_Abil.Exp,LongWord(nLostExp));
        end else begin
          m_Abil.Exp:=0;
        end;
      end else begin
        if m_Abil.Level >= 1 then begin
          Dec(m_Abil.Level);
          Inc(m_Abil.Exp,GetLevelExp(m_Abil.Level));
          if m_Abil.Exp >= LongWord(nLostExp) then begin
            Dec(m_Abil.Exp,LongWord(nLostExp));
          end else begin
            m_Abil.Exp:=0;
          end;
        end else begin
          m_Abil.Level:=0;
          m_Abil.Exp:=0;
        end;
        //HasLevelUp(m_Abil.Level + 1);
      end;
    end;
  end;
end;
procedure TBaseObject.Alive;
begin
  //체력이 0이면 10 보충
  if m_Abil.HP = 0 then
    m_Abil.HP := 10;

  m_boDeath := False;
  SendRefMsg(RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_RELIVE, '');
  SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX,m_nCurrY, 0, '');

  m_boAliveMsg := False;
  //능력치 재전송
  //   RecalcAbilitys;
  SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
end;
procedure TBaseObject.ReAlive; //004BC710
begin
  m_boDeath:=False;
  SendRefMsg(RM_ALIVE,m_btDirection,m_nCurrX,m_nCurrY,0,'');
  SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
end;

procedure TBaseObject.ReAliveMsg; //004BC710 소생술
begin
  SendRefMsg(RM_ALIVE,m_btDirection,m_nCurrX,m_nCurrY,0,'');
  SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
end;

procedure TBaseObject.SetLastHiter(BaseObject: TBaseObject); //004BC74C
var
  nDir: byte;
begin
  m_LastHiter:=BaseObject;
  m_LastHiterTick:=GetTickCount();
  if m_ExpHitter = nil then begin
    m_ExpHitter:=BaseObject;
    m_ExpHitterTick:=GetTickCount();
  end else begin
    if m_ExpHitter = BaseObject then
      m_ExpHitterTick:=GetTickCount();
  end;

  if m_btRaceServer = RC_PLAYOBJECT then begin
    if (m_boChunMuSkill = 1) and (m_LastHiter <> nil) and (m_wStatusTimeArr[POISON_STONE] = 0) and (m_wStatusTimeArr[POISON_STUN] = 0)  then begin      //천무 반격
      if (abs(m_nCurrX - m_LastHiter.m_nCurrX) <= 1) and (abs(m_nCurrY - m_LastHiter.m_nCurrY) <= 1) then begin
        nDir := GetNextDirection (m_nCurrX, m_nCurrY, m_LastHiter.m_nCurrX, m_LastHiter.m_nCurrY);
        //if Random(10) <= (m_MagicChunMuSkill.btLevel + 1) then begin
          if TPlayObject(Self).GetMagicRun(SKILL_FIRESWORD) then begin
             SendMsg(Self, RM_TOSENDMSG, 0, 3, nDir, 0, '');
          end else begin
             SendMsg(Self, RM_TOSENDMSG, 0, 4, nDir, 0, '');
          end;
          m_dwStatusArrTimeOutTick[11] := 0;
         // SendMsg (Self,RM_BUFF, 54, 0, 39, 0, '');  //천무버프 종료
       // end;
      end;
    end;
  end;
end;

procedure TBaseObject.SetPKFlag(BaseObject: TBaseObject); //004BC7BC
begin
  if (PKLevel < 2) and
     (BaseObject.PKLevel < 2) and
     (not m_PEnvir.Flag.boFightZone) and
     (not m_PEnvir.Flag.boFight3Zone) and
     (not m_PEnvir.Flag.boPKZONE) and
     (not m_PEnvir.Flag.VailantZone) and
     (not m_boPKFlag) then begin

    BaseObject.m_dwPKTick:=GetTickCount();
    if not BaseObject.m_boPKFlag then begin
      if not BaseObject.m_PEnvir.Flag.boDEATHMATCH then begin     //데스매치
        BaseObject.m_boPKFlag:=True;
        BaseObject.RefNameColor();
      end;
    end;
  end;
end;


function TBaseObject.IsGoodKilling(cert: TBaseObject): Boolean; //004BC8D8
begin
  Result:=False;
  if cert.m_PEnvir.Flag.boDEATHMATCH then Result:=True;     //데스매치
  if cert.m_PEnvir.Flag.boPKZONE then Result:=True;
  if cert.m_boPKFlag then Result:=True;
end;

//004C880C 0FFFF6
function TBaseObject.IsProtectTarget(BaseObject:TBaseObject): boolean;
begin
  Result:=True;
  if BaseObject = nil then exit;
  if (InSafeZone) or (BaseObject.InSafeZone) then Result:=False;
  if not BaseObject.m_boInFreePKArea then begin
    //劤훙괏빱
    if g_Config.boPKLevelProtect then begin
      if (m_Abil.Level > g_Config.nPKProtectLevel) then begin //흔벎댕黨寧땍된섬
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level <= g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
          //굳묑샌돨훙膠鬼寧땍된섬청唐븐츰，橙꼇옵鹿묑샌。
          Result:=False;
          exit;
        end;
      end;
      if (m_Abil.Level <= g_Config.nPKProtectLevel) then begin //흔벎鬼黨寧땍된섬
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level > g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
          Result:=False;
          exit;
        end;
      end;
    end;

    if (PKLevel >= 2) and (m_Abil.Level > g_Config.nRedPKProtectLevel) then begin
      if (BaseObject.m_Abil.Level <= g_Config.nRedPKProtectLevel) and (BaseObject.PKLevel < 2) then begin
        Result:=False;
        exit;
      end;
    end;

    if (m_Abil.Level <= g_Config.nRedPKProtectLevel) and (PKLevel < 2) then begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > g_Config.nRedPKProtectLevel) then begin
        Result:=False;
        exit;
      end;
    end;

    if (GetTickCount - m_dwMapMoveTick < 3000) or (GetTickCount - BaseObject.m_dwMapMoveTick < 3000) then
      Result:=False;
  end;

  if g_Config.boOpenStoreGMMode and BaseObject.m_boStore then Result := False;   //개인상점중 공격 당하나 설정

end;
function TBaseObject.IsAttackTarget(BaseObject:TBaseObject): boolean; //004C89D0 0FFFF5
  function sub_4C88E4():Boolean;
  begin
    Result:=True;
  end;
var
  Castle:TUserCastle;
begin
  Result:=False;
  Castle:=g_CastleManager.InCastleWarArea(Self);      //공성지역
  if (BaseObject = nil) or (BaseObject = Self) or (BaseObject.m_btRaceServer = RC_PET) then exit;
  if (BaseObject.m_btRaceServer = 250) then begin  //점령깃발
    if ((Castle <> nil) and Castle.m_boUnderWar) then begin
      if Castle.IsDefenseWarGuild(TGuild(m_MyGuild)) then Exit; //사북문파 및 동맹문파는 점령깃발 공격 못함
    end;
    if m_MyGuild = nil then Exit;
  end;
  if (m_btRaceServer >= RC_ANIMAL) then begin  //사람이 아닌 몹의대한공식
    if m_Master <> nil then begin       //몹자신이 주인이있다.
      if (m_Master.m_LastHiter = BaseObject) or
         (m_Master.m_ExpHitter = BaseObject) or
         (m_Master.m_TargetCret = BaseObject) then
         Result:=True;

      if BaseObject.m_TargetCret <> nil then begin      //대상이 타겟이 있다면.
        if (BaseObject.m_TargetCret = m_Master) or           //대상의 타겟이 내 주인이거나
           (BaseObject.m_TargetCret.m_Master = m_Master) and   //대상의 타겟의 주인이  내 주인인데
           (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then    //사람이 아니면,,
          Result:=True;
      end; //004C8AB3

      if (BaseObject.m_TargetCret = Self) and (BaseObject.m_btRaceServer >= RC_ANIMAL) then
        Result:=True;
      //004C8AD1

      if BaseObject.m_Master <> nil then begin
        if (BaseObject.m_Master = m_Master.m_LastHiter) or (BaseObject.m_Master = m_Master.m_TargetCret) then
          Result:=True;
      end;//004C8B15

      if BaseObject.m_Master = m_Master then Result:=False;     //타겟의 주인이 내주인이면 공격안됨
      if BaseObject.m_boPobakSeize then Result:=False;       //포박상태면 무시/
      if BaseObject.m_boHolySeize then Result:=False;        //결계에 갇혀있어도 무시한다.
      if m_Master.m_boSlaveRelax then begin     //내주인이 휴식명령을 내렸다면,,
        if (m_btRaceServer <> RC_DARKCLONE) or (m_btRaceServer <> RC_BONZECLONE) then    //자객여화신, 승려 꼬봉 제외 멈추게한다.
        Result:=False;
      end;

      if m_btRaceServer = RC_HEROOBJECT then begin
        if THeroObject(Self).m_boTarget and (m_TargetCret = BaseObject) then Result := True;
        if THeroObject(Self).m_boSpellTarget and (m_TargetCret = BaseObject) then Result := True;
      end;

      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin              //타겟이 사람이다.
        if BaseObject.InSafeZone then Result:=False;
        if g_Config.boOpenStoreGMMode and BaseObject.m_boStore then begin     //개인상점중 공격 당하나 설정
          Result := False;
        end;
      end;
      BreakCrazyMode();
      if m_btRaceServer = RC_HEROOBJECT then begin
        if Result and m_Master.IsAttackTarget(BaseObject) then begin
          Result := True;
          if (InSafeZone or BaseObject.InSafeZone) and ((BaseObject.m_Master <> nil) or (BaseObject.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT])) then Result:=False;
        end else begin
          Result := False;
        end;
      end;
    end else begin  //몹이 주인이 없다면,,
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then Result:=True;       //타겟이 사람이면 ok
      if (m_btRaceServer > RC_PEACENPC) and (m_btRaceServer < RC_ANIMAL) then  //궁수경비나 경비병이면 무조건 ok
        Result:=True;
      if BaseObject.m_Master <> nil then Result:=True;    //타겟이 주인이 없다면 ok
    end; //004C8BB5
    if m_boCrazyMode and ((BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer > RC_PEACENPC)) then Result:=True;
    if m_boHallucMode then
      if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (BaseObject.m_Master = nil) and (BaseObject.m_btRaceServer <> RC_NPC) then
          Result:=True //Hallucination
      else
          Result:=False;
    if m_boNastyMode and ((BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC)) then Result:=True;
  end else begin //004C8BCE
    if (m_btRaceServer = RC_PLAYOBJECT) then begin    //나자신 즉 사람이 공격할때 상대방을 맞게 할건지?
      case m_btAttatckMode of    //
        HAM_ALL: begin
          if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
            Result:=True;
          if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (g_Config.boNeutralityAttack) and (not m_PEnvir.Flag.boALLATTMAP) then begin
            if ((BaseObject.m_MyGuild <> nil) and (TGuild(BaseObject.m_MyGuild).nGuildMode = 0))   //타겟이 중립문파이면 공격 x
             or ((m_MyGuild <> nil) and (TGuild(m_MyGuild).nGuildMode = 0)) then    //나역시 중립문파일경우 공격 x
              Result:=False;
          end;
          if g_Config.boNonPKServer then
            Result:=sub_4C88E4();
        end;
        HAM_PEACE: begin
          if (BaseObject.m_btRaceServer >= RC_ANIMAL) and (BaseObject.m_btRaceServer <> RC_HEROOBJECT) then
            Result:=True;
        end;
        HAM_GROUP: begin
          if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
            Result:=True;
          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
            if IsGroupMember (BaseObject) then
              Result:=False;
            if (g_Config.boNeutralityAttack) and (not m_PEnvir.Flag.boALLATTMAP) then begin
              if ((BaseObject.m_MyGuild <> nil) and (TGuild(BaseObject.m_MyGuild).nGuildMode = 0))   //타겟이 중립문파이면 공격 x
              or ((m_MyGuild <> nil) and (TGuild(m_MyGuild).nGuildMode = 0)) then    //나역시 중립문파일경우 공격 x
               Result:=False;
            end;
          end;
          if g_Config.boNonPKServer then
            Result:=sub_4C88E4();
        end;
        HAM_GUILD: begin
          if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
            Result:=True;
          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
            if m_MyGuild <> nil then begin
              if TGuild(m_MyGuild).IsMember(BaseObject.m_sCharName) then
                Result:=False;
              if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then begin      //문파전,공성전 지역에 있음
                if TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild)) then
                  Result:=False;
              end;
            end;
            if (g_Config.boNeutralityAttack) and (not m_PEnvir.Flag.boALLATTMAP) then begin
              if ((BaseObject.m_MyGuild <> nil) and (TGuild(BaseObject.m_MyGuild).nGuildMode = 0))   //타겟이 중립문파이면 공격 x
              or ((m_MyGuild <> nil) and (TGuild(m_MyGuild).nGuildMode = 0)) then    //나역시 중립문파일경우 공격 x
               Result:=False;
            end;
          end;
          if g_Config.boNonPKServer then
            Result:=sub_4C88E4();
        end;
        HAM_ENEMY: begin       //적대 문파  (공격하냐 마냐)  (몹,적대만 공격)
          if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then     //몹들 공격
            Result:=True;
          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin  //사람일때
            if GetGuildRelation(Self, BaseObject) <> 2 then begin   //적이 아닐경우
             Result:=False;
            end;
            if (g_Config.boNeutralityAttack) and (not m_PEnvir.Flag.boALLATTMAP) then begin
              if ((BaseObject.m_MyGuild <> nil) and (TGuild(BaseObject.m_MyGuild).nGuildMode = 0))   //타겟이 중립문파이면 공격 x
              or ((m_MyGuild <> nil) and (TGuild(m_MyGuild).nGuildMode = 0)) then    //나역시 중립문파일경우 공격 x
               Result:=False;
            end;
          end;
          if g_Config.boNonPKServer then
            Result:=sub_4C88E4();
        end;
        HAM_PKATTACK: begin
          if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer > RC_PEACENPC) then
            Result:=True;
          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
            if PKLevel >= 2 then begin
              if BaseObject.PKLevel < 2 then
                Result:=True
              else Result:=False;
          end else begin
            if BaseObject.PKLevel >= 2 then
              Result:=True
            else Result:=False;
          end;
          if g_Config.boNonPKServer then
            Result:=sub_4C88E4();
        end;
      end;
    end else Result:= True;
  end; //004C8DF0
  if BaseObject.m_boAdminMode or BaseObject.m_boStoneMode or (BaseObject.m_btRaceServer = RC_PET) or BaseObject.m_boPenetrateMode or BaseObject.m_boYeongMu then
    Result:=False;
end;


function TBaseObject.IsProperTarget(BaseObject:TBaseObject):Boolean; //004C8E30 0FFFF4
begin
  Result:=IsAttackTarget(BaseObject);
  if Result then begin
    if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
      Result:=IsProtectTarget(BaseObject); //보호받는 레벨?
    end;
  end;
  if (BaseObject <> nil) and    //타겟이 있다.
     (m_btRaceServer in [RC_PLAYOBJECT]) and   //내가 사람이다.
     (BaseObject.m_Master <> nil) and     //타겟이 주인이 있다.
     (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then begin   //타겟이 사람이 아니다.
    if BaseObject.m_Master = Self then begin   //타겟의 주인이 나다.
      if (m_btAttatckMode <> HAM_ALL) or (BaseObject = TPlayObject(Self).m_MyHero) then Result := False;    //영웅은 주인이 공격을 못한다.
    end else begin
      Result:=IsAttackTarget(BaseObject.m_Master);
      if InSafeZone or BaseObject.InSafeZone then Result:=False;
    end;
  end;
end;

procedure TBaseObject.WeightChanged; //004C49BC
begin
  m_WAbil.Weight:=RecalcBagWeight();
  SendUpdateMsg(Self,RM_WEIGHTCHANGED,0,0,0,0,'');
end;


function TBaseObject.InStartZone: Boolean; //안전지대
var
  I: Integer;
  StartPoint:pTStartPoint;
begin
  Result:=FALSE;
  g_StartPoint.Lock;
  try
    for I := 0 to g_StartPoint.Count - 1 do begin       //안전 설정
      StartPoint:=g_StartPoint.Items[I];
      if StartPoint.Envir = m_PEnvir then begin
        if (abs(m_nCurrX - StartPoint.nX) <= StartPoint.nSize) and (abs(m_nCurrY - StartPoint.nY) <= StartPoint.nSize) then begin
          Result:=True;
          break;
        end;
      end;
    end;
  finally
    g_StartPoint.UnLock;
  end;
end;

function TBaseObject.InSafeZone: Boolean; //004BEE20
var
  I: Integer;
  StartPoint:pTStartPoint;
begin
  Result:=m_PEnvir.Flag.boSAFE;
  if Result then exit;
  if (m_PEnvir.sMapName <> g_Config.sRedHomeMap) or
     (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
     (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
    Result:=False;
  end else begin //004BEE98
    Result:=True;
  end;

  g_StartPoint.Lock;
  try
    for I := 0 to g_StartPoint.Count - 1 do begin       //안전 설정
      StartPoint:=g_StartPoint.Items[I];
      if StartPoint.Envir = m_PEnvir then begin
        if (abs(m_nCurrX - StartPoint.nX) <= StartPoint.nSize) and (abs(m_nCurrY - StartPoint.nY) <= StartPoint.nSize) then begin
          Result:=True;
          break;
        end;
      end;
    end;
  finally
    g_StartPoint.UnLock;
  end;
end;

function TBaseObject.InSafeZone(Envir: TEnvirnoment; nX,
  nY: Integer): Boolean;
var
  I: Integer;
  StartPoint:pTStartPoint;
begin
  Result:=Envir.Flag.boSAFE;
  if Result then exit;
  if (Envir.sMapName <> g_Config.sRedHomeMap) or
     (abs(nX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
     (abs(nY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then begin
    Result:=False;
  end else begin //004BEE98
    Result:=True;
  end;
  if Result then exit;

  try
    g_StartPoint.Lock;
    for I := 0 to g_StartPoint.Count - 1 do begin //안전 설정
      StartPoint:=g_StartPoint.Items[I];
      if StartPoint.Envir = m_PEnvir then begin
        if (abs(nX - StartPoint.nX) <= StartPoint.nSize) and (abs(nY - StartPoint.nY) <= StartPoint.nSize) then begin
          Result:=True;
          break;
        end;
      end;
    end;
  finally
    g_StartPoint.UnLock;
  end;
end;

//004BDBBC
procedure TBaseObject.OpenHolySeizeMode(dwInterval:LongWord);
begin
  m_boHolySeize:=True;
  m_dwHolySeizeTick:=GetTickCount();
  m_dwHolySeizeInterval:=dwInterval;
  RefNameColor();
end;

procedure TBaseObject.OpenPobakSeizeMode(dwInterval:LongWord);   //포박술
begin
  m_boPobakSeize:=True;
  m_dwPobakSeizeTick:=GetTickCount();
  m_dwPobakSeizeInterval:=dwInterval;
end;

procedure TBaseObject.BreakHolySeizeMode;
begin
  m_boHolySeize:=False;
  RefNameColor();
end;

procedure TBaseObject.BreakPobakSeizeMode;
begin
  m_boPobakSeize:=False;
end;

procedure TBaseObject.OpenCrazyMode(nTime:Integer); //004BDC14
begin
  m_boCrazyMode:=True;
  m_dwCrazyModeTick:=GetTickCount();
  m_dwCrazyModeInterval:=nTime * 1000;
  RefNameColor();
end;

procedure TBaseObject.BreakCrazyMode;  //004BDC54
begin
  if m_boCrazyMode then begin
    m_boCrazyMode:=False;
    RefNameColor();
  end;
end;

procedure TBaseObject.OpenHallucMode(nTime:Integer); //미혼술
begin
  m_boHallucMode:=True;
  m_dwHallucModeInterval:= GetTickCount();
  m_dwHallucModeTick:= nTime * 1000;
  RefNameColor();
end;

procedure TBaseObject.BreakHallucMode; //미혼술
begin
  if m_boHallucMode then begin
    m_boHallucMode:=False;
    RefNameColor();
  end;
end;

procedure TBaseObject.LeaveGroup; //004C3B70
ResourceString
  sExitGropMsg = '-%s藁놔죄鬼莉。';
begin
  SendGroupText(format(sExitGropMsg,[m_sCharName]));
  SendDefMsg(Self, SM_GROUPCANCEL, 0, 0, 0, 0, '');
  if m_btRaceServer = RC_PLAYOBJECT then begin
    TPlayObject(Self).SendGroupMsg(TPlayObject(Self), SM_GROUPDELMEM_OK, Integer(Self), 0, 0, 0, m_sCharName);
    m_GroupOwner := nil;
  end;
  m_GroupOwner := nil;
end;

function TPlayObject.CancelGroup: Boolean;//004C397C
ResourceString
  sCanceGrop = '-썩⊙豈§窈';
begin
  Result:=True;
  if m_GroupMembers.Count <= 1 then begin
    SendGroupText(sCanceGrop);
    m_GroupMembers.Clear;
    m_GroupOwner:=nil;
    RecalcGroupAbilitys;
    Result:=False;
  end;    
end;

procedure TPlayObject.SendGroupMembers(BaseObject: TPlayObject); //004DCBA4
var
  I: Integer;
  PlayObject:TPlayObject;
  sSendMsg:String;
  ClientGroup: TClientGroup;
begin
  sSendMsg:='';
  for I := 0 to m_GroupMembers.Count - 1 do begin
    PlayObject:=TPlayObject(m_GroupMembers.Objects[i]);
    if PlayObject <> nil then begin
      ClientGroup.UserID := Integer(PlayObject);
      ClientGroup.UserName := PlayObject.m_sCharName;
      ClientGroup.Level := PlayObject.m_Abil.Level;
      ClientGroup.HP := PlayObject.m_WAbil.HP;
      ClientGroup.MP := PlayObject.m_WAbil.MP;
      ClientGroup.MaxHP := PlayObject.m_WAbil.MaxHP;
      ClientGroup.MaxMP := PlayObject.m_WAbil.MaxMP;
      ClientGroup.btJob := PlayObject.m_btJob;
      ClientGroup.btSex := PlayObject.m_btGender;
      sSENDMSG := sSENDMSG + EncodeBuffer(@ClientGroup, SizeOf(ClientGroup)) + '/';
    end;
  end;
  if BaseObject = nil then begin
    for i := 0 to m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
      if PlayObject <> nil then
        PlayObject.SendDefMessage(SM_GROUPMEMBERS, Integer(m_GroupClass), integer(m_boCheckHero), 0, 0, sSENDMSG);
        PlayObject.RecalcGroupAbilitys;
    end;
  end
  else begin
    BaseObject.SendDefMessage(SM_GROUPMEMBERS, Integer(m_GroupClass), integer(m_boCheckHero), 0, 0, sSENDMSG);
    BaseObject.RecalcGroupAbilitys;
  end;
end;

function TBaseObject.GetMagicInfo(nMagicID: Integer): pTUserMagic; //004CBC7C
var
  I: Integer;
  UserMagic:pTUserMagic;
begin
  Result:=nil;
  for I := 0 to m_MagicList.Count - 1 do begin
    UserMagic:=m_MagicList.Items[i];
    if UserMagic.MagicInfo.wMagicId = nMagicID then begin
      Result:=UserMagic;
      break;
    end;
  end;
end;


//nType 종류  1 부적 2 독가루 3 소부 4독가루(회)
function TPlayObject.CheckAmulet(nCount:Integer;nType:Integer;var Idx:Integer):Boolean;
var
  AmuletStdItem:TItem;
begin
  Result:=False;
  Idx:=0;
  if m_UseItems[U_ARMRINGL].wIndex > 0 then begin       //팔찌자리
    AmuletStdItem:=UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
    if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 25) then begin
      case nType of
        1: begin       //부적
          if (AmuletStdItem.Shape = 5) and (ROUND(m_UseItems[U_ARMRINGL].Dura / 10) >= nCount) then begin
              Idx:=U_ARMRINGL;
              Result:=True;
              exit;
          end;
        end;
        2: begin    //독가루
          if (AmuletStdItem.Shape <= 2) and (ROUND(m_UseItems[U_ARMRINGL].Dura / 10) >= nCount) then begin
              Idx:=U_ARMRINGL;
              Result:=True;
              exit;
          end;
        end;
        3: begin    //소생의부적
          if (AmuletStdItem.Shape = 6) and (ROUND(m_UseItems[U_ARMRINGL].Dura / 10) >= nCount) then begin
              Idx:=U_ARMRINGL;
              Result:=True;
              exit;
          end;
        end;
        4: begin    //독가루 (회색
          if (AmuletStdItem.Shape <= 1) and (ROUND(m_UseItems[U_ARMRINGL].Dura / 10) >= nCount) then begin
              Idx:=U_ARMRINGL;
              Result:=True;
              exit;
          end;
        end;
        5: begin    //부적독가루
          if (AmuletStdItem.Shape in [7,8]) and (ROUND(m_UseItems[U_ARMRINGL].Dura / 10) >= nCount) then begin
              Idx:=U_ARMRINGL;
              Result:=True;
              exit;
          end;
        end;
        6: begin    //보부 - 승려
          if (AmuletStdItem.Shape = 10) and (ROUND(m_UseItems[U_ARMRINGL].Dura / 10) >= nCount) then begin
              Idx:=U_ARMRINGL;
              Result:=True;
              exit;
          end;
        end;
      end;
    end;
  end;


  if m_UseItems[U_BUJUK].wIndex > 0 then begin    //부적 자리
    AmuletStdItem:=UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 25) then begin
      case nType of    //
        1: begin
          if (AmuletStdItem.Shape = 5) and (ROUND(m_UseItems[U_BUJUK].Dura / 10) >= nCount) then begin
              Idx:=U_BUJUK;
              Result:=True;
              exit;
          end;
        end;
        2: begin
          if (AmuletStdItem.Shape <= 2) and (ROUND(m_UseItems[U_BUJUK].Dura / 10) >= nCount) then begin
              Idx:=U_BUJUK;
              Result:=True;
              exit;
          end;
        end;
        3: begin
          if (AmuletStdItem.Shape = 6) and (ROUND(m_UseItems[U_BUJUK].Dura / 10) >= nCount) then begin
              Idx:=U_BUJUK;
              Result:=True;
              exit;
          end;
        end;
        4: begin
          if (AmuletStdItem.Shape <= 1) and (ROUND(m_UseItems[U_BUJUK].Dura / 10) >= nCount) then begin
              Idx:=U_BUJUK;
              Result:=True;
              exit;
          end;
        end;
        5: begin
          if (AmuletStdItem.Shape in [7,8]) and (ROUND(m_UseItems[U_BUJUK].Dura / 10) >= nCount) then begin
              Idx:=U_BUJUK;
              Result:=True;
              exit;
          end;
        end;
        6: begin     //보부 - 승려
          if (AmuletStdItem.Shape = 10) and (ROUND(m_UseItems[U_BUJUK].Dura / 10) >= nCount) then begin
              Idx:=U_BUJUK;
              Result:=True;
              exit;
          end;
        end;
      end;
    end;
  end;
  if not Result then begin
     case nType of
      1:  SysMsg('콱극伎陋구빱疵形',c_Green,t_Hint);
      2:  SysMsg('콱극伎陋구뗀뢴。',c_Green,t_Hint);
      3:  SysMsg('콱극伎陋구릿삶륜。',c_Green,t_Hint);
      4:  SysMsg('콱극伎陋구뿍ザ쓿發',c_Green,t_Hint);
      5:  SysMsg('콱극伎陋구뗀륜관。',c_Green,t_Hint);
      6:  SysMsg('콱극伎陋구쏜爵燒形',c_Green,t_Hint);
     end;
  end;

end;


procedure TPlayObject.UseAmulet(nCount:Integer;nType:Integer;var Idx:Integer);
begin
  if m_UseItems[Idx].Dura > nCount * 10 then begin
    Dec(m_UseItems[Idx].Dura,nCount * 10);
    SendMsg(Self,RM_DURACHANGE,Idx,m_UseItems[Idx].Dura,m_UseItems[Idx].DuraMax,0,'');
  end else begin
    m_UseItems[Idx].Dura:=0;
    SendDelItems(@m_UseItems[Idx]);
    m_UseItems[Idx].wIndex:=0;
  end;
end;


function TBaseObject.GetMagicRun(nMagicID: Integer): Boolean;      //무공 배웠는지
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  Result := False;
  for I := 0 to m_MagicList.Count - 1 do begin
    UserMagic := m_MagicList.Items[I];
    if UserMagic.MagicInfo.wMagicId = nMagicID then begin
      Result := True;
      Break;
    end;
  end;
end;

function TPlayObject.GetSpellPoint(UserMagic: pTUserMagic): Integer; //004C6910
begin
  Result:=ROUND(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefSpell;
end;

function TPlayObject.DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean; ////004C3130
  function CanMotaebo(BaseObject:TBaseObject):Boolean;//0x004C30B0
  var
    nC:Integer;
  begin
    Result:=False;
    if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then begin
      nC:=m_Abil.Level - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then begin
        if IsProperTarget(BaseObject) then Result:=True;
      end;
    end;      
  end;
var
  bo35:Boolean;
  I,nDmg,n24,n28:Integer;
  PoseCreate:TBaseObject;
  BaseObject_30:TBaseObject;
  BaseObject_34:TBaseObject;
  nX,nY:integer;
begin
  Result:=False;
  bo35:=True;
  m_btDirection:=nDir;
  BaseObject_34:=nil;
  n24:=nMagicLevel + 1;
  n28:=n24;
  PoseCreate:=GetPoseCreate();
  if PoseCreate <> nil  then begin
    for I:=0 to _MAX(2,nMagicLevel + 1) do begin
      PoseCreate:=GetPoseCreate();
      if PoseCreate <> nil  then begin
        n28:=0;
        if not CanMotaebo(PoseCreate) then break;
        if nMagicLevel >= 3 then begin
          if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,2,nX,nY) then begin
            BaseObject_30:=m_PEnvir.GetMovingObject(nX,nY,True);
            if (BaseObject_30 <> nil) and CanMotaebo(BaseObject_30) then
              BaseObject_30.CharPushed(m_btDirection,1);  //004C3237
          end; //004C323C
        end; //004C323C if nMagicLevel >= 3 then begin
        BaseObject_34:=PoseCreate;

        if PoseCreate.CharPushed(m_btDirection,1) <> 1 then break;
        Inc(PoseCreate.PushedCount);
        GetFrontPosition(nX,nY);  //sub_004B2790
        if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nX,nY,False) > 0 then begin
          m_nCurrX:=nX;
          m_nCurrY:=nY;
          SendRefMsg(RM_RUSH,nDir,m_nCurrX,m_nCurrY,0,'');
          bo35:=False;
          Result:=True;
        end;
        Dec(n24);
      end; //004C32D7  if PoseCreate <> nil  then begin
    end; //004C32DD for i:=0 to _MAX(2,nMagicLevel + 1) do begin
  end else begin //004C32E8 if PoseCreate <> nil  then begin
    bo35:=False;
    for i:=0 to _MAX(2,nMagicLevel + 1) do begin
      GetFrontPosition(nX,nY);//sub_004B2790
      if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nX,nY,False) > 0 then begin
        m_nCurrX:=nX;
        m_nCurrY:=nY;
        SendRefMsg(RM_RUSH,nDir,m_nCurrX,m_nCurrY,0,'');
        Dec(n28);
      end else begin
        if m_PEnvir.CanWalk(nX,nY,True) then n28:=0
        else begin
          bo35:=True;
          break;
        end;
      end;
    end; //004C33AD
  end; //004C33B3
  if (BaseObject_34 <> nil) then begin  //004C33B3
    if n24 < 0 then n24:=0;
    nDmg:=Random((n24 + 1) * 10) + ((n24 + 1) * 10);
    nDmg:=BaseObject_34.GetHitStruckDamage(Self,nDmg);
    BaseObject_34.StruckDamage(nDmg);
    BaseObject_34.SendRefMsg(RM_STRUCK,nDmg,BaseObject_34.m_WAbil.HP,BaseObject_34.m_WAbil.MaxHP,Integer(Self),'');
    if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then begin
      BaseObject_34.SendMsg(BaseObject_34,RM_STRUCK,nDmg,BaseObject_34.m_WAbil.HP,BaseObject_34.m_WAbil.MaxHP,Integer(Self),'');
    end;
  end; //004C3464
  if bo35 then begin
    GetFrontPosition(nX,nY);  //sub_004B2790
    SendRefMsg(RM_RUSHKUNG,m_btDirection,nX,nY,0,'');
    SysMsg(sMateDoTooweak,c_Red,t_Hint);
  end;
  if n28 > 0 then begin
    if n24 < 0 then n24:=0;
    nDmg:=Random(n24 * 10) + ((n24 + 1) * 3);
    nDmg:=GetHitStruckDamage(Self,nDmg);
    StruckDamage(nDmg);
    SendRefMsg(RM_STRUCK,nDmg,m_WAbil.HP,m_WAbil.MaxHP,0,'');
  end;

end;

function TPlayObject.DoSonicWave(nDir: Byte; nMagicLevel, Damage: Integer): Boolean; ////004C3130
  function CanSonicWave(BaseObject:TBaseObject):Boolean;//0x004C30B0
  var
    nC:Integer;
  begin
    Result:=False;
    if ((m_Abil.Level + 6)> BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then begin
      nC:=(m_Abil.Level + 6) - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then begin
        if IsProperTarget(BaseObject) then Result:=True;
      end;
    end;
  end;
var
  nDmg:Integer;
  PoseCreate:TBaseObject;
  BaseObject_20:TBaseObject;
  BaseObject_30:TBaseObject;
  BaseObject_34:TBaseObject;
  nX,nY:integer;
begin
  Result:=False;
  m_btDirection:=nDir;
  PoseCreate:=nil;
  BaseObject_20:=nil;
  BaseObject_30:=nil;
  BaseObject_34:=nil;
  PoseCreate:=GetPoseCreate();


  if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,3,nX,nY) then begin
    BaseObject_20:=m_PEnvir.GetMovingObject(nX,nY,True);
    if (BaseObject_20 <> nil) and (IsProperTarget(BaseObject_20)) then begin
      nDmg:=Damage;
      nDmg:=BaseObject_20.GetHitStruckDamage(Self,nDmg);
      BaseObject_20.StruckDamage(nDmg);
      BaseObject_20.SendRefMsg(RM_STRUCK,nDmg,BaseObject_20.m_WAbil.HP,BaseObject_20.m_WAbil.MaxHP,Integer(Self),'');
      if BaseObject_20.m_btRaceServer <> RC_PLAYOBJECT then begin
        BaseObject_20.SendMsg(BaseObject_20,RM_STRUCK,nDmg,BaseObject_20.m_WAbil.HP,BaseObject_20.m_WAbil.MaxHP,Integer(Self),'');
      end;
    end;
  end;


  if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,2,nX,nY) then begin
    BaseObject_30:=m_PEnvir.GetMovingObject(nX,nY,True);
    if (BaseObject_30 <> nil) and (IsProperTarget(BaseObject_30)) then begin
      nDmg:=Damage;
      nDmg:=BaseObject_30.GetHitStruckDamage(Self,nDmg);
      BaseObject_30.StruckDamage(nDmg);
      BaseObject_30.SendRefMsg(RM_STRUCK,nDmg,BaseObject_30.m_WAbil.HP,BaseObject_30.m_WAbil.MaxHP,Integer(Self),'');
      if BaseObject_30.m_btRaceServer <> RC_PLAYOBJECT then begin
        BaseObject_30.SendMsg(BaseObject_30,RM_STRUCK,nDmg,BaseObject_30.m_WAbil.HP,BaseObject_30.m_WAbil.MaxHP,Integer(Self),'');
      end;
    end;
  end;

  if (PoseCreate <> nil) and (IsProperTarget(PoseCreate)) then begin
    nDmg:=Damage;
    nDmg:=PoseCreate.GetHitStruckDamage(Self,nDmg);
    PoseCreate.StruckDamage(nDmg);
    PoseCreate.SendRefMsg(RM_STRUCK,nDmg,PoseCreate.m_WAbil.HP,PoseCreate.m_WAbil.MaxHP,Integer(Self),'');
    if PoseCreate.m_btRaceServer <> RC_PLAYOBJECT then begin
      PoseCreate.SendMsg(PoseCreate,RM_STRUCK,nDmg,PoseCreate.m_WAbil.HP,PoseCreate.m_WAbil.MaxHP,Integer(Self),'');
    end;
  end;
  BaseObject_34:=PoseCreate;

  if (BaseObject_20 <> nil) and CanSonicWave(BaseObject_20) then begin  //004C33B3
    if BaseObject_20.CharPushed(m_btDirection, nMagicLevel + 1) <> 1 then
      Inc(BaseObject_20.PushedCount);
    Result:=True;
  end;

  if (BaseObject_30 <> nil) and CanSonicWave(BaseObject_30) then begin  //004C33B3
    if BaseObject_30.CharPushed(m_btDirection, nMagicLevel + 1) <> 1 then
      Inc(BaseObject_30.PushedCount);
    Result:=True;
  end;

  if (BaseObject_34 <> nil) and CanSonicWave(BaseObject_34) then begin  //004C33B3
    if BaseObject_34.CharPushed(m_btDirection, nMagicLevel + 1) <> 1 then
      Inc(BaseObject_34.PushedCount);
    Result:=True;
  end;
end;



function TPlayObject.DoBaldo(nDir: Byte; UserMagic: pTUserMagic): Boolean;     //발도술
  function MPow(UserMagic:pTUserMagic):Integer;
  begin
    Result:=UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower);
  end;
  function GetPower(nPower:Integer;UserMagic:pTUserMagic):Integer;
  begin
    Result:=ROUND(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower));
  end;
var
  I,nDmg,n24,nWeaponDamage:Integer;
  PoseCreate:TBaseObject;
  BaseObject_30:TBaseObject;
  BaseObject_34:TBaseObject;
  nX,nY:integer;
begin
   if m_wStatusTimeArr[STATE_ASSTRANSPARENT] > 0 then  //월영술 및 열화신 공격시.. 풀림
   m_wStatusTimeArr[STATE_ASSTRANSPARENT]:=1;

   if m_wStatusTimeArr[STATE_YEONGMU] > 0 then  //월영무 공격시.. 풀림
   m_wStatusTimeArr[STATE_YEONGMU]:=1;

  Result:=False;
  m_btDirection:=nDir;
  BaseObject_34:=nil;
  BaseObject_30:=nil;
  n24:=UserMagic.btLevel + 1;
  PoseCreate:=GetPoseCreate();       //앞에 누가 있는지 확인
  if PoseCreate <> nil then begin         //앞에 누가 있다면.
     BaseObject_30:=nil;
     BaseObject_34:=PoseCreate;          //앞에있는 사람 지정
  end else begin          //앞에 아무도 없으면
    for i:=0 to _MAX(0,0) do begin
    if UserMagic.btLevel >= 2 then begin    //무공 레벨 2부터 앞으로 전진
      GetFrontPosition(nX,nY);
      if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nX,nY,FALSE) > 0 then begin   //앞으로 이동
        m_nCurrX:=nX;
        m_nCurrY:=nY;
        SendRefMsg(RM_RUSH,nDir,m_nCurrX,m_nCurrY,0,'');
        Result:=True;
        PoseCreate:=GetPoseCreate();     //앞에 대상 확인
        if PoseCreate <> nil then begin           //앞에 대상이 있다.
           BaseObject_34:=nil;
           BaseObject_30:=PoseCreate;        // BaseObject_30 을 지정해준다.
        end;
      end;
    end;
    end;
  end;
  if (BaseObject_34 <> nil) and (IsProperTarget(BaseObject_34))  then begin    //앞에 대상에게..
    Result:=True;
    nDmg:=GetAttackPower(GetPower(MPow(UserMagic),UserMagic) + LoWord(m_WAbil.DC),SmallInt(( HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)) + 1 ));

    nDmg:=BaseObject_34.GetHitStruckDamage(Self,nDmg);
    BaseObject_34.StruckDamage(nDmg);
    BaseObject_34.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, nDmg{wparam}, BaseObject_34.m_WAbil.HP{lparam1}, BaseObject_34.m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 600);

    if (Random(30) <= UserMagic.btLevel) and (Random(BaseObject_34.m_btAntiPoison) = 0) and (Not BaseObject_34.m_NoPoison) then begin     //발도술 스턴
         BaseObject_34.MakePosion(POISON_STUN,(UserMagic.btLevel + 1) ,0);
    end;
    DelaySendMsg(Self,RM_KMSendMsg,0,0,m_btDirection,0,'',300);

    nWeaponDamage:=(Random(5) + 2) - m_AddAbil.btWeaponStrong;    //단단한 무기는 내구가 잘 안단다.
    if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then
      DoDamageWeapon(nWeaponDamage);
  end;
  if (BaseObject_30 <> nil) and (IsProperTarget(BaseObject_30)) then begin    //전진 후 앞에 대상에게..
    Result:=True;
    nDmg:=GetAttackPower(GetPower(MPow(UserMagic),UserMagic) + LoWord(m_WAbil.DC),SmallInt(( HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC)) + 1 ));
    nDmg:=BaseObject_30.GetHitStruckDamage(Self,nDmg);
    BaseObject_30.StruckDamage(nDmg);
    BaseObject_30.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, nDmg{wparam}, BaseObject_30.m_WAbil.HP{lparam1}, BaseObject_30.m_WAbil.MaxHP{lparam2}, Longint(self){hiter}, '', 850);

    if (Random(30) <= UserMagic.btLevel) and (Random(BaseObject_30.m_btAntiPoison) = 0)  and (Not BaseObject_30.m_NoPoison) then begin    //발도술 스턴
         BaseObject_30.MakePosion(POISON_STUN,(UserMagic.btLevel + 1),0);
    end;
    DelaySendMsg(Self,RM_KMSendMsg,0,0,m_btDirection,0,'',650);

    nWeaponDamage:=(Random(5) + 2) - m_AddAbil.btWeaponStrong;    //단단한 무기는 내구가 잘 안단다.
    if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then
      DoDamageWeapon(nWeaponDamage);
  end;
end;



function TPlayObject.FinalBun(nDir: Byte; nMagicLevel: Integer): Boolean;     //자객신규모공
var
  I,n24:Integer;
  PoseCreate:TBaseObject;
  BaseObject_30:TBaseObject;
  BaseObject_34:TBaseObject;
  nX,nY:integer;
  PlayObject:TPlayObject;
begin
   if m_wStatusTimeArr[STATE_ASSTRANSPARENT] > 0 then  //월영술 및 열화신 공격시.. 풀림
   m_wStatusTimeArr[STATE_ASSTRANSPARENT]:=1;

   if m_wStatusTimeArr[STATE_YEONGMU] > 0 then  //월영무 공격시.. 풀림
   m_wStatusTimeArr[STATE_YEONGMU]:=1;

  Result:=False;
  m_btDirection:=nDir;
  BaseObject_34:=nil;
  BaseObject_30:=nil;
  n24:=nMagicLevel + 1;
  SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,63,'0');    //일격비 이팩트
  PoseCreate:=GetPoseCreate();       //앞에 누가 있는지 확인
  if PoseCreate <> nil then begin         //앞에 누가 있다면.
     BaseObject_34:=PoseCreate;          //앞에있는 사람 지정
  end else begin          //앞에 아무도 없으면
    for i:=0 to _MAX(0,0) do begin
      GetFrontPosition(nX,nY);
      if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nX,nY,True) > 0 then begin   //앞으로 이동
        m_nCurrX:=nX;
        m_nCurrY:=nY;
        SendRefMsg(RM_RUSH,nDir,m_nCurrX,m_nCurrY,0,'');
     //   Result:=True;
        PoseCreate:=GetPoseCreate();     //앞에 대상 확인
        if PoseCreate <> nil then begin           //앞에 대상이 있다.
           BaseObject_30:=PoseCreate;        // BaseObject_30 을 지정해준다.
        end;
      end;
    end;
  end;
  if (BaseObject_34 <> nil) and (IsProperTarget(BaseObject_34))  then begin    //앞에 대상에게..
  Result:=True;
    if BaseObject_34.m_btJob in [0,5] then begin               //직업변경
     BaseObject_34.DamageHealth(m_WAbil.HP);
    end else
    if BaseObject_34.m_btJob in [1,6] then begin                //직업변경
     BaseObject_34.DamageHealth(Round(m_WAbil.HP / 3));
    end else
    if BaseObject_34.m_btJob in [2,7] then begin                 //직업변경
     BaseObject_34.DamageHealth(Round(m_WAbil.HP / 1.5));
    end;
    if BaseObject_34.m_btJob in [3,8] then begin                 //직업변경
     BaseObject_34.DamageHealth(Round(m_WAbil.HP / 1.2));
    end;
    BaseObject_34.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, 1, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Longint(self), '', 300);
    BaseObject_34.SendRefMsg(RM_10205,0,BaseObject_34.m_nCurrX,BaseObject_34.m_nCurrY,62,'0');   //일격비 이팩트
    DelaySendMsg(PlayObject,RM_ToSendMsg,0,91,m_btDirection,0,'',300);
  end;
  if (BaseObject_30 <> nil) and (IsProperTarget(BaseObject_30)) then begin    //전진 후 앞에 대상에게..
     Result:=True;
    if BaseObject_30.m_btJob in [0,5] then begin                //직업변경
     BaseObject_30.DamageHealth(m_WAbil.HP);
    end else
    if BaseObject_30.m_btJob in [1,6] then begin               //직업변경
     BaseObject_30.DamageHealth(Round(m_WAbil.HP / 3));
    end else
    if BaseObject_30.m_btJob in [2,7] then begin                 //직업변경
     BaseObject_30.DamageHealth(Round(m_WAbil.HP / 1.5));
    end;
    if BaseObject_30.m_btJob in [3,8] then begin                    //직업변경
     BaseObject_30.DamageHealth(Round(m_WAbil.HP / 1.2));
    end;
    BaseObject_30.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, 1, BaseObject_30.m_WAbil.HP, BaseObject_30.m_WAbil.MaxHP, Longint(self), '', 500);
    BaseObject_30.SendDelayRefMsg (RM_10205,0,BaseObject_30.m_nCurrX,BaseObject_30.m_nCurrY,62,'0',600);        //일격비
    DelaySendMsg(PlayObject,RM_ToSendMsg,0,91,m_btDirection,0,'',650);
  end;
end;


procedure TPlayObject.SendSerieMagicBlasthitMsg(UserMagic: pTUserMagic);   //참진격
begin
  SendRefMsg(RM_BLASTHIT, UserMagic.wMagIdx, m_nCurrX, m_nCurrY, 0, '');
end;


function TPlayObject.BlastMotaebo(nDir: Byte; UserMagic: pTUserMagic): Boolean;       //참진격
  function MPow(UserMagic:pTUserMagic):Integer;
  begin
    Result:=UserMagic.MagicInfo.wPower + Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower);
  end;
  function GetPower(nPower:Integer;UserMagic:pTUserMagic):Integer;
  begin
    Result:=ROUND(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower));
  end;
  function CanMotaebo(BaseObject: TBaseObject): Boolean;
  begin
    Result := False;
    if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode) then begin
      if IsProperTarget(BaseObject) then Result := True;
    end;
  end;
var
  bo35: Boolean;
  I, nPower: Integer;
  PoseCreate: TBaseObject;
  BaseObject_34: TBaseObject;
  BaseObject_40: TBaseObject;
  nX, nY: Integer;
begin
  Result := False;
  bo35 := False;
  m_btDirection := nDir;
  BaseObject_34 := nil;
  BaseObject_40 := nil;
  PoseCreate := GetPoseCreate();
  if PoseCreate <> nil then begin
    if CanMotaebo(PoseCreate) then begin
      BaseObject_34 := PoseCreate;
      if PoseCreate.CharPushed(m_btDirection, 1) = 1 then begin
        BaseObject_34 := PoseCreate;
        GetFrontPosition(nX, nY);
        if (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0) then begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_RUSH,nDir,m_nCurrX,m_nCurrY,0,'');
          Result := True;
          bo35 := True;
        end;
      end;
    end else begin
      BaseObject_40 := PoseCreate;
    end;
  end else begin
    for i:=0 to _MAX(0,0) do begin
      GetFrontPosition(nX,nY);//sub_004B2790
      if m_PEnvir.MoveToMovingObject(m_nCurrX,m_nCurrY,Self,nX,nY,False) > 0 then begin
        m_nCurrX:=nX;
        m_nCurrY:=nY;
        Result:=True;
        SendRefMsg(RM_RUSH,nDir,m_nCurrX,m_nCurrY,0,'');
        bo35 := True;
      end else begin
        if not m_PEnvir.CanWalk(nX,nY,True) then begin
          bo35:=False;
          break;
        end;
      end;
    end; //004C33AD
  end; //004C33B3

  if (BaseObject_34 <> nil) and (IsProperTarget(BaseObject_34)) then begin
    Result:=True;
    nPower := GetAttackPower( GetPower(MPow(UserMagic),UserMagic) + LoWord(m_WAbil.DC), Integer((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
    if Random(15 - UserMagic.btLevel) < UserMagic.btLevel then begin
      nPower := Round((nPower * (UserMagic.btLevel + 1)) * 0.8 );
      SendSerieMagicBlasthitMsg(UserMagic);
    end;

    nPower:=BaseObject_34.GetHitStruckDamage(Self,nPower);
    BaseObject_34.StruckDamage(nPower);
    BaseObject_34.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, nPower, BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Longint(self), '', 600);

  end;

  if (BaseObject_40 <> nil) and (IsProperTarget(BaseObject_40)) then begin
    Result:=True;
    nPower := GetAttackPower( GetPower(MPow(UserMagic),UserMagic) + LoWord(m_WAbil.DC), Integer((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
    if Random(15 - UserMagic.btLevel) < UserMagic.btLevel then begin
      nPower := Round((nPower * (UserMagic.btLevel + 1)) * 0.6 );
      SendSerieMagicBlasthitMsg(UserMagic);
    end;

    nPower:=BaseObject_40.GetHitStruckDamage(Self,nPower);
    BaseObject_40.StruckDamage(nPower);
    BaseObject_40.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, nPower, BaseObject_40.m_WAbil.HP, BaseObject_40.m_WAbil.MaxHP, Longint(self), '', 850);

  end;


  if not bo35 then begin
    GetFrontPosition(nX,nY);
    SendRefMsg(RM_RUSHKUNG,m_btDirection,nX,nY,0,'');
  end;
end;

//004C1268
procedure TBaseObject.TrainSkill(UserMagic: pTUserMagic;
  nTranPoint: Integer);
begin
  if m_boFastTrain then
    nTranPoint:=nTranPoint * 3;
  if m_boFastTrain2 then
    nTranPoint:=nTranPoint * 2;
  Inc(UserMagic.nTranPoint,nTranPoint);
end;

function TBaseObject.CheckMagicLevelup(UserMagic: pTUserMagic): Boolean; //004C7054    //무공레벨
var
  n10:Integer;
begin
  Result:=False;
  if (UserMagic.btLevel < 4) and (UserMagic.MagicInfo.btTrainLv >= UserMagic.btLevel) then
    n10:=UserMagic.btLevel
  else n10:=0;
  
  if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) and
     (UserMagic.MagicInfo.MaxTrain[n10] <= UserMagic.nTranPoint) then begin

    if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) then begin
      Dec(UserMagic.nTranPoint,UserMagic.MagicInfo.MaxTrain[n10]);
      Inc(UserMagic.btLevel);
      if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_HEROOBJECT) then begin
        SendUpdateDelayMsg(Self,RM_MAGIC_LVEXP,0,UserMagic.MagicInfo.wMagicId,UserMagic.btLevel,UserMagic.nTranPoint,'',800);
      end;
      CheckMagicSpecialAbility(UserMagic);
    end else begin
      UserMagic.nTranPoint:=UserMagic.MagicInfo.MaxTrain[n10];
    end;
    Result:=True;
  end; //004C7132    
end;

function TPlayObject.DoSpell(UserMagic: pTUserMagic; nTargetX,
  nTargetY: Integer; BaseObject: TBaseObject): boolean; //004C6968
var
  nSpellPoint:integer;
  nSpellPoint2 :integer;
begin
  Result:=False;
try
  if not MagicManager.IsWarrSkill(UserMagic.wMagIdx) then begin

    nSpellPoint:=GetSpellPoint(UserMagic);

    if UserMagic.MagicInfo.wMagicID = 75 then begin//번뇌
      nSpellPoint2 := (HiWord(m_WAbil.SC) + LoWord(m_WAbil.SC));
      nSpellPoint:=GetSpellPoint(UserMagic) + nSpellPoint2;
    end;

    if m_wStatusTimeArr[STATE_MAGICUP] > 0 then begin   //심연술 마나 소모량
      nSpellPoint := nSpellPoint *2;
    end;

    if nSpellPoint > 0 then begin
      if m_WAbil.MP < nSpellPoint then exit;
      DamageSpell(nSpellPoint);
      HealthSpellChanged();
    end;
    Result:=MagicManager.DoSpell(Self,UserMagic,nTargetX,nTargetY,BaseObject);
  end;
except
  on e: Exception do begin
    MainOutMessage(format('[Exception] TPlayObject.DoSpell MagID:%d X:%d Y:%d',[UserMagic.wMagIdx,nTargetX,nTargetY]));
    MainOutMessage(E.Message);
  end;

end;
end;

function TPlayObject.PileStones(nX, nY: Integer):Boolean; //004CB64C
var
  Event     :TEvent;
  PileEvent :TEvent;
  s1C       :String;
begin
  Result:=False;
  s1C:='';
  Event:=TEvent(m_PEnvir.GetEvent(nX,nY));
  if (Event <> nil) and (Event.m_nEventType = ET_MINE) then begin
    if TStoneMineEvent(Event).m_nMineCount > 0 then begin
      Dec(TStoneMineEvent(Event).m_nMineCount);
      if Random(g_Config.nMakeMineHitRate) = 0 then begin
        PileEvent:=TEvent(m_PEnvir.GetEvent(m_nCurrX,m_nCurrY));
        if PileEvent = nil then begin //004CB71D
          PileEvent:=TPileStones.Create(m_PEnvir,m_nCurrX,m_nCurrY,ET_PILESTONES,5 * 60 * 1000);
          g_EventManager.AddEvent(PileEvent);
        end else begin
          if PileEvent.m_nEventType = ET_PILESTONES then
            TPileStones(PileEvent).AddEventParam;
        end;
        if Random(g_Config.nMakeMineRate) = 0 then begin
          if m_PEnvir.Flag.boMINE then     //광산
            MakeMine()
          else if m_PEnvir.Flag.boMINE2 then
            MakeMine2()
          else if m_PEnvir.Flag.boMINE3 then
            MakeMine3()
          else if m_PEnvir.Flag.boMINE4 then //석초광산
            MakeMine4();
        end;
        s1C:='1';
        DoDamageWeapon(Random(15) + 5);
        Result:=True;
      end; //004CB79C
    end else begin  //004CB782
      if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) >10 * 60 * 1000 then
        TStoneMineEvent(Event).AddStoneMine();
    end;
  end; //004CB79C
  SendRefMsg(RM_HEAVYHIT,m_btDirection,m_nCurrX,m_nCurrY,0,s1C);
end;


//004C914C
procedure TBaseObject.SetTargetCreat(BaseObject: TBaseObject);
begin
  m_TargetCret:=BaseObject;
  m_dwTargetFocusTick:=GetTickCount();
end;

procedure TBaseObject.DelTargetCreat();//004C9178
begin
  m_TargetCret:=nil;
end;




procedure TBaseObject.RecallSlave(sSlaveName:String);
var
  i,nX,nY:Integer;
begin
  GetBackPosition(nX,nY);

  for i:=m_SlaveList.Count -1 downto 0 do begin
    if (TBaseObject(m_SlaveList.Items[i]).m_sCharName = sSlaveName) then begin
      TBaseObject(m_SlaveList.Items[i]).SpaceMove(m_PEnvir.sMapName, nX, nY, 1);
      Break;
    end;
  end;
end;

procedure TBaseObject.ReloadMonItem();
begin
  UserEngine.MonGetRandomItems(self);
end;


function TBaseObject.SlaveCount(sSlaveName:String):Integer;
var
  i:Integer;
  BaseObject:TBaseObject;
begin
  Result := 0;
  for I := 0 to m_SlaveList.Count - 1 do begin
    BaseObject:=TBaseObject(m_SlaveList.Items[I]);
    if CompareText(sSlaveName,BaseObject.m_sCharName) = 0 then begin
      Inc(Result);
    end;      
  end;
end;


function TBaseObject.ExistAttackSlaves: Boolean;
var
   i: integer;
   cret: TBaseObject;
begin
   //공격 타겟이 있는 소환수가 있으면 TRUE 없으면 FALSE...
   Result := FALSE;
   for i:=0 to m_SlaveList.Count-1 do begin
      cret := TBaseObject(m_SlaveList.Items[i]);
      if not cret.m_boDeath then
      begin
         if cret.m_TargetCret <> nil then begin
            if cret.m_TargetCret.m_btRaceServer = RC_PLAYOBJECT then begin
               Result := TRUE;
               break;
            end;
         end;
      end;
   end;
end;

// 꼬봉존재유무 판단.

function  TBaseObject.GetExistSlave( MonName_ : string ):TBaseObject;
var
   TempCret : TBaseObject;
   i        : integer;
begin
   Result := nil;
   try
      for i := 0 to m_SlaveList.Count -1 do begin
         TempCret := TBaseObject(m_SlaveList.Items[i]);
         if ( TempCret <> nil     ) and
            ( not TempCret.m_boDeath  ) and
            ( not TempCret.BoDisapear )and
            ( not TempCret.m_boGhost) and
            ( comparetext( TempCret.m_sCharName , MonName_) = 0 ) then begin
            Result := TempCret;
            Exit;
         end;
      end;
   except
      MainOutMessage('EXCEPTION GETExistSlave');
   end;
end;

function TBaseObject._Attack(var wHitMode: Word;  AttackTarget: TBaseObject): Boolean;//004C1EF4
  //기본
  function DirectAttack(BaseObject:TBaseObject;nSecPwr:Integer):Boolean; //004C1B04
  begin
    Result:=False;
    //if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and ((BaseObject.InSafeZone) or (InSafeZone)) then
     //    exit;  //안전지대
    if (m_btRaceServer = RC_PLAYOBJECT) or  (m_btRaceServer = RC_HEROOBJECT) or
      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) or
      not (InSafeZone and BaseObject.InSafeZone) then begin

      if IsProperTarget(BaseObject) then begin
        if Random(BaseObject.m_btSpeedPoint) < m_btHitPoint then begin
         BaseObject.StruckDamage(nSecPwr);
         BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nSecPwr,
                                BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '',500);
         //몬스터한테는 직접전달해야 함..
         if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (BaseObject.m_btRaceServer <> RC_HEROOBJECT) then
            BaseObject.SendMsg (BaseObject, RM_STRUCK, nSecPwr, BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(self), '');
         Result := TRUE;
        end;
      end;
    end;
  end;
  //어검술
  function SwordLongAttack(nSecPwr:Integer):Boolean;  //004C1C24
  var
    nX,nY:Integer;
    BaseObject:TBaseObject;
  begin
    Result:=False;

    if m_wStatusTimeArr[STATE_WINDMOON] > 0 then  //어검술 강화
      nSecPwr:=ROUND(nSecPwr * 1.3);

      if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,2,nX,nY) then begin
        BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
        if BaseObject <> nil then begin
          if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
            Result:=DirectAttack(BaseObject,nSecPwr);
            SetTargetCreat(BaseObject);
          end;
        end;
      end;

  end;

  function TaguLongAttack(nSecPwr:Integer):Boolean;  //004C1C24
  var
    nX,nY, I:Integer;
    BaseObject:TBaseObject;
  begin
    Result:=False;
    for i:=2 to 3 do begin
      if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,i,nX,nY) then begin
        BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
        if BaseObject <> nil then begin
          if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
            Result:=DirectAttack(BaseObject,nSecPwr);
            SetTargetCreat(BaseObject);
          end;
        end;
      end;
    end;
  end;

  function ThunderLongAttack(nSecPwr:Integer):Boolean;  //004C1C24
  var
    nX,nY, I:Integer;
    BaseObject:TBaseObject;
    MoC, Dur: integer;
  begin
    Result:=False;
    for i:=1 to 3 do begin
      if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,i,nX,nY) then begin
        BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
        if BaseObject <> nil then begin
          if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
            Result:=DirectAttack(BaseObject,nSecPwr);
            SetTargetCreat(BaseObject);
          end;
        end;
      end;
    end;
  end;

  function ThunderLongAttack2(nSecPwr:Integer):Boolean;  //004C1C24
  var
    nX,nY, I:Integer;
    BaseObject:TBaseObject;
    MoC, Dur: integer;
  begin
    Result:=False;
    for i:=2 to 3 do begin
      if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,m_btDirection,i,nX,nY) then begin
        BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
        if BaseObject <> nil then begin
          if (nSecPwr > 0) and IsProperTarget(BaseObject) then begin
            Result:=DirectAttack(BaseObject,nSecPwr);
            SetTargetCreat(BaseObject);
          end;
        end;
      end;
    end;
  end;

  //반월검법
  function SwordWideAttack(nSecPwr:Integer):Boolean;  //004C1CDC
  const
      valarr: array[0..2] of integer = (7, 1, 2);
  var
    i, ndir, nX, nY: integer;
    BaseObject:TBaseObject;
  begin
    Result:=False;
    for i:=0 to 2 do begin
      ndir := (m_btDirection + valarr[i]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,ndir,1,nX,nY) then begin
        BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject) then begin
          Result:=DirectAttack(BaseObject,nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
    end;
  end;
  //광풍참
  function CrsWideAttack(nSecPwr:Integer):Boolean;
  const
      valarr: array[0..6] of integer = (7, 1, 2, 3, 4, 5, 6);
  var
    i, ndir, nX, nY: integer;
    BaseObject:TBaseObject;
  begin
    Result:=False;
    for i:=0 to 6 do begin
      ndir := (m_btDirection + valarr[i]) mod 8;
      if m_wStatusTimeArr[STATE_WINDMOON] > 0 then   //광풍참 강화
         nSecPwr:=ROUND(nSecPwr * 1.3);

        if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,ndir,1,nX,nY) then begin
          BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
          if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject) then begin

            if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_btRaceServer = RC_HEROOBJECT) then Result:=DirectAttack(BaseObject, nSecPwr)
              else Result:=DirectAttack(BaseObject, Round(nSecPwr * 1.5));   //광풍참 데미지 상승

            SetTargetCreat(BaseObject);
          end;
        end;

    end;
  end;

  function NanCrsWideAttack(nSecPwr:Integer):Boolean;    //난화혈풍참
  var
    I                :Integer;
    BaseObjectList   :TList;
    TargeTBaseObject :TBaseObject;
  begin
    Result         := False;
    BaseObjectList := TList.Create;
    GetMapBaseObjects(m_PEnvir,m_nCurrX,m_nCurrY,2,BaseObjectList);
    for I := 0 to BaseObjectList.Count - 1 do begin
      TargeTBaseObject:=TBaseObject(BaseObjectList.Items[i]);
      if IsProperTarget(TargeTBaseObject) then begin
        if (TargeTBaseObject.m_btRaceServer = RC_PLAYOBJECT) or (TargeTBaseObject.m_btRaceServer = RC_HEROOBJECT) then Result:=DirectAttack(TargeTBaseObject, Round(nSecPwr * 0.5))
        else Result:=DirectAttack(TargeTBaseObject, Round(nSecPwr * 0.8));   //난화혈풍참 데미지 상승
        SetTargetCreat(TargeTBaseObject);
        if Random(10 + TargeTBaseObject.m_btAntiPoison) <= 6 then
          TargeTBaseObject.MakePosion(POISON_DAMAGEARMOR, 5, 0);
      end;
    end;
    FreeAndNil(BaseObjectList);
  end;

  function CIDAttack(nSecPwr: Integer): Boolean;     //회풍천봉법
  var
    nX, nY: Integer;
    BaseObject: TBaseObject;
    I: Integer;
    BaseObjectList: TList;
  begin
    Result := False;
    nX := m_nCurrX;
    nY := m_nCurrY;
    if m_PEnvir.GetNextPosition(nX, nY, m_btDirection, 2, nX, nY) then begin
      BaseObjectList := TList.Create;
      GetMapBaseObjects(m_PEnvir, nX, nY, 2, BaseObjectList);
      for I := 0 to BaseObjectList.Count - 1 do begin
        BaseObject := TBaseObject(BaseObjectList.Items[I]);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject) then begin
          Result := DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
      FreeAndNil(BaseObjectList);
    end;
  end;

  function CrsWindbladeAttack(nSecPwr:Integer):Boolean;    //풍검술 강화
  var
    nC,n10:Integer;
    nX,nY:Integer;
    BaseObject:TBaseObject;
  begin
    Result:=False;
    nC:=0;
    while (True) do begin
      n10:=(m_btDirection + g_Config.CrsAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX,m_nCurrY,n10,1,nX,nY) then begin
        BaseObject:=m_PEnvir.GetMovingObject(nX,nY,True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject) then begin
          Result:=DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
      Inc(nC);
      if nC >= 7 then break;
    end;    
  end;

  function  MPow (pum: PTUserMagic): integer;
  begin
      Result := pum.MagicInfo.wPower + Random(pum.MagicInfo.wMaxPower - pum.MagicInfo.wPower);
  end;
  function GetPower(nPower: Integer; UserMagic: PTUserMagic): Integer;
  begin
    Result := Round(nPower / (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower - UserMagic.MagicInfo.btDefPower));
  end;

var
  nPower,nSecPwr,nWeaponDamage:Integer;
  bo21, bo22, bo23, bo24:Boolean;
  n20, n30, n40, rushDir, rushDist:Integer;
  nCheckCode:Integer;
  nManaPower:Integer;//흡기
  PlayObject: TPlayObject;
  Gap, MoC, Dur: integer;
ResourceString
  sExceptionMsg = '[Exception] TBaseObject::_Attack Name:= %s Code:=%d';
begin
  Result:=False;
  nCheckCode:=0;

try
  bo21 := False;
  bo22 := False;
  bo23 := False;
  bo24 := False;
  nWeaponDamage:=0;
  nPower:=0;
  nSecPwr:=0;
  if AttackTarget <> nil then begin     //데미지 설정부분
    nPower:=GetAttackPower(LoWord(m_WAbil.DC),SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));

    //비광의탈
    if (m_btMask = 29) and (Random(4) = 1) then begin
      case Random(4) of
        0: AttackTarget.SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GoStop1, IntToStr(m_btDirection)); //비광의탈 이팩트
        1: AttackTarget.SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GoStop2, IntToStr(m_btDirection)); //비광의탈 이팩트
        2: AttackTarget.SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GoStop3, IntToStr(m_btDirection)); //비광의탈 이팩트
        3: AttackTarget.SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GoStop4, IntToStr(m_btDirection)); //비광의탈 이팩트
        4: AttackTarget.SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GoStop5, IntToStr(m_btDirection)); //비광의탈 이팩트
      end;
    end;

    if (m_btMask = 30) and (wHitMode in [0, 1]) then begin //국대응원복(남)
      SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GUKDEA, IntToStr(m_btDirection)); //비광의탈 이팩트
    end;

    if (wHitMode = 6) and m_boPowerHit then begin  //예도검법
      m_boPowerHit:=False;
      Inc(nPower,m_nHitPlus);
      bo21:=True;
    end;
    if (wHitMode = 7) and m_boFireHitSkill then begin //염화결
      m_boFireHitSkill:=False;
      nPower:=nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));     //40~160% 더받는다.
      bo21:=True;
    end;
    if (wHitMode = 10) and m_boDeathHitSkill then begin //살생도
      m_boDeathHitSkill:=False;
      nPower:=nPower + ROUND(nPower / 60 * (m_nHitDouble * 10));
      AttackTarget.SendRefMsg(RM_10205,0,AttackTarget.m_nCurrX,AttackTarget.m_nCurrY,5,'0');   //절명검법 이팩트
      if IsProperTarget(AttackTarget) then begin
        if (random(4 - m_MagicDeathSwordSkill.btLevel) = 0) and (Random(AttackTarget.m_btAntiPoison) = 0) then begin
          AttackTarget.MakePosion(POISON_DECHEALTH,(m_MagicDeathSwordSkill.btLevel + 1) * 25,15);
        end;
      end;
      bo21:=True;
    end;
   { if (wHitMode = 22) then begin  //천무예도
      SendRefMsg (RM_10205, 0, m_nCurrX, m_nCurrY, NE_STRUCKCHUNMU, '0');
      nPower := nPower + GetPower(MPow(m_MagicChunMuSkill),m_MagicChunMuSkill);
      bo21 := True;
      m_boChunMuSkill := 0;
    end;
    if (wHitMode = 23) then begin //천무염화결
      SendRefMsg (RM_10205, 0, m_nCurrX, m_nCurrY, NE_STRUCKCHUNMU, '0');
      nPower := nPower + GetPower(MPow(m_MagicChunMuSkill),m_MagicChunMuSkill) * 2;
      bo21 := True;
      m_boChunMuSkill := 0;
    end;   }

    if m_boAssassinHit then begin   //절명검법
      m_boAssassinHit := False;
      Inc(nPower, m_nHitPlus);
      bo22 := True;
    end;

    if m_boManaEater then begin   //흡기
      m_boManaEater := False;
      bo23 := True;
    end;

    if m_boHemorrhage then begin   //혈풍격
      m_boHemorrhage := False;
      Inc(nPower, m_nHitPlus);
      bo24 := True;
    end;

    if IsProperTarget(AttackTarget) then begin     //둔화 옵션
        if (AttackTarget.m_WAbil.Level < 100) and (AttackTarget.m_wStatusTimeArr[POISON_SLOWDOWN] = 0) and
          (m_AddAbil.wSlowDown > 0) and (Random(40{20}) <= m_AddAbil.wSlowDown) and
          (Random(50) > AttackTarget.m_nAntiMagic) then begin // 100->50
          MoC := 1;
          Gap := AttackTarget.m_WAbil.Level - m_WAbil.Level;
          if Gap > 10 then
            Gap := 10;
          if Gap < -10 then
            Gap := -10;
          if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then
            MoC := 2;
           if m_btRaceServer = RC_DARKCLONE then begin
           if Random(90+AttackTarget.m_btAntiPoison) < (14 + (m_AddAbil.wSlowDown - Gap) div Moc) then begin
          //  Dur := (900 * m_AddAbil.wSlowDown + 3300) div 1000;
            AttackTarget.MakePosion(POISON_SLOWDOWN, 5 + m_AddAbil.wSlowDown, 1);
           end;
           end else
           if Random(50+AttackTarget.m_btAntiPoison) < (14 + (m_AddAbil.wSlowDown - Gap) div Moc) then begin
          //  Dur := (900 * m_AddAbil.wSlowDown + 3300) div 1000;
            AttackTarget.MakePosion(POISON_SLOWDOWN, 5 + m_AddAbil.wSlowDown, 1);
           end;
          // ...중독 판정...
        end else            //중독 옵션
        if (AttackTarget.m_WAbil.Level < 100) and (m_AddAbil.wTox > 0) and
          (Random(50) <= m_AddAbil.wTox) and (6 >= Random(7 + AttackTarget.m_btAntiPoison)) then begin
          MoC := 1;
          Gap := AttackTarget.m_WAbil.Level - m_WAbil.Level;
          if Gap > 10 then
            Gap := 10;
          if Gap < -10 then
            Gap := -10;
          if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then
            MoC := 2;
          if m_btRaceServer = RC_DARKCLONE then begin
           if Random(90+AttackTarget.m_btAntiPoison) < (15 + (m_AddAbil.wTox - Gap) div Moc) then begin
            AttackTarget.SendDelayMsg(self, RM_POISON, POISON_DECHEALTH,
              5, integer(self), m_AddAbil.wTox, '', 1000);
           end;
          end else
           if Random(50+AttackTarget.m_btAntiPoison) < (15 + (m_AddAbil.wTox - Gap) div Moc) then begin
            AttackTarget.SendDelayMsg(self, RM_POISON, POISON_DECHEALTH,
              5, integer(self), m_AddAbil.wTox, '', 1000);
           end;
        end;
    end;

  end else begin
    nPower:=GetAttackPower(LoWord(m_WAbil.DC),SmallInt((HiWord(m_WAbil.DC) - LoWord(m_WAbil.DC))));
    if (wHitMode = 6) and m_boPowerHit then begin  //예도검법
      m_boPowerHit:=False;
      Inc(nPower,m_nHitPlus);
      bo21:=True;
    end;

    if (wHitMode = 7) and m_boFireHitSkill then begin      //염화결
      m_boFireHitSkill := False;
      m_dwLatestFireHitTick := GetTickCount();
    end;

    if m_boAssassinHit then begin   //절명검법
      m_boAssassinHit := False;
      Inc(nPower, m_nHitPlus);
      bo22 := True;
    end;

    if m_boManaEater then begin   //흡기
      m_boManaEater := False;
      bo23 := True;
    end;

    if m_boHemorrhage then begin   //혈풍격
      m_boHemorrhage := False;
      Inc(nPower, m_nHitPlus);
      bo24 := True;
    end;
    if (m_btMask = 30) and (wHitMode in [0, 1]) then begin //국대응원복(남)
      SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY, NE_GUKDEA, IntToStr(m_btDirection)); //비광의탈 이팩트
    end;
  end;


  if (wHitMode = 22) then begin  //천무예도
    nSecPwr:=0;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
      if m_MagicChunMuSkill <> nil then begin
        nSecPwr := ROUND(nPower + GetPower(MPow(m_MagicChunMuSkill),m_MagicChunMuSkill) * 2);
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then begin
      DirectAttack (AttackTarget, nSecPwr);
      SendRefMsg (RM_10205, 0, m_nCurrX, m_nCurrY, NE_STRUCKCHUNMU, '0');
      bo21 := True;
      m_boChunMuSkill := 0;
    end;
  end;

  if (wHitMode = 23) then begin //천무염화결
    nSecPwr:=0;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
      if m_MagicChunMuSkill <> nil then begin
        nSecPwr := ROUND(nPower + GetPower(MPow(m_MagicChunMuSkill),m_MagicChunMuSkill) * 3);
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then begin
      DirectAttack (AttackTarget, nSecPwr);
      SendRefMsg (RM_10205, 0, m_nCurrX, m_nCurrY, NE_STRUCKCHUNMU, '0');
      bo21 := True;
      m_boChunMuSkill := 0;
    end;
  end;

  nCheckCode:=1;
  if (wHitMode = 4) then begin  //어검술
    nSecPwr:=0;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
      nCheckCode:=11;
      if m_MagicErgumSkill <> nil then begin
        nCheckCode:=12;
        nSecPwr:=ROUND(nPower / (m_MagicErgumSkill.MagicInfo.btTrainLv + 2) * (m_MagicErgumSkill.btLevel + 2));
        nCheckCode:=13;
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then SwordLongAttack(nSecPwr);
  end;
  nCheckCode:=1000;
  if (wHitMode = 5) then begin      //반월검법
    nSecPwr:=0;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
      if m_MagicBanwolSkill <> nil then begin
        nSecPwr:=ROUND(nPower / (m_MagicBanwolSkill.MagicInfo.btTrainLv + 10) * (m_MagicBanwolSkill.btLevel + 2));
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then SwordWideAttack(nSecPwr);
  end;
  nCheckCode:=1001;
  if (wHitMode = 8) then begin     //광풍참
    nSecPwr:=0;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if m_MagicCrsSkill <> nil then begin
        nSecPwr:=ROUND(nPower / (m_MagicCrsSkill.MagicInfo.btTrainLv + 11) * (m_MagicCrsSkill.btLevel + 3));
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then CrsWideAttack(nSecPwr);
  end;

  if (wHitMode = 29) then begin     //난화혈풍참
    nSecPwr:=0;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
      if m_MagicNanCrsSkill <> nil then begin
        nSecPwr := ROUND(nPower + GetPower(MPow(m_MagicNanCrsSkill), m_MagicNanCrsSkill));
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then NanCrsWideAttack(nSecPwr);
  end;

  nCheckCode:=1002;
  if (wHitMode = 28) then begin    //회풍천봉법
    nPower:=GetAttackPower(LoWord(m_WAbil.SC),SmallInt((HiWord(m_WAbil.SC) - LoWord(m_WAbil.SC))));
    nSecPwr:=0;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if m_MagicCrsBongskill <> nil then begin
        nSecPwr:=ROUND(nPower / (m_MagicCrsBongskill.MagicInfo.btTrainLv + 11) * (m_MagicCrsBongskill.btLevel + 3));
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then CIDAttack(nSecPwr);
  end;

  nCheckCode:=1003;
  if (wHitMode = 9) and (AttackTarget <> nil) then begin    //쌍룡참
     nPower := nPower + m_nHitPlus;
     nSecPwr := nPower;
     nCheckCode:=1004;
     DirectAttack (AttackTarget, nSecPwr);
         // 상태이상...스턴판정
     if (AttackTarget.m_wStatusTimeArr[POISON_STUN] = 0) and
         (Random(50) > AttackTarget.m_nAntiMagic) then begin   // 100->50
        MoC := 1;
        if AttackTarget.m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then MoC := 2;
           if ((MoC = 1) and (Random(90) < 5*(m_MagicTwnHitSkill.btLevel+1))) or
              ((MoC = 2) and (Random(90) < 2*(m_MagicTwnHitSkill.btLevel+1))) then begin
              Dur := Round(1.5 + 0.8 * m_MagicTwnHitSkill.btLevel);
              AttackTarget.MakePosion(POISON_STUN, Dur, 1);
           end;
     end;
     nCheckCode:=1005;
     if m_boTwinHitSkill = 1 then begin  //2쌍룡참 해제..
       m_boTwinHitSkill := 2;
     end;
  end;
  nCheckCode:=1004;
  if (wHitMode = 25) then begin  //타구봉법
    nSecPwr:=0;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      nCheckCode:=11;
      if m_MagicTaguSkill <> nil then begin
        nCheckCode:=12;
        Inc(nPower, m_nHitPlus);
        nSecPwr:=ROUND(nPower / (m_MagicTaguSkill.MagicInfo.btTrainLv + 2) * (m_MagicTaguSkill.btLevel + 2));
        nCheckCode:=13;
      end;
    end else nSecPwr:=nSecPwr;
    if nSecPwr > 0 then TaguLongAttack(nSecPwr);
  end;
  nCheckCode:=1005;
  if (wHitMode = 26) then begin    //뇌룡봉법
     nSecPwr:=0;
     if m_btRaceServer = RC_PLAYOBJECT then begin
       nCheckCode:=11;
       if m_MagicThunderShaolin <> nil then begin
         nCheckCode:=12;
         Inc(nPower, m_nHitPlus * 2);
         nSecPwr:=ROUND(nPower / (m_MagicThunderShaolin.MagicInfo.btTrainLv + 1) * (m_MagicThunderShaolin.btLevel + 1));
         nCheckCode:=13;
       end;
     end else nSecPwr:=nSecPwr;
     if nSecPwr > 0 then begin
        ThunderLongAttack (nSecPwr);
        ThunderLongAttack2 (nSecPwr);
     end;
     if (AttackTarget <> nil) then begin
       if (AttackTarget.m_wStatusTimeArr[POISON_STUN] = 0) and
         (Random(50) > AttackTarget.m_nAntiMagic) then begin   // 100->50
          MoC := 1;
          if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then MoC := 2;
          if ((MoC = 1) and (Random(90) < 5*(m_MagicThunderShaolin.btLevel+1))) or
             ((MoC = 2) and (Random(90) < 2*(m_MagicThunderShaolin.btLevel+1))) then begin
              Dur := Round(1.5 + 0.8 * m_MagicThunderShaolin.btLevel);
             AttackTarget.MakePosion(POISON_STUN, Dur, 1);
          end;
       end;
     end;
     if m_boThunderHitSkill = 1 then begin  //2뇌룡봉법 해제..
       m_boThunderHitSkill := 2;
     end;
  end;

  if (wHitMode = 27) then begin //천화봉법
    nPower := nPower + m_nHitPlus;

    if m_btRaceServer = RC_PLAYOBJECT then begin
      if m_MagicFireShaolin <> nil then begin
        nPower:=nPower + ROUND(nPower / 100 * (m_nHitDouble * 5));
      end;
    end;
    if nPower > 0 then TaguLongAttack(nPower);
    if m_boFireShaolinSkill = 1 then begin  //천화봉법 해제..
       m_boFireShaolinSkill := 2;
     end;
  end;

  nCheckCode:=2;

  if (wHitMode in [15, 18]) then begin     //풍검술
    nSecPwr:=0;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin
      if m_MagicWindbladeSkill <> nil then begin    //풍검술
       nPower:=nPower - ROUND(nPower / (m_nHitDouble))*2;
       nSecPwr:=ROUND(nPower / (m_MagicWindbladeSkill.MagicInfo.btTrainLv + 10) * (m_MagicWindbladeSkill.btLevel + 2));
       if m_btRaceServer = RC_HEROOBJECT then begin
         if AttackTarget = nil then exit; //004C218D
         if nPower > 0 then begin
           nPower:=AttackTarget.GetHitStruckDamage(Self,nPower);
           AttackTarget.SetLastHiter(self);
           AttackTarget.StruckDamage(nPower);
           AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK),RM_10101,nPower,AttackTarget.m_WAbil.HP,AttackTarget.m_WAbil.MaxHP,Integer(Self),'',600);
         end;
       end;
      end;
    end else
    nSecPwr:=nSecPwr;
    if (nSecPwr > 0) and (m_wStatusTimeArr[STATE_WINDMOON] > 0) then CrsWindbladeAttack(nSecPwr); //풍검술 강화
  end;


  nCheckCode:=3;



  if AttackTarget = nil then exit; //004C218D

  nCheckCode:=4;
  if IsProperTarget{0FFF4}(AttackTarget) then begin
    nCheckCode:=41;
    if AttackTarget.m_btHitPoint > 0 then begin
      if (m_btHitPoint < Random(AttackTarget.m_btSpeedPoint)) then begin
        nCheckCode:=42;
        nPower:=0;
      end;
    end;
    nCheckCode:=43;
  end else nPower:=0;
  nCheckCode:=5;
  if nPower > 0 then begin
    nPower:=AttackTarget.GetHitStruckDamage(Self,nPower);
    nWeaponDamage:=(Random(5) + 2) - m_AddAbil.btWeaponStrong;   //단단한 무기는 내구가 잘 안단다.
  end;
  nCheckCode:=600;
  if nPower > 0 then begin     //004C21FC
    nCheckCode:=601;

    if bo22 and (m_AssassinHitSkill <> nil) then begin    //절명검법
      AttackTarget.SendRefMsg (RM_10205, 0, AttackTarget.m_nCurrX, AttackTarget.m_nCurrY, 28{ NE_ASSASSINHIT}, '0');  //절명검법 이팩트
      if (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
        (m_AssassinHitSkill.btLevel < 3) and
        (m_AssassinHitSkill.MagicInfo.TrainLevel[m_AssassinHitSkill.btLevel] <= m_Abil.Level) then begin
        TrainSkill(m_AssassinHitSkill, Random(2) + 1);
        if not CheckMagicLevelup(m_AssassinHitSkill) then begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_AssassinHitSkill.MagicInfo.wMagicId, m_AssassinHitSkill.btLevel, m_AssassinHitSkill.nTranPoint, '', 3000);
        end;
      end;
    end;

    if bo23 and (m_MagicVampSkill <> nil) then begin    //흡기
      if (m_btRaceServer = RC_PLAYOBJECT) and (m_MagicVampSkill.btLevel < 3) and
        (m_MagicVampSkill.MagicInfo.TrainLevel[m_MagicVampSkill.btLevel] <= m_Abil.Level) then begin
        TPlayObject(Self).TrainSkill(m_MagicVampSkill, Random(2) + 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicVampSkill) then begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicVampSkill.MagicInfo.wMagicId, m_MagicVampSkill.btLevel, m_MagicVampSkill.nTranPoint, '', 3000);
        end;
      end;
      nManaPower := ((m_Abil.MaxMP div 100) * 2) * Random(m_MagicVampSkill.btLevel + 2) + Random(m_MagicVampSkill.btLevel * 5 + 1);
      Attacktarget.DamageSpell(nManaPower);
      Attacktarget.HealthSpellChanged();
      AttackTarget.SendRefMsg(RM_10205, 0, AttackTarget.m_nCurrX, AttackTarget.m_nCurrY, NE_MANAEATERT, '0');   //흡기 이팩트
      if m_WAbil.MP + nManaPower > m_WAbil.MaxMP then begin
        m_WAbil.MP := m_WAbil.MaxMP;
      end else m_WAbil.MP := m_WAbil.MP + nManaPower;
      HealthSpellChanged();
      SendDelayRefMsg(RM_10205,0, m_nCurrX, m_nCurrY, NE_MANAEATERS,'0', 300);   //흡기 이팩트 본인
    end;

    if bo24 and (m_MagicHemorrhageSkill <> nil) then begin    //혈풍격
      AttackTarget.SendRefMsg (RM_10205, 0, AttackTarget.m_nCurrX, AttackTarget.m_nCurrY, NE_HEMORRHAGE, IntToStr(Random(5)));  //혈풍격 이팩트
      nPower := nPower + m_nHitPlus;
       // 상태이상...스턴판정
      if (AttackTarget.m_wStatusTimeArr[POISON_HEMORRHAGE] = 0) and
        (Random(50) > AttackTarget.m_nAntiMagic) then begin   // 100->50
        MoC := 1;
        if AttackTarget.m_btRaceServer = RC_PLAYOBJECT then MoC := 2;
        if ((MoC = 1) and (Random(55) < 5*(m_MagicHemorrhageSkill.btLevel+1))) or
            ((MoC = 2) and (Random(50) < 2*(m_MagicHemorrhageSkill.btLevel+1))) then begin
           Dur := Round( m_nLuck + 3 + 5 * m_MagicHemorrhageSkill.btLevel );
           AttackTarget.MakePosion(POISON_HEMORRHAGE, Dur, nPower);
        end;
      end;
      if (m_btRaceServer = RC_PLAYOBJECT) and
        (m_MagicHemorrhageSkill.btLevel < 3) and
        (m_MagicHemorrhageSkill.MagicInfo.TrainLevel[m_MagicHemorrhageSkill.btLevel] <= m_Abil.Level) then begin
         TPlayObject(Self).TrainSkill(m_MagicHemorrhageSkill, Random(2) + 1);
         if not TPlayObject(Self).CheckMagicLevelup(m_MagicHemorrhageSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicHemorrhageSkill.MagicInfo.wMagicId, m_MagicHemorrhageSkill.btLevel, m_MagicHemorrhageSkill.nTranPoint, '', 3000);
         end;
      end;
    end;



    AttackTarget.SetLastHiter(self);
    AttackTarget.StruckDamage(nPower);
    nCheckCode:=602;

    AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK),RM_10101,nPower,AttackTarget.m_WAbil.HP,AttackTarget.m_WAbil.MaxHP,Integer(Self),'',200);
    nCheckCode:=603;
    if not AttackTarget.m_boUnParalysis and m_boParalysis and (Random(AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate{5}) = 0) then begin
      nCheckCode:=604;
      AttackTarget.MakePosion(POISON_STONE,g_Config.nAttackPosionTime{5},0);
    end;
    if m_boAllParalysis and (Random(100 - g_Config.nAttackSuperPosionRate) = 0) then begin
      nCheckCode:=604;
      AttackTarget.MakePosion(POISON_STONE,g_Config.nAttackPosionTime{5},0);
    end;
   // end;
    nCheckCode:=605;
    //때리는자가 (체력 흡수)
    if SuckupEnemyHealthRate > 0 then begin
      SuckupEnemyHealth := SuckupEnemyHealth + (nPower / 100 * SuckupEnemyHealthRate);
      if SuckupEnemyHealth >= 2 then begin
        n30 := Trunc (SuckupEnemyHealth);
        SuckupEnemyHealth := SuckupEnemyHealth - n30;
        DamageHealth (-n30);
      end;
    end;
    //때리는자가 (마력 흡수)
    if SuckupEnemyManaRate > 0 then begin
      SuckupEnemyMana := SuckupEnemyMana + (nPower / 100 * SuckupEnemyManaRate);
      if SuckupEnemyMana >= 2 then begin
        n40 := Trunc (SuckupEnemyMana);
        SuckupEnemyMana := SuckupEnemyMana - n40;
        DamageSpell (-n40);
      end;
    end;
    nCheckCode:=606;
    if (m_MagicOneSwordSkill <> nil) and    //외수검법
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicOneSwordSkill.btLevel < 3) and
       (m_MagicOneSwordSkill.MagicInfo.TrainLevel[m_MagicOneSwordSkill.btLevel] <= m_Abil.Level) then begin
      nCheckCode:=607;
      TrainSkill(m_MagicOneSwordSkill,Random(3) + 1);
      nCheckCode:=608;
      if not CheckMagicLevelup(m_MagicOneSwordSkill) then begin
        nCheckCode:=609;
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicOneSwordSkill.MagicInfo.wMagicId,m_MagicOneSwordSkill.btLevel,m_MagicOneSwordSkill.nTranPoint,'',3000);
      end;
      nCheckCode:=610;
    end;

    if (m_MagicGukCheSkill <> nil) and    //격체전공
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicGukCheSkill.btLevel < 3) and
       (m_MagicGukCheSkill.MagicInfo.TrainLevel[m_MagicGukCheSkill.btLevel] <= m_Abil.Level) then begin
      nCheckCode:=607;
      TrainSkill(m_MagicGukCheSkill,Random(3) + 1);
      nCheckCode:=608;
      if not CheckMagicLevelup(m_MagicGukCheSkill) then begin
        nCheckCode:=609;
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicGukCheSkill.MagicInfo.wMagicId,m_MagicGukCheSkill.btLevel,m_MagicGukCheSkill.nTranPoint,'',3000);
      end;
      nCheckCode:=610;
    end;

    if bo21 and (m_MagicPowerHitSkill <> nil) and     //예도검법
      (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
      (m_MagicPowerHitSkill.btLevel < 3) and
      (m_MagicPowerHitSkill.MagicInfo.TrainLevel[m_MagicPowerHitSkill.btLevel] <= m_Abil.Level) then begin
      nCheckCode:=611;
      TrainSkill(m_MagicPowerHitSkill,Random(3) + 1);
      nCheckCode:=612;
      if not CheckMagicLevelup(m_MagicPowerHitSkill) then begin
        nCheckCode:=613;
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicPowerHitSkill.MagicInfo.wMagicId,m_MagicPowerHitSkill.btLevel,m_MagicPowerHitSkill.nTranPoint,'',3000);
      end;
      nCheckCode:=614;
    end;

    nCheckCode:=6;
    if (wHitMode = 4) and (m_MagicErgumSkill <> nil) and       //어검술
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicErgumSkill.btLevel < 3) and
       (m_MagicErgumSkill.MagicInfo.TrainLevel[m_MagicErgumSkill.btLevel] <= m_Abil.Level) then begin
      nCheckCode:=61;
      TrainSkill(m_MagicErgumSkill, 1);
      nCheckCode:=62;
      if not CheckMagicLevelup(m_MagicErgumSkill) then begin
        nCheckCode:=63;
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicErgumSkill.MagicInfo.wMagicId,m_MagicErgumSkill.btLevel,m_MagicErgumSkill.nTranPoint,'',3000);
      end;
    end;
    if (wHitMode = 25) and (m_MagicTaguSkill <> nil) and     //타구봉법
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicTaguSkill.btLevel < 3) and
       (m_MagicTaguSkill.MagicInfo.TrainLevel[m_MagicTaguSkill.btLevel] <= m_Abil.Level) then begin
      nCheckCode:=61;
      TrainSkill(m_MagicTaguSkill, 1);
      nCheckCode:=62;
      if not CheckMagicLevelup(m_MagicTaguSkill) then begin
        nCheckCode:=63;
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicTaguSkill.MagicInfo.wMagicId,m_MagicTaguSkill.btLevel,m_MagicTaguSkill.nTranPoint,'',3000);
      end;
    end;


    nCheckCode:=7;
    if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) and    //반월검법
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicBanwolSkill.btLevel < 3) and
       (m_MagicBanwolSkill.MagicInfo.TrainLevel[m_MagicBanwolSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicBanwolSkill,1);
      if not CheckMagicLevelup(m_MagicBanwolSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicBanwolSkill.MagicInfo.wMagicId,m_MagicBanwolSkill.btLevel,m_MagicBanwolSkill.nTranPoint,'',3000);
      end;
    end;
    if (wHitMode = 15) and (m_MagicWindbladeSkill <> nil) and      //풍검술
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicWindbladeSkill.btLevel < 3) and
       (m_MagicWindbladeSkill.MagicInfo.TrainLevel[m_MagicWindbladeSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicWindbladeSkill,1);
      if not CheckMagicLevelup(m_MagicWindbladeSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicWindbladeSkill.MagicInfo.wMagicId,m_MagicWindbladeSkill.btLevel,m_MagicWindbladeSkill.nTranPoint,'',3000);
      end;
    end;

    nCheckCode:=8;
    if (wHitMode = 7) and (m_MagicFireSwordSkill <> nil) and     //염화결
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicFireSwordSkill.btLevel < 3) and
       (m_MagicFireSwordSkill.MagicInfo.TrainLevel[m_MagicFireSwordSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicFireSwordSkill, 1);
      if not CheckMagicLevelup(m_MagicFireSwordSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicFireSwordSkill.MagicInfo.wMagicId,m_MagicFireSwordSkill.btLevel,m_MagicFireSwordSkill.nTranPoint,'',3000);
      end;
    end;

    if (wHitMode = 10) and (m_MagicDeathSwordSkill <> nil) and
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicDeathSwordSkill.btLevel < 3) and
       (m_MagicDeathSwordSkill.MagicInfo.TrainLevel[m_MagicDeathSwordSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicDeathSwordSkill, 1);
      if not CheckMagicLevelup(m_MagicDeathSwordSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicDeathSwordSkill.MagicInfo.wMagicId,m_MagicDeathSwordSkill.btLevel,m_MagicDeathSwordSkill.nTranPoint,'',3000);
      end;
    end;

    if (wHitMode = 8) and (m_MagicCrsSkill <> nil) and
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicCrsSkill.btLevel < 3) and
       (m_MagicCrsSkill.MagicInfo.TrainLevel[m_MagicCrsSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicCrsSkill, 1);
      if not CheckMagicLevelup(m_MagicCrsSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicCrsSkill.MagicInfo.wMagicId,m_MagicCrsSkill.btLevel,m_MagicCrsSkill.nTranPoint,'',3000);
      end;
    end;

    if (wHitMode = 29) and (m_MagicNanCrsSkill <> nil) and     //난화혈풍참
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicNanCrsSkill.btLevel < 3) and
       (m_MagicNanCrsSkill.MagicInfo.TrainLevel[m_MagicNanCrsSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicNanCrsSkill, 1);
      if not CheckMagicLevelup(m_MagicNanCrsSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicNanCrsSkill.MagicInfo.wMagicId,m_MagicNanCrsSkill.btLevel,m_MagicNanCrsSkill.nTranPoint,'',3000);
      end;
    end;

    if (wHitMode = 28) and (m_MagicCrsBongskill <> nil) and
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicCrsBongskill.btLevel < 3) and
       (m_MagicCrsBongskill.MagicInfo.TrainLevel[m_MagicCrsBongskill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicCrsBongskill, 1);
      if not CheckMagicLevelup(m_MagicCrsBongskill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicCrsBongskill.MagicInfo.wMagicId,m_MagicCrsBongskill.btLevel,m_MagicCrsBongskill.nTranPoint,'',3000);
      end;
    end;


    if (wHitMode = 9) and (m_MagicTwnHitSkill <> nil) and        //쌍룡참
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicTwnHitSkill.btLevel < 3) and
       (m_MagicTwnHitSkill.MagicInfo.TrainLevel[m_MagicTwnHitSkill.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicTwnHitSkill, 1);
      if not CheckMagicLevelup(m_MagicTwnHitSkill) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicTwnHitSkill.MagicInfo.wMagicId,m_MagicTwnHitSkill.btLevel,m_MagicTwnHitSkill.nTranPoint,'',3000);
      end;
    end;

    if (wHitMode = 26) and (m_MagicThunderShaolin <> nil) and        //뇌룡봉법
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicThunderShaolin.btLevel < 3) and
       (m_MagicThunderShaolin.MagicInfo.TrainLevel[m_MagicThunderShaolin.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicThunderShaolin, 1);
      if not CheckMagicLevelup(m_MagicThunderShaolin) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicThunderShaolin.MagicInfo.wMagicId,m_MagicThunderShaolin.btLevel,m_MagicThunderShaolin.nTranPoint,'',3000);
      end;
    end;

    if (wHitMode = 27) and (m_MagicFireShaolin <> nil) and        //천화봉법
       (m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT]) and
       (m_MagicFireShaolin.btLevel < 3) and
       (m_MagicFireShaolin.MagicInfo.TrainLevel[m_MagicFireShaolin.btLevel] <= m_Abil.Level) then begin

      TrainSkill(m_MagicFireShaolin, 1);
      if not CheckMagicLevelup(m_MagicFireShaolin) then begin
        SendDelayMsg(Self,RM_MAGIC_LVEXP,0,m_MagicFireShaolin.MagicInfo.wMagicId,m_MagicFireShaolin.btLevel,m_MagicFireShaolin.nTranPoint,'',3000);
      end;
    end;

    if ((wHitMode = 22) or (wHitMode = 23)) and (m_MagicChunMuSkill <> nil) and    //천무 예도 염화결
       (m_btRaceServer = RC_PLAYOBJECT) and (m_MagicChunMuSkill.btLevel < 3) then begin
        if (m_MagicChunMuSkill.MagicInfo.TrainLevel[m_MagicChunMuSkill.btLevel] <= m_Abil.Level) then begin
          TPlayObject(Self).TrainSkill(m_MagicChunMuSkill, Random(2) + 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicChunMuSkill) then begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicChunMuSkill.MagicInfo.wMagicId, m_MagicChunMuSkill.btLevel, m_MagicChunMuSkill.nTranPoint, '', 3000);
          end;
        end;
    end;


    Result:=True;
  end; //004C270C
  nCheckCode:=9;
  if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then
    DoDamageWeapon(nWeaponDamage);

  //Not needed (RM_10101 up above is sent)
//  if AttackTarget.m_btRaceServer <> RC_PLAYOBJECT then
//    AttackTarget.SendMsg(AttackTarget,RM_STRUCK,nPower,AttackTarget.m_WAbil.HP,AttackTarget.m_WAbil.MaxHP,Integer(Self),'');
except
  on e: Exception do begin
    MainOutMessage(format(sExceptionMsg,[m_sCharName,nCheckCode]));
    MainOutMessage(E.Message);
  end;
end;
end;

procedure TBaseObject.SendAttackMsg(wIdent: Word; btDir: Byte; nX,nY: Integer);//004C2E0C
begin
  SendRefMsg(wIdent,btDir,nX,nY,0,'');
end;

function TBaseObject.GetHitStruckDamage(Target:TBaseObject;nDamage: integer): Integer; //004BDD20
var
  nArmor,nRnd:Integer;
  UserMagic: pTUserMagic;
  nMagLevel, nAmuletIdx: Integer;
  PlayObject: TPlayObject;
  nRate: Integer;
begin
  m_boUseGodShield := False;

  nRnd:=((HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1);
  if (nRnd > 0) then
    nArmor:=LoWord(m_WAbil.AC) + (Random(nRnd))
  else
    nArmor:=LoWord(m_WAbil.AC);

  nDamage:=_MAX(0, nDamage - nArmor);

  if (nDamage > 0) then begin
    if (m_btLifeAttrib = LA_UNDEAD) and (Target <> nil) then begin
      Inc(nDamage,Target.m_AddAbil.UndeadPower);
    end;
    if m_boAbilMagBubbleDefence then begin  //주술의막
      if m_wStatusTimeArr[STATE_WINDMOON] > 0 then nDamage:=ROUND((nDamage / 130) * (m_btMagBubbleDefenceLevel + 2) * 8.0)  //주술의막 강화
      else nDamage:=ROUND((nDamage / 100) * (m_btMagBubbleDefenceLevel + 2) * 8.0);
      DamageBubbleDefence(nDamage);
    end;
    if m_boAbilMagProtectDefence then begin  //호신강기
      nDamage:=ROUND((nDamage / 100) * (m_btMagProtectDefenceLevel + 2) * 8.0);
      DamageProtectDefence(nDamage);
    end;
    if m_boAbilCelestialDefence then begin     //선천
      nDamage:=ROUND((nDamage / 100) * (m_btCelestialDefenceLevel + 2) * 8.0);
      DamageCelestialDefence(nDamage);
    end;
    if m_boAbilMagKumGangDefence then begin     //금강불괴
      nDamage:=ROUND((nDamage / 100) * (m_btMagKumGangDefenceLevel + 2) * 8.0);
    end;
  end;

  if m_btRaceServer = RC_PLAYOBJECT then begin
    PlayObject := TPlayObject(Self);
    UserMagic := PlayObject.GetMagicInfo(SKILL_EMBRACE);
    if (nDamage > 0) and (Assigned(UserMagic)) then begin
      case UserMagic.btLevel of
          1: begin
              nMagLevel := 20;
              nRate := 20;
            end;
          2: begin
              nMagLevel := 30;
              nRate := 30;
            end;
          3: begin
              nMagLevel := 40;
              nRate := 40;
            end;
          else begin
              nMagLevel := 10;
              nRate := 10;
            end;
      end;
      if Random(100) < nMagLevel then begin
        if PlayObject.CheckAmulet(1, 6, nAmuletIdx) then begin        //진신사리 확인
          PlayObject.UseAmulet(1, 6, nAmuletIdx);
          m_boUseGodShield := True;
          nDamage := nDamage - ROUND(nRate / 100 * nDamage);
          if nDamage <= 0 then
            nDamage := 1;
        end;
      end;
    end;
  end;

  Result:=nDamage;
end;

function TBaseObject.GetMagStruckDamage(BaseObject:TBaseObject;nDamage: Integer): Integer; //004BDDEC
var
  n14:Integer;
  nMagLevel, nAmuletIdx: Integer;
  nRate: Integer;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  m_boUseGodShield := False;

  n14:=LoWord(m_WAbil.MAC) + Random(SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)) + 1);
  nDamage:=_MAX(0,nDamage - n14);
  if (m_btLifeAttrib = LA_UNDEAD) and (BaseObject <> nil) then begin
    Inc(nDamage,m_AddAbil.UndeadPower);
  end;
  if (nDamage > 0) and m_boAbilMagBubbleDefence then begin     //주술의막
    if m_wStatusTimeArr[STATE_WINDMOON] > 0 then nDamage:=ROUND((nDamage / 130) * (m_btMagBubbleDefenceLevel + 2) * 8.0) //주술의막 강화
    else nDamage:=ROUND((nDamage / 100) * (m_btMagBubbleDefenceLevel + 2) * 8.0);
    DamageBubbleDefence(nDamage);
  end;
  if (nDamage > 0) and m_boAbilMagProtectDefence then begin     //호신강기
    nDamage:=ROUND((nDamage / 100) * (m_btMagProtectDefenceLevel + 2) * 8.0);
    DamageProtectDefence(nDamage);
  end;
  if (nDamage > 0) and m_boAbilCelestialDefence then begin     //선천기공
    nDamage:=ROUND((nDamage / 100) * (m_btCelestialDefenceLevel + 2) * 8.0);
    DamageCelestialDefence(nDamage);
  end;
  if (nDamage > 0) and m_boAbilMagKumGangDefence then begin     //금강불괴
    nDamage:=ROUND((nDamage / 130) * (m_btMagKumGangDefenceLevel + 2) * 8.0);
  end;
  if m_btRaceServer = RC_PLAYOBJECT then begin
    PlayObject := TPlayObject(Self);
    UserMagic := PlayObject.GetMagicInfo(SKILL_EMBRACE);
    if (nDamage > 0) and (Assigned(UserMagic)) then begin
      case UserMagic.btLevel of
          1: begin
              nMagLevel := 20;
              nRate := 20;
            end;
          2: begin
              nMagLevel := 30;
              nRate := 30;
            end;
          3: begin
              nMagLevel := 40;
              nRate := 40;
            end;
          else begin
              nMagLevel := 10;
              nRate := 10;
            end;
      end;
      if Random(100) < nMagLevel then begin
        if PlayObject.CheckAmulet(1, 6, nAmuletIdx) then begin        //진신사리 확인
          PlayObject.UseAmulet(1, 6, nAmuletIdx);
          m_boUseGodShield := True;
          nDamage := nDamage - ROUND(nRate / 100 * nDamage);
          if nDamage <= 0 then
            nDamage := 1;
        end;
      end;
    end;
  end;

  Result:=nDamage;
end;

//004BDEB8
procedure TBaseObject.StruckDamage(var nDamage: integer);
var
  I: Integer;
  nDam,nPower, nnX, nnY:integer;
  nDura,nOldDura:integer;
  boNeedRecalc:Boolean;
  ps: TItem;
  PlayObject: TPlayObject;
  StdItem:TItem;
  UserMagic: pTUserMagic;
begin
  if m_boUseGodShield then begin
    if m_btRaceServer = RC_PLAYOBJECT then begin
      PlayObject := TPlayObject(Self);
      UserMagic := PlayObject.GetMagicInfo(SKILL_EMBRACE);
      if Assigned(UserMagic) and (UserMagic.btLevel < 3) then begin
        if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <= PlayObject.m_Abil.Level then begin
          PlayObject.TrainSkill(UserMagic, Random(2) + 1);
          if not PlayObject.CheckMagicLevelup(UserMagic) then begin
            PlayObject.SendDelayMsg(PlayObject, SM_MAGIC_LVEXP, UserMagic.MagicInfo.wMagicId,
              UserMagic.btLevel, LoWord(UserMagic.nTranPoint),
              HiWord(UserMagic.nTranPoint), '', 3000);
          end;
        end;
      end;
    end;
    SendRefMsg(RM_SHOWEFFECT, EFFECT_SHIELD, Integer(Self), m_nCurrX, m_nCurrY, '');
  end;
  m_boUseGodShield := False;

  if nDamage <= 0 then exit;
  if m_btRaceServer = RC_PET then exit;
  nDam:=Random(10) + 5;
  if m_wStatusTimeArr[POISON_DAMAGEARMOR] > 0 then begin
    nDam:=ROUND(nDam * (g_Config.nPosionDamagarmor / 10){1.2});
    nDamage:=ROUND(nDamage * (g_Config.nPosionDamagarmor / 10){1.2});
  end;
  if m_wStatusTimeArr[POISON_STUN] > 0 then begin //when yellow from tdb do more damage
    nDamage:=ROUND(nDamage * 1.2);
  end;
  boNeedRecalc:=False;

  if (m_UseItems[U_DRESS].wIndex > 0) and m_boCanLooseDura then begin
   StdItem:=UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
    nDura:=m_UseItems[U_DRESS].Dura;
    nOldDura:=ROUND(nDura / 1000);
     Dec(nDura,nDam);
    if nDura <= 0 then begin
      m_UseItems[U_DRESS].Dura:=0;
      boNeedRecalc:=True;
      SendMsg(Self,RM_DURACHANGE,U_DRESS,nDura,m_UseItems[U_DRESS].DuraMax,0,'');
    end else begin
      m_UseItems[U_DRESS].Dura:=nDura;
    end;
    if nOldDura <> ROUND(nDura / 1000) then begin
      SendMsg(Self,RM_DURACHANGE,U_DRESS,nDura,m_UseItems[U_DRESS].DuraMax,0,'');
    end;
  end;
 // for I := Low(THumanUseItems) to High(THumanUseItems) do begin
  for I := U_DRESS to U_PETS5 do begin
    if not m_boCanLooseDura then Continue;
    if (m_UseItems[i].wIndex > 0) and (Random(8) = 0) and (i <> U_RIGHTHAND) and (i <> U_CHARM) and (i <> U_BUJUK) then begin
      if i = U_ARMRINGL then begin
        ps := UserEngine.GetStdItem (m_UseItems[i].wIndex);
         if ps <> nil then begin
                  //부적,독가루
            if ps.StdMode = 25 then continue;
         end;
      end;

      StdItem:=UserEngine.GetStdItem(m_UseItems[i].wIndex);

      nDura:=m_UseItems[i].Dura;
      nOldDura:=ROUND(nDura / 1000);
      Dec(nDura,nDam);
      if nDura <= 0 then begin
        if i in [U_PETS1..U_PETS5] then begin     //탈것 아이템 삭제
         SysMsg(UserEngine.GetStdItemName(m_UseItems[i].wIndex) + '凜넣씹봬쐴랍句呵。',c_RedWhite,t_Notice);
         m_UseItems[i].Dura:=0;
         boNeedRecalc:=True;
         SendMsg(Self,RM_DURACHANGE,i,nDura,m_UseItems[i].DuraMax,0,'');
         if m_btRaceServer = RC_PLAYOBJECT then begin
           PlayObject:=TPlayObject(Self);
           PlayObject.SendDelItems(@m_UseItems[i]);
         end;
         m_UseItems[i].wIndex:=0;
        end else begin
         SysMsg(UserEngine.GetStdItemName(m_UseItems[i].wIndex) + '돨넣씹봬쐴죄。',c_Red,t_Notice);
         m_UseItems[i].Dura:=0;
         boNeedRecalc:=True;
         SendMsg(Self,RM_DURACHANGE,i,nDura,m_UseItems[i].DuraMax,0,'');
        end;
      end else begin
        m_UseItems[i].Dura:=nDura;
      end;
      if nOldDura <> ROUND(nDura / 1000) then begin
        SendMsg(Self,RM_DURACHANGE,i,nDura,m_UseItems[i].DuraMax,0,'');
      end;
    end;
  end;
  if boNeedRecalc then begin
    RecalcAbilitys();
    SendMsg(Self,RM_ABILITY,0,0,0,0,'');
    SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  end;
  DamageHealth(nDamage);

end;


function TBaseObject.GetDirBaseObjectsCount(btDir, nRage: Integer): Integer;
var
  I, III: Integer;
  X, Y: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '{嫩끽} TBaseObject::GetDirectionBaseObjects';
begin
  Result := 0;
  try
    case btDir of
      DR_UP: begin //굇
          for y := m_nCurrY downto m_nCurrY - nRage{m_nCurrY to m_nCurrY + nRage} do begin //20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX , y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_UPRIGHT: begin//땜굇
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY -{+} I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_RIGHT: begin//땜
          for x := m_nCurrX to m_nCurrX + nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWNRIGHT: begin//땜켓
          for I := 0 to nRage do begin
            x := m_nCurrX + I;
            y := m_nCurrY +{-} I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWN: begin //켓
          for y := m_nCurrY to m_nCurrY + nRage{m_nCurrY downto m_nCurrY - nRage} do begin//20080405
            if m_PEnvir.GetMapCellInfo(m_nCurrX, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_DOWNLEFT: begin//鮫켓蕨
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY +{-} I;//20080405
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_LEFT: begin//鮫
          for x := m_nCurrX downto m_nCurrX - nRage do begin
            if m_PEnvir.GetMapCellInfo(x, m_nCurrY, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
      DR_UPLEFT: begin//鮫굇
          for I := 0 to nRage do begin
            x := m_nCurrX - I;
            y := m_nCurrY {+}- I;//20080404
            if m_PEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
              if MapCellInfo.ObjList.Count > 0 then begin//20080629
                for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
                  OSObject := pTOSObject(MapCellInfo.ObjList.Items[III]);
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    BaseObject := TBaseObject(OSObject.CellObj);
                    if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not BaseObject.m_boGhost) then begin
                      Inc(Result);
                    end;
                  end;
                end;//for
              end;
            end;
          end;
        end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TBaseObject.GeTBaseObjectInfo(): String; //004CF87C
begin
  Result:=m_sCharName + ' ' +
          'Map:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ') ' +
          'Co-Ord:' + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY) + ' ' +
          'Level:' + IntToStr(m_Abil.Level) + ' ' +
          'Exp:' + IntToStr(m_Abil.Exp) + ' ' +
          'HP: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) + ' ' +
          'MP: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) + ' ' +
          'DC: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) + ' ' +
          'MC: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) + ' ' +
          'SC: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) + ' ' +
          'AC: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) + ' ' +
          'MAC: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) + ' ' +
          'Hit:' + IntToStr(m_btHitPoint) + ' ' +
          'Speed:' + IntToStr(m_btSpeedPoint);
end;


function TBaseObject.GetBackPosition(var nX,nY: Integer): Boolean;     //004B2900
var
  Envir:TEnvirnoment;
begin
  Envir:=m_PEnvir;
  nX:=m_nCurrX;
  nY:=m_nCurrY;
  case m_btDirection of
    DR_UP: if nY < (Envir.m_nHeight - 1) then Inc(nY);
    DR_DOWN: if nY > 0 then Dec(nY);
    DR_LEFT: if nX < (Envir.m_nWidth - 1) then Inc(nX);
    DR_RIGHT: if nX > 0 then Dec(nX);
    DR_UPLEFT: begin
      if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
        Inc(nX);
        Inc(nY);
      end;
    end;
    DR_UPRIGHT: begin
      if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
        Dec(nX);
        Inc(nY);
      end
    end;
    DR_DOWNLEFT: begin
      if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
        Inc(nX);
        Dec(nY);
      end;
    end;
    DR_DOWNRIGHT: begin
      if (nX > 0) and (nY > 0) then begin
        Dec(nX);
        Dec(nY);
      end;
    end;
   end;
  Result:=True;
end;


function TBaseObject.GetBackPosition(btDirection: Byte; var nX, nY: Integer): Boolean;
var
  Envir: TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case btDirection of
    DR_UP: if nY < (Envir.m_nHeight - 1) then Inc(nY);
    DR_DOWN: if nY > 0 then Dec(nY);
    DR_LEFT: if nX < (Envir.m_nWidth - 1) then Inc(nX);
    DR_RIGHT: if nX > 0 then Dec(nX);
    DR_UPLEFT: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_UPRIGHT: begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
          Dec(nX);
          Inc(nY);
        end
      end;
    DR_DOWNLEFT: begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_DOWNRIGHT: begin
        if (nX > 0) and (nY > 0) then begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;

function TBaseObject.GetBackPosition2(var nX,nY: Integer): Boolean;     //004B2900
var
  Envir:TEnvirnoment;
begin
  Envir:=m_PEnvir;
  nX:=m_nCurrX;
  nY:=m_nCurrY;
  case m_btDirection of
    DR_UP: if nY < (Envir.m_nHeight - 1) then Inc(nY, 3);
    DR_DOWN: if nY > 0 then Dec(nY, 3);
    DR_LEFT: if nX < (Envir.m_nWidth - 1) then Inc(nX, 3);
    DR_RIGHT: if nX > 0 then Dec(nX, 3);
    DR_UPLEFT: begin
      if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then begin
        Inc(nX, 3);
        Inc(nY, 3);
      end;
    end;
    DR_UPRIGHT: begin
      if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then begin
        Dec(nX, 3);
        Inc(nY, 3);
      end
    end;
    DR_DOWNLEFT: begin
      if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then begin
        Inc(nX, 3);
        Dec(nY, 3);
      end;
    end;
    DR_DOWNRIGHT: begin
      if (nX > 0) and (nY > 0) then begin
        Dec(nX, 3);
        Dec(nY, 3);
      end;
    end;
   end;
  Result:=True;
end;

procedure TAnimalObject.HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: integer; boFlag: Boolean); //004C2E40
var
  I: Integer;
  nDamage:Integer;
  BaseObjectList:TList;
  BaseObject:TBaseObject;
begin
  m_btDirection:=GetNextDirection(m_nCurrx,m_nCurrY,TargeTBaseObject.m_nCurrX,TargeTBaseObject.m_nCurrY);
  BaseObjectList:=TList.Create;
  m_PEnvir.GeTBaseObjects(TargeTBaseObject.m_nCurrX,TargeTBaseObject.m_nCurrY,False,BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do begin
    BaseObject:=TBaseObject(BaseObjectList.Items[I]);
    if IsProperTarget(BaseObject) then begin
      nDamage:=0;
      Inc(nDamage,BaseObject.GetHitStruckDamage(Self,nHitPower));
      Inc(nDamage,BaseObject.GetMagStruckDamage(Self,nMagPower));
      if nDamage > 0 then begin
        BaseObject.StruckDamage(nDamage);
        BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK),RM_10101,nDamage,BaseObject.m_WAbil.HP,BaseObject.m_WAbil.MaxHP,Integer(Self),'',200);
      end;
    end;
  end;
  FreeAndNil(BaseObjectList);
  SendRefMsg(RM_HIT,m_btDirection,m_nCurrX,m_nCurrY,0,'');
end;

procedure TAnimalObject.DelTargetCreat;
begin
  inherited;
  m_nTargetX:=-1;
  m_nTargetY:=-1;
end;
procedure TAnimalObject.SearchTarget; //004C94B4
var
  BaseObject,BaseObject18:TBaseObject;
  i,nC,n10:integer;
begin
  BaseObject18:=nil;
  n10:=999;
  for i:=0 to m_VisibleActors.Count -1 do begin
    BaseObject:=pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject;
    if not BaseObject.m_boDeath then begin
      if IsProperTarget(BaseObject) and
         (not BaseObject.m_boHideMode or m_boCoolEye) then begin
        nC:=abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
        if nC < n10 then begin
          n10:=nC;
          BaseObject18:=BaseObject;
        end;
      end;
    end;      
  end;
  if BaseObject18 <> nil then SetTargetCreat{FFF2}(BaseObject18);
end;
procedure TAnimalObject.sub_4C959C;//004C959C
var
  I,nC,n10:integer;
  Creat,BaseObject:TBaseObject;
begin
  Creat:=nil;
  n10:=999;
  for I := 0 to m_VisibleActors.Count - 1 do begin
    BaseObject:=pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject;
    if BaseObject.m_boDeath then Continue;
    if IsProperTarget(BaseObject) then begin
      nC:=abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
      if nC < n10 then begin
        n10:=nC;
        Creat:=BaseObject;
      end;
    end;
  end;    // for
  if Creat <> nil then
    SetTargetCreat(Creat);
end;
procedure TAnimalObject.SetTargetXY(nX, nY: Integer);//004C9668
begin
  m_nTargetX:= nX;
  m_nTargetY:= nY;
end;

procedure TAnimalObject.Wondering; //004C9810
begin
  if BoDontMove then exit;
  if (Random(20)= 0) then
    if (Random(4) = 1) then TurnTo(Random(8))
    else WalkTo(m_btDirection,False);
end;

function TBaseObject.MakePosion(nType, nTime, nPoint: Integer):Boolean;  //004C35A8
var
  nOldCharStatus:Integer;
begin
  Result:=False;

  if m_btRaceServer = RC_PET then exit;

  if (m_btRaceServer <> RC_PLAYOBJECT) and (m_NoPoison) and (nType in [2, 3]) then  exit;

  if (nType = POISON_STONE) and (nTime <> 1) then
  nTime := nTime - m_nPoisonRecover;   //중독회복
  if nTime <= 0 then Exit;

  if nType in [0..MAX_STATUS_ATTRIBUTE-1] then begin

    nOldCharStatus:=m_nCharStatus;
    if m_wStatusTimeArr[nType] > 0 then begin
      if nTime > m_wStatusTimeArr[nType] then
        m_wStatusTimeArr[nType]:=nTime;
    end else
      m_wStatusTimeArr[nType]:=nTime;

    m_dwStatusArrTick[nType]:=GetTickCount();
    m_nCharStatus:=GetCharStatus();

    if nType = POISON_HEMORRHAGE then begin
      HemorrhageLevel := nPoint;
    end;

    if nType = POISON_THUNDER then begin
      ThunderLevel := nPoint;
    end;

    m_btGreenPoisoningPoint:=nPoint;

    if nOldCharStatus <> m_nCharStatus then
      StatusChanged();
    if m_btRaceServer = RC_PLAYOBJECT then begin
      if nType = POISON_THUNDER then begin
        SysMsg ('콱굳쮸규죄。', c_Red,t_Hint);
      end else
      SysMsg ('콱櫓뗀죄。', c_Red,t_Hint);


      if (nType = POISON_DECHEALTH) then
      SendMsg (Self,RM_COOLBUFF, 85, 0, 83, nTime, '櫓뗀 - 넣崎딜沂: ');   //녹독
      if (nType = POISON_DAMAGEARMOR) then
      SendMsg (Self,RM_COOLBUFF, 86, 0, 84, nTime, '櫓뗀 - 슉됴렝徒: ');   //빨독
      if (nType = POISON_FREEZE) then
      SendMsg (Self,RM_COOLBUFF, 87, 0, 85, nTime, '깥떨 - 쐐岺盧땡: ');   //둔화
      if (nType = POISON_STUN) then
      SendMsg (Self,RM_COOLBUFF, 88, 0, 86, nTime, '杞仝 - 쐐岺盧땡: ');   //스턴
      if (nType = POISON_SLOWDOWN) then
      SendMsg (Self,RM_COOLBUFF, 89, 0, 87, nTime, '숑醵 - 盧땡、묑샌醵똑슉됴: ');   //둔화
      if (nType = POISON_STONE) then
      SendMsg (Self,RM_COOLBUFF, 90, 0, 88, nTime, '柯뺏 - 쐐岺盧땡: ');   //마비
      if (nType = POISON_HEMORRHAGE) then
      SendMsg (Self,RM_COOLBUFF, 91, 0, 92, nTime, '놔沂  - 넣崎딜沂: ');   //혈풍격
      if (nType = POISON_THUNDER) then
      SendMsg (Self,RM_COOLBUFF, 112, 0, 95, nTime, '金옹 - 넣崎딜沂: ');   //복호장
    end;
    Result:=True;
  end;  //004C366C

end;


function TBaseObject.sub_4DD704: Boolean; //004DD704
var
  I: Integer;
  SendMessage:pTSendMessage;
begin
  Result:=False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for I := 0 to m_MsgList.Count - 1 do begin
      SendMessage:=m_Msglist.Items[i];
      if SendMessage.wIdent = RM_10401 then begin
        Result:=True;
        break;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TPlayObject.SendChangeGuildName; //004DE5A4
begin
  if m_MyGuild <> nil then begin
    SendDefMessage(SM_CHANGEGUILDNAME,0,TGuild(m_MyGuild).nGuildMark,0,0,TGuild(m_MyGuild).sGuildName + '/' + m_sGuildRankName);
  end else begin
    SendDefMessage(SM_CHANGEGUILDNAME,0,0,0,0,'');
  end;    
end;

procedure TPlayObject.SendDelItemList(ItemList: TStringList); //004D0DAC
var
  I: Integer;
  s10:String;
begin
  s10:='';
  for I := 0 to ItemList.Count - 1 do begin
    s10:=s10 + ItemList.Strings[i] + '/' + IntToStr(Integer(ItemList.Objects[i])) + '/';
  end;
  m_DefMsg:=MakeDefaultMsg(SM_DELITEMS,0,0,0,ItemList.Count);
  SendSocket(@m_DefMsg,EncodeString(s10));
end;

procedure TPlayObject.SendDelItems(UserItem: pTUserItem);//004D0BDC
var
  StdItem:TItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin
  StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then begin
    StdItem.GetStandardItem(ClientItem.S);
    opt := StdItem.GetItemAddValue(UserItem,ClientItem.S);
    sUserItemName := '';
    sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);
    ClientItem.MakeIndex:=UserItem.MakeIndex;
    ClientItem.Dura:=UserItem.Dura;
    ClientItem.DuraMax:=UserItem.DuraMax;
    ClientItem.Amount:=UserItem.Amount;
    ClientItem.UpgradeOpt := opt;
    m_DefMsg:=MakeDefaultMsg(SM_DELITEM,Integer(Self),0,0,1);
    SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
  end;
end;

// 아이템 업그레이드 파괴 효과를 위한 DelItem함수
procedure TPlayObject.SendDelItemWithFlag (UserItem: pTUserItem; wBreakdown: Word);       //스쳐
var
  StdItem:TItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin
  StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then begin
    StdItem.GetStandardItem(ClientItem.S);
    opt := StdItem.GetItemAddValue(UserItem,ClientItem.S);
    sUserItemName := '';
    sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

    ClientItem.MakeIndex:=UserItem.MakeIndex;
    ClientItem.Dura:=UserItem.Dura;
    ClientItem.DuraMax:=UserItem.DuraMax;
    ClientItem.Amount:=UserItem.Amount;
    ClientItem.UpgradeOpt := opt;
    m_DefMsg:=MakeDefaultMsg(SM_DELITEM,Integer(Self),0,wBreakdown,1);
    SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
  end;
end;

procedure TPlayObject.SendUpdateItem(UserItem: pTUserItem);//004D0A10
var
  StdItem:TItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin

  StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then begin
    StdItem.GetStandardItem(ClientItem.S);
    opt := StdItem.GetItemAddValue(UserItem,ClientItem.S);
    sUserItemName := '';
    sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

    ClientItem.MakeIndex:=UserItem.MakeIndex;
    ClientItem.Dura:=UserItem.Dura;
    ClientItem.DuraMax:=UserItem.DuraMax;
    ClientItem.Amount:=UserItem.Amount;
    ClientItem.UpgradeOpt := opt;
    m_DefMsg:=MakeDefaultMsg(SM_UPDATEITEM,Integer(Self),0,0,1);
    SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
  end;
end;


procedure TPlayObject.SendComUpdateItem(UserItem: pTUserItem);//004D0A10
var
  StdItem:TItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin

  StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then begin
    StdItem.GetStandardItem(ClientItem.S);
    opt := StdItem.GetItemAddValue(UserItem,ClientItem.S);
    sUserItemName := '';
    sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

    ClientItem.MakeIndex:=UserItem.MakeIndex;
    ClientItem.Dura:=UserItem.Dura;
    ClientItem.DuraMax:=UserItem.DuraMax;
    ClientItem.Amount:=UserItem.Amount;
    ClientItem.UpgradeOpt := opt;
    m_DefMsg:=MakeDefaultMsg(SM_COMUPDATEITEM,Integer(Self),0,0,1);
    SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
  end;
end;

function TPlayObject.CheckTakeOnItems(nWhere: Integer;var StdItem: TStdItem): Boolean; //004C5084
var
  Castle:TUserCastle;
  strtemp: string;
begin
  Result:=False;
  if (StdItem.StdMode in [10,12]) and (m_btGender <> gMan) then begin    //남자옷
    SysMsg(sWearNotOfWoMan,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode = 11) and (m_btGender <> gWoMan) then begin   //여자옷
    SysMsg(sWearNotOfMan,c_Red,t_Hint);
    exit;
  end;

  if StdItem.boOnlyHero then begin
    SysMsg('늪膠틔꼇角亶衿淚痰膠틔。', c_Red, t_Hint);
    Exit;
  end;


  if (StdItem.StdMode in [10,11,12]) and (StdItem.AniCount = 110) and m_PEnvir.Flag.boNOPENETRATE then begin
    SysMsg('뎠품貫零꼇콘賈痰。',c_Red,t_Hint);
    exit;
  end;

  if (StdItem.StdMode in [10,11,12]) and (StdItem.AniCount = 110) and (GetTickCount - m_PenetrateLastTick < 20 * 1000) then begin    //망자의옷
    SysMsg(IntToStr( 20 - (GetTickCount - m_PenetrateLastTick) div 1000) + '취鹿빈옵鹿賈痰。',c_Red,t_Hint);
    exit;
  end;

  //2005 빼빼로 이벤트 (2005/11/8~11/21)
   if StdItem.StdMode = 30 then begin
      if StdItem.Shape = 3 then begin
         //사랑의빼빼로는 연인이 없으면 착용할 수 없다.
         if TPlayObject(self).fLover <> nil then begin
            strtemp := TPlayObject(self).fLover.GetLoverName;
            if strtemp = '' then begin
               SysMsg ('怜唐졔훙꼽옵鹿陋구。',c_Red,t_Hint);
               exit;
            end;
         end;
      end else if StdItem.Shape = 4 then begin
         //호박머리는 연인이 있으면 착용할 수 없다.
         if TPlayObject(self).fLover <> nil then begin
            strtemp := TPlayObject(self).fLover.GetLoverName;
            if strtemp <> '' then begin
               SysMsg ('졔훙꼇콘陋구。',c_Red,t_Hint);
               exit;
            end;
         end;
      end;
   end;

  if (StdItem.CheckBonze) and not (m_btJob in [g_Bonze, g_BonzeUp]) then begin   //승려만착용
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [12, 90, 103]) and not (m_btJob in [g_Bonze, g_BonzeUp]) then begin //승려옷 무기 타직업 못 입음.  탈것
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [10, 11, 12, 90, 5, 6, 7, 99]) then begin     //승려가 착용가능한 아이템
    if (m_btJob in [g_Bonze, g_BonzeUp]) and not ( (StdItem.StdMode in [12, 90]) or ((StdItem.StdMode = 10) and (StdItem.Shape in [1, 2, 12]))
      or ((StdItem.StdMode in [5,6]) and (StdItem.Shape in [19])) or ((StdItem.StdMode in [7]) and (StdItem.Shape in [47,48])) ) then begin
      SysMsg(sWearNotOfJob,c_Red,t_Hint);
      exit;
    end;
  end;


  if (StdItem.StdMode = 99) and not (m_btJob in [3,8]) then begin   //99무기 자객만착용        //직업변경
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.HumUp = 1) and (m_btJob <> g_WarriorUp) then begin    //훔1 벽혈 전사만
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.HumUp = 2) and (m_btJob <> g_WizardUp) then begin    //훔2 홍현 술사만
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.HumUp = 3) and (m_btJob <> g_MonkUp)  then begin     //훔3 익선 도사만
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.HumUp = 4) and (m_btJob <> g_AssassinUp) then begin   //훔4 비연 자객만
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;

  if (StdItem.StdMode in [5,6,7]) and not (StdItem.Shape in [19,34..36,37,39..49,55,56,57,73..77]) and (m_btJob = g_WarriorUp) then begin  //벽혈전사 착용 무기
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [5,6,7]) and not (StdItem.Shape in [19,34..36,37,39..48,50,55,56,57,78..81]) and (m_btJob = g_WizardUp) then begin   //홍현술사 착용 무기
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [5,6,7]) and not (StdItem.Shape in [19,34..36,37,39..48,51,55,56,57,82..85]) and (m_btJob = g_MonkUp) then begin     //익선도사 착용 무기
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [5,6,7,99,90]) and not (StdItem.Shape in [19,34..36,37,39..48,55,56,57,86..89,98,100..102,104]) and (m_btJob = g_AssassinUp) then begin  //비연자객 착용 무기
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;

  if ((StdItem.StdMode = 10) or (StdItem.StdMode = 11)) and (StdItem.CheckNoAss) and (m_btJob = g_Assassin) then begin  //그래픽스 옷
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if ((StdItem.StdMode = 10) or (StdItem.StdMode = 11)) and ((StdItem.shape >= 100) or (StdItem.CheckAss)) {and (116 > StdItem.shape)} and (m_btJob <> g_Assassin) then begin //자객옷 타직업 못입음
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if ((StdItem.StdMode = 10) or (StdItem.StdMode = 11)) and (((StdItem.Shape > 2) and (StdItem.shape < 9)) or ((StdItem.Shape > 12) and (StdItem.shape < 19))) and (m_btJob = g_Assassin) then begin    //전사,술사,도사 옷중 자객 착용 가능
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if ((StdItem.StdMode = 10) or (StdItem.StdMode = 11)) and ((StdItem.Shape > 24) and (StdItem.shape < 28)) and (m_btJob = g_Assassin) then begin   //전사,술사,도사 옷중 자객 착용 가능
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if ((StdItem.StdMode = 10) or (StdItem.StdMode = 11)) and ((StdItem.Shape > 30) and (StdItem.shape < 34)) and (m_btJob = g_Assassin) then begin   //전사,술사,도사 옷중 자객 착용 가능
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [10,11,12]) and (StdItem.HumUp = 0) and not (StdItem.Shape in [0,9,10,11,30,111]) and not (m_btJob in [0..4]) then begin   //흄0 을 직업 0..3 이 아닌 캐릭(등선) 착용 할 경우
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [101]) and not (m_btJob in [0..4]) then begin   //탈것 등선 아닌켈       //직업변경
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (StdItem.StdMode in [102]) and not (m_btJob in [5..9]) then begin   //탈것 등선 켈       //직업변경
    SysMsg(sWearNotOfJob,c_Red,t_Hint);
    exit;
  end;
  if (nWhere = 1) or (nWhere = 2) then begin
    if StdItem.Weight > m_WAbil.MaxHandWeight then begin
      SysMsg(sHandWeightNot,c_Red,t_Hint);
      exit;
    end;
  end else begin
    if (StdItem.Weight + GetUserItemWeitht(nWhere)) > m_WAbil.MaxWearWeight then begin
      SysMsg(sWearWeightNot,c_Red,t_Hint);
      exit;
    end;
  end;
 // Castle:=g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of    //
    0: begin        //필요레벨
      if m_Abil.Level >= StdItem.NeedLevel then begin
        Result:=True;
      end else begin
        SysMsg(g_sLevelNot,c_Red,t_Hint);
      end;
    end;
    1: begin        //필요 파괴
      if HiWord(m_WAbil.DC) >= StdItem.NeedLevel then begin
        Result:=True;
      end else begin
        SysMsg(g_sDCNot,c_Red,t_Hint);
      end;
    end;
    2: begin     //필요마법
      if HiWord(m_WAbil.MC) >= StdItem.NeedLevel then begin
        Result:=True;
      end else begin
        SysMsg(g_sMCNot,c_Red,t_Hint);
      end;
    end;
    3: begin      //필요도력
      if HiWord(m_WAbil.SC) >= StdItem.NeedLevel then begin
        Result:=True;
      end else begin
        SysMsg(g_sSCNot,c_Red,t_Hint);
      end;
    end;
    8: begin      //필요 파괴 마법
      if (HiWord(m_WAbil.DC) >= StdItem.NeedLevel) and (HiWord(m_WAbil.SC) >= StdItem.NeedOption) then begin
        Result:=True;
      end else begin
        if (HiWord(m_WAbil.DC) < StdItem.NeedLevel) then
          SysMsg('묑샌제꼇璃。', c_Red, t_Hint);
        if (HiWord(m_WAbil.SC) < StdItem.NeedOption) then
          SysMsg('침랬제꼇璃。', c_Red, t_Hint);
      end;
    end;
    10: begin
      if( m_btJob = LoWord(StdItem.NeedLevel)) and (m_Abil.Level >= HiWord(StdItem.NeedLevel)) then begin
        Result:=True;
      end else begin
        SysMsg(g_sJobOrLevelNot,c_Red,t_Hint);
      end;
    end;
    11: begin
      if( m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel)) then begin
        Result:=True;
      end else begin
        SysMsg(g_sJobOrDCNot,c_Red,t_Hint);
      end;
    end;
    12: begin
      if( m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel)) then begin
        Result:=True;
      end else begin
        SysMsg(g_sJobOrMCNot,c_Red,t_Hint);
      end;
    end;
    13: begin
      if( m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel)) then begin
        Result:=True;
      end else begin
        SysMsg(g_sJobOrSCNot,c_Red,t_Hint);
      end;
    end;

    4: begin
      if m_btReLevel >= StdItem.NeedLevel then begin   //전직
        Result:=True;
      end else begin
        SysMsg(g_sReNewLevelNot,c_Red,t_Hint);
      end;
    end;
    40: begin
      if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
        if m_Abil.Level >= HiWord(StdItem.NeedLevel) then begin
          Result:=True;
        end else begin
          SysMsg(g_sLevelNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sReNewLevelNot,c_Red,t_Hint);
      end;
    end;
    41: begin
      if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
        if HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel) then begin
          Result:=True;
        end else begin
          SysMsg(g_sDCNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sReNewLevelNot,c_Red,t_Hint);
      end;
    end;
    42: begin
      if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
        if HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel) then begin
          Result:=True;
        end else begin
          SysMsg(g_sMCNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sReNewLevelNot,c_Red,t_Hint);
      end;
    end;
    43: begin
      if m_btReLevel >= LoWord(StdItem.NeedLevel) then begin
        if HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel) then begin
          Result:=True;
        end else begin
          SysMsg(g_sSCNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sReNewLevelNot,c_Red,t_Hint);
      end;
    end;

    6: begin  //문파
      if (m_MyGuild <> nil)then begin
        Result:=True;
      end else begin
        SysMsg(g_sGuildNot,c_Red,t_Hint);
      end;
    end;
    60: begin   //문파 문주
      if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then begin
        Result:=True;
      end else begin
        SysMsg(g_sGuildMasterNot,c_Red,t_Hint);
      end;
    end;
    7: begin
      Castle:=g_CastleManager.CastleMember(Self,'낡沽');
      if (m_MyGuild <> nil) and (Castle <> nil) then begin  //사북문
        Result:=True;
      end else begin
        SysMsg(g_sSabukHumanNot,c_Red,t_Hint);
      end;
    end;
    70: begin              //사북문주
      Castle:=g_CastleManager.CastleMember(Self,'낡沽');
      if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1) then begin
        if m_Abil.Level >= StdItem.NeedLevel then begin
          Result:=True;
        end else begin
          SysMsg(g_sLevelNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sSabukMasterManNot,c_Red,t_Hint);
      end;
    end;
    80: begin   //정복자
      Castle:=g_CastleManager.IsMasterCastleMember(Self);
      if (m_MyGuild <> nil) and (Castle <> nil) then begin
        if m_Abil.Level >= StdItem.NeedLevel then begin
          Result:=True;
        end else begin
          SysMsg(g_sLevelNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sCastleKingMan,c_Red,t_Hint);
      end;
    end;
    9: begin           //남만문원
      Castle:=g_CastleManager.CastleMember(Self,'켓찮');
      if (m_MyGuild <> nil) and (Castle <> nil) then begin
        Result:=True;
      end else begin
        SysMsg(g_sNammanHumanNot,c_Red,t_Hint);
      end;
    end;
    90: begin   //남만성문주
      Castle:=g_CastleManager.CastleMember(Self,'켓찮');
      if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1) then begin
        if m_Abil.Level >= StdItem.NeedLevel then begin
          Result:=True;
        end else begin
          SysMsg(g_sLevelNot,c_Red,t_Hint);
        end;
      end else begin
        SysMsg(g_sNammanMasterManNot,c_Red,t_Hint);
      end;
    end;


    20: begin
      if m_btColumn > 0 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐淚으죗깊꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;
    21: begin
      if m_btColumn = 1 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐忌눈考낀꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;
    22: begin
      if m_btColumn = 2 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐忌눈냥逃꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;
    23: begin
      if m_btColumn = 3 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐션諒考낀꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;
    24: begin
      if m_btColumn = 4 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐션諒냥逃꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;
    25: begin
      if m_btColumn = 5 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐쑹亶考낀꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;
    26: begin
      if m_btColumn = 6 then begin
        Result:=True;
      end else begin
        SysMsg('怜唐쑹亶냥逃꼽옵鹿賈痰。',c_Red,t_Hint);
      end;
    end;


  end;
end;

function TBaseObject.sub_4C5370(nX, nY:Integer;nRange: Integer;var nDX, nDY:Integer): Boolean; //004C5370
var
  I    :Integer;
  II   :Integer;
  III  :Integer;
begin
  Result:=False;
  if m_PEnvir.GetMovingObject(nX,nY,True) = nil then begin
    Result:=True;
    nDX:=nX;
    nDY:=nY;
  end;
  if not Result then begin
    for I := 1 to nRange do begin
      for II := -I to I do begin
        for III := -I to I do begin
          nDX := nX + III;
          nDY := nY + II;
          if m_PEnvir.GetMovingObject(nDX,nDY,True) = nil then begin
            Result:=True;
            break;
          end;
        end;
        if Result then break;
      end;
      if Result then break;
    end;
  end;
  if not Result then begin
    nDX:=nX;
    nDY:=nY;
  end;    
end;

function TPlayObject.GetUserItemWeitht(nWhere: Integer): Integer; //004BF764
var
  I: Integer;
  n14:Integer;
  StdItem:TItem;
begin
  n14:=0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    if (nWhere = -1) or (not (i = nWhere) and not (i = 1) and not (i = 2)) then begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if StdItem <> nil then Inc(n14,StdItem.Weight);
    end;
  end;
  Result:=n14;
end;

function TPlayObject.ProcessUserCmd(sCmd {, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7}: string): Boolean;
var
  i                         : Integer;
begin
  Result := False;
  g_UserCmdList.Lock;
  try
    for i := 0 to g_UserCmdList.Count - 1 do begin
      if CompareText(sCmd, g_UserCmdList.Strings[i]) = 0 then begin
        if g_FunctionNPC <> nil then
          g_FunctionNPC.GotoLable(Self, '@UserCmd' + IntToStr(Integer(g_UserCmdList.Objects[i])), False);
        Result := True;
        Break;
      end;
    end;
  finally
    g_UserCmdList.UnLock;
  end;
end;

function TPlayObject.EatItems(StdItem: TItem;UserItem:pTUserItem): Boolean;//물약
var
  boNeedRecalc:Boolean;
  nRate, i:Integer;
  nTime, nTick:Integer;
  nHTime:Integer;
  nSec:Integer;
  sMonName:String;
  nMakeLevel,nExpLevel:Integer;
  dwRoyaltySec:LongWord;
  PlayObject:TPlayObject;
  BaseObject:TBaseObject;
  sMsg:String;
  nDura, nHP, nMP:Integer;
begin
  Result:=False;
  if m_PEnvir.Flag.boNODRUG then begin
    SysMsg(sCanotUseDrugOnThisMap,c_Red,t_Hint);
    exit;
  end;
  case StdItem.StdMode of
    0: begin //물약
    if not m_boDeath then begin
      case StdItem.Shape of
        1: begin
          IncHealthSpell(StdItem.AC,StdItem.MAC);
          Result:=True;
        end;
        2: begin     //미지수
          m_boUserUnLockDurg:=True;
          Result:=True;
        end;
        3: begin
          IncHealthSpell(Round((m_WAbil.MaxHP / 100)*StdItem.AC),Round((m_WAbil.MaxMP / 100)*StdItem.MAC));
          Result:=True;
        end;
        4: begin
          nHP := 0;
          if m_btJob = StdItem.Need then begin
            nHP := StdItem.MAC - StdItem.AC;
            IncHealthSpell(StdItem.AC + Random(nHP),0);
            Result:=True;
          end;
        end;
        6: begin //지속물약
          sMsg := '[넣崎뿟릿-몸훙]\';
          if (StdItem.AC > 0) then begin
            m_nIncStayHealth := StdItem.AC;
            m_dwStayHPTick := StdItem.AniCount * 1000;
            m_dwStayHPTime := GetTickCount + StdItem.DuraMax * 60 * 1000;
            sMsg := sMsg + 'HP + ' + IntToStr(StdItem.AC) + '\';
          end;
          if (StdItem.MAC > 0) then begin
            m_nIncStaySpell := StdItem.MAC;
            m_dwStayMPTick := StdItem.AniCount * 1000;
            m_dwStayMPTime := GetTickCount + StdItem.DuraMax * 60 * 1000;
            sMsg := sMsg + 'MP + ' + IntToStr(StdItem.MAC) + '\';
          end;
          sMsg := sMsg + IntToStr(StdItem.AniCount) + '취코넣崎뿟릿\넣崎珂쇌: ';

          m_wStatusArrValue[76] := 1;
          m_dwStatusArrTimeOutTick[76] := GetTickCount + StdItem.DuraMax * 60 * 1000;

          SendMsg (Self,RM_BUFF, 118, 0, 467, StdItem.DuraMax * 60, sMsg);    //지속물약 버프
          Result:=True;
        end;

        7: begin //그룹 지속물약
          if m_GroupOwner <> nil then begin
            nHP := StdItem.AC;
            nMP := StdItem.MAC;
            nTick := StdItem.AniCount;
            nTime := StdItem.DuraMax;
            for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
              BaseObject := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
              sMsg := '[넣崎뿟릿-莉뚠]\';
              if (nHP > 0) then begin
                BaseObject.m_nGrIncStayHealth := nHP;
                BaseObject.m_dwGrStayHPTick := nTick * 1000;
                BaseObject.m_dwGrStayHPTime := GetTickCount + nTime * 60 * 1000;
                sMsg := sMsg + 'HP + ' + IntToStr(nHP) + '\';
              end;
              if (nMP > 0) then begin
                BaseObject.m_nGrIncStaySpell := nMP;
                BaseObject.m_dwGrStayMPTick := nTick * 1000;
                BaseObject.m_dwGrStayMPTime := GetTickCount + nTime * 60 * 1000;
                sMsg := sMsg + 'MP + ' + IntToStr(nMP) + '\';
              end;
              sMsg := sMsg + IntToStr(StdItem.AniCount) + '취코넣崎뿟릿\넣崎珂쇌: ';
              BaseObject.SendMsg (Self, RM_BUFF, 119, 0, 468, nTime * 60, sMsg);    //지속물약 버프
              BaseObject.m_wStatusArrValue[77] := 1;
              BaseObject.m_dwStatusArrTimeOutTick[77] := GetTickCount + nTime * 60 * 1000;
            end;
            Result:=True;
          end else begin
            SysMsg('怜唐鬼莉냥逃옵鹿賈痰。',c_Red,t_Hint);
          end;
        end;

        10: begin     //축복의기름
          if not m_boDeath then
          if WeaptonMakeLuck() then Result:=True;
        end;
        11: begin     //무신의기름
          if not m_boDeath then
          if SuperRepairWeapon() then Result:=True;
        end;
        else begin
          if (StdItem.AC > 0) then begin
            Inc(m_nIncHealth,StdItem.AC);
          end;
          if (StdItem.MAC > 0) then begin
            Inc(m_nIncSpell,StdItem.MAC);
          end;
          Result:=True;
        end;
      end;
    end;
    end;

    2: begin    //환템 물약 겹치기 불가
     case StdItem.Shape of
      7: begin  //장원 초대장
      if not m_boDeath then
        if (UserItem.btValue[19] = 2) and (UserItem.MaxDate > DateTimeToUnix(now)) and (g_GuildTerritory.FindGuildTerritory(UserItem.btValue[0]).GuildName <> '')  then begin
          Result:= MoveToGT(UserItem.btValue[0]);
          SysMsg('콱눈箇돕죄契삔鏤蹈。',c_Green ,t_Hint);
        end else begin
          SysMsg('콱돨契삔鏤蹈돕퍅죄。',c_Red,t_Hint);
        end;
        Result := True;
      end;
      13: begin   //경험치 물약
      if not m_boDeath then
        GetExp(StdItem.DuraMax);
        Result := True;
      end;
      14: begin     //부활주문서
        if m_boDeath = True then begin
         if (m_PEnvir.Flag.boNOREVIVAL = FALSE) then begin
          m_WAbil.HP:=m_WAbil.MaxHP;
          m_WAbil.MP:=m_WAbil.MaxMP;
          m_boDeath := False;
          SendMsg(self,RM_ABILITY,0,0,0,0,'');
          SendRefMsg(RM_LOOPNORMALEFFECT, integer(self), 0, 0, NE_RELIVE, '');
          SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX,m_nCurrY, 0, '');
          Result := True;
         end else begin
          SysMsg('뎠품뒈暠轟랬릿삶。',c_RedWhite,t_Hint);
         end;
        end;
      end;
      15: begin     //음양변환서
       if not m_boDeath then begin
         if not (m_btJob in [4, 9]) then begin               //직업변경
          if m_UseItems[U_DRESS].wIndex = 0 then begin
            if m_btGender = 0 then
              m_btGender:= 1
            else
            m_btGender:= 0;
            Result := True;
            FeatureChanged();
            SysMsg(m_sCharName + '昑깎랙鄕舡캇沈',c_Green,t_Hint);
            SendMsg(PlayObject,RM_ToSendMsg,0,90,m_btGender,0,'');
          end else begin
            Result := False;
            SysMsg('누淪원솖珂꼇콘瘻뻣昑깎。',c_Red,t_Hint);
          end;
         end else begin
           Result := False;
           SysMsg('쩟꼇콘瘻뻣昑깎。',c_Red,t_Hint);
         end;
       end;
      end;
      16: begin       //경험치가산
        if not m_boDeath then begin
           Result := True;
           nRate:= StdItem.AC;
           nTime:= StdItem.DuraMax * 3600;
           m_nKillMonExpRate2:=nRate;
           m_dwKillMonExpRateTime2:=LongWord(nTime);
           SysMsg(format(g_sChangeKillMonExpRateMsg,[m_nKillMonExpRate2 / 100,m_dwKillMonExpRateTime2]),c_Green,t_Hint);
           SendMsg (Self,RM_BUFF, 8, 0, 300, StdItem.DuraMax * 3600 , '쒔駱令藤속 ' + IntToStr(nRate - 100) +'%: ' );    //경험치가산 버프
        end;
      end;
      17: begin   //면죄서찰
        if not m_boDeath then begin
            Result := True;
            m_nPkPoint:= m_nPkPoint - StdItem.AC;
            RefNameColor;
        end;
      end;

      18: begin   //변신탈 환템
       if (not m_boDeath) and (not m_PEnvir.Flag.boDEATHMATCH) then begin
        if (UserItem.btValue[19] = 2) and (UserItem.MaxDate > DateTimeToUnix(now)) then begin
         if (m_btMask = 0) then begin
           sMsg:= '[ 긴 ]\출燎텝묘콘\';
           if StdItem.AC > 0 then begin
            m_wStatusArrValue[16]:=StdItem.AC;
            m_dwStatusArrTimeOutTick[16]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('렝徒 + %d, ',[StdItem.AC]);
           end;
           if StdItem.MAC > 0 then begin
            m_wStatusArrValue[27]:=StdItem.MAC;
            m_dwStatusArrTimeOutTick[27]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('침랬렝徒 + %d, ',[StdItem.MAC]);
           end;
           if StdItem.DC > 0 then begin
            m_wStatusArrValue[37]:=StdItem.DC;
            m_dwStatusArrTimeOutTick[37]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('묑샌 + %d, ',[StdItem.DC]);
           end;
           if StdItem.MC > 0 then begin
            m_wStatusArrValue[38]:=StdItem.MC;
            m_dwStatusArrTimeOutTick[38]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('침랬 + %d, ',[StdItem.MC]);
           end;
           if StdItem.SC > 0 then begin
            m_wStatusArrValue[39]:=StdItem.SC;
            m_dwStatusArrTimeOutTick[39]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('돛減 + %d, ',[StdItem.SC]);
           end;
           if StdItem.AniCount > 100 then begin
            nRate:= StdItem.AniCount;
            nTime:= StdItem.DuraMax * 3600;
            m_nKillMonExpRate3:=nRate;
            m_dwKillMonExpRateTime3:=LongWord(nTime);
            sMsg := sMsg + '쒔駱令 ' + IntToStr(nRate - 100) + '% ';
           end;
           sMsg := sMsg + '\넣崎珂쇌: ';

           RecalcAbilitys();
           SendMsg(Self,RM_ABILITY,0,0,0,0,'');
           m_btMask := StdItem.Reserved;

           nHTime := StdItem.DuraMax;
           m_wStatusArrValue[80] := 1;
           m_dwStatusArrTimeOutTick[80]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;

           FeatureChanged();
           nSec := nHTime;
           SysMsg('삿돤출燎텝묘콘。',c_Green,t_Hint);

           SendMsg (Self,RM_BUFF, 33, 0, 19, StdItem.DuraMax * 3600, sMsg);    //변신탈 버프
         end else begin
           m_dwStatusArrTimeOutTick[16]:=0;
           m_dwStatusArrTimeOutTick[27]:=0;
           m_dwStatusArrTimeOutTick[37]:=0;
           m_dwStatusArrTimeOutTick[38]:=0;
           m_dwStatusArrTimeOutTick[39]:=0;
           m_nKillMonExpRate3:= 100;
           m_dwStatusArrTimeOutTick[80]:=0;
         //  FeatureChanged();
         end;
        end else begin
        Result := True;
        SysMsg('긴勺驛狀箕揮汶',c_Red,t_Hint);
        end;
       end;
      end;


      31: begin   //변신탈 환템
       if (not m_boDeath) and (not m_PEnvir.Flag.boDEATHMATCH) then begin
           sMsg:= '[ 긴 ]\출燎텝묘콘\';
           if StdItem.AC > 0 then begin
            m_wStatusArrValue[16]:=StdItem.AC;
            m_dwStatusArrTimeOutTick[16]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('렝徒 + %d, ',[StdItem.AC]);
           end;
           if StdItem.MAC > 0 then begin
            m_wStatusArrValue[27]:=StdItem.MAC;
            m_dwStatusArrTimeOutTick[27]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('침랬렝徒 + %d, ',[StdItem.MAC]);
           end;
           if StdItem.DC > 0 then begin
            m_wStatusArrValue[37]:=StdItem.DC;
            m_dwStatusArrTimeOutTick[37]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('묑샌 + %d, ',[StdItem.DC]);
           end;
           if StdItem.MC > 0 then begin
            m_wStatusArrValue[38]:=StdItem.MC;
            m_dwStatusArrTimeOutTick[38]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('침랬 + %d, ',[StdItem.MC]);
           end;
           if StdItem.SC > 0 then begin
            m_wStatusArrValue[39]:=StdItem.SC;
            m_dwStatusArrTimeOutTick[39]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            sMsg := sMsg + format('돛減 + %d, ',[StdItem.SC]);
           end;
           if StdItem.AniCount > 100 then begin
            nRate:= StdItem.AniCount;
            nTime:= StdItem.DuraMax * 3600;
            m_nKillMonExpRate3:=nRate;
            m_dwKillMonExpRateTime3:=LongWord(nTime);
            sMsg := sMsg + '쒔駱令 + ' + IntToStr(nRate - 100) + '% ';
           end;
           sMsg := sMsg + '\넣崎珂쇌: ';

           RecalcAbilitys();
           SendMsg(Self,RM_ABILITY,0,0,0,0,'');
           m_btMask := StdItem.Reserved;

           nHTime := StdItem.DuraMax;
           m_wStatusArrValue[80] := 1;
           m_dwStatusArrTimeOutTick[80]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           FeatureChanged();
           nSec := nHTime;
           SysMsg('삿돤출燎텝묘콘。',c_Green,t_Hint);

           SendMsg (Self,RM_BUFF, 33, 0, 19, StdItem.DuraMax * 3600, sMsg);    //변신탈 버프
           Result := True;
       end;
      end;



      19: begin       //드롭율
        if not m_boDeath then begin
           Result := True;
           nRate:= StdItem.AC;
           nTime:= StdItem.DuraMax * 3600;
           m_nKillMonDropRate:=nRate;
           m_dwKillMonDropRateTime:=LongWord(nTime);
           SysMsg(format(g_sChangeKillMonExpRateMsg,[m_nKillMonDropRate / 100,m_dwKillMonDropRateTime]),c_Green,t_Hint);
           SendMsg (Self,RM_BUFF, 15, 0, 13, StdItem.DuraMax * 3600, '괵쪽瓊' + IntToStr(nRate - 100) +'%: ' );    //드롭율 버프
        end;
      end;

      20: begin       //호위병
       if not m_boDeath then begin
         if (UserItem.btValue[19] = 2) and (UserItem.MaxDate > DateTimeToUnix(now)) then begin
          if (SlaveCount(g_Config.sGuard45) = 0) and (SlaveCount(g_Config.sGuard50) = 0) and (SlaveCount(g_Config.sGuard55) = 0)
          and (SlaveCount(g_Config.sGuard60) = 0) and (SlaveCount(g_Config.sArcher45) = 0) and (SlaveCount(g_Config.sArcher50) = 0)
          and (SlaveCount(g_Config.sArcher55) = 0) and (SlaveCount(g_Config.sArcher60) = 0) then begin
           if m_WAbil.Level < 50 then begin
             if SlaveCount(g_Config.sGuard45) > 0 then begin
              RecallSlave(g_Config.sGuard45);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sGuard45;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end else
           if (m_WAbil.Level > 49)  and  (m_WAbil.Level < 55 )then begin
             if SlaveCount(g_Config.sGuard50) > 0 then begin
              RecallSlave(g_Config.sGuard50);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sGuard50;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end else
           if (m_WAbil.Level > 54)  and (m_WAbil.Level < 60) then begin
             if SlaveCount(g_Config.sGuard55) > 0 then begin
              RecallSlave(g_Config.sGuard55);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sGuard55;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end else
           if (m_WAbil.Level > 59) then begin
             if SlaveCount(g_Config.sGuard60) > 0 then begin
              RecallSlave(g_Config.sGuard60);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sGuard60;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end;
          end else begin
          SysMsg('콱怜콘梁뻥寧몸빱括。',c_Red,t_Hint);
          end;
         end else begin
         Result := True;
         SysMsg('賈痰퍅掘돕퍅。',c_Red,t_Hint);
         end;
       end;
      end;
      21: begin      //호위좌사
       if not m_boDeath then begin
         if (UserItem.btValue[19] = 2) and (UserItem.MaxDate > DateTimeToUnix(now)) then begin
          if (SlaveCount(g_Config.sGuard45) = 0) and (SlaveCount(g_Config.sGuard50) = 0) and (SlaveCount(g_Config.sGuard55) = 0)
          and (SlaveCount(g_Config.sGuard60) = 0) and (SlaveCount(g_Config.sArcher45) = 0) and (SlaveCount(g_Config.sArcher50) = 0)
          and (SlaveCount(g_Config.sArcher55) = 0) and (SlaveCount(g_Config.sArcher60) = 0) then begin
           if m_WAbil.Level < 50 then begin
             if SlaveCount(g_Config.sArcher45) > 0 then begin
              RecallSlave(g_Config.sArcher45);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sArcher45;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end else
           if (m_WAbil.Level > 49)  and  (m_WAbil.Level < 55 )then begin
             if SlaveCount(g_Config.sArcher50) > 0 then begin
              RecallSlave(g_Config.sArcher50);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sArcher50;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end else
           if (m_WAbil.Level > 54)  and (m_WAbil.Level < 60) then begin
             if SlaveCount(g_Config.sArcher55) > 0 then begin
              RecallSlave(g_Config.sArcher55);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sArcher55;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end else
           if (m_WAbil.Level > 59) then begin
             if SlaveCount(g_Config.sArcher60) > 0 then begin
              RecallSlave(g_Config.sArcher60);
              exit;
             end;
             if not sub_4DD704 then begin
              sMonName:=g_Config.sArcher60;
              nMakeLevel:=2;
              nExpLevel:=2;
              dwRoyaltySec:=10 * 24 * 60 * 60;
             if MakeSlave(sMonName,nMakeLevel,nExpLevel,3,dwRoyaltySec) <> nil then
             end;
           end;
          end else begin
          SysMsg('콱怜콘梁뻥寧몸빱括。',c_Red,t_Hint);
          end;
         end else begin
         Result := True;
         SysMsg('賈痰퍅掘돕퍅。',c_Red,t_Hint);
         end;
       end;
      end;
      22: begin     //공력수
       if not m_boDeath then begin
         Result := True;
         nRate:= StdItem.AC;
         nTime:= StdItem.DuraMax * 3600;
         m_nPowerRate3:=nRate;
         m_dwPowerRateTime3:=LongWord(nTime);
         SysMsg(format(g_sChangePowerRateMsg,[m_nPowerRate3 / 100,m_dwPowerRateTime3]),c_Green,t_Hint);
         SendMsg (Self,RM_BUFF, 49, 0, 306, StdItem.DuraMax * 3600, '묑샌제藤속 ' + IntToStr(StdItem.AC - 100) +': ' );    //공력수 버프
       end;
      end;
      23: begin //천령수
       if not m_boDeath then begin
         if (UserItem.btValue[19] = 2) and (UserItem.MaxDate > DateTimeToUnix(now)) then begin
          if m_wStatusArrValue[17] = 0 then begin
            sMsg:= '[ 莖쥣彊 ]\';
            if StdItem.AC > 0 then begin       //행운
              m_wStatusArrValue[17]:=StdItem.AC;
              m_dwStatusArrTimeOutTick[17]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
              sMsg := sMsg + format('妗頓 + %d, ',[StdItem.AC]);
            end;
            if StdItem.DC > 0 then begin   //공격력
              nRate:= StdItem.DC;
              nTime:= StdItem.DuraMax * 3600;
              m_nPowerRate2:=nRate;
              m_dwPowerRateTime2:=LongWord(nTime);
              sMsg := sMsg + format('묑샌제 + %d, ',[StdItem.DC - 100]);
            end;
            if StdItem.MC > 0 then begin  //민첩
             m_wStatusArrValue[19]:= StdItem.MC;
             m_dwStatusArrTimeOutTick[19]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
             sMsg := sMsg + format('츌쌥 + %d, ',[StdItem.MC]);
            end;
            if StdItem.SC > 0 then begin    //정확
             m_wStatusArrValue[20]:= StdItem.SC;
             m_dwStatusArrTimeOutTick[20]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
             sMsg := sMsg + format('硫횅 + %d, ',[StdItem.SC]);
            end;
            if StdItem.MAC > 0 then begin   //체력
             m_wStatusArrValue[21]:= StdItem.MAC;
             m_dwStatusArrTimeOutTick[21]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
             sMsg := sMsg + format('餉篁 + %d ',[StdItem.MAC]);
            end;
            sMsg := sMsg + '\넣崎珂쇌: ';
            RecalcAbilitys();
            SendMsg(Self,RM_ABILITY,0,0,0,0,'');
            SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');

            SendMsg (Self, RM_BUFF, 52, 0, 317, StdItem.DuraMax * 3600, sMsg);    //천령수 버프
            SysMsg('莖쥣彊넣崎' + IntToStr(StdItem.DuraMax) + '鬼珂',c_Green,t_Hint);
          end else begin
            m_dwStatusArrTimeOutTick[17]:=0;
            m_dwStatusArrTimeOutTick[19]:=0;
            m_dwStatusArrTimeOutTick[20]:=0;
            m_dwStatusArrTimeOutTick[21]:=0;
            m_dwPowerRateTime2:=0;
          end;
         end else begin
          Result := True;
          SysMsg('賈痰珂쇌돕퍅。',c_Red,t_Hint);
         end;
       end;
      end;
      24: begin     //정확의물약
       if not m_boDeath then begin
          Result := True;
          m_wStatusArrValue[18]:=StdItem.AC;
          m_dwStatusArrTimeOutTick[18]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
          RecalcAbilitys();
          SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
          SysMsg('硫횅昑藤속 ' + IntToStr(StdItem.AC) +' ，넣崎 '+ IntToStr(StdItem.DuraMax * 3600) + '취。',c_Green,t_Hint);
          SendMsg (Self, RM_BUFF, 17, 0, 320, StdItem.DuraMax * 3600, format('硫횅藤속 %d: ',[StdItem.AC]));    //정확의물약 버프
       end;
      end;
      25: begin     //미용사마음대로1
       if (not m_boDeath) and (m_btJob <> 4) then begin
        Case Random(20) of
        1..3 :begin
          m_btHair:=0;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹綠쒔긴냥밟庫。',c_Green,t_Hint);
        end;
        4..10 :begin
          m_btHair:=2;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹綠쒔긴냥김綾。',c_Green,t_Hint);
        end;
        11..15 :begin
          m_btHair:=3;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹綠쒔긴냥낀랙。',c_Green,t_Hint);
        end;
        else begin
          m_btHair:=1;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹綠쒔긴냥똬랙。',c_Green,t_Hint);
        end;
        end;
       end;
      end;
      26: begin     //미용사마음대로2
       if (not m_boDeath) and (m_btJob <> 4) then begin
        Case Random(45) of
        1..4 :begin
          m_btHair:=9;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄융サ캇дⓐ래',c_Green,t_Hint);
        end;
        5..10 :begin
          m_btHair:=8;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄븐サ캇дⓐ래',c_Green,t_Hint);
        end;
        11..15 :begin
          m_btHair:=7;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄厘サ캇дⓐ래',c_Green,t_Hint);
        end;
        16..20 :begin
          m_btHair:=6;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄융サ켐렁⇒',c_Green,t_Hint);
        end;
        21..25 :begin
          m_btHair:=5;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄븐サ켐렁⇒',c_Green,t_Hint);
        end;
        26..30 :begin
          m_btHair:=4;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄厘サ켐렁⇒',c_Green,t_Hint);
        end;
        31..35 :begin
          m_btHair:=3;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄낀랙。',c_Green,t_Hint);
        end;
        36..40 :begin
          m_btHair:=2;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄쯩棺김。',c_Green,t_Hint);
        end;
        else begin
          m_btHair:=1;
          Result := True;
          FeatureChanged();
        SysMsg('랙謹긴냥죄똬랙。',c_Green,t_Hint);
        end;
        end;
       end;
      end;
      27: begin //옥청수
       if not m_boDeath then begin
         if (UserItem.btValue[19] = 2) and (UserItem.MaxDate > DateTimeToUnix(now)) then begin
         if m_wStatusArrValue[26] = 0 then begin
           sMsg:= '[ 圖헌彊 ]\';
           if StdItem.AC > 0 then begin       //행운
           m_wStatusArrValue[26]:=StdItem.AC;
           m_dwStatusArrTimeOutTick[26]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('妗頓 + %d, ',[StdItem.AC]);
           end;
           if StdItem.MAC > 0 then begin   //방어
           m_wStatusArrValue[22]:= StdItem.MAC;
           m_dwStatusArrTimeOutTick[22]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('렝徒 + %d, ',[StdItem.MAC]);
           end;
           if StdItem.DC > 0 then begin   //파괴
           m_wStatusArrValue[23]:= StdItem.DC;
           m_dwStatusArrTimeOutTick[23]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('묑샌 + %d, ',[StdItem.DC]);
           end;
           if StdItem.MC > 0 then begin  //마법
           m_wStatusArrValue[24]:= StdItem.MC;
           m_dwStatusArrTimeOutTick[24]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('침랬 + %d, ',[StdItem.MC]);
           end;
           if StdItem.SC > 0 then begin    //도력
           m_wStatusArrValue[25]:= StdItem.SC;
           m_dwStatusArrTimeOutTick[25]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('돛減 + %d ',[StdItem.SC]);
           end;
           if StdItem.AniCount > 0 then begin
            m_wStatusArrValue[14]:=StdItem.AniCount;
            m_dwStatusArrTimeOutTick[14]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
            SendMsg(Self,RM_ToSendMsg,0,86,1,0,'');
           end;
           sMsg := sMsg + '\넣崎珂쇌: ';

           RecalcAbilitys();
           SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
           SendMsg(Self,RM_ABILITY,0,0,0,0,'');

           SendMsg (Self,RM_BUFF, 44, 0, 305, StdItem.DuraMax * 3600, sMsg);    //옥청수 버프
           SysMsg('圖헌彊넣崎' + IntToStr(StdItem.DuraMax) + '鬼珂。',c_Green,t_Hint);
         end else begin
           m_dwStatusArrTimeOutTick[26]:=0;
           m_dwStatusArrTimeOutTick[22]:=0;
           m_dwStatusArrTimeOutTick[23]:=0;
           m_dwStatusArrTimeOutTick[24]:=0;
           m_dwStatusArrTimeOutTick[25]:=0;
           m_dwStatusArrTimeOutTick[14]:=0;
         end;
         end else begin
         Result := True;
         SysMsg('賈痰퍅掘돕퍅。',c_Red,t_Hint);
         end;
       end;
      end;
      28: begin   //킬/데스 초기화
        if not m_boDeath then begin
            Result := True;
            TPlayObject(Self).ZeroFamePoint;
        end;
      end;
      29: begin //환템 드랍
        if not m_boDeath then begin
           Result := True;
           m_wStatusArrValue[14]:=StdItem.DuraMax;
           m_dwStatusArrTimeOutTick[14]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           RecalcAbilitys();
           SendMsg(Self,RM_ToSendMsg,0,86,1,0,'');
           SysMsg('괵쪽藤속넣崎' + IntToStr(StdItem.DuraMax) + '鬼珂。',c_Green,t_Hint);
        end;
      end;
      30: begin //수련의물약
       if not m_boDeath then begin
         Result := True;
         m_wStatusArrValue[28]:=1;
         m_dwStatusArrTimeOutTick[28]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
         SysMsg('무세콘坎족똑藤속。',c_GreenWhite,t_Hint);
         RecalcAbilitys();
         SendMsg (Self,RM_BUFF, 53, 0, 318, StdItem.DuraMax * 3600, '세콘坎족똑 2 굡: ');   //수련의물약 버프
       end;
      end;
      32: begin //솔플 경험치
         if not m_boDeath then begin
          if m_GroupOwner = nil then begin
           Result := True;
           nRate:= StdItem.AC;
           nTime:= StdItem.DuraMax * 3600;
           m_nKillMonExpRate8:=nRate;
           m_dwKillMonExpRateTime8:=LongWord(nTime);
           SysMsg(format(g_sChangeKillMonExpRateMsg,[m_nKillMonExpRate8 / 100,m_dwKillMonExpRateTime8]),c_Green,t_Hint);
           SendMsg (Self,RM_BUFF, 84, 0, 334, StdItem.DuraMax * 3600 , '쒔駱令藤속 ' + IntToStr(nRate - 100) +'%: ' );    //경험치가산 버프
          end;
         end;
      end;




      4: begin           //축복의 기름 축기
       if not m_boDeath then
        if WeaptonMakeLuck() then Result:=True;
      end;

      9: begin     //수리기름
       if not m_boDeath then
        if RepairWeapon() then Result:=True;
      end;
      10: begin     //무신의기름
       if not m_boDeath then
        if SuperRepairWeapon() then Result:=True;
      end;
      11: begin     //로또
       if not m_boDeath then
        if WinLottery() then Result:=True;
      end;

      43: begin     //생고기 25
       if not m_boDeath then
        UserItem:=@m_UseItems[U_TIGER];
        if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then exit;
         Dec(UserItem.DuraMax,(UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura{30});
         nDura:=_MIN(StdItem.DuraMax,UserItem.DuraMax - UserItem.Dura);
         if nDura > 0 then begin
          Inc(UserItem.Dura,nDura);
          SendMsg(Self,RM_DURACHANGE,13,UserItem.Dura,UserItem.DuraMax,0,'');
          RecalcAbilitys();
          SendMsg(Self,RM_ABILITY,0,0,0,0,'');
          SysMsg(g_sTigerRepairSuccess,c_RedWhite,t_Hint);
          Result:=True;
         end;
      end;

      44: begin     //고급찹살떡
       if not m_boDeath then
        UserItem:=@m_UseItems[U_TIGER];
        if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then exit;
         nDura:=_MIN(StdItem.DuraMax,UserItem.DuraMax - UserItem.Dura);
         if nDura > 0 then begin
          Inc(UserItem.Dura,nDura);
          SendMsg(Self,RM_DURACHANGE,13,UserItem.Dura,UserItem.DuraMax,0,'');
          RecalcAbilitys();
          SendMsg(Self,RM_ABILITY,0,0,0,0,'');
          SysMsg(g_sTigerRepairSuccess,c_RedWhite,t_Hint);
          Result:=True;
         end;
      end;

      45: begin //드렁허리
       if not m_boDeath then begin
         sMsg := '[ 드렁허리 ]\';
         if StdItem.AC > 0 then begin       //행운
           m_wStatusArrValue[26]:=StdItem.AC;
           m_dwStatusArrTimeOutTick[26]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('妗頓 + %d, ',[StdItem.AC]);
         end;
         if StdItem.MAC > 0 then begin   //방어
           m_wStatusArrValue[22]:= StdItem.MAC;
           m_dwStatusArrTimeOutTick[22]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('렝徒 + %d, ',[StdItem.MAC]);
         end;
         if StdItem.DC > 0 then begin   //파괴
           m_wStatusArrValue[23]:= StdItem.DC;
           m_dwStatusArrTimeOutTick[23]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('묑샌 + %d, ',[StdItem.DC]);
         end;
         if StdItem.MC > 0 then begin  //마법
           m_wStatusArrValue[24]:= StdItem.MC;
           m_dwStatusArrTimeOutTick[24]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('침랬 + %d, ',[StdItem.MC]);
         end;
         if StdItem.SC > 0 then begin    //도력
           m_wStatusArrValue[25]:= StdItem.SC;
           m_dwStatusArrTimeOutTick[25]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           sMsg := sMsg + format('돛減 + %d ',[StdItem.SC]);
         end;
         if StdItem.AniCount > 0 then begin
           m_wStatusArrValue[14]:=StdItem.AniCount;
           m_dwStatusArrTimeOutTick[14]:=GetTickCount + StdItem.DuraMax * 3600 * 1000;
           SendMsg(Self,RM_ToSendMsg,0,86,1,0,'');
         end;
         sMsg := sMsg + '\넣崎珂쇌: ';

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
         Result := True;
         SendMsg (Self,RM_BUFF, 45, 0, 305, StdItem.DuraMax * 3600, sMsg);   //드렁허리 버프

         SysMsg('드렁허리넣崎' + IntToStr(StdItem.DuraMax) + '鬼珂',c_Green,t_Hint);
       end;
      end;

     end;
    end;


    3: begin    //환템 물약 겹치기 가능
      case StdItem.Shape of

      8: begin  //문주의가르침 문주의 깨달음  문파성장
        if not m_boDeath then begin
          Result := True;
          if m_MyGuild <> nil then begin
            GetGuildExp(StdItem.AC);
          end;
        end;
      end;


      12: begin
        boNeedRecalc:=False;
      if not m_boDeath then begin
        if StdItem.DC > 0 then begin
          m_wStatusArrValue[0]:=StdItem.DC;
          m_wStatusArrFlag[0]:=0;
          m_dwStatusArrTimeOutTick[0{0x220}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂묑샌藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂묑샌藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint) ;
          SendMsg (Self,RM_BUFF, 3, 0, 307, StdItem.MAC2 , format('묑샌 + %d: ' ,[StdItem.DC]) );   //파괴의물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.MC > 0 then begin
          m_wStatusArrValue[1{0x219}]:=StdItem.MC;
          m_wStatusArrFlag[1]:=0;
          m_dwStatusArrTimeOutTick[1{0x224}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂침랬藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂침랬藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint)  ;
          SendMsg (Self,RM_BUFF, 5, 0, 308, StdItem.MAC2 , format('침랬 + %d: ' ,[StdItem.MC]) );  //마력의물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.SC > 0 then begin
          m_wStatusArrValue[2{0x21A}]:=StdItem.SC;
          m_wStatusArrFlag[2]:=0;
          m_dwStatusArrTimeOutTick[2{0x228}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂돛減藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂돛減藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 6, 0, 309, StdItem.MAC2 , format('돛減 + %d: ' ,[StdItem.SC]) );  //도력의물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.AC2 > 0 then begin
          m_wStatusArrValue[3{0x21B}]:=StdItem.AC2;
          m_wStatusArrFlag[3]:=0;
          m_dwStatusArrTimeOutTick[3{0x22C}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 7, 0, 312, StdItem.MAC2, format('묑샌醵똑 + %d: ' ,[StdItem.AC2]) );  //광풍물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.AC > 0 then begin
          m_wStatusArrValue[4{0x21C}]:=StdItem.AC;
          m_wStatusArrFlag[4]:=0;
          m_dwStatusArrTimeOutTick[4{0x230}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂餉篁둣梔 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂餉篁둣梔 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 10, 0, 310, StdItem.MAC2 , format('MAX HP + %d: ' ,[StdItem.AC]) );  //육체 버프
          boNeedRecalc:=True;
        end;
        if StdItem.MAC > 0 then begin
          m_wStatusArrValue[5{0x21D}]:=StdItem.MAC;
          m_wStatusArrFlag[5]:=0;
          m_dwStatusArrTimeOutTick[5{0x234}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂침랬令令藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂침랬令令藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 11, 0, 311, StdItem.MAC2 , format('MAX MP + %d\넣崎: ' ,[StdItem.MAC]) );  //정신 버프
          boNeedRecalc:=True;
        end;
        if boNeedRecalc then begin
          RecalcAbilitys();
          SendMsg(Self,RM_ABILITY,0,0,0,0,'');
          Result:=True;
        end;
      end;
      end;

      13: begin   //폭죽 아이템
        boNeedRecalc:=False;
      if not m_boDeath then begin
        if StdItem.DC > 0 then begin
          m_wStatusArrValue[0]:=StdItem.DC;
          m_wStatusArrFlag[0]:=0;
          m_dwStatusArrTimeOutTick[0{0x220}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂묑샌藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂묑샌藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint) ;
          SendMsg (Self,RM_BUFF, 3, 0, 307, StdItem.MAC2 , format('묑샌 + %d: ' ,[StdItem.DC]) );   //파괴의물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.MC > 0 then begin
          m_wStatusArrValue[1{0x219}]:=StdItem.MC;
          m_wStatusArrFlag[1]:=0;
          m_dwStatusArrTimeOutTick[1{0x224}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂침랬藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂침랬藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint)  ;
          SendMsg (Self,RM_BUFF, 5, 0, 308, StdItem.MAC2 , format('침랬 + %d : ' ,[StdItem.MC]) );  //마력의물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.SC > 0 then begin
          m_wStatusArrValue[2{0x21A}]:=StdItem.SC;
          m_wStatusArrFlag[2]:=0;
          m_dwStatusArrTimeOutTick[2{0x228}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂돛減藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂돛減藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 6, 0, 309, StdItem.MAC2 , format('돛減 + %d: ' ,[StdItem.SC]) );  //도력의물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.AC2 > 0 then begin
          m_wStatusArrValue[3{0x21B}]:=StdItem.AC2;
          m_wStatusArrFlag[3]:=0;
          m_dwStatusArrTimeOutTick[3{0x22C}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 7, 0, 312, StdItem.MAC2, format('묑샌醵똑 + %d: ' ,[StdItem.AC2]) );  //광풍물약 버프
          boNeedRecalc:=True;
        end;
        if StdItem.AC > 0 then begin
          m_wStatusArrValue[4{0x21C}]:=StdItem.AC;
          m_wStatusArrFlag[4]:=0;
          m_dwStatusArrTimeOutTick[4{0x230}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂餉篁둣梔 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂餉篁둣梔 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 10, 0, 310, StdItem.MAC2 , format('MAX HP + %d: ' ,[StdItem.AC]) );  //육체 버프
          boNeedRecalc:=True;
        end;
        if StdItem.MAC > 0 then begin
          m_wStatusArrValue[5{0x21D}]:=StdItem.MAC;
          m_wStatusArrFlag[5]:=0;
          m_dwStatusArrTimeOutTick[5{0x234}]:=GetTickCount + StdItem.MAC2 * 1000;
          if StdItem.MAC2 >= 3600 then
          SysMsg('줄珂침랬令藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
          else
          SysMsg('줄珂침랬令藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
          SendMsg (Self,RM_BUFF, 11, 0, 311, StdItem.MAC2 , format('MAX MP + %d: ' ,[StdItem.MAC]) );  //정신 버프
          boNeedRecalc:=True;
        end;
        if boNeedRecalc then begin
          RecalcAbilitys();
          SendMsg(Self,RM_ABILITY,0,0,0,0,'');
          SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,4,'0');
          Result:=True;
        end;
      end;
      end;

      14: begin  //이벤트물약
         boNeedRecalc:=False;
         if not m_boDeath then begin
           if StdItem.DC > 0 then begin
             m_wStatusArrValue[90]:=StdItem.DC;
             m_wStatusArrFlag[90]:=0;
             m_dwStatusArrTimeOutTick[90]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂묑샌藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂묑샌藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint) ;
             SendMsg (Self,RM_BUFF, 96, 0, 307, StdItem.MAC2 , format('묑샌 + %d: ' ,[StdItem.DC]) );   //파괴의물약 버프
             boNeedRecalc:=True;
           end;
           if StdItem.MC > 0 then begin
             m_wStatusArrValue[91]:=StdItem.MC;
             m_wStatusArrFlag[91]:=0;
             m_dwStatusArrTimeOutTick[91]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂침랬藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂침랬藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint)  ;
             SendMsg (Self,RM_BUFF, 97, 0, 308, StdItem.MAC2 , format('침랬 + %d: ' ,[StdItem.MC]) );  //마력의물약 버프
             boNeedRecalc:=True;
           end;
           if StdItem.SC > 0 then begin
             m_wStatusArrValue[92]:=StdItem.SC;
             m_wStatusArrFlag[92]:=0;
             m_dwStatusArrTimeOutTick[92]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂돛減藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂돛減藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 98, 0, 309, StdItem.MAC2 , format('돛減 + %d: ' ,[StdItem.SC]) );
             boNeedRecalc:=True;
           end;
           if StdItem.AC > 0 then begin
             m_wStatusArrValue[93]:=StdItem.AC;
             m_wStatusArrFlag[93]:=0;
             m_dwStatusArrTimeOutTick[93]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂렝徒藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂렝徒藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 99, 0, 870, StdItem.MAC2 , format('렝徒 + %d: ' ,[StdItem.AC]) );
             boNeedRecalc:=True;
           end;
           if StdItem.MAC > 0 then begin
             m_wStatusArrValue[94]:=StdItem.MAC;
             m_wStatusArrFlag[94]:=0;
             m_dwStatusArrTimeOutTick[94]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂침랬렝徒藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂침랬렝徒藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 100, 0, 871, StdItem.MAC2 , format('침랬렝徒 + %d: ' ,[StdItem.MAC]) );
             boNeedRecalc:=True;
           end;
           if StdItem.HpAdd > 0 then begin
             m_wStatusArrValue[95]:=StdItem.HpAdd;
             m_wStatusArrFlag[95]:=0;
             m_dwStatusArrTimeOutTick[95]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂MAXHP藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂MAXHP藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 101, 0, 310, StdItem.MAC2 , format('MAXHP + %d: ' ,[StdItem.HpAdd]) );
             boNeedRecalc:=True;
           end;
           if StdItem.MpAdd > 0 then begin
             m_wStatusArrValue[96]:=StdItem.MpAdd;
             m_wStatusArrFlag[96]:=0;
             m_dwStatusArrTimeOutTick[96]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂MAXMP藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂MAXMP藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 102, 0, 311, StdItem.MAC2 , format('MAXMP + %d: ' ,[StdItem.MpAdd]) );
             boNeedRecalc:=True;
           end;
           if StdItem.AtkSpd > 0 then begin
             m_wStatusArrValue[97]:=StdItem.AtkSpd;
             m_wStatusArrFlag[97]:=0;
             m_dwStatusArrTimeOutTick[97]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 103, 0, 312, StdItem.MAC2 , format('묑샌醵똑 + %d: ' ,[StdItem.AtkSpd]) );
             boNeedRecalc:=True;
           end;
           if StdItem.Accurate > 0 then begin
             m_wStatusArrValue[98]:=StdItem.Accurate;
             m_wStatusArrFlag[98]:=0;
             m_dwStatusArrTimeOutTick[98]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂硫횅藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂硫횅藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 104, 0, 320, StdItem.MAC2 , format('硫횅 + %d: ' ,[StdItem.Accurate]) );
             boNeedRecalc:=True;
           end;
           if StdItem.Agility > 0 then begin
             m_wStatusArrValue[99]:=StdItem.Agility;
             m_wStatusArrFlag[99]:=0;
             m_dwStatusArrTimeOutTick[99]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂츌쌥藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂츌쌥藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 105, 0, 319, StdItem.MAC2 , format('츌쌥 + %d: ' ,[StdItem.Agility]) );
             boNeedRecalc:=True;
           end;
           if StdItem.MagAvoid > 0 then begin
             m_wStatusArrValue[100]:=StdItem.MagAvoid;
             m_wStatusArrFlag[100]:=0;
             m_dwStatusArrTimeOutTick[100]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂침랬뜰긁藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂침랬뜰긁藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 106, 0, 332, StdItem.MAC2 , format('침랬뜰긁 + %d: ' ,[StdItem.MagAvoid]) );
             boNeedRecalc:=True;
           end;
           if StdItem.ToxAvoid > 0 then begin
             m_wStatusArrValue[101]:=StdItem.ToxAvoid;
             m_wStatusArrFlag[101]:=0;
             m_dwStatusArrTimeOutTick[101]:=GetTickCount + StdItem.MAC2 * 1000;
             if StdItem.MAC2 >= 3600 then
              SysMsg('줄珂뗀膠뜰긁藤속 ' + IntToStr(StdItem.MAC2 div 3600) + '鬼珂。',c_Green,t_Hint)
             else
              SysMsg('줄珂뗀膠뜰긁藤속 ' + IntToStr(StdItem.MAC2 div 60) + '롸爐。',c_Green,t_Hint);
             SendMsg (Self,RM_BUFF, 107, 0, 333, StdItem.MAC2 , format('뗀膠뜰긁 + %d: ' ,[StdItem.ToxAvoid]) );
             boNeedRecalc:=True;
           end;
           if boNeedRecalc then begin
             RecalcAbilitys();
             SendMsg(Self,RM_ABILITY,0,0,0,0,'');
             if (StdItem.MagAvoid > 0) or (StdItem.ToxAvoid > 0) then
               SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
             Result:=True;
           end;

         end;

      end;
      
      else
        if not m_boDeath then
        Result:=EatUseItems(StdItem.Shape);
      end;
    end;
  end;
end;

function TPlayObject.ReadBook(StdItem:TItem): Boolean; //004C67DC
var
  Magic:pTMagic;
  UserMagic:pTUserMagic;
  PlayObject:TPlayObject;
begin
  Result:=False;
  Magic:=UserEngine.FindMagic(StdItem.Name);
  if Magic <> nil then begin
    if not IsTrainingSkill(Magic.wMagicId) then begin
      if (Magic.btJob = 99) or (Magic.btJob = m_btJob) or (Magic.btJob + 5 = m_btJob) then begin      //우화등선 케릭 무공 배우기          //직업변경
        if m_Abil.Level >= Magic.TrainLevel[0] then begin
          New(UserMagic);
          UserMagic.MagicInfo:=Magic;
          UserMagic.wMagIdx:=Magic.wMagicId;
          UserMagic.btKey:=0;
          UserMagic.btLevel:=0;
          UserMagic.nTranPoint:=0;
          m_MagicList.Add(UserMagic);
          RecalcAbilitys();
          if m_btRaceServer = RC_PLAYOBJECT  then begin
            PlayObject:=TPlayObject(Self);
            PlayObject.SendAddMagic(UserMagic);
            PlayObject.SysMsg(Magic.sMagicName + '냥묘欺構세콘。', c_Green, t_Hint);
          end;
          Result:=True;
        end;
      end;
    end;
  end;
end;

function TBaseObject.IsTrainingSkill(nIndex: Integer): Boolean; //004C6780
var
  I: Integer;
  UserMagic:pTUserMagic;
begin
  Result:=False;
  for I := 0 to m_MagicList.Count - 1 do begin
    UserMagic:=m_MagicList.Items[i];
    if (UserMagic <> nil) and (UserMagic.wMagIdx = nIndex) then begin
      Result:=True;
      break;
    end;
  end;
end;

procedure TPlayObject.SendAddMagic(UserMagic: pTUserMagic); //004D12F4
var
  ClientMagic:TClientMagic;
begin
   ClientMagic.Key:=Char(UserMagic.btKey);
   ClientMagic.Level:=UserMagic.btLevel;
   ClientMagic.CurTrain:=UserMagic.nTranPoint;
   ClientMagic.Def:=UserMagic.MagicInfo^;
   m_DefMsg:=MakeDefaultMsg(SM_ADDMAGIC,0,0,0,1);
   SendSocket(@m_DefMsg,EncodeBuffer(@ClientMagic,SizeOf(TClientMagic)));
end;
procedure TPlayObject.SendDelMagic(UserMagic: pTUserMagic);
begin
  m_DefMsg:=MakeDefaultMsg(SM_DELMAGIC,UserMagic.wMagIdx,0,0,1);
  SendSocket(@m_DefMsg,'');
end;

function TPlayObject.EatUseItems(nShape: integer): Boolean; //004BD1BC
var
  Castle:TUserCastle;
begin
  Result:=False;
  case nShape of    //아공전서
    1: begin
      if (not m_PEnvir.Flag.boNOCASTLEMOVE) then begin
        SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
        BaseObjectMove(m_sHomeMap,'','');
        Result:=True;
      end else begin
        SysMsg('묑냘濫珂쐐岺賈痰。',c_Red,t_Hint);
      end;
    end;
    2: begin         //아공도약서
      if (not m_PEnvir.Flag.boNOCASTLEMOVE) then begin
        if (not m_PEnvir.Flag.boNORANDOMMOVE) then begin
          if m_PEnvir.Flag.nGuildTerritory > 0 then begin
            if RandomToGT(m_sMapName,{TTerritory(TGuild(m_MyGuild).m_Territory).TerritoryNumber}m_PEnvir.Flag.nGuildTerritory) then
              Result:=True;
          end else begin
            SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
            NoBaseObjectMove(m_sMapName,'','');      //nomove작업
            Result:=True;
          end;
        end;
      end else begin
        SysMsg('묑냘濫珂쐐岺賈痰。',c_Red,t_Hint);
      end;
    end;
    3: begin           //초공전서
      if (not m_PEnvir.Flag.boNOCASTLEMOVE) then begin
        SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
        if PKLevel < 2 then begin
          BaseObjectMove(m_sHomeMap,IntToStr(m_nHomeX),IntToStr(m_nHomeY));
        end else begin
          BaseObjectMove(g_Config.sRedHomeMap,IntToStr(g_Config.nRedHomeX),IntToStr(g_Config.nRedHomeY));
        end;
        Result:=True;
      end else begin
        SysMsg('묑냘濫珂쐐岺賈痰。',c_Red,t_Hint);
      end;
    end;
    4: begin          //귀환전서
      if (not m_PEnvir.Flag.boNOCASTLEMOVE) then begin
        if m_myGuild <> nil then begin
          if TGuild(m_MyGuild).m_Territory = nil then begin
            SysMsg('콱뻘청唐契삔鏤蹈。',c_Red,t_Hint);
            exit;
          end;
          if MoveToGT(TTerritory(TGuild(m_MyGuild).m_Territory).TerritoryNumber) then begin  //장원 이동
            Result:=True;
            SysMsg('콱綠쒔盧땡돕죄契삔鏤蹈。',c_Green ,t_Hint);
          end else
            SysMsg('콱뻘청唐契삔鏤蹈。',c_Red,t_Hint);
        end else
          SysMsg('콱뻘청唐속흙쳔탰。',c_Red,t_Hint);
      end else begin
        SysMsg('묑냘濫珂쐐岺賈痰。',c_Red,t_Hint);
      end;
    end;
    5: begin    //귀성전서
      if (not m_PEnvir.Flag.boNOCASTLEMOVE) then begin
        if m_MyGuild <> nil then begin
          if not m_boInFreePKArea then begin
            Castle:=g_CastleManager.IsMasterCastleMember(Self);  //정복자 확인
            if (Castle <> nil) and Castle.IsMasterGuild(TGuild(m_MyGuild)) then begin
              if g_FunctionNPC <> nil then begin
                g_FunctionNPC.GotoLable(Self,'@CastleMasterGo',False);
              end;
              //BaseObjectMove(Castle.GetHMapName,IntToStr(Castle.GetHHomeX),IntToStr(Castle.GetHHomeY)); //남만성으로 감
              Result:=True;
            end else begin
              Castle:=g_CastleManager.IsCastleMember(Self);
              if (Castle <> nil) and Castle.IsMasterGuild(TGuild(m_MyGuild)) then begin
                BaseObjectMove(Castle.GetHMapName,IntToStr(Castle.GetHHomeX),IntToStr(Castle.GetHHomeY));
              end else begin
                SysMsg('怜唐欖쥴냘광돨契삔냥逃꼽옵鹿賈痰。',c_Red,t_Hint);
              end;
              Result:=True;
            end;
          end else begin //004BD3F7
            SysMsg('콱꼇콘盧땡。',c_Red,t_Hint);
          end;
        end;
      end else begin
        SysMsg('묑냘濫珂쐐岺賈痰。',c_Red,t_Hint);
      end;
    end;
   
  end;
end;
function TPlayObject.MoveToGT(number:integer):boolean;      //장원 이동
var
  i:Integer;
  Envir:TEnvirnoment;
begin
  result:=False;
  envir:=nil;
  for i:=0 to g_MapManager.Count -1 do begin
    Envir:=TEnvirnoment(g_MapManager.Items[I]);
    if (Envir.Flag.nGuildTerritory = number) and (Envir.sMapName = g_Config.sGTHomeMap) then
      break;
  end;
  if envir = nil then exit;
  SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
  SpaceGTMoveEX(Envir.sMapName,g_Config.nGTHomeX,g_Config.nGTHomeY,0,number);
  result:=true;
end;


function TPlayObject.CallToGT(number,x,y:integer):boolean;      //장원 이동
var
  i:Integer;
  Envir:TEnvirnoment;
begin
  result:=False;
  envir:=nil;
  for i:=0 to g_MapManager.Count -1 do begin
    Envir:=TEnvirnoment(g_MapManager.Items[I]);
    if (Envir.Flag.nGuildTerritory = number) and (Envir.sMapName = g_Config.sGTCallMap) then
      break;
  end;
  if envir = nil then exit;
  SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
  SpaceGTMoveEX(Envir.sMapName,x,y,0,number);
  result:=true;
end;

function TPlayObject.RandomToGT(sMap:String;number:integer):boolean;      //장원 이동
var
  i:Integer;
  Envir,Envir2:TEnvirnoment;
  nX,nY,nEgdey:Integer;
begin
  result:=False;
  envir:=nil;
  for i:=0 to g_MapManager.Count -1 do begin
    Envir:=TEnvirnoment(g_MapManager.Items[I]);
    if (Envir.Flag.nGuildTerritory = number) and ((Envir.sMapName = g_Config.sGTHomeMap) or (Envir.sMapName = g_Config.sGTCallMap) or (Envir.sMapName = g_Config.sGTCallMap2) or (Envir.sMapName = g_Config.sGTCallMap3)) then
      break;
  end;
  if envir = nil then exit;

  Envir2:=g_MapManager.FindMap(sMap);
  if Envir2 <> nil then begin
    if Envir2.m_nHeight < 150 then begin
      if Envir2.m_nHeight < 30 then begin
        nEgdey:=2;
      end else nEgdey:=20;
    end else nEgdey:=50;
    nX:=Random(Envir2.m_nWidth - nEgdey -1) + nEgdey;
    nY:=Random(Envir2.m_nHeight - nEgdey -1) + nEgdey;
  end;

  SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
  SpaceGTMoveEX(sMap,nX,nY,0,number);
  result:=true;
end;



procedure TPlayObject.MoveToHome;
begin
  SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
  BaseObjectMove(m_sHomeMap,IntToStr(m_nHomeX),IntToStr(m_nHomeY));
end;


procedure TPlayObject.BaseObjectMove(sMap,sX,sY:String); //004BD0C4    //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
  Hum:TPlayObject;
begin
  Envir:=m_PEnvir;
  if sMap = '' then sMap:=m_sMapName;
  if (sX <> '') and (sY <> '') then begin
    nX:=Str_ToInt(sX,0);
    nY:=Str_ToInt(sY,0);
    SpaceMove(sMap,nX,nY,0);
  end else begin
    MapRandomMove(sMap,0);
  end;
  if (Envir <> m_PEnvir) then begin
    if (m_btRaceServer = RC_PLAYOBJECT) then begin   //리콜 해제
      Hum := TPlayObject(Self);

      if Hum.m_boTimeRecall or Hum.m_boTimeRecallGroup then
        Hum.SendMsg(Self,RM_COOLTIME,0,0,0, 0 , Hum.m_sMoveMap); //리콜 버프

      Hum.m_boTimeRecall:=False;
      Hum.m_boTimeRecallGroup:=False;
    end;
  end;
end;

procedure TPlayObject.NoBaseObjectMove(sMap,sX,sY:String); //004BD0C4    //nomove작업
var
  Envir:TEnvirnoment;
  nX,nY:Integer;
  Hum:TPlayObject;
begin
  Envir:=m_PEnvir;
  if sMap = '' then sMap:=m_sMapName;
  if (sX <> '') and (sY <> '') then begin
    nX:=Str_ToInt(sX,0);
    nY:=Str_ToInt(sY,0);
    NoSpaceMove(sMap,nX,nY,0);
  end else begin
    NoMapRandomMove(sMap,0);
  end;
  if (Envir <> m_PEnvir) then begin
    if (m_btRaceServer = RC_PLAYOBJECT) then begin   //리콜 해제
      Hum := TPlayObject(Self);

      if Hum.m_boTimeRecall or Hum.m_boTimeRecallGroup then
        Hum.SendMsg(Self,RM_COOLTIME,0,0,0, 0 , Hum.m_sMoveMap); //리콜 버프

      Hum.m_boTimeRecall:=False;
      Hum.m_boTimeRecallGroup:=False;
    end;
  end;
end;

function TPlayObject.WeaptonMakeLuck: Boolean;     //행운 표시
var
  StdItem:TItem;
  nRand:Integer;
  boMakeLuck:Boolean;
  PlayObject:TPlayObject;
begin
  Result:=False;
  if (m_UseItems[U_WEAPON].wIndex <= 0) or (m_UseItems[U_WEAPON].btValue[19] = 1) or (m_UseItems[U_WEAPON].btValue[19] > 2) then exit;  //대여무기 봉인템 축기 x
  nRand:=0;
  StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
  if StdItem <> nil then begin
    nRand:=abs((StdItem.DC2 - StdItem.DC)) div 5;
  end;
  if Random(g_Config.nWeaponMakeUnLuckRate{20}) = 1 then begin
    MakeWeaponUnlock();
  end else begin //004BD527
    boMakeLuck:=False;
    if m_UseItems[U_WEAPON].btValue[4] > 0 then begin
      Dec(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sWeaptonMakeLuck,c_Red,t_Hint);
      boMakeLuck:=True;
    end else if m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint1{1} then begin
      Inc(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sWeaptonMakeLuck,c_Red,t_Hint);
      boMakeLuck:=True;
    end else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint2{3}) and (Random(nRand + g_Config.nWeaponMakeLuckPoint2Rate{6}) = 1) then begin
      Inc(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sWeaptonMakeLuck,c_Red,t_Hint);
      boMakeLuck:=True;
    end else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint3{7}) and (Random(nRand * g_Config.nWeaponMakeLuckPoint3Rate{10 + 30}) = 1) then begin
      Inc(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sWeaptonMakeLuck,c_Red,t_Hint);
      boMakeLuck:=True;
    end;
    if m_btRaceServer = RC_PLAYOBJECT then begin
      RecalcAbilitys();
      PlayObject:=TPlayObject(Self);
      PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
      SendMsg(Self,RM_ABILITY,0,0,0,0,'');
      SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
    end;
    if not boMakeLuck then SysMsg(g_sWeaptonNotMakeLuck,c_Red,t_Hint);
  end;
  Result:=True;
end;

function TPlayObject.RepairWeapon: Boolean; //004BD69C
var
  nDura:Integer;
  UserItem:pTUserItem;
begin
  Result:=False;
  UserItem:=@m_UseItems[U_WEAPON];
  if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) or (UserItem.btValue[19] = 1) then exit;  //대여무기 수리기름 x
  Dec(UserItem.DuraMax,(UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura{30});
  nDura:=_MIN(5000,UserItem.DuraMax - UserItem.Dura);
  if nDura > 0 then begin
    Inc(UserItem.Dura,nDura);
    SendMsg(Self,RM_DURACHANGE,1,UserItem.Dura,UserItem.DuraMax,0,'');
    RecalcAbilitys();
    SendMsg(Self,RM_ABILITY,0,0,0,0,'');
    SysMsg(g_sWeaponRepairSuccess,c_Red,t_Hint);
    Result:=True;
  end;
end;

function TPlayObject.SuperRepairWeapon: Boolean; //004BD768
begin
  Result:=False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then exit;
  m_UseItems[U_WEAPON].Dura:=m_UseItems[U_WEAPON].DuraMax;
  SendMsg(Self,RM_DURACHANGE,1,m_UseItems[U_WEAPON].Dura,m_UseItems[U_WEAPON].DuraMax,0,'');
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SysMsg(g_sWeaponRepairSuccess,c_Red,t_Hint);
  Result:=True;
end;

// 일반 아이템 수리(2004/03/17).
function TPlayObject.RepairItemNormaly( psSeed: TItem; puSeed: PTUserItem ): Boolean;
var
   repair: integer;
   hum: TPlayObject;
begin
   Result := FALSE;

   if psSeed <> nil then begin
      if not (psSeed.boCanRepair) or (puSeed.btValue[19] = 1) then begin
         SysMsg ('늪膠틔轟랬錦잿。', c_Red,t_Hint);
         Result := FALSE;
         exit;
      end;

      repair := _MIN(5000, _MAX(0, puSeed.DuraMax - puSeed.Dura));   //DURAMAX수정
      if repair > 0 then begin
         puSeed.DuraMax := _MAX(0, puSeed.DuraMax - (repair div 30));   //DURAMAX수정
         puSeed.Dura := _MIN(puSeed.Dura + repair, puSeed.DuraMax);
         if m_btRaceServer = RC_PLAYOBJECT then begin
            hum := TPlayObject(self);
            hum.SendUpdateItem (puSeed);
         end;
         SysMsg ('''' + psSeed.Name + '''' + '錦잿供귄。', c_Green,t_Hint);
         Result := TRUE;
      end else begin
         SysMsg ('늪陋구꼇矜狼錦잿。', c_Red,t_Hint);
      end;
   end;
end;

function TPlayObject.RepairItemSuper( psSeed: TItem; puSeed: PTUserItem ): Boolean;
var
   repair: integer;
   hum: TPlayObject;
begin
   Result := FALSE;

   if psSeed <> nil then begin
      if not (psSeed.boCanRepair) then begin
         SysMsg ('늪陋구轟랬錦잿。', c_Red,t_Hint);
         Result := FALSE;
         exit;
      end;

      repair := _MIN(65000, _MAX(0, puSeed.DuraMax - puSeed.Dura));   //DURAMAX수정
      if repair > 0 then begin
         puSeed.Dura := _MIN(puSeed.Dura + repair, puSeed.DuraMax);
         if m_btRaceServer = RC_PLAYOBJECT then begin
            hum := TPlayObject(self);
            hum.SendUpdateItem (puSeed);
         end;
         SysMsg ('''' + psSeed.Name + '''' + ' 錦잿供귄。', c_Green,t_Hint);
         Result := TRUE;
      end else begin
         SysMsg ('늪陋구꼇矜狼錦잿。', c_Red,t_Hint);
      end;
   end;
end;

function TPlayObject.WinLottery: Boolean; //004BD7F8
var
  nGold,nWinLevel,nRate:Integer;
begin
  nGold:=0;
  nWinLevel:=0;
  {
  case Random(30000) of
    0..4999: begin //004BD866
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=500;
       nWinLevel:=6;
       Inc(nWinLotteryLevel6);
     end;
    end;
    14000..15999: begin //004BD895
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=1000;
       nWinLevel:=5;
       Inc(nWinLotteryLevel5);
     end;
    end;
    16000..16149: begin //004BD8C4
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=10000;
       nWinLevel:=4;
       Inc(nWinLotteryLevel4);
     end;
    end;
    16150..16169: begin //004BD8F0
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=100000;
       nWinLevel:=3;
       Inc(nWinLotteryLevel3);
     end;
    end;
    16170..16179: begin //004BD918
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=200000;
       nWinLevel:=2;
       Inc(nWinLotteryLevel2);
     end;
    end;
    16180 + 1820: begin //004BD940
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=1000000;
       nWinLevel:=1;
       Inc(nWinLotteryLevel1);
     end;
    end;
  end;
  }
  nRate:=Random(g_Config.nWinLotteryRate);
  if nRate in [g_Config.nWinLottery6Min..g_Config.nWinLottery6Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold:=g_Config.nWinLottery6Gold;
      nWinLevel:=6;
      Inc(g_Config.nWinLotteryLevel6);
    end;
  end else
  if nRate in [g_Config.nWinLottery5Min..g_Config.nWinLottery5Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold:=g_Config.nWinLottery5Gold;
      nWinLevel:=5;
      Inc(g_Config.nWinLotteryLevel5);
    end;
  end else
  if nRate in [g_Config.nWinLottery4Min..g_Config.nWinLottery4Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold:=g_Config.nWinLottery4Gold;
      nWinLevel:=4;
      Inc(g_Config.nWinLotteryLevel4);
    end;
  end else
  if nRate in [g_Config.nWinLottery3Min..g_Config.nWinLottery3Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold:=g_Config.nWinLottery3Gold;
      nWinLevel:=3;
      Inc(g_Config.nWinLotteryLevel3);
    end;
  end else
  if nRate in [g_Config.nWinLottery2Min..g_Config.nWinLottery2Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold:=g_Config.nWinLottery2Gold;
      nWinLevel:=2;
      Inc(g_Config.nWinLotteryLevel2);
    end;
  end else
  if nRate in [g_Config.nWinLottery1Min + g_Config.nWinLottery1Max] then begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then begin
      nGold:=g_Config.nWinLottery1Gold;
      nWinLevel:=1;
      Inc(g_Config.nWinLotteryLevel1);
    end;
  end;
  if nGold > 0 then begin
    case nWinLevel of    //
      1: SysMsg(g_sWinLottery1Msg,c_Green,t_Hint);
      2: SysMsg(g_sWinLottery2Msg,c_Green,t_Hint);
      3: SysMsg(g_sWinLottery3Msg,c_Green,t_Hint);
      4: SysMsg(g_sWinLottery4Msg,c_Green,t_Hint);
      5: SysMsg(g_sWinLottery5Msg,c_Green,t_Hint);
      6: SysMsg(g_sWinLottery6Msg,c_Green,t_Hint);
    end;  
    if IncGold(nGold) then begin
      GoldChanged();
    end else begin
      DropGoldDown(nGold,True,nil,nil);
    end;
      
  end else begin
    Inc(g_Config.nNoWinLotteryCount,500);
    SysMsg(g_sNotWinLotteryMsg,c_Red,t_Hint);
  end;
  Result:=True;
end;



procedure TBaseObject.DamageCelestialDefence(nInt: Integer); //선천기공
begin
  if m_wStatusTimeArr[STATE_SUNCHENDEFENCEUP{0x76}] > 0 then begin
    if m_wStatusTimeArr[STATE_SUNCHENDEFENCEUP{0x76}] > 3 then
      Dec(m_wStatusTimeArr[STATE_SUNCHENDEFENCEUP{0x76}],3)
    else m_wStatusTimeArr[STATE_SUNCHENDEFENCEUP{0x76}]:=1;
  end;
end;

procedure TBaseObject.DamageBubbleDefence(nInt: Integer); //주술의막
begin
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP{0x76}] > 0 then begin
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP{0x76}] > 3 then
      Dec(m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP{0x76}],3)
    else m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP{0x76}]:=1;
  end;
end;

procedure TBaseObject.DamageProtectDefence(nInt: Integer); //호신강기
begin
  if m_wStatusTimeArr[STATE_PROTECTSHIELD{0x76}] > 0 then begin
    if m_wStatusTimeArr[STATE_PROTECTSHIELD{0x76}] > 3 then
      Dec(m_wStatusTimeArr[STATE_PROTECTSHIELD{0x76}],3)
    else m_wStatusTimeArr[STATE_PROTECTSHIELD{0x76}]:=1;
  end;
end;

function TBaseObject.IsGuildMaster: Boolean; //004BF4A0
begin
  Result:=False;
  if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
    Result:=True;
end;

function TBaseObject.IsMyGuildMaster: Boolean;      //장원 외치기
begin
   Result := FALSE;
   if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then begin
      //다른 문주이면 FALSE.
      // 문주의 장원 번호와 현재 있는 맵의 장원번호가 일치 해야함.
      if (TGuild(m_MyGuild).m_Territory <> nil) and (TTerritory(TGuild(m_MyGuild).m_Territory).TerritoryNumber = m_PEnvir.Flag.nGuildTerritory) then begin
         Result := TRUE;
      end;
   end;
end;

procedure TPlayObject.ChangeServerMakeSlave(SlaveInfo: pTSlaveInfo);  //004DF84C
var
  nSlavecount:Integer;
  BaseObject:TBaseObject;
begin
  if m_btJob = jTaos then begin
    nSlavecount:=1;
  end else begin
    nSlavecount:=5;
  end;
  BaseObject:=MakeSlave(SlaveInfo.sSlaveName,3,SlaveInfo.btSlaveLevel,nSlavecount,SlaveInfo.dwRoyaltySec);
  if BaseObject <> nil then begin
    BaseObject.n294:=SlaveInfo.nKillCount;
    BaseObject.m_btSlaveExpLevel:=SlaveInfo.btSlaveExpLevel;
    BaseObject.m_WAbil.HP:=SlaveInfo.nHP;
    BaseObject.m_WAbil.MP:=SlaveInfo.nMP;
    if (1500 - SlaveInfo.btSlaveLevel * 200) < BaseObject.m_nWalkSpeed then begin
      BaseObject.m_nWalkSpeed:=1500 - SlaveInfo.btSlaveLevel * 200;
    end;
    if Integer(2000 - SlaveInfo.btSlaveLevel * 200) < BaseObject.m_nNextHitTime then begin
      BaseObject.m_nWalkSpeed:=2000 - SlaveInfo.btSlaveLevel * 200;
    end;
    RecalcAbilitys();
  end;
end;

procedure TPlayObject.SendDelDealItem(UserItem:pTUserItem); //004DD5D0        //거래
var
  pStdItem:TItem;
  ClientItem:TClientItem;
  sUserItemName: string;
begin

  SendDefMessage(SM_DEALDELITEM_OK,0,0,0,0,'');
  if m_DealCreat <> nil then begin
      pStdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if pStdItem <> nil then begin
        pStdItem.GetStandardItem(ClientItem.S);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(pStdItem,pStdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := FilterStdShowName(pStdItem,sUserItemName);

        ClientItem.MakeIndex:=UserItem.MakeIndex;
        ClientItem.Dura:=UserItem.Dura;
        ClientItem.DuraMax:=UserItem.DuraMax;
        ClientItem.Amount:=UserItem.Amount;
      end;
      m_DefMsg:=MakeDefaultMsg(SM_DEALREMOTEDELITEM,Integer(Self),0,0,1);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
    m_DealCreat.m_DealLastTick:=GetTickCount();
    m_DealLastTick:=GetTickCount();
  end;
end;

procedure TPlayObject.SendAddDealItem(UserItem: pTUserItem); //004DD464     //거래
var
  StdItem:TItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin
  if m_DealCreat <> nil then begin
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
     if not StdItem.boCanTrade or (UserItem.btValue[19] > 0) then begin //반짝 대여 봉인 아이템 거래 불가
       SendDefMessage(SM_DEALADDITEM_FAIL,0,0,0,0,'');
       SendMsg(Self,RM_MENU_OK,0,integer(Self),0,0, StdItem.Name + '角轟랬슥弄돨膠틔。');
       exit;
     end;
        StdItem.GetStandardItem(ClientItem.S);
        opt := StdItem.GetItemAddValue(UserItem,ClientItem.S);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

        ClientItem.MakeIndex:=UserItem.MakeIndex;
        ClientItem.Dura:=UserItem.Dura;
        ClientItem.DuraMax:=UserItem.DuraMax;
        ClientItem.Amount:=UserItem.Amount;
        ClientItem.UpgradeOpt := opt;
        m_DefMsg:=MakeDefaultMsg(SM_DEALREMOTEADDITEM,Integer(Self),0,0,1);
        TPlayObject(m_DealCreat).SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
        m_DealCreat.m_DealLastTick:=GetTickCount();
        m_DealLastTick:=GetTickCount();
    end;
  end;
  SendDefMessage(SM_DEALADDITEM_OK,0,0,0,0,'');
end;
procedure TPlayObject.OpenDealDlg(BaseObject:TBaseObject); //004DD300      //거래
begin
  m_boDealing:=True;
  m_DealCreat:=BaseObject;
  GetBackDealItems();
  SendDefMessage(SM_DEALMENU,0,0,0,0,m_DealCreat.m_sCharName);
  m_DealLastTick:=GetTickCount();
end;





procedure TPlayObject.SendDelRentalItem(UserItem:pTUserItem); //004DD5D0        //대여
var
  pStdItem:TItem;
  ClientItem:TClientItem;
  sUserItemName: string;
begin

  SendDefMessage(SM_RENTALDELITEM_OK,0,0,0,0,'');
  if m_RentalCreat <> nil then begin
      pStdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if pStdItem <> nil then begin
        pStdItem.GetStandardItem(ClientItem.S);
        sUserItemName := '';
        sUserItemName := FilterStdShowName(pStdItem,pStdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := FilterStdShowName(pStdItem,sUserItemName);

        ClientItem.MakeIndex:=UserItem.MakeIndex;
        ClientItem.Dura:=UserItem.Dura;
        ClientItem.DuraMax:=UserItem.DuraMax;
        ClientItem.Amount:=UserItem.Amount;
      end;
      m_DefMsg:=MakeDefaultMsg(SM_RENTALREMOTEDELITEM,Integer(Self),0,0,1);
      TPlayObject(m_RentalCreat).SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
    m_RentalCreat.m_RentalLastTick:=GetTickCount();
    m_RentalLastTick:=GetTickCount();
  end;
end;

procedure TPlayObject.SendAddRentalItem(UserItem: pTUserItem); //004DD464     //대여
var
  StdItem:TItem;
  ClientItem:TClientItem;
  opt: integer;
  sUserItemName: string;
begin
  if m_RentalCreat <> nil then begin
    StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then begin
     if not (StdItem.StdMode in [5,6,90,99,12,10,11,15,19,20,21,22,23,24,26,62,64]) then begin  //대여 기간적용
       SendDefMessage(SM_RENTALADDITEM_FAIL,0,0,0,0,'');
       SendMsg(Self,RM_MENU_OK,0,integer(Self),0,0, StdItem.Name + '轟랬理썼。');
       exit;
     end;
     if (CanConsignItem(StdItem.name)) or (CanRentalItem(StdItem.Name)) or not StdItem.boCanTrade or (UserItem.btValue[19] > 0) then begin //반짝 아이템 거래 불가
       SendDefMessage(SM_RENTALADDITEM_FAIL,0,0,0,0,'');
       SendMsg(Self,RM_MENU_OK,0,integer(Self),0,0, StdItem.Name + '轟랬理썼。');
       exit;
     end;

        StdItem.GetStandardItem(ClientItem.S);
        opt := StdItem.GetItemAddValue(UserItem,ClientItem.S);

        sUserItemName := '';
        sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

        ClientItem.MakeIndex:=UserItem.MakeIndex;
        ClientItem.Dura:=UserItem.Dura;
        ClientItem.DuraMax:=UserItem.DuraMax;
        ClientItem.Amount:=UserItem.Amount;
        ClientItem.UpgradeOpt := opt;
        m_DefMsg:=MakeDefaultMsg(SM_RENTALREMOTEADDITEM,Integer(Self),0,0,1);
        TPlayObject(m_RentalCreat).SendSocket(@m_DefMsg,EncodeBuffer(@ClientItem,SizeOf(TClientItem)));
        m_RentalCreat.m_RentalLastTick:=GetTickCount();
        m_RentalLastTick:=GetTickCount();
    end;
  end;
  SendDefMessage(SM_RENTALADDITEM_OK,0,0,0,0,'');
end;
procedure TPlayObject.OpenRentalDlg(BaseObject:TBaseObject;mode:integer); //004DD300      //대여
begin
  m_boRentaling:=True;
  m_RentalCreat:=BaseObject;
  GetBackRentalItems();
  SendDefMessage(SM_RENTALMENU,mode,0,0,0,m_RentalCreat.m_sCharName);
  m_RentalLastTick:=GetTickCount();
end;

procedure TPlayObject.SendGroupMsg(BaseObject: TPlayObject; wIdent: Word;
  nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if (m_GroupOwner <> nil) and (m_GroupOwner.m_GroupMembers.Count > 0) then
    for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if PlayObject <> BaseObject then begin
        if wident = SM_GROUPINFO2 then begin
          PlayObject.SendDefMsg(BaseObject, wIdent,
            Integer(BaseObject),
            BaseObject.m_Abil.Level,
            0,
            BaseObject.m_WAbil.MaxMP, '');
        end
        else
          PlayObject.SendDefMsg(BaseObject, wIdent, nRecog, nParam, nTag, nSeries, sMsg);
      end;
    end;
end;

procedure TPlayObject.SendGroupSocket(BaseObject: TPlayObject; wIdent: Word;
  nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if (m_GroupOwner <> nil) and (m_GroupOwner.m_GroupMembers.Count > 0) then
    for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if PlayObject <> BaseObject then begin
        PlayObject.SendDefSocket(BaseObject, wIdent, nRecog, nParam, nTag, nSeries, sMsg);
      end;
    end;
end;

procedure TPlayObject.SendRefGroupMsg(BaseObject: TPlayObject; wIdent: Word;
  nRecog: Integer; nParam, nTag, nSeries: Word; sMsg: string);
var
  i: Integer;
  PlayObject: TPlayObject;
begin
  if (m_GroupOwner <> nil) and (BaseObject <> nil) and (m_GroupOwner.m_GroupMembers.Count > 0) then
    for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do begin
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if (PlayObject <> BaseObject) and
        ((BaseObject.m_PEnvir <> m_PEnvir) or
        (Abs(BaseObject.m_nCurrX - PlayObject.m_nCurrX) > 12) or
        (Abs(BaseObject.m_nCurrY - PlayObject.m_nCurrY) > 12)) then begin
        if wident = SM_GROUPINFO2 then begin
          PlayObject.SendDefMsg(BaseObject, wIdent,
            Integer(BaseObject),
            BaseObject.m_Abil.Level,
            0,
            BaseObject.m_WAbil.MaxMP, '');
        end
        else
          PlayObject.SendDefMsg(BaseObject, wIdent, nRecog, nParam, nTag, nSeries, sMsg);
      end;
    end;
end;

procedure TPlayObject.JoinGroup(PlayObject: TPlayObject); //004C3AE4
ResourceString
  sJoinGroupMsg = '-%s속흙죄鬼莉。';
var
  ClientGroup: TClientGroup;
begin
  m_GroupOwner:=PlayObject;
  SendGroupText(format(sJoinGroupMsg,[m_sCharName]));

  ClientGroup.UserID := Integer(Self);
  ClientGroup.UserName := m_sCharName;
  ClientGroup.Level := m_Abil.Level;
  ClientGroup.HP := m_WAbil.HP;
  ClientGroup.MP := m_WAbil.MP;
  ClientGroup.MaxHP := m_WAbil.MaxHP;
  ClientGroup.MaxMP := m_WAbil.MaxMP;
  ClientGroup.btJob := m_btJob;
  ClientGroup.btSex := m_btGender;
  SendGroupSocket(Self, SM_GROUPADDMEM_OK, Integer(Self), 0, 0, 0, EncodeBuffer(@ClientGroup, SizeOf(ClientGroup)));
  if PlayObject.m_dwKillMonExpRateTime8 > 0 then begin
   PlayObject.m_nKillMonExpRate8:=100;
   PlayObject.m_dwKillMonExpRateTime8:= 0;
   PlayObject.SendMsg(self, RM_BUFF, 84, 0, 334, 0, ''); //솔플 경험치 해제
  end;
  if m_dwKillMonExpRateTime8 > 0 then begin
   m_nKillMonExpRate8:=100;
   m_dwKillMonExpRateTime8:= 0;
   SendMsg(self, RM_BUFF, 84, 0, 334, 0, ''); //솔플 경험치 해제
  end;
end;

procedure TPlayObject.ChangeGroup(PlayObject: TPlayObject);
begin
  m_GroupOwner := PlayObject;
  SendMsg(Self, RM_GROUPMESSAGE, 0, g_Config.btGroupMsgFColor,
    g_Config.btGroupMsgBColor, 0, '-' + PlayObject.m_sCharName + '님이 그룹장이 되었습니다.');
end;

function TBaseObject.MagCanHitTarget(nX, nY:Integer;
  TargeTBaseObject: TBaseObject): Boolean; //004C6B1C
var
  n14,n18,n1C,n20:Integer;
begin
  Result:=False;
  if TargeTBaseObject = nil then exit;
  n20:=abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
  n14:=0;
  while (n14 < 13) do begin
    n18:=GetNextDirection(nX,nY,TargeTBaseObject.m_nCurrX,TargeTBaseObject.m_nCurrY);
    if m_PEnvir.GetNextPosition(nX,nY,n18,1,nX,nY) and m_PEnvir.IsValidCell(nX,nY) then begin
      if (nX = TargeTBaseObject.m_nCurrX) and (nY = TargeTBaseObject.m_nCurrY) then begin
        Result:=True;
        break;
      end else begin
        n1C:=abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
        if n1C > n20 then begin
          Result:=True;
          break;
        end;
        n1C:=n20;
      end;
    end else begin
      break;
    end;
    Inc(n14);
  end;
end;

function TBaseObject.IsFriend (cret: TBaseObject): Boolean; //004C8F08
  begin
    Result:=False;
    if cret = nil then Exit;
    if cret.m_btRaceServer in [RC_PLAYOBJECT] then begin
      case m_btAttatckMode of
        HAM_ALL:  Result:=True;
        HAM_PEACE: Result:=True;
        HAM_GROUP: begin
          if cret = self then
            Result:=True;
          if IsGroupMember(cret)then
            Result:=True;
        end;
        HAM_GUILD: begin
          if cret = self then
            Result:=True;
          if m_MyGuild <> nil then begin
            if TGuild(m_MyGuild).IsMember(cret.m_sCharName) then
              Result:=True;
            if m_boGuildWarArea and (cret.m_MyGuild <> nil) then begin     //문파전,공성전 지역에 있음
              if TGuild(m_MyGuild).IsAllyGuild(TGuild(cret.m_MyGuild)) then
                Result:=True;
            end;
          end;
        end;
        HAM_ENEMY: begin         //적대 문파 (무공 버프 주냐 마냐..)
          if cret = self then Result:=True;
          if m_MyGuild <> nil then begin
            if TGuild(m_MyGuild).IsMember(cret.m_sCharName) then
              Result:=True;
            if m_boGuildWarArea and (cret.m_MyGuild <> nil) then begin            //문파전,공성전 지역에 있음
              if TGuild(m_MyGuild).IsAllyGuild(TGuild(cret.m_MyGuild)) then
                Result:=True;
            end;
          end;
        end;
        HAM_PKATTACK: begin
          if cret = self then Result:=True;
          if PKLevel >= 2 then begin
            if cret.PKLevel < 2 then Result:=True;
          end else begin
            if cret.PKLevel >= 2 then Result:=True;
          end;
        end;

      end;
    end;
end;
function TBaseObject.IsProperFriend(BaseObject: TBaseObject): boolean; //버프를 주냐 마냐...
var
  SelfObject: TBaseObject;
begin //004C909C
  Result:=False;
  SelfObject := nil;
  if BaseObject = nil then exit;
  if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_HEROOBJECT) then begin
    if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
      Result:=True;
    if BaseObject.m_Master <> nil then
      Result:=False;
    exit;
  end;
  if m_btRaceServer in [RC_PLAYOBJECT, RC_HEROOBJECT] then begin      //사람과 영웅만 체크
    if m_btRaceServer = RC_PLAYOBJECT then begin
      SelfObject := Self;
    end else begin
      if (m_Master <> nil) and (m_Master.m_btRaceServer = RC_PLAYOBJECT) then begin
        SelfObject := m_Master;
      end;
    end;
    if (SelfObject <> nil) and (SelfObject.m_btRaceServer = RC_PLAYOBJECT) then begin
      Result := SelfObject.IsFriend(BaseObject);   //본인 또는 주인의 친구
      if (BaseObject.m_btRaceServer < RC_ANIMAL) then exit;    //타겟이 몹이 아니다 그럼 끝
      if BaseObject.m_Master <> nil then begin    //타겟이 주인이있다.
        if BaseObject.m_Master = SelfObject then begin    //타겟의 주인이 내주인이거나 나다.
          Result := True;
          exit;
        end;
        Result := SelfObject.IsFriend(BaseObject.m_Master); //타겟이 주인이 있다면 그 주인의 상태를 비교해서 공격..
        exit;
      end;
    end;
  end else Result:=True;//004C913E
end;

function TBaseObject.IsReincarnation(BaseObject: TBaseObject): Boolean;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then Exit;
  if BaseObject.m_boDeath then begin
    if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
      Result := True;
  end;
end;

function TBaseObject.MagMakeDefenceArea(nX, nY, nRange, nSec: Integer;
  btState: Byte): Integer; //004C6F04
var
  III: Integer;
  I,II: Integer;
  nStartX,nStartY,nEndX,nEndY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
begin
  Result:=0;
  nStartX:=nX - nRange;
  nEndX:=nX + nRange;
  nStartY:=nY - nRange;
  nEndY:=nY + nRange;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(i,ii,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
          OSObject:=MapCellInfo.ObjList.Items[III];
          if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
            BaseObject:=TBaseObject(OSObject.CellObj);
            if (BaseObject <> nil) and (not BaseObject.m_boGhost) then begin
              if IsProperFriend(BaseObject) then begin
                if btState = 0 then begin
                  BaseObject.DefenceUp(nSec);
                end else begin
                  BaseObject.MagDefenceUp(nSec);
                end;
                Inc(Result);
              end
            end;
          end;
        end;
      end;
    end;
  end;
end;


function TBaseObject.MagMakeAddDefenceArea(nX, nY, nRange, nSec, point: Integer;    //흡성대법 강마진법
  btState: Byte): Integer; //004C6F04
var
  III: Integer;
  I,II: Integer;
  nStartX,nStartY,nEndX,nEndY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
begin
  Result:=0;
  nStartX:=nX - nRange;
  nEndX:=nX + nRange;
  nStartY:=nY - nRange;
  nEndY:=nY + nRange;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(i,ii,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
          OSObject:=MapCellInfo.ObjList.Items[III];
          if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
            BaseObject:=TBaseObject(OSObject.CellObj);
            if (BaseObject <> nil) and (not BaseObject.m_boGhost) then begin
              if IsProperFriend(BaseObject) then begin
                if btState = 0 then begin
                  BaseObject.HeathRecoveryUp(nSec,point);
                end else begin
                  BaseObject.SpellRecoveryUp(nSec,point);
                end;
                Inc(Result);
              end
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TBaseObject.MagBigPosion(xx, yy, range, sec , pwr , skilllevel: integer; BoMag: Boolean): Boolean;        //몹 독무
var
  I                :Integer;
  BaseObjectList   :TList;
  TargeTBaseObject :TBaseObject;
begin
  Result         := False;
  BaseObjectList := TList.Create;
  GetMapBaseObjects(m_PEnvir,xx,yy,range,BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do begin
    TargeTBaseObject:=TBaseObject(BaseObjectList.Items[i]);
    if IsProperTarget(TargeTBaseObject) then begin
      SetTargetCreat(TargeTBaseObject);
      TargeTBaseObject.SendDelayMsg(Self, RM_MAGSTRUCK_MINE,0,pwr,0,0,'',1800);
      Result:=True;
     if (Random(50) < skilllevel * 8) and (Random(TargeTBaseObject.m_btAntiPoison) = 0) then begin
        TargeTBaseObject.MakePosion(POISON_DECHEALTH,((skilllevel * 8) div 3),10);
     end;
    end;
  end;
  FreeAndNil(BaseObjectList);
end;


//서우

function TBaseObject.MagChangePosition(nTargetX, nTargetY: Integer): Boolean;  //서우 돌진
begin
  Result := False;
  if m_PEnvir.CanWalk(nTargetX, nTargetY, True) and (m_PEnvir.GetXYObjCount(nTargetX, nTargetY) = 0) then begin
    SpaceMagMove(nTargetX, nTargetY, 0);
    Result := True;
  end;
end;



function TBaseObject.MagCheckBuff(): Boolean;  //견빙수호장
var
 nC18:Boolean;
 i:integer;
begin
  Result := False;
  if (m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0) or (m_wStatusTimeArr[STATE_DEFENCEUP] > 0) or (m_wStatusTimeArr[STATE_BLOODSWORD] > 0)
  or (m_wStatusTimeArr[STATE_KUMGANG] > 0) or (m_wStatusTimeArr[STATE_YEONGMU] > 0) or (m_wStatusTimeArr[STATE_WINDMOON] > 0) or (m_wStatusTimeArr[STATE_BLOODMOON] > 0)
    or (m_wStatusTimeArr[STATE_SPEEDRUN] > 0) or (m_wStatusTimeArr[STATE_SKYSWORD] > 0) or (m_dwStatusArrTimeOutTick[7] > 0)
    or (m_dwStatusArrTimeOutTick[8] > 0) or (m_dwStatusArrTimeOutTick[9] > 0) or (m_dwStatusArrTimeOutTick[12] > 0) or (m_dwStatusArrTimeOutTick[13] > 0)  or (m_dwStatusArrTimeOutTick[29] > 0)
    or (m_dwStatusArrTimeOutTick[10] > 0) or (m_dwStatusArrTimeOutTick[15] > 0)  then begin

     m_dwStatusArrTimeOutTick[7] := 0;   //첨기폭
     m_dwStatusArrTimeOutTick[8] := 0;   //호신기막

     m_dwStatusArrTimeOutTick[9] := 0;   //체신풍
     m_dwStatusArrTimeOutTick[10] := 0;  //풍신술

     m_dwStatusArrTimeOutTick[12] := 0;  //흡성대법
     m_dwStatusArrTimeOutTick[13] := 0;  //강마진법

     m_dwStatusArrTimeOutTick[15] := 0;  //무극진기

     m_dwStatusArrTimeOutTick[29] := 0;  //수라강림

      if (m_wStatusTimeArr[STATE_MAGDEFENCEUP] > 0) then
        m_wStatusTimeArr[STATE_MAGDEFENCEUP]:=1;    //대지
      if (m_wStatusTimeArr[STATE_DEFENCEUP] > 0) then
        m_wStatusTimeArr[STATE_DEFENCEUP]:=1;//항마
      if (m_wStatusTimeArr[STATE_BLOODSWORD] > 0) then
        m_wStatusTimeArr[STATE_BLOODSWORD]:=1;//혈룡검법
      if (m_wStatusTimeArr[STATE_SPEEDRUN] > 0) then
        m_wStatusTimeArr[STATE_SPEEDRUN]:=1;//경신보
      if (m_wStatusTimeArr[STATE_SKYSWORD] > 0) then
        m_wStatusTimeArr[STATE_SKYSWORD]:=1;//천상비술

      if (m_wStatusTimeArr[STATE_KUMGANG] > 0) then
        m_wStatusTimeArr[STATE_KUMGANG]:=1;//금강불괴
      if (m_wStatusTimeArr[STATE_YEONGMU] > 0) then
        m_wStatusTimeArr[STATE_YEONGMU]:=1;//월영무
      if (m_wStatusTimeArr[STATE_WINDMOON] > 0) then
        m_wStatusTimeArr[STATE_WINDMOON]:=1;//청풍명월
      if (m_wStatusTimeArr[STATE_BLOODMOON] > 0) then
        m_wStatusTimeArr[STATE_BLOODMOON]:=1;//적혈무영


     nC18:=True;
  end else
     nC18 := False;

  if nC18 then begin
    Result := TRUE;
  end else begin
    Result := False;
  end;
end;

function  TBaseObject.MagMakeCurseArea(xx, yy, range, sec , pwr , skilllevel: integer; BoMag: Boolean): integer;
var
   i, j, k, stx, sty, enx, eny, tcount: integer;
   pm: pTMapCellinfo;
   OSObject:pTOSObject;
   inrange: Boolean;
   cret: TBaseObject;
   isNormalAttack : boolean;
   isAttack : Boolean;
   targetsec : integer;
begin
   tcount := 0;
   stx := xx-range;
   enx := xx+range;
   sty := yy-range;
   eny := yy+range;
   for i:=stx to enx do begin
      for j:=sty to eny do begin
         inrange := m_PEnvir.GetMapCellInfo (i, j, pm);
         if inrange then
            if pm.ObjList <> nil then begin
               for k:=0 to pm.ObjList.Count-1 do begin
                 OSObject:=pm.ObjList.Items[k];
                  if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
                    cret:=TBaseObject(OSObject.CellObj);
                     if cret <> nil then begin
                        if (not cret.m_boGhost) and (not cret.m_boDeath) then begin
                           //몬스터의 마법인 경우
                           if not BoMag then begin
                              if IsProperTarget (cret) then begin
                                 //중독 회복
                                 targetsec := (sec div 6) - cret.m_nPoisonRecover ;
                                 isAttack := false;

                                 //확률계산
                                 if ( Random(90 + (cret.m_btAntiPoison * 2) ) < ( 14 + (skilllevel + 1) * 8) ) then
                                    isAttack := true;

                                 if isAttack and ( targetsec > 0 )then begin
                                    cret.SendDelayMsg (self, RM_CURSE, targetsec, pwr, 0, 0, '', 1200);
                                    cret.SendDelayMsg (cret, RM_STRUCK, 1, m_WAbil.HP, m_WAbil.MP, integer(self), '', 1200);

                                    Inc (tcount);
                                 end;
                              end;
                           end else begin
                              if IsProperTarget (cret) then begin
                                 // 확률계산하구
                                 isNormalAttack := true;
                                 targetsec      := sec;
                                 if cret.m_btRaceServer = RC_PLAYOBJECT then begin     //타겟 사람인경우
                                    isNormalAttack := false;
                                    //중독 회복
                                    targetsec := (sec div 6 ) - cret.m_nPoisonRecover;
                                 end else begin      //몹인경우
                                    if cret.m_Abil.Level >= 100 then begin
                                       isNormalAttack := false;
                                       targetsec := (sec div 4 );
                                    end;
                                 end;

                                 isAttack := false;
                                 if isNormalAttack then begin  //몹인경우
                                    if ( Random(60 + cret.m_btAntiPoison) < ( 22{14} + ( skilllevel + 1) * 3 + (integer(m_Abil.Level) - integer( cret.m_Abil.level) )) ) then
                                       isAttack := true;
                                 end else begin    //사람인 경우
                                    if ( Random(70 + (cret.m_btAntiPoison * 2) ) < ( 22{14} + ( skilllevel + 1) * 3 + (integer(m_Abil.level) - integer(cret.m_Abil.Level) )) ) then
                                       isAttack := true;
                                 end;

                                 if isAttack and ( targetsec > 0 )then begin
                                    cret.SendDelayMsg (self, RM_CURSE, targetsec , pwr, 0, 0, '', 1200);
                                    cret.SendDelayMsg (cret, RM_STRUCK, 1, m_WAbil.HP, m_WAbil.MP, integer(self), '', 1200);
                                    Inc (tcount);
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               end;
            end;
      end;
   end;
   Result := tcount;
end;


procedure TBaseObject.BWindCutHit (TargeTBaseObject: TBaseObject ; hitPwr ,magpwr: integer );  //공파섬
var
   i, dam: integer;
begin
   if IsProperTarget (TargeTBaseObject) then begin
     dam := 0;
     dam := dam + TargeTBaseObject.GetHitStruckDamage (Self, hitpwr);
     dam := dam + TargeTBaseObject.GetMagStruckDamage (Self, magpwr);
     if dam > 0 then begin
       TargeTBaseObject.StruckDamage (dam);
       TargeTBaseObject.SendDelayMsg (TBaseObject(RM_STRUCK), RM_10101, dam,
             TargeTBaseObject.m_WAbil.HP, TargeTBaseObject.m_WAbil.MaxHP, Longint(Self){hiter}, '', 200);
     end;
   end;
end;

function  TBaseObject.MagBKWindCut (xx,yy,skilllevel, nPower: integer): Boolean;    //은형술
var
   i    : integer;
   rlist: TList;
   cret : TBaseObject;
   pwr  : integer;
   isnear : boolean;
  // xx,yy : integer;
   f1x,f1y,f2x,f2y : integer;
   CriticalDamage: Boolean;
   DcRandom: integer;
begin
   Result := FALSE;
   pwr := 0;
   isnear := FALSE;
   rlist := TList.Create;

   // 범위의 줌심이 되는 좌표 변경
  // xx := m_nCurrX;
  // yy := m_nCurrY;
   f1x := xx;
   f1y := yy;
   f2x := xx;
   f2y := yy;

   case m_btDirection of
   0 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx;
            f1y := yy - 1;
            f2x := xx;
            f2y := yy - 2;

            //중앙좌표 설정
            yy := yy - 3;
            GetMapBaseObjects (m_PEnvir, xx, yy, 2, rlist);
        end;
   1 :  begin

            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx + 1;
            f1y := yy - 1;
            f2x := xx + 2;
            f2y := yy - 2;

            //중앙좌표 설정
            xx := xx + 3;
            yy := yy - 3;

            GetObliqueMapBaseObjects (m_PEnvir, xx, yy, 2, m_btDirection, rlist);
        end;
   2 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx + 1;
            f1y := yy ;
            f2x := xx + 2;
            f2y := yy;

            //중앙좌표 설정
            xx  := xx + 3;

            GetMapBaseObjects (m_PEnvir, xx, yy, 2, rlist);
        end;
   3 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx + 1;
            f1y := yy + 1;
            f2x := xx + 2;
            f2y := yy + 2;

            //중앙좌표 설정
            xx := xx + 3;
            yy := yy + 3;

            GetObliqueMapBaseObjects (m_PEnvir, xx, yy, 2, m_btDirection, rlist);
        end;
   4 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx ;
            f1y := yy + 1;
            f2x := xx ;
            f2y := yy + 2;

            //중앙좌표 설정
            yy := yy + 3;

            GetMapBaseObjects (m_PEnvir, xx, yy, 2, rlist);
        end;
   5 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx - 1;
            f1y := yy + 1;
            f2x := xx - 2;
            f2y := yy + 2;

            //중앙좌표 설정
            xx := xx - 3;
            yy := yy + 3;

            GetObliqueMapBaseObjects (m_PEnvir, xx, yy, 2, m_btDirection, rlist);
        end;
   6 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx - 1;
            f1y := yy ;
            f2x := xx - 2;
            f2y := yy ;

            //중앙좌표 설정
            xx := xx - 3;

            GetMapBaseObjects (m_PEnvir, xx, yy, 2, rlist);
        end;
   7 :  begin
            // 강하게 타격이 들어가는 좌표 설정
            f1x := xx - 1;
            f1y := yy - 1;
            f2x := xx - 2;
            f2y := yy - 2;

            //중앙좌표 설정
            xx := xx - 3;
            yy := yy - 3;

            GetObliqueMapBaseObjects (m_PEnvir, xx, yy, 2, m_btDirection, rlist);
        end;
   end;

   //장비 행운치로 크리티컬 확률 결정
   CriticalDamage := FALSE;
   if Random(100) <= (1 + m_UseItems[U_WEAPON].btValue[3] - m_UseItems[U_WEAPON].btValue[4]) then
      CriticalDamage := TRUE;

   for i:=0 to rlist.Count-1 do begin
      cret := TBaseObject (rlist[i]);
      if IsProperTarget (cret) and ( not cret.m_boDeath) and ( not cret.m_BoGhost ) then
      begin

      pwr := nPower;
         //크리티컬 데미지
         if CriticalDamage then begin
            pwr := nPower * 2;
         end;

         if pwr > 0 then begin
            BWindCutHit( cret, pwr, 0 );
            Result := TRUE;
         end;
      end;
   end;
   FreeAndNil(rlist);

end;

procedure TBaseObject.MagCurse(sec , pwrrate: integer);
begin
    MakePosion(POISON_SLOWDOWN,sec,1);

   if ExtraAbilTimes[EABIL_PWRRATE] < ( GetTickCount + LongWord(sec * 1000)) then begin

      ExtraAbil[EABIL_PWRRATE] := pwrrate;
      ExtraAbilTimes[EABIL_PWRRATE] := GetTickCount + LongWord(sec * 1000); //초단위

      if pwrrate < 100 then begin
       SysMsg('묑샌제숑 '+IntToStr(100-pwrrate) + '%，넣崎' + IntToStr(sec) + '취。',c_Green,t_Hint );
      end else begin
       SysMsg('묑샌제藤속 '+IntToStr(pwrrate-100) + '%，넣崎' + IntToStr(sec) + '취。',c_Green,t_Hint );
      end;

      RecalcAbilitys;
      SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');

   end;
end;

function TBaseObject.DefenceUp(nSec: Integer): Boolean; //004C6C28        //대지원호
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_DEFENCEUP{0x72}] > 0 then begin  //004C6C5C
    if m_wStatusTimeArr[STATE_DEFENCEUP{0x72}] < nSec then begin
      m_wStatusTimeArr[STATE_DEFENCEUP{0x72}]:=nSec;
      Result:=True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_DEFENCEUP{0x72}]:=nSec;
    Result:=True;
  end;
  m_dwStatusArrTick[STATE_DEFENCEUP{0x20C}]:=GetTickCount;
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(Self).SysMsg(format('亶衿돨 ' + g_sDefenceUpTime,[nSec]),c_Green,t_Hint);
  end else
  SysMsg(format(g_sDefenceUpTime,[nSec]),c_Green,t_Hint);

  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg (Self,RM_BUFF, 12, 0, 10, nSec, format('[ 誅Φ슨栗 ]\렝徒 + %d: ' ,[nPowerDefen]));   //대지 버프
end;

function TBaseObject.AttPowerUp(nPower, nTime: Integer): Boolean;
var
  i,nMin,nSec:Integer;
  cret: TBaseObject;
begin
  Result:=False;

  m_wStatusArrValue[15]:=nPower;
  m_wStatusArrFlag[15] := 0;
  m_dwStatusArrTimeOutTick[15]:=GetTickCount + nTime * 1000;

  nMin := nTime div 60;
  nSec := nTime mod 60;
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(Self).SysMsg(format('亶衿돨 ' + g_sAttPowerUpTime,[nMin, nSec]),c_Green,t_Hint);
  end else begin
    if m_btJob = 4 then begin             //직업변경
      SysMsg(format(g_sAttPowerBonzeUpTime,[nMin, nSec]),c_Green,t_Hint);
    end else begin
      SysMsg(format(g_sAttPowerUpTime,[nMin, nSec]),c_Green,t_Hint);
    end;
  end;
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  if m_btJob = 4 then begin                 //직업변경
    SendMsg (Self,RM_BUFF, 4, 0, 2, nTime, format('[ 轟섐廬폭 ]\묑샌，돛減 + %d: ',[nPower]) );   //무극진기 버프
  end else begin
    SendMsg (Self,RM_BUFF, 4, 0, 2, nTime, format('[ 轟섐廬폭 ]\묑샌제 + %d: ',[nPower]) );   //무극진기 버프
  end;


  if m_SlaveList.Count >= 1 then begin
      for i := 0 to m_SlaveList.Count -1 do begin
         cret := TBaseObject(m_SlaveList.Items[i]);
         if (cret <> nil) then begin
            cret.m_wStatusArrValue[0] := nPower;
            cret.m_wStatusArrFlag[0] := 0;
            cret.m_dwStatusArrTimeOutTick[0] := GetTickCount + nTime * 1000; //초단위
            cret.RecalcAbilitys;
         end;
      end;
   end;

  Result:=True;
end;

function TBaseObject.MagicPowerUpWindMoon(nTime: Integer): Boolean;   //청풍명월
begin
  Result:=False;
  m_wStatusTimeArr[STATE_WINDMOON]:=nTime;
  m_dwStatusArrTick[STATE_WINDMOON]:=GetTickCount;

  m_nCharStatus:=GetCharStatus();
  StatusChanged();

  RecalcAbilitys();

  SysMsg(format(g_sWindMoonUpTime,[nTime]),c_Green,t_Hint);
  Case m_btJob of              //직업변경
    0,5 : SendMsg (Self,RM_BUFF, 16, 0, 14, nTime, '[ 헌루츠墩 ]\늬굵Ｊ樵Я寧凋７ªЭ廚叡 돤돕퓻뺏: ' );  //청풍명월 버프
    1,6 : SendMsg (Self,RM_BUFF, 16, 0, 14, nTime, '[ 헌루츠墩 ]\삽퓰，침랬뜀，삽질폭落 돤돕퓻뺏: ' );
    2,7 : SendMsg (Self,RM_BUFF, 16, 0, 14, nTime, '[ 헌루츠墩 ]\聃쥣뜀，誅Φ슨栗 돤돕퓻뺏: ' );
    3,8 : SendMsg (Self,RM_BUFF, 16, 0, 14, nTime, '[ 헌루츠墩 ]\루숲減，루綽 돤돕퓻뺏: ' );
    4,9 : SendMsg (Self,RM_BUFF, 16, 0, 14, nTime, '[ 헌루츠墩 ]\邱莖廬폭，슉질벅랬 돤돕퓻뺏: ' );
  end;
  Result:=True;
end;

function TBaseObject.MagicPowerUpBloodMoon(nTime: Integer): Boolean;   //적혈무영
var
 nSec:Integer;
begin
  Result:=False;
  m_wStatusTimeArr[STATE_BLOODMOON]:=nTime;
  m_dwStatusArrTick[STATE_BLOODMOON]:=GetTickCount;

  m_nCharStatus:=GetCharStatus();
  StatusChanged();
  RecalcAbilitys();

  SysMsg(format(g_sBloodMoonUpTime,[nTime]),c_Green,t_Hint);
  Case m_btJob of         //직업변경
    0,5 : SendMsg (Self,RM_BUFF, 64, 0, 120, nTime, '[ 븐沂校緞 ]\빱昨評빰ЫＦ澎В휑젓 돤돕퓻뺏: ' );  //적혈무영 버프
    1,6 : SendMsg (Self,RM_BUFF, 64, 0, 120, nTime, '[ 븐沂校緞 ]\莖岡깥뻔，莖苟眼汝П旱撚 돤돕퓻뺏: ' );
    2,7 : SendMsg (Self,RM_BUFF, 64, 0, 120, nTime, '[ 븐沂校緞 ]\뗀絞 돤돕퓻뺏: ' );
    3,8 : SendMsg (Self,RM_BUFF, 64, 0, 120, nTime, '[ 븐沂校緞 ]\墩빽쫘校 돤돕퓻뺏: ' );
    4,9 : SendMsg (Self,RM_BUFF, 64, 0, 120, nTime, '[ 븐沂校緞 ]\륨빪벅랬 돤돕퓻뺏: ' );
  end;
  Result:=True;
end;

function TBaseObject.AttSpeedUp(nPower, nTime: Integer): Boolean;  //체신풍
var
  nSec:Integer;
begin
  Result:=False;

  if m_wStatusTimeArr[STATE_ASSTRANSPARENT] > 0 then  //월영술 및 열화신 공격시.. 풀림
  m_wStatusTimeArr[STATE_ASSTRANSPARENT]:=1;

  if m_wStatusTimeArr[STATE_YEONGMU] > 0 then  //월영무 공격시.. 풀림
  m_wStatusTimeArr[STATE_YEONGMU]:=1;

  m_wStatusArrValue[9]:=nPower;
  m_dwStatusArrTimeOutTick[9]:=GetTickCount + nTime * 1000;

  nSec := nTime;

  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(Self).SysMsg(format('亶衿돨 ' + g_sAttSpeedUpTime,[nSec]),c_Green,t_Hint);
  end else
  SysMsg(format(g_sAttSpeedUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  Result:=True;
  SendMsg (Self,RM_BUFF, 22, 0, 20, nSec, format('[ 竟祺루 ]\묑샌醵똑 + %d: ',[nPower]) );   //체신풍 버프
end;

function TBaseObject.DelayOhaeng(nTime: Integer): Boolean;  //음양오행진
begin
  Result:=False;

  m_wStatusArrValue[65]:=nTime;
  m_dwStatusArrTimeOutTick[65]:=GetTickCount + nTime * 1000;

  SendMsg (Self,RM_COOLBUFF, 74, 0, 56, nTime, '[ 綾捺巧契黎 ]\잤홱珂쇌: ');   //음양오행진 쿨타임 버프
  Result:=True;
end;


function TBaseObject.AttPowerDown(nPower, nTime: Integer): Boolean;
var
  nMin,nSec:Integer;
begin
  Result:=False;

  m_wStatusArrValue[6]:=nPower;
  m_dwStatusArrTimeOutTick[6]:=GetTickCount + nTime * 1000;

  nMin := nTime div 60;
  nSec := nTime mod 60;

  SysMsg(format(g_sAttPowerDownTime,[nMin, nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  Result:=True;
end;

function TBaseObject.SpeedUp(nPower, nTime: Integer): Boolean;   //풍신술
var
  nSec:Integer;
begin
  Result:=False;

  m_wStatusArrValue[10]:=nPower;
  m_dwStatusArrTimeOutTick[10]:=GetTickCount + nTime * 1000;

  nSec := nTime ;
  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(Self).SysMsg(format('亶衿돨 ' + g_sSpeedPointUpTime,[nSec]),c_Green,t_Hint);
  end else
  SysMsg(format(g_sSpeedPointUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  Result:=True;
  SendMsg (Self,RM_BUFF, 24, 0, 22, nSec, format('[ 루綽 ]\츌쌥 + %d: ',[nPower]) );  //풍신술 버프
end;

function TBaseObject.MagSuraDefenceUp(nPower, nTime: Integer): Boolean;   //수라강림
var
  nSec:Integer;
begin
  Result:=False;

  m_wStatusArrValue[29]:=nPower;
  m_dwStatusArrTimeOutTick[29]:=GetTickCount + nTime * 1000;

  nSec := nTime ;

  SysMsg(format(g_sSuraMagDefenceUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  Result:=True;
  SendMsg (Self,RM_BUFF, 63, 0, 508, nSec, format('[ 莖洲돝 ]\침랬렝徒 + %d: ',[nPower]) );  //수라강림 버프
end;

function TBaseObject.SunChunJingiHPUP(nPower, nTime, nDelay: Integer): Boolean;    //선천진기 - 승려
begin
  Result:=False;
  m_boSunchunUse := True;
  m_wStatusArrValue[81]:=nPower;
  m_dwStatusArrTimeOutTick[81]:=GetTickCount + nTime * 1000;

  SysMsg(format(g_sSunChunHPUpTime,[nPower, nTime]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  Result:=True;
  SendMsg (Self,RM_BUFF, 94, 0, 409, nTime, format('[ 邱莖廬폭 ]\MAXHP + %d: ',[nPower]) );  //선천진기 버프
end;

function TBaseObject.MagPenetrate(nPower, nTime: Integer): Boolean; //004C6F04
var
  III: Integer;
  I,II: Integer;
  nStartX,nStartY,nEndX,nEndY:Integer;
  MapCellInfo:pTMapCellinfo;
  OSObject:pTOSObject;
  BaseObject:TBaseObject;
begin
  Result:=False;
  nStartX:=m_nCurrX - nPower;
  nEndX:=m_nCurrX + nPower;
  nStartY:=m_nCurrY - nPower;
  nEndY:=m_nCurrY + nPower;
  for I := nStartX to nEndX do begin
    for II := nStartY to nEndY do begin
      if m_PEnvir.GetMapCellInfo(i,ii,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
        for III := 0 to MapCellInfo.ObjList.Count - 1 do begin
          OSObject:=MapCellInfo.ObjList.Items[III];
          if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then begin
            BaseObject:=TBaseObject(OSObject.CellObj);
            if (BaseObject <> nil) and (not BaseObject.m_boGhost) then begin

              if BaseObject.m_wStatusTimeArr[STATE_PENETRATE] > 0 then begin
                BaseObject.m_wStatusTimeArr[STATE_PENETRATE]:=1;
                m_wStatusArrValue[60]:=nTime;
                m_dwStatusArrTimeOutTick[60]:=GetTickCount + nTime * 1000;
                SendMsg (Self, RM_COOLBUFF, 68, 0, 16, nTime, '[ 价空裂癩 ]\잤홱珂쇌: ' );  //망자의눈 쿨타임 버프
                Result:=True;
              end;

            end;
          end;
        end;
      end;
    end;
  end;
end;


function TBaseObject.ChenMuUp(nPower, nTime, nDelay: Integer): Boolean;   //천무
var
  nSec:Integer;
begin
  Result:=False;

  m_wStatusArrValue[11]:=nPower;
  m_dwStatusArrTimeOutTick[11]:=GetTickCount + nTime * 1000;

  m_wStatusArrValue[32]:=nPower;
  m_dwStatusArrTimeOutTick[32]:=GetTickCount + nDelay * 1000;

  nSec := nTime ;

  SysMsg(format(g_sTenMuUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  Result:=True;
  SendMsg (Self, RM_BUFF, 54, 0, 39, nTime, format('[ 莖蛟 ]\襁┠뉘，렝徒 + %d, 침랬 + %d: ',[nPower + 2, nPower + 2]) );  //천무 버프
  SendMsg (Self, RM_COOLBUFF, 55, 0, 40, nDelay, '[ 莖蛟 ]\잤홱珂쇌: ' );  //천무 쿨타임 버프
end;

function TBaseObject.TempPowerUp(nAbil, nPower, nTime: Integer): Boolean;   //TempPowerUp
begin
  Result:=false;
  case nAbil of
    0 : begin
         Result:=False;
         m_wStatusArrValue[0]:=nPower;
         m_wStatusArrFlag[0]:=0;
         m_dwStatusArrTimeOutTick[0]:=GetTickCount + nTime * 1000;

         if nTime >= 3600 then
          SysMsg('줄珂묑샌藤속 ' + IntToStr(nTime div 3600) + '鬼珂。',c_Green,t_Hint)
         else
          SysMsg('줄珂묑샌藤속 ' + IntToStr(nTime div 60) + '롸爐。',c_Green,t_Hint);

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg (Self,RM_BUFF, 3, 0, 307, nTime, format('묑샌제 + %d: ' ,[nPower]) );   //파괴의물약 버프

         Result:=True;
    end;
    1 : begin
         Result:=False;
         m_wStatusArrValue[1]:=nPower;
         m_wStatusArrFlag[1]:=0;
         m_dwStatusArrTimeOutTick[1]:=GetTickCount + nTime * 1000;

         if nTime >= 3600 then
          SysMsg('줄珂침랬藤속 ' + IntToStr(nTime div 3600) + '鬼珂。',c_Green,t_Hint)
         else
          SysMsg('줄珂침랬藤속 ' + IntToStr(nTime div 60) + '롸爐。',c_Green,t_Hint);

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg (Self,RM_BUFF, 5, 0, 308, nTime, format('침랬 +  %d: ' ,[nPower]) );  //마력의물약 버프
         Result:=True;
    end;
    2 : begin
         Result:=False;
         m_wStatusArrValue[2]:=nPower;
         m_wStatusArrFlag[2]:=0;
         m_dwStatusArrTimeOutTick[2]:=GetTickCount + nTime * 1000;

         if nTime >= 3600 then
          SysMsg('줄珂돛減藤속 ' + IntToStr(nTime div 3600) + '鬼珂。',c_Green,t_Hint)
         else
          SysMsg('줄珂돛減藤속 ' + IntToStr(nTime div 60) + '롸爐。',c_Green,t_Hint);

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg (Self,RM_BUFF, 6, 0, 309, nTime, format('돛減 + %d: ' ,[nPower]) );  //도력의물약 버프
         Result:=True;
    end;
    3 : begin
         Result:=False;
         m_wStatusArrValue[3]:=nPower;
         m_wStatusArrFlag[3]:=0;
         m_dwStatusArrTimeOutTick[3]:=GetTickCount + nTime * 1000;

         if nTime >= 3600 then
          SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(nTime div 3600) + '鬼珂。',c_Green,t_Hint)
         else
          SysMsg('줄珂묑샌醵똑藤속 ' + IntToStr(nTime div 60) + '롸爐。',c_Green,t_Hint);

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg (Self,RM_BUFF, 7, 0, 312, nTime, format('묑샌醵똑 + %d: ' ,[nPower]) );  //광풍물약 버프
         Result:=True;
    end;
    4 : begin
         Result:=False;
         m_wStatusArrValue[4]:=nPower;
         m_wStatusArrFlag[4]:=0;
         m_dwStatusArrTimeOutTick[4]:=GetTickCount + nTime * 1000;

         if nTime >= 3600 then
          SysMsg('줄珂餉篁둣梔 ' + IntToStr(nTime div 3600) + '鬼珂。',c_Green,t_Hint)
         else
          SysMsg('줄珂餉篁둣梔 ' + IntToStr(nTime div 60) + '롸爐。',c_Green,t_Hint);

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg (Self,RM_BUFF, 10, 0, 310, nTime, format('MAX HP + %d: ' ,[nPower]) );  //육체 버프
         Result:=True;
    end;
    5 : begin
         Result:=False;
         m_wStatusArrValue[5]:=nPower;
         m_wStatusArrFlag[5]:=0;
         m_dwStatusArrTimeOutTick[5]:=GetTickCount + nTime * 1000;

         if nTime >= 3600 then
          SysMsg('줄珂침랬令藤속 ' + IntToStr(nTime div 3600) + '鬼珂。',c_Green,t_Hint)
         else
          SysMsg('줄珂침랬令藤속 ' + IntToStr(nTime div 60) + '롸爐。',c_Green,t_Hint);

         RecalcAbilitys();
         SendMsg(Self,RM_ABILITY,0,0,0,0,'');
         SendMsg (Self,RM_BUFF, 11, 0, 311, nTime, format('MAX MP + %d: ' ,[nPower]) );  //정신 버프
         Result:=True;
    end;
  end;
end;

function TBaseObject.MagDefenceUp(nSec: Integer): Boolean; //004C6D38
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP{0x74}] > 0 then begin //004C6D6C
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP{0x74}] < nSec then begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP{0x74}]:=nSec;
      Result:=True;
    end;
  end else begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP{0x74}]:=nSec;
    Result:=True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP{0x210}]:=GetTickCount;

  if m_btRaceServer = RC_HEROOBJECT then begin
    THeroObject(Self).SysMsg(format('亶衿돨 ' + g_sMagDefenceUpTime,[nSec]),c_Green,t_Hint);
  end else
  SysMsg(format(g_sMagDefenceUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg (Self,RM_BUFF, 13, 0, 11, nSec, format('[ 聃쥣뜀 ]\침랬렝徒 + %d: ' ,[nPowerMagDefen]));  //항마 버프
end;

function TBaseObject.HeathRecoveryOhaeng(nSec,npoint: Integer): Boolean; //음양오행진
begin
  Result:=False;

  m_boOhaeng := True;
  m_wStatusArrValue[120]:=npoint;
  m_dwStatusArrTimeOutTick[120]:=GetTickCount + nSec * 1000;

  RecalcAbilitys();
  Result:=True;
end;


function TBaseObject.HeathRecoveryUp(nSec,npoint: Integer): Boolean; //흡성대법
begin
  Result:=False;

  m_wStatusArrValue[12]:=npoint;
  m_dwStatusArrTimeOutTick[12]:=GetTickCount + nSec * 1000;

  m_wStatusArrValue[104]:=1;
  m_dwStatusArrTimeOutTick[104]:=GetTickCount + nSec * 1000;

  SysMsg(format(g_sHeathRecoveryUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  SendMsg (Self,RM_BUFF, 34, 0, 31, nSec, format('[ 俱槿댕랬 ]\餉環寧 + %d\렝徒 + %d: ' ,[npoint * 10, nPowerDefen2]));  //흡성대법 버프

  Result:=True;
end;

function TBaseObject.SpellRecoveryUp(nSec,npoint: Integer): Boolean; //강마진법
begin
  Result:=False;

  m_wStatusArrValue[13]:=npoint;
  m_dwStatusArrTimeOutTick[13]:=GetTickCount + nSec * 1000;

  m_wStatusArrValue[105]:=1;
  m_dwStatusArrTimeOutTick[105]:=GetTickCount + nSec * 1000;

  SysMsg(format(g_sSpellRecoveryUpTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
  SendMsg (Self,RM_BUFF, 35, 0, 32, nSec, format('[ 퓻침黎랬 ]\침랬뿟릿 + %d\침랬렝徒 + %d: ' ,[npoint * 10, nPowerMagDefen2]));  //강마진법 버프

  Result:=True;
end;


function TBaseObject.MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean; //004C6E4C 주술의막
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] <> 0 then exit;   //004C6E79
  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP]:=nSec;
  m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP]:=GetTickCount();
  m_nCharStatus:=GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  m_boAbilMagBubbleDefence:=True;
  m_btMagBubbleDefenceLevel:=nLevel;
  Result:=True;
end;

function TBaseObject.MagProtectDefenceUp(nLevel, nSec: Integer): Boolean; //호신강기
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_PROTECTSHIELD] <> 0 then exit;   //004C6E79
  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_PROTECTSHIELD]:=nSec;
  m_dwStatusArrTick[STATE_PROTECTSHIELD]:=GetTickCount();
  m_nCharStatus:=GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  m_boAbilMagProtectDefence:=True;
  m_btMagProtectDefenceLevel:=nLevel;
  Result:=True;
end;


function TBaseObject.MagKumGangDefenceUp(nLevel, nSec, nDSec: Integer): Boolean; //금강불괴
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_KUMGANG] <> 0 then exit;   //004C6E79
  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_KUMGANG]:=nSec;
  m_dwStatusArrTick[STATE_KUMGANG]:=GetTickCount();
  m_nCharStatus:=GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  m_boAbilMagKumGangDefence:=True;
  m_btMagKumGangDefenceLevel:=nLevel;

  //파괴 감소
  ExtraAbil[EABIL_DCRATE] := 90;
  ExtraAbilTimes[EABIL_DCRATE] := GetTickCount + LongWord(nSec * 1000); //초단위
  SysMsg('쏜먼꼇뻐：瞳' + IntToStr(nSec) + '취코，슉됴10돨묑샌제윱숑10%襁─',c_Green,t_Hint );

  //금강불괴 버프
  SendMsg (Self, RM_BUFF, 70, 0, 52, nSec, '[ 쏜먼꼇뻐 ]\숑貌襁┌Р뼛炳샌\묑샌제슉됴10%: ' );  //금강불괴 쿨타임 버프

  //딜레이
  m_wStatusArrValue[61]:=nDSec;
  m_dwStatusArrTimeOutTick[61]:=GetTickCount + nDSec * 1000;
  SendMsg (Self, RM_COOLBUFF, 71, 0, 53, nDSec, '[ 쏜먼꼇뻐 ]\잤홱珂쇌: ' );  //금강불괴 쿨타임 버프

  RecalcAbilitys;
  SendMsg (self, RM_ABILITY, 0, 0, 0, 0, '');

  Result:=True;
end;

function TBaseObject.MagicUp(nPower, nSec: Integer): Boolean; //004C6E4C 심연술
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_MAGICUP] <> 0 then
  exit;

  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_MAGICUP]:=nSec;
  m_btStatusValue[STATE_MAGICUP]:=nPower;
  m_dwStatusArrTick[STATE_MAGICUP]:=GetTickCount;
  m_nCharStatus:=GetCharStatus();


  m_wStatusArrValue[33]:=nPower;
  m_dwStatusArrTimeOutTick[33]:=GetTickCount + 80 * 1000;

  SysMsg(format(g_sMagicUpTime,[nSec]),c_Green,t_Hint);

  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  Result:=True;
  SendMsg (Self,RM_BUFF, 56, 0, 37, nSec, '[ 雎錟 ]\MP句봬藤속30%\' + format('침랬 + %d: ' ,[nPower]));  //심연술 버프
  SendMsg (Self,RM_COOLBUFF, 57, 0, 38, 80, '[ 雎錟 ]\잤홱珂쇌: ');   //심연술 쿨타임 버프
end;


function TBaseObject.WalkSpeedUp(nSec: Integer): Boolean; //경신보
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_SPEEDRUN] <> 0 then
  exit;
  m_wStatusTimeArr[STATE_SPEEDRUN]:=nSec;
  m_dwStatusArrTick[STATE_SPEEDRUN]:=GetTickCount;
  m_nCharStatus:=GetCharStatus();

  StatusChanged();
  
  m_wStatusArrValue[30]:=1;
  m_dwStatusArrTimeOutTick[30]:=GetTickCount + 120 * 1000;

  SysMsg(format(g_sWalkSpeedUpTime,[nSec]),c_Green,t_Hint);

  RecalcAbilitys();
  Result:=True;
  SendMsg (Self, RM_BUFF, 23, 0, 21, nSec, '[ 햐滋 ]\瓊멕盧땡醵똑: ');     //경신보 버프
  SendMsg (Self, RM_COOLBUFF, 25, 0, 23, 120, '[ 햐滋 ]\잤홱珂쇌: ');    //경신보 쿨타임 버프

end;

function TBaseObject.BloodUp(nPower, nSec: Integer): Boolean; //004C6E4C 혈룡검법
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_BLOODSWORD] <> 0 then
  exit;
  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_BLOODSWORD]:=nSec;
  m_btStatusValue[STATE_BLOODSWORD]:=nPower;
  m_dwStatusArrTick[STATE_BLOODSWORD]:=GetTickCount;
  m_nCharStatus:=GetCharStatus();

  m_wStatusArrValue[34]:=nPower;
  m_dwStatusArrTimeOutTick[34]:=GetTickCount + 150 * 1000;

  SysMsg(format(g_sBloodUpTime,[nSec]),c_Green,t_Hint);

  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  RecalcAbilitys();
  Result:=True;
  SendMsg (Self,RM_BUFF, 58, 0, 46, nSec, format('[ 沂질숲랬 ]\묑샌醵똑 + %d: ' ,[nPower])); //혈룡검법 버프
  SendMsg (Self, RM_COOLBUFF, 59, 0, 47, 150, '[ 沂질숲랬 ]\잤홱珂쇌: ');   //혈룡검법 쿨타임 버프

end;

function TBaseObject.ThunderWave(nPower, nSec: Integer): Boolean; //복호장
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_THUNDERWAVE] <> 0 then begin
    m_wStatusTimeArr[STATE_THUNDERWAVE]:=1;
  end else begin
    nOldStatus:=m_nCharStatus;
    m_wStatusTimeArr[STATE_THUNDERWAVE]:=60000;
    m_btStatusValue[STATE_THUNDERWAVE]:=nPower;
    m_btThunderPower := nPower;
    m_nCharStatus:=GetCharStatus();
    m_btThunderWavePoint := nSec;
    if nOldStatus <> m_nCharStatus then begin
      StatusChanged();
    end;
    Result:=True;
  end;
end;

function TBaseObject.SkySword(nPower, nSec: Integer): Boolean; //천상비술
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_SKYSWORD] <> 0 then
  exit;
  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_SKYSWORD]:=nSec;
  m_dwStatusArrTick[STATE_SKYSWORD]:=GetTickCount;
  m_nCharStatus:=GetCharStatus();

  m_wStatusArrValue[35]:=nPower;
  m_dwStatusArrTimeOutTick[35]:=GetTickCount + 65 * 1000;

  SysMsg(format(g_sSkyTime,[nSec]),c_Green,t_Hint);

  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  RecalcAbilitys();
  Result:=True;
  SendMsg (Self,RM_BUFF, 60, 0, 48, nSec, format('[ 莖衢襪 ]\莖岡깥뻔，莖苟眼汝嘉랬珂옵鹿盧땡\넣崎: ' ,[nPower])); //천상비술 버프
  SendMsg (Self, RM_COOLBUFF, 61, 0, 49, 65, '[ 莖衢襪 ]\잤홱珂쇌: ');   //천상비술 쿨타임 버프
end;

function TBaseObject.CatSword(nPower, nSec, nDel: Integer): Boolean; //묘설란
begin
  Result:=False;

  m_wStatusArrValue[36]:=nPower;
  m_dwStatusArrTimeOutTick[36]:=GetTickCount + nDel * 1000;

  RecalcAbilitys();
  Result:=True;
  SendMsg (Self, RM_COOLBUFF, 62, 0, 50, nDel, '[ 챔敾 ]\잤홱珂쇌: ');   //묘설란 쿨타임 버프
end;



function TBaseObject.MagProtectionField(nPower, nTime: Integer): Boolean;
var
  nSec:integer;                 //호신기막
begin
  Result:=False;

  if m_wStatusArrValue[8] < 1 then begin
   m_wStatusArrValue[8]:=nPower;
  end;
  m_dwStatusArrTimeOutTick[8]:=GetTickCount + nTime * 1000;
  nSec := nTime;
  SendMsg (Self,RM_BUFF, 2, 0, 1, nSec, format('[ 빱昨評 ]\렝徒 + %d상: ',[m_wStatusArrValue[8] + 2]));     //호신기막 버프
  SysMsg(format(g_sMagProtectionFieldTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  Result:=True;
end;


function TBaseObject.MagProtectionField5(nPower, nTime: Integer): Boolean;
var
  nMin,nSec:integer;
begin
  Result:=False;

  if m_wStatusArrValue[83] < 1 then
  m_wStatusArrValue[83]:=1;
  m_dwStatusArrTimeOutTick[83]:=GetTickCount + nTime * 1000;

  nSec := nTime;

  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  m_boAdminmode:=True;
  Result:=True;
end;

function TBaseObject.MagRage(nPower, nTime: Integer): Boolean;
var
  nSec:integer;                            //첨기폭
begin
  Result:=False;

  if m_wStatusArrValue[7] < 1 then begin
   m_wStatusArrValue[7]:=nPower;
  end;
  m_dwStatusArrTimeOutTick[7]:=GetTickCount + nTime * 1000;
  nSec := nTime;
  SysMsg(format(g_sMagRageTime,[nSec]),c_Green,t_Hint);
  RecalcAbilitys();
  SendMsg(Self,RM_ABILITY,0,0,0,0,'');
  SendMsg (Self,RM_BUFF, 1, 0, 0, nSec, format('[ 숲폭괵 ]\묑샌 + %d: ',[m_wStatusArrValue[7] + 2]));     //첨기폭 버프
  Result:=True;
end;


function TBaseObject.CelestialDefenceUp(nLevel, nSec: Integer): Boolean; //선천기공
var
  nOldStatus:Integer;
begin
  Result:=False;
  if m_wStatusTimeArr[STATE_SUNCHENDEFENCEUP] <> 0 then exit;   //004C6E79
  nOldStatus:=m_nCharStatus;
  m_wStatusTimeArr[STATE_SUNCHENDEFENCEUP]:=nSec;
  m_dwStatusArrTick[STATE_SUNCHENDEFENCEUP]:=GetTickCount();
  m_nCharStatus:=GetCharStatus();
  if nOldStatus <> m_nCharStatus then begin
    StatusChanged();
  end;
  m_boAbilCelestialDefence:=True;
  m_btCelestialDefenceLevel:=nLevel;
  Result:=True;
end;

function TBaseObject.BloodWaterUp(TargeTBaseObject:TBaseObject; nLevel, nSec: Integer): Boolean; //혈룡수
begin
  Result:=False;
  if (TargeTBaseObject <> nil) then begin

     if TargeTBaseObject.m_wStatusTimeArr[STATE_BLOODWATER{0x74}] > 0 then begin //004C6D6C
       if TargeTBaseObject.m_wStatusTimeArr[STATE_BLOODWATER{0x74}] < nSec then begin
          TargeTBaseObject.m_wStatusTimeArr[STATE_BLOODWATER{0x74}]:=nSec;
          Result:=True;
       end;
     end else begin
       TargeTBaseObject.m_wStatusTimeArr[STATE_BLOODWATER{0x74}]:=nSec;
       Result:=True;
     end;
     TargeTBaseObject.m_dwStatusArrTick[STATE_BLOODWATER{0x210}]:=GetTickCount;
     TargeTBaseObject.m_nCharStatus := GetCharStatus;
     TargeTBaseObject.StatusChanged;

     TargeTBaseObject.m_wStatusArrValue[15] := 5 * nLevel;     //파괴
     TargeTBaseObject.m_wStatusArrFlag[15] := 0;
     TargeTBaseObject.m_dwStatusArrTimeOutTick[15] := GetTickCount + nSec * 1000; //초단위
     TargeTBaseObject.m_wStatusArrValue[1] := 5 * nLevel;      //마법
     TargeTBaseObject.m_wStatusArrFlag[1] := 0;
     TargeTBaseObject.m_dwStatusArrTimeOutTick[1] := GetTickCount + nSec * 1000; //초단위
     TargeTBaseObject.m_wStatusArrValue[2] := 5 * nLevel;      //도력
     TargeTBaseObject.m_wStatusArrFlag[2] := 0;
     TargeTBaseObject.m_dwStatusArrTimeOutTick[2] := GetTickCount + nSec * 1000; //초단위
     TargeTBaseObject.m_wStatusArrValue[4] := 50 * nLevel;    //체력
     TargeTBaseObject.m_wStatusArrFlag[4] := 0;
     TargeTBaseObject.m_dwStatusArrTimeOutTick[4] := GetTickCount + nSec * 1000; //초단위
     TargeTBaseObject.m_wStatusArrValue[8] := 2 * nLevel;      //방어
     TargeTBaseObject.m_dwStatusArrTimeOutTick[8] := GetTickCount + nSec * 1000; //초단위
     TargeTBaseObject.m_wStatusArrValue[27] := 2 * nLevel;     //마항
     TargeTBaseObject.m_dwStatusArrTimeOutTick[27] := GetTickCount + nSec * 1000; //초단위
     TargeTBaseObject.RecalcAbilitys;
  end;
end;




function TPlayObject.RandomOreDura: integer;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) then begin
    if m_UseItems[U_WEAPON].Dura = 0 then begin
      Result := Random(5000) + 1000;
    end else begin
      Result := Random(13000) + 3000;
      if Random(20) = 0 then begin
        Result := Result + Random(10000);
      end;
    end;
  end else begin
    Result := Random(11000) + 3000;
    if Random(20) = 0 then begin
      Result := Result + Random(10000);
    end;
  end;
end;

procedure TPlayObject.MakeMine; //004CB3AC
   function GetDuraStr (dura: integer): string;
   begin
       Result := IntToStr(Round(dura/1000));
   end;
var
  UserItem: pTUserItem;
  boot: Boolean;
begin
  if m_ItemList.Count >= MAXBAGITEM then exit;

  case Random(120) of
    1..2: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGoldStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    3..20: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sSilverStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    21..45: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sSteelStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    46..56: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
        SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sBlackStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    else begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
        SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sCopperStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
  end;
end;

procedure TPlayObject.MakeMine2;
   function GetDuraStr (dura: integer): string;
   begin
       Result := IntToStr(Round(dura/1000));
   end;
var
  UserItem: pTUserItem;
  boot: Boolean;
begin
  if m_ItemList.Count >= MAXBAGITEM then exit;

  case Random(120) of
    1..2: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone1, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone1+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    3..20: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone2, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone2+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    21..45: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone3, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone3+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    else begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone4, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone4+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
  end;
end;

procedure TPlayObject.MakeMine3;
   function GetDuraStr (dura: integer): string;
   begin
       Result := IntToStr(Round(dura/1000));
   end;
var
  UserItem: pTUserItem;
  boot: Boolean;
begin
  if m_ItemList.Count >= MAXBAGITEM then exit;

  case Random(275) of
    1..6: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
        SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGoldStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    7..30: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sSilverStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    31..66: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
        SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sSteelStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    67..91: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sBlackStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    92..131: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sCopperStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    132..137: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone1, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone1+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    138..161: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone2, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone2+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    162..197: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone3, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone3+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    198..233: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGreenStone, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGreenStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
    else begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGemStone4, UserItem) then begin
        UserItem.Dura := RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGemStone4+ '굳랙君。',c_BlueWhite,t_Hint);
      end else
        Dispose(UserItem);
    end;
  end;
end;


procedure TPlayObject.MakeMine4; //녹광석
   function GetDuraStr (dura: integer): string;
   begin
       Result := IntToStr(Round(dura/1000));
   end;
var
  UserItem: pTUserItem;
  boot: Boolean;
begin
  if m_ItemList.Count >= MAXBAGITEM then exit;

  case Random(130) of
    1..2: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGoldStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    3..20: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sSilverStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    21..45: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sSteelStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    46..57: begin   //녹광석
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGreenStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sGreenStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;

    58..68: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
        SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sBlackStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
    else begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone,UserItem) then begin
        UserItem.Dura:=RandomOreDura;
        AddItemToBag(UserItem,boot);
         if boot then
         SendAddItem(UserItem,1);
         SysMsg('늉똑' + GetDuraStr(UserItem.Dura) + '돨'+ g_Config.sCopperStone+ '굳랙君。',c_BlueWhite,t_Hint);
      end else Dispose(UserItem);
    end;
  end;
end;


function  TPlayObject.FindItemNameEx (iname: string; var count, durasum, duratop: integer): PTUserItem;
var
   i: integer;
   ps: TItem;
   pu: PTUserItem;
begin
   Result := nil;
   durasum := 0;
   duratop := 0;
   count := 0;
   ps := nil;
   pu := nil;
   for i:=0 to m_ItemList.Count-1 do begin
      pu := PTUserItem(m_ItemList[i]);
      if pu <> nil then begin
         ps := UserEngine.GetStdItem(pu.wIndex);
         if ps <> nil then begin
            if CompareText(UserEngine.GetStdItemNameV(pu.wIndex), iname) = 0 then begin
               if ps.StdMode in [0,1,3,45,46] then begin
                  count := count + pu.Amount;
                  continue;
                  Result := pu;
               end else begin
                  if pu.Dura > duratop then begin
                     duratop := pu.Dura;
                     Result := pu;
                  end;
                  durasum := durasum + pu.Dura;
                  if Result = nil then
                     Result := pu;
                  Inc(count);
               end;
            end;
         end;
      end;
   end;
end;

function TBaseObject.sub_4C4CD4(sItemName: String;
  var nCount: Integer): pTUserItem; //004C4CD4
var
  I: Integer;
  sName:String;
begin
  Result:=nil;
  nCount:=0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do begin
    sName:=UserEngine.GetStdItemName(m_UseItems[i].wIndex);
    if CompareText(sName,sItemName) = 0 then begin
      Result:=@m_UseItems[i];
      Inc(nCount);
    end;
  end;
end;

function TPlayObject.QuestTakeCheckItem(CheckItem: pTUserItem):Boolean; //004C4F6C
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result:=False;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = CheckItem then begin
      SendDelItems(UserItem);
      Dispose(UserItem);
      m_ItemList.Delete(I);
      Result:=True;
      break;
    end;
  end;
  for I := Low(m_UseItems) to High(m_UseItems) do begin
    if @m_UseItems[I] = CheckItem then begin
      SendDelItems(@m_UseItems[I]);
      m_UseItems[I].wIndex:=0;
      Result:=True;
      break;
    end;
  end;
end;

function TPlayObject.QuestTakeCheckItem2(CheckItem: pTUserItem; wBreakdown: Word):Boolean; //004C4F6C
var
  I: Integer;
  UserItem: pTUserItem;
begin
  Result:=False;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = CheckItem then begin
      SendDelItemWithFlag (UserItem, wBreakdown);
      Dispose(UserItem);
      m_ItemList.Delete(I);
      Result:=True;
      break;
    end;
  end;
  for I := Low(m_UseItems) to High(m_UseItems) do begin
    if @m_UseItems[I] = CheckItem then begin
      SendDelItemWithFlag (@m_UseItems[I], wBreakdown);
      m_UseItems[I].wIndex:=0;
      Result:=True;
      break;
    end;
  end;
end;

procedure TPlayObject.ClientQueryWakeCost(nParam1, nInt: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItemA: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItemA := nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem := m_ItemList.Items[I];
    if (UserItem.MakeIndex = nInt) then begin

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);


      if (CompareText(sUserItemName, sMsg) = 0) then begin
        UserItemA := UserItem;
        Break;
      end;
      UserItemA := nil;
    end;
  end;
  if UserItemA = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryWakeCost(Self, UserItemA);
end;

procedure TPlayObject.ClientQueryReStoreCost(nParam1, nInt: Integer;
  sMsg: string);
var
  I: Integer;
  UserItem: pTUserItem;
  UserItemA: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  UserItemA := nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem := m_ItemList.Items[I];
    if (UserItem.MakeIndex = nInt) then begin

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);


      if (CompareText(sUserItemName, sMsg) = 0) then begin
        UserItemA := UserItem;
        Break;
      end;
      UserItemA := nil;
    end;
  end;
  if UserItemA = nil then Exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryWakeReStore(Self, UserItemA);
end;

procedure TPlayObject.ClientQueryRepairCost(nParam1, nInt: Integer;
  sMsg: String); //004DBCCC
var
  I: Integer;
  UserItem:pTUserItem;
  UserItemA:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  UserItemA:=nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if (UserItem.MakeIndex = nInt) then begin

      sUserItemName := '';
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if (CompareText(sUserItemName,sMsg) = 0) then begin
        UserItemA:=UserItem;
        break;
      end;
    end;
  end; 
  if UserItemA = nil then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
     ((Merchant.m_PEnvir = m_PEnvir) and
     (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
     (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then 
    Merchant.ClientQueryRepairCost(Self,UserItemA);

end;

procedure TPlayObject.ClientRepairItem(nParam1, nInt: Integer;
  sMsg: String); //004DBFC0
var
  I: Integer;
  UserItem:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  UserItem:=nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    sUserItemName := '';
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nInt) and
       (CompareText(sUserItemName,sMsg) = 0) then begin
      break;
    end;
  end;    // for
  if UserItem = nil then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
     ((Merchant.m_PEnvir = m_PEnvir) and
     (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
     (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientRepairItem(Self,UserItem);
end;


procedure TPlayObject.ClientCheckWeapon(nParam1, nInt: Integer;   //제련 확인
  sMsg: String); //004DBFC0
var
  I: Integer;
  UserItem:pTUserItem;
  Merchant:TMerchant;
  sUserItemName:String;
begin
  UserItem:=nil;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    //혤菱땍屢膠틔츰냔
    sUserItemName:=GetItemName(UserItem);

    if (UserItem.MakeIndex = nInt) and
       (CompareText(sUserItemName,sMsg) = 0) then begin
      break;
    end;
  end;    // for
  if UserItem = nil then exit;
  Merchant:=UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
     ((Merchant.m_PEnvir = m_PEnvir) and
     (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
     (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientCheckWeapon(Self,UserItem);
end;

procedure TPlayObject.ClientTradeGT(nParam1:integer);
var
  Value:integer;
begin
  if Not m_boDealing then exit;
  if m_DealCreat = nil then exit;
  if Not m_DealCreat.m_boDealGT then exit;
  if (nParam1 <> 1) or (m_MyGuild = nil) or (IsGuildMaster = False) or (g_GuildTerritory.FindGuildTerritoryEx(TGuild(m_MyGuild).sGuildName) <> nil) then begin
    m_DealCreat.SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'뚤렘앳없슥弄。');
    m_boDealing:=False;
    m_DealCreat.m_boDealing := False;
    m_DealCreat.m_boDealGT := False;
    m_DealCreat.m_DealCreat := nil;
    m_DealCreat := nil;
    exit;
  end;

  if (m_DealCreat.m_MyGuild = nil) or (TGuild(m_DealCreat.m_MyGuild).m_Territory = nil) or (TTerritory(TGuild(m_DealCreat.m_MyGuild).m_Territory).ForSale = False) then begin
    SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'커품돨契삔鏤蹈청唐놔簡。');
    m_boDealing:=False;
    m_DealCreat.m_boDealing := False;
    m_DealCreat.m_boDealGT := False;
    m_DealCreat.m_DealCreat := nil;
    m_DealCreat := nil;
    exit;
  end;
  Value:= TTerritory(TGuild(m_DealCreat.m_MyGuild).m_Territory).ForSaleGold;
  if (m_nGold >= Value) and ((m_DealCreat.m_nGoldMax - Value) >= m_DealCreat.m_nGold)  then begin
    if TTerritory(TGuild(m_DealCreat.m_MyGuild).m_Territory).Buy(TGuild(m_MyGuild).sGuildName) then begin
        DecGold(Value);
        GoldChanged();
    //    inc(m_DealCreat.m_nGold,Value);
        m_DealCreat.IncGold(Value);
        m_DealCreat.GoldChanged();
        SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'묜毆，퀭綠쒔냥묘뭔찜죄契삔鏤蹈。');
        m_DealCreat.SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'콱돨契삔鏤蹈綠쒔냥묘놔簡。');
        exit;
    end;
  end;

  m_DealCreat.SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'슥弄굳혤句죄。');
  SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'슥弄굳혤句죄。');
  m_boDealing:=False;
  m_DealCreat.m_boDealing := False;
  m_DealCreat.m_boDealGT := False;
  m_DealCreat.m_DealCreat := nil;
  m_DealCreat := nil;
end;


//==================================================================

procedure TPlayObject.AddAucItem(nItemIdx:Integer; sMsg: String);     //경매
var
  I,k,idx:Integer;
  nerror:integer;
  UserItem:pTUserItem;
  StdItem:TItem;
  AItem: TStdItem;
  AucItem: TAucItem;
  sSendMsg, sUserItemName: string;
  ClientItem:TClientItem;
  Play: TPlayObject;
  opt: integer;
begin
  nerror:=0;
  sSendMsg:='';
  UserItem:=nil;
  idx:=0;
  if Pos(' ',sMsg) >= 0 then GetValidStr3(sMsg,sMsg,[' ']);
  idx:= FrmDB.LoadAucNotSold;
  try
    if strtoint(sMsg) < 1000 then begin
      nerror:=1;
      SendDefMessage(SM_AUC_FAIL,nerror,0,0,0,'');
      exit;
    end;
    if strtoint(sMsg) > m_nGoldMax{150000000} then begin
      nerror:=2;
      SendDefMessage(SM_AUC_FAIL,nerror,0,0,0,'');
      exit;
    end;
    if idx >= 3 then begin
      nerror:=5;
      SendDefMessage(SM_AUC_FAIL,nerror,3,0,0,'');
      exit;
    end;
  except
    nerror:=1;
    SendDefMessage(SM_AUC_FAIL,nerror,0,0,0,'');
    exit;
  end;

  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if (UserItem.MakeIndex = nItemIdx) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
         if CanConsignItem(StdItem.name) or (UserItem.btValue[19] > 0) or (StdItem.StdMode = 14) then begin   //반짝 위탁 금지
           nerror:=6;
           SendDefMessage(SM_AUC_FAIL,nerror,0,0,0,'');
           exit;
         end;
         if StdItem.StdMode in [0,1,3,45,46] then begin
           if UserItem.Amount > StdItem.MaxAmount then begin       //물약 버그 악용 막기 위탁금지
             nerror:=6;
             SendDefMessage(SM_AUC_FAIL,nerror,0,0,0,'');
             exit;
           end;
         end;
         if DecGold( Round(strtoint(sMsg) * 0.1) ) then begin
           GoldChanged();
           FrmDB.AddAucItem(UserItem,sMsg,m_sCharName,m_sUserID);  //특수문자 버그 패치 20101119
           AucItem.Price := strtoint(sMsg);
           AucItem.Seller := m_sCharName;
           AucItem.APrice := 0;
           AucItem.Solder := '';
           StdItem.GetStandardItem(AItem);
           opt := StdItem.GetItemAddValue(UserItem,AItem);

           sUserItemName := '';
           sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
           if UserItem.btValue[11] = 1 then
             sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
           if sUserItemName <> '' then
             ClientItem.S.Name := FilterStdShowName(StdItem,sUserItemName);

           ClientItem.S := AItem;
           ClientItem.Dura := UserItem.Dura;
           ClientItem.DuraMax := UserItem.DuraMax;
           ClientItem.MakeIndex := UserItem.MakeIndex;
           ClientItem.Amount := UserItem.Amount;      //물약
           ClientItem.UpgradeOpt := opt;
           AucItem.Item := ClientItem;
           sSendMsg:=sSendMsg + EncodeBuffer(@AucItem,SizeOf(TAucItem)) + '/';

           for k := 0 to UserEngine.m_PlayObjectList.Count - 1 do begin
             Play:=TPlayObject(UserEngine.m_PlayObjectList.Objects[k]);
             if Play.m_btRaceServer = RC_PLAYOBJECT then begin
               Play.m_DefMsg:=MakeDefaultMsg(SM_AUC_OK,Integer(Self),0,0,0);
               Play.SendSocket(@Play.m_DefMsg,sSendMsg);
             end;
           end;
           UserEngine.SendBroadCastMsg(m_sCharName + '콱돨膠틔' + ClientItem.S.Name + '綠쒔냥묘탠찡。', t_Cust2 );
           SysMsg('∽∽∽ 교관쏜귑 + 탠찡쏜귑돨鑒좆꼇콘낚법 1,000,000,000 쏜귑。',c_Red,t_Hint);

           m_ItemList.Delete(I);
           WeightChanged();
           exit;
         end;
         nerror:=4;
      end;
    end;
  end;
  if nerror = 0 then nerror:=3;
  SendDefMessage(SM_AUC_FAIL,nerror,0,0,0,'');
end;

//==================================================================

procedure TPlayObject.ConsignItem(nItemIdx:Integer; sMsg: String);     //위탁
var
  I,idx:Integer;
  nerror:integer;
  UserItem:pTUserItem;
  StdItem:TItem;
begin
  nerror:=0;
  UserItem:=nil;
  idx:=0;
  if Pos(' ',sMsg) >= 0 then GetValidStr3(sMsg,sMsg,[' ']);
  idx:= FrmDB.LoadConsignidx(m_sCharName);
  try
    if strtoint(sMsg) < 1000 then begin
      nerror:=1;
      SendDefMessage(SM_CONSIGN_FAIL,nerror,0,0,0,'');
      exit;
    end;
    if strtoint(sMsg) > m_nGoldMax{150000000} then begin
      nerror:=2;
      SendDefMessage(SM_CONSIGN_FAIL,nerror,0,0,0,'');
      exit;
    end;
    if idx >= g_Config.ConsigitemIdx then begin
      nerror:=5;
      SendDefMessage(SM_CONSIGN_FAIL,nerror,g_Config.ConsigitemIdx,0,0,'');
      exit;
    end;
  except
    nerror:=1;
    SendDefMessage(SM_CONSIGN_FAIL,nerror,0,0,0,'');
    exit;
  end;

  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if (UserItem.MakeIndex = nItemIdx) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
         if CanConsignItem(StdItem.name) or (UserItem.btValue[19] > 0) or (StdItem.StdMode = 14) then begin   //반짝 위탁 금지
           nerror:=6;
           SendDefMessage(SM_CONSIGN_FAIL,nerror,0,0,0,'');
           exit;
         end;
         if StdItem.StdMode in [0,1,3,45,46] then begin
           if UserItem.Amount > StdItem.MaxAmount then begin       //물약 버그 악용 막기 위탁금지
             nerror:=6;
             SendDefMessage(SM_CONSIGN_FAIL,nerror,0,0,0,'');
             exit;
           end;
         end;
         if DecGold(1000) then begin
           GoldChanged();
           FrmDB.ConsignItem(UserItem,sMsg,m_sCharName,m_sUserID);  //특수문자 버그 패치 20101119
           m_ItemList.Delete(I);
           WeightChanged();
           SendDefMessage(SM_CONSIGN_OK,0,0,0,0,'');
           exit;
         end;
         nerror:=4;
      end;
    end;
  end;
  if nerror = 0 then nerror:=3;
  SendDefMessage(SM_CONSIGN_FAIL,nerror,0,0,0,'');
end;


procedure TPlayObject.ComStorageItem(NPC: TObject; nItemIdx{,Amount}:Integer);     //공용창고
var
  Merchant:TMerchant;
  I,idx:Integer;
  nerror:integer;
  UserItem:pTUserItem;
  StdItem:TItem;
begin
  nerror:=0;
  UserItem:=nil;
  idx:=0;
  idx:= FrmDB.LoadComStorageidx(m_sUserID);

  if idx >= g_Config.ComStorageIdx then begin
      nerror:=1;
      SendDefMessage(SM_COMSTORAGE_FAIL,nerror,g_Config.ComStorageIdx,0,0,'');
      exit;
  end;


  Merchant:=UserEngine.FindMerchant(NPC);
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if (UserItem.MakeIndex = nItemIdx) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
         if CanConsignItem(StdItem.name) or not StdItem.boCanStore or (UserItem.btValue[19] > 0) or (StdItem.StdMode = 14) then begin   //공용창고 못맞김
          nerror:=2;
          SendDefMessage(SM_COMSTORAGE_FAIL,nerror,0,0,0,'');
          exit;
         end;
         if StdItem.StdMode in [0,1,3,45,46] then begin
          if UserItem.Amount > StdItem.MaxAmount then begin     //물약 버그 악용 막기 공용창고
           nerror:=2;
           SendDefMessage(SM_COMSTORAGE_FAIL,nerror,0,0,0,'');
           exit;
          end;
         end;

        if (Merchant <> nil) and
           (Merchant.m_boComStoragement) and
           (((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin

            FrmDB.ComStorageItem(UserItem,m_sUserID);
            m_ItemList.Delete(I);
            WeightChanged();
            SendDefMessage(SM_COMSTORAGE_OK,0,0,0,0,'');
            exit;
 
        end;
        if nerror = 3 then nerror:=4;
      end;
    end;
  end;
  if nerror = 0 then nerror:=4;
  SendDefMessage(SM_COMSTORAGE_FAIL,nerror,0,0,0,'');
end;

procedure TPlayObject.GuildStorageItem(NPC: TObject; nItemIdx{,Amount}:Integer);     //문파창고
var
  Merchant:TMerchant;
  I,idx:Integer;
  nerror:integer;
  UserItem:pTUserItem;
  StdItem:TItem;
begin
  nerror:=0;
  UserItem:=nil;
  idx:=0;
  idx:= FrmDB.LoadGuildStorageidx(TGuild(m_MyGuild).sGuildName);

  if idx >= g_Config.GuildStorageIdx then begin
      nerror:=1;
      SendDefMessage(SM_GUILDSTORAGE_FAIL,nerror,g_Config.GuildStorageIdx,0,0,'');
      exit;
  end;

  if TGuild(m_MyGuild).sGuildName = '' then begin
     nerror:=6;
     SendDefMessage(SM_GUILDSTORAGE_FAIL,nerror,g_Config.GuildStorageIdx,0,0,'');
     exit;
  end;


  Merchant:=UserEngine.FindMerchant(NPC);
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    if (UserItem.MakeIndex = nItemIdx) then begin
      StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then begin
         if CanConsignItem(StdItem.name) or not StdItem.boCanStore or (UserItem.btValue[19] > 0) or (StdItem.StdMode = 14) then begin   //문파창고 못맞김
          nerror:=2;
          SendDefMessage(SM_GUILDSTORAGE_FAIL,nerror,0,0,0,'');
          exit;
         end;
         if StdItem.StdMode in [0,1,3,45,46] then begin
          if UserItem.Amount > StdItem.MaxAmount then begin     //물약 버그 악용 막기 문파창고
           nerror:=2;
           SendDefMessage(SM_GUILDSTORAGE_FAIL,nerror,0,0,0,'');
           exit;
          end;
         end;

        if (Merchant <> nil) and
           (Merchant.m_boGuildStoragement) and
           (((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
            FrmDB.GuildStorageItem(UserItem,TGuild(m_MyGuild).sGuildName);
            m_ItemList.Delete(I);
            WeightChanged();
            SendDefMessage(SM_GUILDSTORAGE_OK,0,0,0,0,'');
            exit;
        end;
        if nerror = 3 then nerror:=4;
      end;
    end;
  end;
  if nerror = 0 then nerror:=4;
  SendDefMessage(SM_GUILDSTORAGE_FAIL,nerror,0,0,0,'');
end;


procedure TPlayObject.ClientGetWakeUpItems(nItemIdx: Integer; mode: byte; sData: string);
  function WakeStr(Idx: Byte): string;
  begin
    Result := '';
    case Idx of
      1: Result := '澹촐';
      2: Result := '침加';
      3: Result := '鉤썹';
      4: Result := '磵빱';
      5: Result := '뇜침';
      6: Result := '욉벽';
    end;
  end;
  function FindItem(nItemIdx: Integer): Integer;
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := -1;
    for I := 0 to m_ItemList.Count - 1 do begin
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nItemIdx then begin
        Result := I;
        Break;
      end;
    end;
  end;

var
  I, n14, n18, nMode, j: Integer;
  UserItem, pu: pTUserItem;
  ItemIndexs: Integer;
  boFind: Boolean;
  StdItem, ps: TItem;
  ClientItem: TClientItem;
  nRate: Integer;
  sSENDMSG: string;
  sUserItemName: string;
  sCheckItemName: string;
  opt: integer;

begin
  n14 := 0;
  sSENDMSG := '';
  ItemIndexs := FindItem(nItemIdx);

  UserItem := pTUserItem(m_ItemList.Items[ItemIndexs]);
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);

  if (StdItem <> nil) then begin
    if (UserItem.btValue[18] < 5) then begin
      nRate := StdItem.Grade;
      if StdItem.StdMode in [5,6,99,90] then begin
        UserItem.btValue[12] := mode + 1;
        nMode := 1;
      end;
      if StdItem.StdMode in [15] then begin
        UserItem.btValue[12] := mode + 4;
        nMode := 2;
      end;
      if StdItem.StdMode in [10,11,12] then begin
        UserItem.btValue[12] := mode + 6;
        nMode := 3;
      end;

      if Random(80 + UserItem.btValue[18] * 4) < ( g_Config.nWakeUpRate + m_nBodyLuckLevel) then begin  //성공함
          if (UserItem.btValue[13] <= 0) and (n14 = 0) then begin         //용맹
            if (UserItem.btValue[12] = 6) and (nMode = 3) then UserItem.btValue[13] := 10 + (Random(nRate) * 5)
            else UserItem.btValue[13] := 1 + Random(nRate);
            UserItem.btValue[18] := 1;
            n14 := 1;
          end;
          if (UserItem.btValue[14] <= 0) and (n14 = 0) then begin         //마성
            if (UserItem.btValue[12] = 6) and (nMode = 3) then UserItem.btValue[14] := 10 + (Random(nRate) * 5)
            else UserItem.btValue[14] := 1 + Random(nRate);
            UserItem.btValue[18] := 2;
            n14 := 1;
          end;
          if (UserItem.btValue[15] <= 0) and (n14 = 0) then begin         //선계
            if (UserItem.btValue[12] = 6) and (nMode = 3) then UserItem.btValue[15] := 10 + (Random(nRate) * 5)
            else UserItem.btValue[15] := 1 + Random(nRate);
            UserItem.btValue[18] := 3;
            n14 := 1;
          end;
          if (UserItem.btValue[16] <= 0) and (n14 = 0) then begin          //수호
            if (UserItem.btValue[12] = 6) and (nMode = 3) then UserItem.btValue[16] := 10 + (Random(nRate) * 5)
            else UserItem.btValue[16] := 1 + Random(nRate);
            UserItem.btValue[18] := 4;
            n14 := 1;
          end;
          if (UserItem.btValue[17] <= 0) and (n14 = 0) then begin          //제마
            if (UserItem.btValue[12] = 6) and (nMode = 3) then UserItem.btValue[17] := 10 + (Random(nRate) * 5)
            else UserItem.btValue[17] := 1 + Random(nRate);
            UserItem.btValue[18] := 5;
            n14 := 1;
          end;

          SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Enchant_Good1,'0');
          SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Enchant_Good,'0');
       end else begin
          n14 := -1;
          SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Enchant_Fail1,'0');
          SendRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Enchant_Fail,'0');
       end;
    end else begin
     n14 := -2;
    end;
    if n14 = 1 then begin
      if StdItem = nil then exit;
      StdItem.GetStandardItem(ClientItem.S);
      opt := StdItem.GetItemAddValue(UserItem, ClientItem.s);

      sUserItemName := '';
      sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
      if UserItem.btValue[11] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.s.Name := FilterStdShowName(StdItem,sUserItemName);

      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      ClientItem.Amount := UserItem.Amount;
      ClientItem.UpgradeOpt := opt;

      sSENDMSG := EncodeBuffer(@ClientItem, SizeOf(TClientItem));
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('41' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + '(' + WakeStr(UserItem.btValue[12]) + ')'+ #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            IntToStr(UserItem.btValue[18]) + '쌓뙈' + #9 + '[얾今냥묘]');
    end else begin //실패함
      if n14 = -1 then begin
        sUserItemName := '';
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        if UserItem.btValue[11] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if StdItem.NeedIdentify = 1 then
        AddGameDataLog('42' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + '(' + WakeStr(UserItem.btValue[12]) + ')'+ #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            IntToStr(UserItem.btValue[18]) + '쌓뙈' + #9 + '[얾今呵겨]');

        DelBagItem(UserItem.MakeIndex, sUserItemName);
      end;
    end;
  end;
  if n14 <= 0 then begin
    m_DefMsg := MakeDefaultMsg(SM_SENDWAKEUPITEM_FAIL, n14, 0, 0, 0);
    TPlayObject(Self).SendSocket(@m_DefMsg, sSENDMSG);
  end else begin
    m_DefMsg := MakeDefaultMsg(SM_SENDWAKEUPITEM_OK, 0, 0, 0, 0);
    TPlayObject(Self).SendSocket(@m_DefMsg, sSENDMSG);
  end;
end;


procedure TPlayObject.ClientGetWakeUp(nItemIdx: Integer; mode: byte; sData: string);
var
  I, n14, n18, nMode, j, k, n, g, itemp: Integer;
  UserItem, UserItemA, pu: pTUserItem;
  ItemIndexs: Integer;
  Index : Integer;
  StdItem, ps: TItem;
  list :TStringList;

  sItemMakeIndex: array [0..1] of string;
  sItemName: array [0..1] of string;
  sItemCount: array [0..1] of string;

  sourcecount, counteritmcount: integer;
  sourcemindex: integer;
  sourcename: string;

  checkcount, WakePrice: integer;
  dellist: TStringList;
  delitemname : string;
begin
  n14 := 0;
  nMode := 0;
  for i:= 0 to 1 do begin
    sData := GetValidStr3 (sData, sItemMakeIndex[i], [':']);
    sData := GetValidStr3 (sData, sItemName[i], [':']);
    sData := GetValidStr3 (sData, sItemCount[i], ['/']);
  end;
  UserItem := nil;
  UserItemA := nil;

  for g := 0 to m_ItemList.Count - 1 do begin
    UserItem := m_ItemList.Items[g];
    if UserItem.MakeIndex = nItemIdx then begin
      UserItemA := UserItem;
      break;
    end;
  end;

  StdItem := UserEngine.GetStdItem(UserItemA.wIndex);

  if (StdItem <> nil) then begin
    if (UserItemA.btValue[18] < 5) then begin
      if StdItem.StdMode in [5,6,99,90] then
        nMode := 1;
      if StdItem.StdMode in [15] then
        nMode := 2;
      if StdItem.StdMode in [10,11,12] then
        nMode := 3;

      WakePrice := StdItem.DuraMax + (18000 * UserItemA.btValue[18] * StdItem.Grade) + (StdItem.NeedLevel * 1000 * StdItem.Grade) + (StdItem.Price * (StdItem.Grade - 1));

      list := GetWakeUpCondition (IntToStr(nMode), IntToStr(mode), IntToStr(UserItemA.btValue[18]), IntToStr(StdItem.Grade));
      checkcount := List.Count;
      for k:= 0 to 1 do begin
        sourcemindex := Str_ToInt(sItemMakeIndex[k], 0);
        sourcename := sItemName[k];
        sourcecount := Str_ToInt(sItemCount[k], 0);
        for j:= 0 to List.Count-1 do begin
          if (sourcename = List[j]) and (sourcecount >= Integer(list.Objects[j])) then begin
            Dec(checkcount);
          end;
        end;
      end;

      if (m_nGold < WakePrice) then
        n14 := -3;

      if (UserItemA.btValue[18] > 4) then
        n14 := -2;

      if (n14 = 0) and (checkcount <= 0) then begin
        n14 := 1;

        DecGold( WakePrice );
        GoldChanged;

        dellist := nil;
        for k:=0 to list.Count-1 do begin  //새로운 List
          sourcemindex := Str_ToInt(sItemMakeIndex[k], 0);
          sourcename := sItemName[k];
          sourcecount := Integer(list.Objects[k]);
          counteritmcount := Integer(list.Objects[k]);

          for n := m_ItemList.Count-1 downto 0 do begin
            pu := PTUserItem (m_ItemList[n]);
            if sourcecount > 0 then begin
              if sourcename = UserEngine.GetStdItemNameV(pu.wIndex) then begin
                ps := UserEngine.GetStdItem (pu.wIndex);
                if ps <> nil then begin
                  //카운트 아이템.
                  if (ps.StdMode in [0,1,3,45,46]) then begin
                    if pu.Amount < counteritmcount then begin
                      counteritmcount := counteritmcount - pu.Amount;
                      pu.Amount := 0;
                    end else begin
                      itemp := counteritmcount;
                      counteritmcount := _MAX(0, itemp - pu.Amount);
                      pu.Amount := pu.Amount - itemp;
                    end;
                    if pu.Amount > 0 then begin
                      SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Amount, 0,FilterStdShowName(ps,ps.Name));
                      continue;
                    end;
                  end;
                end;
                  //일반 아이템 또는 카운트 아이템 삭제
                if dellist = nil then dellist := TStringList.Create;
                delitemname := UserEngine.GetStdItemName(pu.wIndex);
                dellist.AddObject(delitemname, TObject(PTUserItem (m_ItemList[n]).MakeIndex));

                Dispose (PTUserItem(m_ItemList[n]));
                m_ItemList.Delete (n);
                dec (sourcecount);
              end;
            end else
              break;
          end;
        end;
        if dellist <> nil then //dellist은  RM_DELITEMS에서 Free됨.
          SendMsg (self, RM_SENDDELITEMLIST, 0, integer(dellist), 0, 0, '');
      end else begin
        if (m_nGold < WakePrice) then       // 필요한 금전이 있는지 확인
          n14 := -3
        else  n14 := -4;
      end;
    end;
   // if dellist <> nil then FreeAndNil(dellist);
    if n14 = 1 then begin
      if Random(4) = 0 then begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Miss,'0', 0);
      end else begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Good,'0', 0);
      end;
      if Random(4) = 0 then begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Miss,'0', 700);
      end else begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Good,'0', 700);
      end;
      if Random(4) = 0 then begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Miss,'0', 1400);
      end else begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Good,'0', 1400);
      end;
      if Random(4) = 0 then begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Miss,'0', 2200);
      end else begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Good,'0', 2200);
      end;
      if Random(4) = 0 then begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Miss,'0', 3000);
      end else begin
        SendDelayRefMsg(RM_10205,0,m_nCurrX,m_nCurrY,NE_Hammer_Good,'0', 3000);
      end;

      SendDelayMsg(Self, RM_SENDWAKEUPITEM, nItemIdx, mode, 0, 0, sData, 3200);
    end else begin
      m_DefMsg := MakeDefaultMsg(SM_SENDWAKEUPITEM_FAIL, n14, 0, 0, 0);
      TPlayObject(Self).SendSocket(@m_DefMsg, '');
    end;
  end;
end;

procedure TPlayObject.ClientStorageItem(NPC: TObject;         //여관    //창고
  nItemIdx: Integer; sMsg: String; nMode:Integer); //004DC2B8
var
  Merchant:TMerchant;
  I:Integer;
  UserItem:pTUserItem;
  bo19:Boolean;
  StdItem:TItem;
  sUserItemName:String;
begin
  bo19:=False;
  UserItem:=nil;

  if Pos(' ',sMsg) >= 0 then
    GetValidStr3(sMsg,sMsg,[' ']);

  if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
    SysMsg(g_sTryModeCanotUseStorage,c_Red,t_Hint);
    exit;
  end;
  for i := m_ItemList.Count - 1 downto 0 do begin
    if m_ItemList.Count <= 0 then break;
    UserItem:=m_ItemList.Items[I];
    if UserItem = nil then Continue;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);

    sUserItemName := '';
    sUserItemName := FilterStdShowName(StdItem,StdItem.Name);
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName,sMsg) = 0) then begin
      if (nMode = 1) then begin
        if m_StorageItemList.Count < STORAGELIMIT then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          if not StdItem.boCanStore or (UserItem.btValue[19] = 1) then begin    //대여템 여관 금지
           SendDefMessage(SM_STORAGE_FAIL,0,0,0,0,'');
           exit;
          end;
          m_StorageItemList.Add(UserItem);
          m_ItemList.Delete(I);
          WeightChanged();
          SendAddStorage(UserItem);
          SendDefMessage(SM_STORAGE_OK,0,0,0,0,'');
          //004DC55E
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('1' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+IntToStr(UserItem.Amount)+')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0'  + #9 + '[꾑욋 뇨닸]');
        end else begin
          SendDefMessage(SM_STORAGE_FULL,0,0,0,0,'');
        end;
        bo19:=True;
      end else begin
        Merchant:=UserEngine.FindMerchant(NPC);
        if (Merchant <> nil) and
         (Merchant.m_boStorage) and
         (((Merchant.m_PEnvir = m_PEnvir) and
         (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
         (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then begin
        if m_StorageItemList.Count < STORAGELIMIT then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          if not StdItem.boCanStore or (UserItem.btValue[19] = 1) then begin    //대여템 여관 금지
           SendDefMessage(SM_STORAGE_FAIL,0,0,0,0,'');
           exit;
          end;
          m_StorageItemList.Add(UserItem);
          m_ItemList.Delete(I);
          WeightChanged();
          SendAddStorage(UserItem);
          SendDefMessage(SM_STORAGE_OK,0,0,0,0,'');
          //004DC55E
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('1' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+IntToStr(UserItem.Amount)+')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0'  + #9 + '[꾑욋 뇨닸]');
        end else begin
          SendDefMessage(SM_STORAGE_FULL,0,0,0,0,'');
        end;
        bo19:=True;
        end;
      end;
      break;
    end;
  end;
  if not bo19 then SendDefMessage(SM_STORAGE_FAIL,0,0,0,0,'');
end;

procedure TPlayObject.ClientTakeBackStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: String; nMode:Integer);  //여관        //창고
var
  Merchant:TMerchant;
  I:Integer;
  UserItem:pTUserItem;
  bo19:Boolean;
  StdItem:TItem;
  sUserItemName:String;
begin
  bo19:=False;
  UserItem:=nil;
  if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then begin
    SysMsg(g_sTryModeCanotUseStorage,c_Red,t_Hint);
    exit;
  end;
  for I := 0 to m_StorageItemList.Count - 1 do begin
    UserItem:=m_StorageItemList.Items[I];

    sUserItemName := '';
    if UserItem.btValue[11] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then begin

      if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then begin
        if (nMode = 1) then begin
          if IsEnoughBag then begin
            StdItem:=UserEngine.GetStdItem(UserItem.wIndex);

            if (UserItem.btValue[19] = 2) then begin  //반짝 여관
              if (UserItem.MaxDate < DateTimeToUnix(now)) then begin
                m_StorageItemList.Delete(I);
                Dispose(UserItem);
                SysMsg('膠틔"'+ StdItem.Name +'"凜賈痰퍅掘돕퍅랍굳쓱爻',c_Red,t_Hint);       //창고
                exit;
              end;
            end;
            if (UserItem.wIndex > 0) and (UserItem.btValue[19] > 2) and (UserItem.MaxDate < DateTimeToUnix(now)) then begin//봉인
              UserItem.btValue[19] := 0;
              UserItem.MaxDate := 0;
              SysMsg(StdItem.Name +'돨룐丹퍅掘綠쒔돕퍅。',c_Red,t_Hint);
            end;

            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            WeightChanged();
            m_StorageItemList.Delete(I);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK,nItemIdx,0,0,0,'');
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('0' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0'  + #9 + '[꾑욋 혤쀼]');
          end else begin
            SendAddStorage(UserItem);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG,0,0,0,0,'');
          end;
          bo19:=True;
        end else begin
          Merchant := UserEngine.FindMerchant(NPC);
          if (Merchant <> nil) and
           (Merchant.m_boStorage) and
           (((Merchant.m_PEnvir = m_PEnvir) and
           (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
           (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC))then begin
          if IsEnoughBag then begin
            StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem,1);
            WeightChanged();
            m_StorageItemList.Delete(I);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK,nItemIdx,0,0,0,'');
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('0' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     StdItem.Name+'('+ IntToStr(UserItem.Amount) +')' + #9 +
                     IntToStr(UserItem.MakeIndex) + #9 +
                     '1' + #9 +
                     '0'  + #9 + '[꾑욋 혤쀼]');
          end else begin
            SendAddStorage(UserItem);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG,0,0,0,0,'');
          end;
          bo19:=True;
          end;
        end;
      end else begin
        SendAddStorage(UserItem);
        SysMsg(g_sCanotGetItems,c_Red,t_Hint);
      end;
      break;
    end;
  end;
  if not bo19 then SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL,0,0,0,0,'');
end;


procedure TPlayObject.ClientGetStorage(PlayObject: TPlayObject);     //이동여관
var
  sPassWord, sPassWord1 :String;
  Merchant: TMerchant;
begin
  if PlayObject.m_boStoragePwd then begin       //암호 설정이 되있으면,, 
    PlayObject.SendMsg(Self, RM_INPUTPASSWORD, 0, 1, 0, 0, '');
  end else begin
    PlayObject.SendMsg(Self, RM_USERSTORAGEITEM, 0, 0, 1, 0, '');
  end;
end;

procedure TPlayObject.ClientStorageSetPassWord(PlayObject: TPlayObject; sMsg: string; Mode: Integer);     //창고암호
var
  sPassWord, sPassWord1 :String;
  Merchant: TMerchant;
begin
  sMsg := GetValidStr3(sMsg, sPassWord, ['/']);
  sMsg := GetValidStr3(sMsg, sPassWord1, ['/']);
  Case Mode of
    1: begin
      PlayObject.m_boStoragePwd := True;
      PlayObject.m_sStoragePwd := sPassWord;
    end;
    2: begin
      if PlayObject.m_sStoragePwd <> sPassWord then begin
        SendDefMessage(SM_STORAGEPW_FAIL, 0, 0, 0, 0, '');
      end else begin
        Merchant := UserEngine.FindMerchant(TObject(StrToInt(sPassWord1)));
        if Merchant <> nil then
        PlayObject.SendMsg(Self, RM_USERSTORAGEITEM, 0, Integer(Merchant), 0, 0, '');
      end;
    end;
    3: begin
      if PlayObject.m_sStoragePwd <> sPassWord then begin
        SendDefMessage(SM_STORAGEPW_FAIL, 0, 0, 0, 0, '');
      end else begin
        PlayObject.m_sStoragePwd := sPassWord1;
        SendDefMessage(SM_STORAGEPW_SUC, 0, 0, 0, 0, '');
      end;
    end;
    4: begin
       if PlayObject.m_sStoragePwd <> sPassWord then begin
         SendDefMessage(SM_STORAGEPW_FAIL, 0, 0, 0, 0, '');
       end else begin
         PlayObject.SendMsg(Self, RM_USERSTORAGEITEM, 0, 0, 1, 0, '');
       end;
    end;
  end;
end;

procedure TPlayObject.ClientCheckStoragePw(PlayObject: TPlayObject);      //창고암호
var
  IsLock: Integer;
begin
  IsLock := -1;
  if PlayObject.m_boStoragePwd then IsLock := 1
   else IsLock := 0;

  SendDefMessage(SM_STORAGEPW_CHK, IsLock, 0, 0, 0, '');
end;

procedure TPlayObject.ClientUpwaoinItem(NPC:TObject;nMakeIndex:Integer;sMsg:String);       //재련
var
  Merchant:TMerchant;
begin
  Merchant:=UserEngine.FindMerchant(NPC);
  if Merchant <> nil then begin
     Merchant.UpgradeWapon(Self,nMakeIndex,sMsg);
  end;
end;

function TBaseObject.CheckItems(sItemName: String): pTUserItem; //004C4AB0
var
  I: Integer;
  UserItem:pTUserItem;
begin
  Result:=nil;
  for I := 0 to m_Itemlist.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if CompareText(UserEngine.GetStdItemName(UserItem.wIndex),sItemName) = 0 then begin
      Result:=UserItem;
      break;
    end;
  end;    // for
end;

procedure TPlayObject.MakeSaveRcd(var HumanRcd: THumData);//004B3580
var
  I: Integer;
  HumItems:pTHumItems;
  BagItems:pTBagItems;
  HumMagic:pTHumMagic;
  AutoItems: pTAutoItems;
  UserMagic:pTUserMagic;
  StorageItems:pTStorageItems;         //창고
begin
  HumanRcd.boIsHero := False;

  HumanRcd.sChrName:=m_sCharName;
  HumanRcd.sCurMap:=m_sMapName;
  HumanRcd.wCurX:=m_nCurrX;
  HumanRcd.wCurY:=m_nCurrY;
  HumanRcd.btDir:=m_btDirection;
  HumanRcd.btHair:=m_btHair;
  HumanRcd.btSex:=m_btGender;
  HumanRcd.btJob:=m_btJob;
  HumanRcd.nGold:=m_nGold;

  HumanRcd.Abil.Level:=m_Abil.Level;

  HumanRcd.Abil.AC := m_WAbil.AC;
  HumanRcd.Abil.MAC := m_WAbil.MAC;
  HumanRcd.Abil.DC := m_WAbil.DC;
  HumanRcd.Abil.MC := m_WAbil.MC;
  HumanRcd.Abil.SC := m_WAbil.SC;

  HumanRcd.Abil.HP:=m_Abil.HP;
  HumanRcd.Abil.MP:=m_Abil.MP;
  HumanRcd.Abil.MaxHP:=m_Abil.MaxHP;
  HumanRcd.Abil.MaxMP:=m_Abil.MaxMP;
  HumanRcd.Abil.Exp:=m_Abil.Exp;
  HumanRcd.Abil.MaxExp:=m_Abil.MaxExp;
  HumanRcd.Abil.Weight:=m_Abil.Weight;
  HumanRcd.Abil.MaxWeight:=m_Abil.MaxWeight;
  HumanRcd.Abil.WearWeight:=m_Abil.WearWeight;
  HumanRcd.Abil.MaxWearWeight:=m_Abil.MaxWearWeight;
  HumanRcd.Abil.HandWeight:=m_Abil.HandWeight;
  HumanRcd.Abil.MaxHandWeight:=m_Abil.MaxHandWeight;

  HumanRcd.Abil.KillPointCurr:=m_Abil.KillPointCurr;
  HumanRcd.Abil.KillPoint:=m_Abil.KillPoint;
  HumanRcd.Abil.DeathPointCurr:=m_Abil.DeathPointCurr;
  HumanRcd.Abil.DeathPoint:=m_Abil.DeathPoint;

  HumanRcd.sMasterName := m_sMasterName;

  //HumanRcd.Abil:=m_Abil;
  HumanRcd.Abil.HP:=m_WAbil.HP;
  HumanRcd.Abil.MP:=m_WAbil.MP;

  HumanRcd.wStatusTimeArr:=m_wStatusTimeArr;
  HumanRcd.sHomeMap:=m_sHomeMap;
  HumanRcd.wHomeX:=m_nHomeX;
  HumanRcd.wHomeY:=m_nHomeY;
  HumanRcd.nPKPoint:=m_nPkPoint;    //피케이
  HumanRcd.BonusAbil:=m_BonusAbil;// 08/09
  HumanRcd.nBonusPoint:=m_nBonusPoint;// 08/09
  HumanRcd.sStoragePwd:=m_sStoragePwd;
  HumanRcd.btAiMode:=m_btAiMode;
  HumanRcd.btReLevel:=m_btReLevel;       //전직

  HumanRcd.nGameGold:=m_nGameGold;
  HumanRcd.nBankGold:=m_nBankGold;
  HumanRcd.nGamePoint:=m_nGamePoint;
  HumanRcd.nPCPoint:=m_nPCPoint;

  if m_boAllowGroup then HumanRcd.btAllowGroup:=1
  else HumanRcd.btAllowGroup:=0;

  HumanRcd.btAttatckMode:=m_btAttatckMode;
  HumanRcd.btIncHealth:=m_nIncHealth;
  HumanRcd.btIncSpell:=m_nIncSpell;
  HumanRcd.btIncHealing:=m_nIncHealing;
  HumanRcd.btFightZoneDieCount:=m_nFightZoneDieCount;
  HumanRcd.sAccount:=m_sUserID;
  HumanRcd.boLockLogon:=m_boLockLogon;

  HumanRcd.nMasterUpExp:=m_nMasterUpExp;
  HumanRcd.boAllowGuildReCall:=m_boAllowGuildReCall;
  HumanRcd.wGroupRcallTime:=m_wGroupRcallTime;
  HumanRcd.dBodyLuck:=m_dBodyLuck;
  HumanRcd.boAllowGroupReCall:=m_boAllowGroupReCall;
  HumanRcd.QuestUnitOpen:=m_QuestUnitOpen;
  HumanRcd.QuestUnit:=m_QuestUnit;
  HumanRcd.QuestFlag:=m_QuestFlag;

  HumanRcd.MissionFlag := m_MissionFlag;
  HumanRcd.MissionInfo := m_MissionInfo;
  HumanRcd.MissionArithmometer := m_MissionArithmometer;
  HumanRcd.MissionIndex := m_MissionIndex;

  HumanRcd.btHeroAutoDurg := m_btHeroAutoDurg;
  HumanRcd.nHeroGrade := m_nHeroGrade;
  HumanRcd.boIsHero := False;
  HumanRcd.sHeroChrName := m_sHeroCharName;

  HumItems:=@HumanRcd.HumItems;
  HumItems[U_DRESS]:=m_UseItems[U_DRESS];
  HumItems[U_WEAPON]:=m_UseItems[U_WEAPON];
  HumItems[U_RIGHTHAND]:=m_UseItems[U_RIGHTHAND];
  HumItems[U_HELMET]:=m_UseItems[U_NECKLACE];
  HumItems[U_NECKLACE]:=m_UseItems[U_HELMET];
  HumItems[U_ARMRINGL]:=m_UseItems[U_ARMRINGL];
  HumItems[U_ARMRINGR]:=m_UseItems[U_ARMRINGR];
  HumItems[U_RINGL]:=m_UseItems[U_RINGL];
  HumItems[U_RINGR]:=m_UseItems[U_RINGR];
  HumItems[U_BUJUK]:=m_UseItems[U_BUJUK];
  HumItems[U_BELT]:=m_UseItems[U_BELT];
  HumItems[U_BOOTS]:=m_UseItems[U_BOOTS];
  HumItems[U_CHARM]:=m_UseItems[U_CHARM];
  HumItems[U_TIGER]:=m_UseItems[U_TIGER];   //호랑이

  HumItems[U_PETS1]:=m_UseItems[U_PETS1];       //호랑이
  HumItems[U_PETS2]:=m_UseItems[U_PETS2];
  HumItems[U_PETS3]:=m_UseItems[U_PETS3];
  HumItems[U_PETS4]:=m_UseItems[U_PETS4];
  HumItems[U_PETS5]:=m_UseItems[U_PETS5];

  HumItems[U_FISH1]:=m_UseItems[U_FISH1];       //낚시
  HumItems[U_FISH2]:=m_UseItems[U_FISH2];
  HumItems[U_FISH3]:=m_UseItems[U_FISH3];
  HumItems[U_FISH4]:=m_UseItems[U_FISH4];
  HumItems[U_FISH5]:=m_UseItems[U_FISH5];

  BagItems:=@HumanRcd.BagItems;
  for I := 0 to m_ItemList.Count - 1 do begin
    if I >= MAXBAGITEM then break;
    BagItems[I]:=pTUserItem(m_ItemList.Items[I])^;
  end;
  HumMagic:=@HumanRcd.Magic;
  for I := 0 to m_MagicList.Count - 1 do begin
    if I >= MAXMAGIC then break;
    UserMagic:=m_MagicList.Items[I];
    HumMagic[I].wMagIdx:=UserMagic.wMagIdx;
    HumMagic[I].btLevel:=UserMagic.btLevel;
    HumMagic[I].btKey:=UserMagic.btKey;
    HumMagic[I].nTranPoint:=UserMagic.nTranPoint;
  end;

  AutoItems := @HumanRcd.AutoItems;
  for I := 0 to m_AutoItem.Count - 1 do begin
    if I >= 2 then Break;
    AutoItems[I] := pTUserItem(m_AutoItem.Items[I])^;
  end;

  StorageItems:=@HumanRcd.StorageItems;        //창고
  for I := 0 to m_StorageItemList.Count -1 do begin
    if I >= STORAGELIMIT then break;
    StorageItems[I]:=pTUserItem(m_StorageItemList.Items[I])^;
  end;
end;



function TBaseObject.sub_4C3538: Integer;//004C3538
var
  nC,n10:Integer;
begin
  Result:=0;
  nC:= -1;
  while (nC <> 2) do  begin
    n10:= -1;
    while (n10 <> 2) do  begin
      if not m_PEnvir.CanWalk(m_nCurrX + nC,m_nCurrY + n10,False) then begin
        if (nC <> 0) or (n10 <> 0) then
          Inc(Result);
      end;
      Inc(n10);
    end;
    Inc(nC);
  end;
end;

procedure TPlayObject.RefRankInfo(nRankNo:Integer;sRankName:string);//004CAE3C
begin
  m_nGuildRankNo:=nRankNo;
  m_sGuildRankName:=sRankName;
  SendMsg(Self,RM_CHANGEGUILDNAME,0,0,0,0,'');
end;

function TBaseObject.DelBagItem(nIndex: Integer): Boolean; //004C4F10
begin
  Result:=False;
  if (nIndex < 0) or (nIndex >= m_ItemList.Count) then exit;
  Dispose(pTUserItem(m_ItemList.Items[nIndex]));
  m_ItemList.Delete(nIndex);
  Result:=True;
end;

function TBaseObject.DelBagItem(nItemIndex: Integer;//004C4DFC
  sItemName: String): Boolean;
var
  I: Integer;
  UserItem:pTUserItem;
begin
  Result:=False;
  for I := 0 to m_ItemList.Count - 1 do begin
    UserItem:=m_ItemList.Items[I];
    if (UserItem.MakeIndex = nItemIndex) and
       (CompareText(UserEngine.GetStdItemName(UserItem.wIndex),sItemName) = 0) then begin
      Dispose(UserItem);
      m_ItemList.Delete(I);
      Result:=True;
      break;
    end;
  end;
  if Result then WeightChanged();
    
end;

function TBaseObject.UpgradeResultToStr( iSum: integer; strOpt: string; iBefore, iAfter: integer; fProb: double; iJewelStdMode: integer ):string;            //스쳐
var
   rtstr : string[20];
   strJewelType: string;
begin
   rtstr := '';
   if iJewelStdMode = 60 then begin
      strJewelType := '괜圖';
   end else if iJewelStdMode = 61 then begin
      strJewelType := '괜瀧';
   end;

   rtstr := IntToStr(iSum) + ',' + strJewelType + ',' + strOpt + ',' + IntToStr(iBefore) + ','+ IntToStr(iAfter) + ',' + FloatToStr(fProb);
   Result := rtstr;
end;

function TPlayObject.GetRunMsgCount: Integer;
var
  I: Integer;
  SendMessage:pTSendMessage;
begin
  Result:=0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do begin
      SendMessage:=m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_RUN) then begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetWalkMsgCount: Integer;
var
  I: Integer;
  SendMessage:pTSendMessage;
begin
  Result:=0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do begin
      SendMessage:=m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_WALK) then begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetTurnMsgCount: Integer;
var
  I: Integer;
  SendMessage:pTSendMessage;
begin
  Result:=0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do begin
      SendMessage:=m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_TURN) then begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSiteDownMsgCount: Integer;
var
  I: Integer;
  SendMessage:pTSendMessage;
begin
  Result:=0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for I := 0 to m_MsgList.Count - 1 do begin
      SendMessage:=m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_SITDOWN) then begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TPlayObject.SetScriptLabel(sLabel: String);
begin
  m_CanJmpScriptLableList.Clear;
  m_CanJmpScriptLableList.Add(sLabel);
end;
//혤돤뎠품신굶옵鹿契瘻돨깃푯
procedure TPlayObject.GetScriptLabel(sMsg: String);
var
  sText:String;
  sData:String;
  sCmdStr,sLabel:String;
begin
  m_CanJmpScriptLableList.Clear;
  while (True) do begin
    if sMsg = '' then break;
    sMsg:=GetValidStr3(sMsg,sText,['\']);
    if sText <> '' then begin
      sData:='';
      while (Pos('<',sText) > 0) and (Pos('>',sText) > 0) and (sText <> '') do begin
        if sText[1] <> '<' then begin
          sText:='<' + GetValidStr3(sText,sData,['<']);
        end;
        sText:=ArrestStringEx(sText,'<','>',sCmdStr);
        sLabel:=GetValidStr3(sCmdStr,sCmdStr,['/']);
        if sLabel <> '' then
          m_CanJmpScriptLableList.Add(sLabel);
      end;
    end;
  end;
end;

function TPlayObject.LableIsCanJmp(sLabel: String): Boolean;
var
  I: Integer;
begin
  Result:=False;
  if CompareText(sLabel,'@main') = 0 then begin
    Result:=True;
    exit;
  end;
  for I := 0 to m_CanJmpScriptLableList.Count - 1 do begin
    if CompareText(sLabel,m_CanJmpScriptLableList.Strings[I]) = 0 then begin
      Result:=True;
      break;
    end;
  end;
  if CompareText(sLabel,m_sPlayDiceLabel) = 0 then begin
    m_sPlayDiceLabel:='';
    Result:=True;
    exit;
  end;
end;

procedure TPlayObject.RecalcAbilitys;
begin
  inherited;
  RecalcAdjusBonus();
end;

procedure TPlayObject.UpdateVisibleGay(BaseObject: TBaseObject);
var
  I                 :Integer;
  boIsVisible       :Boolean;
  VisibleBaseObject :pTVisibleBaseObject;
begin
  boIsVisible:=False;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_Master <> nil) then
    m_boIsVisibleActive:=True;//흔벎角훙膠샀괜괜橙零TRUE

    
  for I := 0 to m_VisibleActors.Count - 1 do begin
    VisibleBaseObject:=m_VisibleActors.Items[i];
    if VisibleBaseObject.BaseObject = BaseObject then begin
      VisibleBaseObject.nVisibleBFlag:=1;
      boIsVisible:=True;
      break;
    end;
  end;

  if boIsVisible then exit;
  New(VisibleBaseObject);
  VisibleBaseObject.nVisibleBFlag := 2;
  VisibleBaseObject.BaseObject   := BaseObject;
  m_VisibleActors.Add(VisibleBaseObject);
end;

procedure TPlayObject.SearchViewRange;
var
  I           :Integer;
  nStartX     :Integer;
  nEndX       :Integer;
  nStartY     :Integer;
  nEndY       :Integer;
  n18         :Integer;
  n1C         :Integer;
  nIdx        :Integer;
  n24         :Integer;
  MapCellInfo :pTMapCellinfo;
  OSObject    :pTOSObject;
  BaseObject  :TBaseObject;
  MapItem     :pTMapItem;
  MapEvent    :TEvent;
  VisibleBaseObject :pTVisibleBaseObject;
  VisibleMapItem    :pTVisibleMapItem;
  nCheckCode        :Integer;
  nDateDropped:DWord;
  countstr , MapItemName: string;
  StdItem:TItem;
ResourceString
  sExceptionMsg1 = '[Exception] TPlayObject::SearchViewRange Code:%d';
  sExceptionMsg2 = '[Exception] TPlayObject::SearchViewRange 1-%d %s %s %d %d %d';

begin
  n24:=0;
  nCheckCode:=0;
  countstr := '';
  try
    nCheckCode:=2;
    for I := 0 to m_VisibleItems.Count - 1 do begin
      pTVisibleMapItem(m_VisibleItems.Items[I]).nVisibleFlag:=0;
    end;
    nCheckCode:=3;
    for I := 0 to m_VisibleEvents.Count - 1 do begin
      TEvent(m_VisibleEvents.Items[i]).nVisibleFlag:=0;
    end;
    nCheckCode:=4;
    for I := 0 to m_VisibleActors.Count - 1 do begin
      pTVisibleBaseObject(m_VisibleActors.Items[i]).nVisibleBFlag:=0;
    end;
    nCheckCode:=5;
  except
    MainOutMessage(format(sExceptionMsg1,[nCheckCode]));
    KickException();
  end;
  nCheckCode:=6;

  nStartX :=m_nCurrX - m_nViewRange;
  nEndX   :=m_nCurrX + m_nViewRange;
  nStartY :=m_nCurrY - m_nViewRange;
  nEndY   :=m_nCurrY + m_nViewRange;
  try
    nCheckCode:=7;
    for n18:= nStartX to nEndX do begin
      nCheckCode:=8;
      for n1C:= nStartY to nEndY  do begin
        nCheckCode:=9;
        if m_PEnvir.GetMapCellInfo(n18,n1C,MapCellInfo) and (MapCellInfo.ObjList <> nil) then begin
          nCheckCode:=10;
          n24:=1;
          nIdx:=0;
          while (True) do begin
            if (MapCellInfo.ObjList <> nil) and (MapCellInfo.ObjList.Count <= 0) then begin //200-11-1 藤속
              nCheckCode := 111;
              FreeAndNil(MapCellInfo.ObjList);
              nCheckCode := 112;
              Break;
            end;
            nCheckCode:=11;
            if MapCellInfo.ObjList.Count <= nIdx then break;    //004B9858
              OSObject:=MapCellInfo.ObjList.Items[nIdx];
              nCheckCode:=12;
              if OSObject <> nil then begin
                nCheckCode:=13;
                if OSObject.btType = OS_MOVINGOBJECT then begin    // 잔상 검사하여 지운다
                  nCheckCode:=14;
                  if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then begin
                    Dispose(OSObject);
                    MapCellInfo.ObjList.Delete(nIdx);
                    if MapCellInfo.ObjList.Count <= 0 then begin
                      FreeAndNil(MapCellInfo.ObjList);
                      break;
                    end;
                    Continue;
                  end; //004B9907
                  nCheckCode:=15;
                  BaseObject:=TBaseObject(OSObject.CellObj);
                  if BaseObject <> nil then begin
                    nCheckCode:=16;
                    if (not BaseObject.m_boGhost) and (not BaseObject.m_boFixedHideMode) and (not BaseObject.m_boObMode) then begin
                      nCheckCode:=17;
                      if (m_btRaceServer < RC_ANIMAL) or
                         (m_Master <> nil) or
                         m_boCrazyMode or
                         m_boNastyMode or
                         m_boHallucMode or //Hallucination
                         m_boWantRefMsg or
                         ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                         (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then begin
                         nCheckCode:=18;
                         UpdateVisibleGay(BaseObject);
                         nCheckCode:=19;
                      end;//004B99E2
                    end; //004B99E2
                  end; //004B99E2 if BaseObject <> nil then begin
                end; //004B99E2 if OSObject.btType = OS_MOVINGOBJECT then begin
                nCheckCode:=20;
                if m_btRaceServer = RC_PLAYOBJECT then begin
                  if OSObject.btType = OS_ITEMOBJECT then begin
                    nCheckCode:=21;
                    if ((GetTickCount - OSObject.dwAddTime) > g_Config.dwClearDropOnFloorItemTime) then begin
                      MapItem:=pTMapItem(OSObject.CellObj);
                      StdItem := UserEngine.GetStdItem(MapItem.UserItem.wIndex);
                      if StdItem <> nil then begin
                        if (StdItem.StdMode = 48) and (StdItem.Shape = 0) then begin    //상현아이템
                          if MapItem <> nil then begin
                            UpdateVisibleItem (n18, n1C, MapItem); //다음 아이템으로 넘어감...
                            Inc (nIdx);
                            continue;
                          end;
                        end;
                      end;
                      Dec(m_PEnvir.m_nItemCount);               //관리자시스템
                      Dec(g_MapManager.m_nItemCount);           //관리자시스템
                    //  MainOutMessage('바닥템 삭제 확인 ' + m_sCharName + ' ' + MapItem.Name ) ;
                      Dispose(pTMapItem(OSObject.CellObj));//Jacky 10/22
                      Dispose(OSObject);
                      MapCellInfo.ObjList.Delete(nIdx);
                      if MapCellInfo.ObjList.Count > 0 then Continue;
                      MapCellInfo.ObjList.Free;
                      MapCellInfo.ObjList:=nil;
                      break;                 
                    end else begin
                      MapItem:=pTMapItem(OSObject.CellObj);
                      nCheckCode:=28;
                      UpdateVisibleItem(n18,n1C,MapItem);
                      if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil) then begin
                        nCheckCode:=29;
                        if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then begin
                          nCheckCode:=30;
                          MapItem.OfBaseObject:=nil;
                          MapItem.DropBaseObject:=nil;
                        end else begin //004B9AF6
                          nCheckCode:=31;
                          if TBaseObject(MapItem.OfBaseObject) <> nil then begin
                            nCheckCode:=32;
                            if TBaseObject(MapItem.OfBaseObject).m_boGhost then MapItem.OfBaseObject:=nil;
                          end;
                          nCheckCode:=33;
                          if TBaseObject(MapItem.DropBaseObject) <> nil then begin
                            nCheckCode:=34;
                            if TBaseObject(MapItem.DropBaseObject).m_boGhost then MapItem.DropBaseObject:=nil;
                          end;
                          nCheckCode:=35;
                        end; //004B9B38
                      end;
                    end;
                  end; //004B9B38 if OSObject.btType = OS_ITEMOBJECT then begin
                  nCheckCode:=36;
                  if OSObject.btType = OS_EVENTOBJECT then begin
                    nCheckCode:=37;
                    MapEvent:=TEvent(OSObject.CellObj);
                    if MapEvent.m_boVisible then begin
                      nCheckCode:=38;
                      UpdateVisibleEvent(n18,n1C,MapEvent);
                    end;
                    nCheckCode:=39;
                  end;
                end
              end; //004B9B81 if OSObject <> nil then begin
            Inc(nIdx);
          end; //while (True) do begin
        end;
      end; //for n1C:= n10 to n14  do begin
    end; //for n18:= n8 to nC do begin
  except
    on e: Exception do begin

      MainOutMessage(format(sExceptionMsg2,[n24,m_sCharName,m_sMapName,m_nCurrX,m_nCurrY,nCheckCode]));
      {
      MainOutMessage(m_sCharName + ',' +
                     m_sMapName + ',' +
                     IntToStr(m_nCurrX) + ',' +
                     IntToStr(m_nCurrY) + ',' +
                     ' SearchViewRange 1-' +
                     IntToStr(n24));
      }
      MainOutMessage(E.Message);
      KickException();
    end;
  end;
  nCheckCode:=40;
  n24:=2;
  try
    n18:=0;
    while (True) do begin
      if m_VisibleActors.Count <= n18 then break;
      nCheckCode:=41;
      VisibleBaseObject:=m_VisibleActors.Items[n18];
      nCheckCode:=42;
      if VisibleBaseObject.nVisibleBFlag = 0 then begin
        nCheckCode:=43;
        if m_btRaceServer = RC_PLAYOBJECT then begin
          nCheckCode:=44;
          BaseObject:=TBaseObject(VisibleBaseObject.BaseObject);
          nCheckCode:=45;
          if (not BaseObject.m_boFixedHideMode) and (not BaseObject.m_boGhost) then begin
            nCheckCode:=46;
            SendMsg(BaseObject,RM_DISAPPEAR,0,0,0,0,'');         //확인
          end;
          nCheckCode:=47;
        end;
        m_VisibleActors.Delete(n18);
        nCheckCode:=48;
        Dispose(VisibleBaseObject);
        nCheckCode:=49;
        Continue;
      end;
      nCheckCode:=50;
      if (m_btRaceServer = RC_PLAYOBJECT) and (VisibleBaseObject.nVisibleBFlag = 2) then begin
        nCheckCode:=51;
        BaseObject:=TBaseObject(VisibleBaseObject.BaseObject);
        nCheckCode:=52;
        if BaseObject <> Self then begin
          nCheckCode:=53;
          if BaseObject.m_boDeath then begin
            nCheckCode:=54;
            if BaseObject.m_boSkeleton then begin
              nCheckCode:=55;
              SendMsg(BaseObject,RM_SKELETON,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,'');
              nCheckCode:=56;
            end else begin //004B9DA8
              nCheckCode:=57;
              SendMsg(BaseObject,RM_DEATH,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,'');
              nCheckCode:=58;
            end;
          end else begin //004B9DD3
            nCheckCode:=59;
            if BaseObject.m_btRaceServer in [RC_PLAYOBJECT] then begin
              SendMsg(BaseObject,RM_TURN,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,BaseObject.GetShowName + '/' + TPlayObject(BaseObject).GetNameRank + '/' + IntToStr(TPlayObject(BaseObject).GetRankColor) + '/' + '0');
            end else begin
              if BaseObject.m_btRaceServer in [RC_HEROOBJECT] then begin
                SendMsg(BaseObject,RM_TURN,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,BaseObject.GetShowName + '/' + ' ' + '/' + IntToStr(0) + '/' + '1');
              end else begin
                if BaseObject.m_btRaceServer in [RC_CLONE, RC_DARKCLONE, RC_BONZECLONE] then begin
                  SendMsg(BaseObject,RM_TURN,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,BaseObject.GetShowName + '/' + ' ' + '/' + IntToStr(0) + '/' + '0');
                end else begin
                  SendMsg(BaseObject,RM_TURN,BaseObject.m_btDirection,BaseObject.m_nCurrX,BaseObject.m_nCurrY,0,BaseObject.GetShowName);
                end;
              end;
            end;
            nCheckCode:=60;
            if BaseObject.m_btRaceServer = 155 then begin //비월천주 상태
              SendMsg (BaseObject, RM_FOXSTATE, BaseObject.m_btDirection, BaseObject.m_nCurrX, BaseObject.m_nCurrY, BaseObject.BodyState, BaseObject.GetShowName);
            end;
          end;
        end; //004B9E09
      end;
      Inc(n18);
    end;
  except
    on e: Exception do begin
      MainOutMessage(format(sExceptionMsg2,[n24,m_sCharName,m_sMapName,m_nCurrX,m_nCurrY,nCheckCode]));
    {MainOutMessage(m_sCharName + ',' +
                   m_sMapName + ',' +
                   IntToStr(m_nCurrX) + ',' +
                   IntToStr(m_nCurrY) + ',' +
                   ' SearchViewRange 2');}
      KickException();
    end;
  end;
  try
    if (m_btRaceServer = RC_PLAYOBJECT) then begin   // 사용자 한테만 전달  '12.12.20
      I:=0;
      while (True) do begin
        if m_VisibleItems.Count <= I then break;
        VisibleMapItem:=m_VisibleItems.Items[I];
        if VisibleMapItem.nVisibleFlag = 0 then begin
          SendMsg(Self,RM_ITEMHIDE,0,Integer(VisibleMapItem.MapItem),VisibleMapItem.nX,VisibleMapItem.nY,'');
          m_VisibleItems.Delete(I);
          Dispose(VisibleMapItem);
          Continue;
        end; //004B9F6C
        if VisibleMapItem.nVisibleFlag = 2 then begin
          if VisibleMapItem.sName = sSTRING_GOLDNAME then
           SendMsg(Self,RM_ITEMSHOW,VisibleMapItem.wLooks,Integer(VisibleMapItem.MapItem),VisibleMapItem.nX,VisibleMapItem.nY,VisibleMapItem.sName + '/' + '0' + '/' + '0')
          else
           SendMsg(Self,RM_ITEMSHOW,VisibleMapItem.wLooks,Integer(VisibleMapItem.MapItem),VisibleMapItem.nX,VisibleMapItem.nY,VisibleMapItem.sName);
        end;
        Inc(I);
      end;
      I:=0;
      while (True) do begin
        if m_VisibleEvents.Count <= I then break;
        MapEvent:=m_VisibleEvents.Items[I];
        if MapEvent.nVisibleFlag = 0 then begin
          SendMsg(Self,RM_HIDEEVENT,0,Integer(MapEvent),MapEvent.m_nX,MapEvent.m_nY,'');
          m_VisibleEvents.Delete(I);
          Continue;
        end; //004BA053
        if MapEvent.nVisibleFlag = 2 then begin
          SendMsg(Self,RM_SHOWEVENT,MapEvent.m_nEventType,Integer(MapEvent),MakeLong(MapEvent.m_nX,MapEvent.m_nEventParam),MapEvent.m_nY,'');
        end;
        Inc(I);
      end;
    end;
  except
    MainOutMessage(m_sCharName + ',' +
                   m_sMapName + ',' +
                   IntToStr(m_nCurrX) + ',' +
                   IntToStr(m_nCurrY) + ',' +
                   ' SearchViewRange 3');

    KickException();
  end;
end;

function TPlayObject.GetShowName: String;
var
  sShowName:String;
  sCharName:String;
  sGuildName:String;
  Castle:TUserCastle;
  FameGrade:integer;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::GetShowName';
begin
try
  sCharName:='';
  sGuildName:='';
  if m_MyGuild <> nil then begin
    Castle:=g_CastleManager.IsMasterCastleMember(Self);  //정복자 확인
    if Castle <> nil then begin  //정복자일경우
      if (m_btRaceServer <> RC_DARKCLONE) and (m_btRaceServer <> RC_BONZECLONE)  then begin
        sGuildName:=AnsiReplaceText(g_sCastleGuildName,'%castlename',Castle.m_sMName);
        sGuildName:=AnsiReplaceText(sGuildName,'%guildname',TGuild(m_MyGuild).sGuildName);
        sGuildName:=AnsiReplaceText(sGuildName,'%rankname',m_sGuildRankName);       //이름  직책
      end;
    end else begin
      Castle:=g_CastleManager.IsCastleMember(Self);
      if Castle <> nil then begin  //성문파이다
         if (m_btRaceServer <> RC_DARKCLONE) and (m_btRaceServer <> RC_BONZECLONE)  then begin
            sGuildName:=AnsiReplaceText(g_sCastleGuildName,'%castlename',Castle.m_sName);
            sGuildName:=AnsiReplaceText(sGuildName,'%guildname',TGuild(m_MyGuild).sGuildName);
            sGuildName:=AnsiReplaceText(sGuildName,'%rankname',m_sGuildRankName);       //이름  직책
         end;
      end else begin
        Castle:=g_CastleManager.InCastleWarArea(Self);
        if g_Config.boShowGuildName or (((Castle <> nil) and Castle.m_boUnderWar) or m_boInFreePKArea) then begin
         if (m_btRaceServer <> RC_CLONE) and (m_btRaceServer <> RC_DARKCLONE)  and (m_btRaceServer <> RC_BONZECLONE)  then begin
            sGuildName:=AnsiReplaceText(g_sNoCastleGuildName,'%guildname',TGuild(m_MyGuild).sGuildName);
            sGuildName:=AnsiReplaceText(sGuildName,'%rankname',m_sGuildRankName);
         end;
        end;
      end;

    end;
  end;
  sCharName:=m_sCharName;
  if not g_Config.boShowRankLevelName then begin
    if m_btReLevel > 0 then begin          //전직
      case m_btJob of
        jWarr: sCharName:=AnsiReplaceText(g_sWarrReNewName,'%chrname',m_sCharName);
        jWizard: sCharName:=AnsiReplaceText(g_sWizardReNewName,'%chrname',m_sCharName);
        jTaos: sCharName:=AnsiReplaceText(g_sTaosReNewName,'%chrname',m_sCharName);
        jAssassin: sCharName:=AnsiReplaceText(g_sAssassinReNewName,'%chrname',m_sCharName);//자객
        jUpWarr: sCharName:=AnsiReplaceText(g_sWarrUPReNewName,'%chrname',m_sCharName);
        jUpWiz: sCharName:=AnsiReplaceText(g_sWizardUPReNewName,'%chrname',m_sCharName);
        jUpTao: sCharName:=AnsiReplaceText(g_sTaosUPReNewName,'%chrname',m_sCharName);
        jUpAssa: sCharName:=AnsiReplaceText(g_sAssassinUPReNewName,'%chrname',m_sCharName);//비연자객
      end;
    end else begin
      sCharName:=m_sCharName;
    end;
  end else begin
    sCharName:=format(m_sRankLevelName,[m_sCharName]);     //랭크네임
  end;

 { if g_Config.boShowColumnName then begin
    if m_btColumn > 0 then begin          //칼럼이름
      case m_btColumn of
        1: sCharName:=AnsiReplaceText(g_sColumn1,'%chrname',m_sCharName);
        2: sCharName:=AnsiReplaceText(g_sColumn2,'%chrname',m_sCharName);
        3: sCharName:=AnsiReplaceText(g_sColumn3,'%chrname',m_sCharName);
        4: sCharName:=AnsiReplaceText(g_sColumn4,'%chrname',m_sCharName);
        5: sCharName:=AnsiReplaceText(g_sColumn5,'%chrname',m_sCharName);
        6: sCharName:=AnsiReplaceText(g_sColumn6,'%chrname',m_sCharName);
      end;
    end else begin
      sCharName:=m_sCharName;
    end;
  end;
           }
  sShowName:=AnsiReplaceText(g_sHumanShowName,'%chrname',sCharName);
  sShowName:=AnsiReplaceText(sShowName,'%famename',GetFameName(FameGrade));
  sShowName:=AnsiReplaceText(sShowName,'%guildname',sGuildName);
  sShowName:=AnsiReplaceText(sShowName,'%rankname',m_sGuildRankName);
  if g_Config.boShowColumnName then begin
    if m_btColumn > 0 then begin          //칼럼이름
      case m_btColumn of
        1: sShowName:=AnsiReplaceText(sShowName,'%column',g_sColumn1);
        2: sShowName:=AnsiReplaceText(sShowName,'%column',g_sColumn2);
        3: sShowName:=AnsiReplaceText(sShowName,'%column',g_sColumn3);
        4: sShowName:=AnsiReplaceText(sShowName,'%column',g_sColumn4);
        5: sShowName:=AnsiReplaceText(sShowName,'%column',g_sColumn5);
        6: sShowName:=AnsiReplaceText(sShowName,'%column',g_sColumn6);
      end;
    end else
      sShowName:=AnsiReplaceText(sShowName,'%column','');
  end;

  Result:=sShowName;
except
  on e: Exception do begin
    MainOutMessage(sExceptionMsg);
    MainOutMessage(E.Message);
  end;
end;
end;
function TPlayObject.CheckItemsNeed(StdItem:TItem): Boolean;
var
  Castle:TUserCastle;
begin
  Result:=True;
  case StdItem.Need of
    6: begin  //문파
      if (m_MyGuild = nil)then begin
        Result:=False;
      end;
    end;
    60: begin   //문파 문주
      if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then begin
        Result:=False;
      end;
    end;
    7: begin    //사북문
      Castle:=g_CastleManager.CastleMember(Self,'낡沽');
      if Castle = nil then begin
        Result:=False;
      end;
    end;
    70: begin    //사북문주
      Castle:=g_CastleManager.CastleMember(Self,'낡沽');
      if (Castle = nil) or (m_nGuildRankNo <> 1) then begin
        Result:=False;
      end;
    end;
    80: begin   //정복자
      Castle:=g_CastleManager.IsMasterCastleMember(Self);
      if Castle = nil then begin
        Result:=False;
      end;
    end;
    9: begin           //남만문원
      Castle:=g_CastleManager.CastleMember(Self,'켓찮');
      if Castle = nil then begin
        Result:=False;
      end;
    end;
    90: begin   //남만성문주
      Castle:=g_CastleManager.CastleMember(Self,'켓찮');
      if (Castle = nil) or (m_nGuildRankNo <> 1) then begin
        Result:=False;
      end;
    end;

    20: begin
      if not (m_btColumn in [1..6]) then Result:=False;
    end;
    21: begin
      if m_btColumn <> 1 then Result:=False;
    end;
    22: begin
      if m_btColumn <> 2 then Result:=False;
    end;
    23: begin
      if m_btColumn <> 3 then Result:=False;
    end;
    24: begin
      if m_btColumn <> 4 then Result:=False;
    end;
    25: begin
      if m_btColumn <> 5 then Result:=False;
    end;
    26: begin
      if m_btColumn <> 6 then Result:=False;
    end;


  end;

end;
procedure TPlayObject.MakeGhost; //PLAYER DISCONNECT
var
  i: Integer;
  CheckMsg: pTCheckMsg;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::MakeGhost';
begin
try

  if (m_MyHero <> nil) then begin
     THeroObject(m_MyHero).LogOut();
  end;
  m_MyHero := nil;
  m_dwRecallHeroTick := GetTickCount;

  if (m_boStore) then StoreCancel; //개인상점 취소

  if (g_HighLevelHuman = Self)   then g_HighLevelHuman:=nil;
  if (g_HighPKPointHuman = Self) then g_HighPKPointHuman:=nil;
  if (g_HighDCHuman = Self)      then g_HighDCHuman:=nil;
  if (g_HighMCHuman = Self)      then g_HighMCHuman:=nil;
  if (g_HighSCHuman = Self)      then g_HighSCHuman:=nil;
  if (g_HighOnlineHuman = Self)  then g_HighOnlineHuman:=nil;

  if m_CheckMsgList.Count > 0 then begin
    for i := 0 to m_CheckMsgList.Count - 1 do begin
      CheckMsg := m_CheckMsgList.Items[i];
      if CheckMsg <> nil then begin
        ClientCheckMsg(CheckMsg.tClass, CheckMsg.AllPurpose, -1);
        DisPose(CheckMsg);
      end;
    end;
  end;
  m_CheckMsgList.Clear;

except
  on e: Exception do begin
    MainOutMessage(sExceptionMsg);
    MainOutMessage(E.Message);
  end;

end;
  inherited;
end;

function TPlayObject.GetMyInfo: String;
var
  sMyInfo:String;
begin
  sMyInfo:=g_sMyInfo;
  sMyInfo:=AnsiReplaceText(sMyInfo,'%name',m_sCharName);
  sMyInfo:=AnsiReplaceText(sMyInfo,'%map',m_PEnvir.sMapDesc);
  sMyInfo:=AnsiReplaceText(sMyInfo,'%x',IntToStr(m_nCurrX));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%y',IntToStr(m_nCurrY));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%level',IntToStr(m_Abil.Level));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%gold',IntToStr(m_nGold));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%pk',IntToStr(m_nPkPoint));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%minhp',IntToStr(m_WAbil.HP));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%maxhp',IntToStr(m_WAbil.MaxHP));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%minmp',IntToStr(m_WAbil.MP));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%maxmp',IntToStr(m_WAbil.MaxMP));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%mindc',IntToStr(LoWord(m_WAbil.DC)));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%maxdc',IntToStr(HiWord(m_WAbil.DC)));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%minmc',IntToStr(LoWord(m_WAbil.MC)));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%maxmc',IntToStr(HiWord(m_WAbil.MC)));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%minsc',IntToStr(LoWord(m_WAbil.SC)));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%maxsc',IntToStr(HiWord(m_WAbil.SC)));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%logontime',DateTimeToStr(m_dLogonTime));
  sMyInfo:=AnsiReplaceText(sMyInfo,'%logonlong',IntToStr((GetTickCount - m_dwLogonTick) div 60000));
  Result:=sMyInfo;
end;

function TPlayObject.CheckItemBindUse(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  ItemBind:pTItemBind;
begin
  Result:=True;
  g_ItemBindAccount.Lock;
  try
    for I := 0 to g_ItemBindAccount.Count - 1 do begin
      ItemBind:=g_ItemBindAccount.Items[I];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
         (ItemBind.nItemIdx = UserItem.wIndex) then begin
        Result:=False;
        if (CompareText(ItemBind.sBindName,m_sUserID) = 0) then begin
          Result:=True;
        end else begin
          SysMsg(g_sItemIsNotThisAccount,c_Red,t_Hint);
        end;          
        exit;
      end;
    end;
  finally
    g_ItemBindAccount.UnLock;
  end;
  
  g_ItemBindIPaddr.Lock;
  try
    for I := 0 to g_ItemBindIPaddr.Count - 1 do begin
      ItemBind:=g_ItemBindIPaddr.Items[I];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
         (ItemBind.nItemIdx = UserItem.wIndex) then begin
        Result:=False;
        if (CompareText(ItemBind.sBindName,m_sIPaddr) = 0) then begin
          Result:=True;
        end else begin
          SysMsg(g_sItemIsNotThisIPaddr,c_Red,t_Hint);
        end;
        exit;
      end;
    end;
  finally
    g_ItemBindIPaddr.UnLock;
  end;
  g_ItemBindCharName.Lock;
  try
    for I := 0 to g_ItemBindCharName.Count - 1 do begin
      ItemBind:=g_ItemBindCharName.Items[I];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
         (ItemBind.nItemIdx = UserItem.wIndex) then begin
        Result:=False;
        if (CompareText(ItemBind.sBindName,m_sCharName) = 0) then begin
          Result:=True;
        end else begin
          SysMsg(g_sItemIsNotThisCharName,c_Red,t_Hint);
        end;
        exit;
      end;
    end;
  finally
    g_ItemBindCharName.UnLock;
  end;
end;

procedure TPlayObject.ProcessClientPassword(ProcessMsg: pTProcessMessage);
var
  nLen:Integer;
  sData:String;
begin
//  SysMsg(ProcessMsg.sMsg,c_Red,t_Hint);
  if ProcessMsg.wParam = 0 then begin
    ProcessUserLineMsg('@' + g_GameCommand.UNLOCK.sCmd);
    exit;
  end;

  sData:=ProcessMsg.sMsg;
  nLen:=length(sData);
  if m_boSetStoragePwd then begin
    m_boSetStoragePwd:=False;
    if (nLen > 3) and (nLen < 8) then begin
      m_sTempPwd:=sData;
      m_boReConfigPwd:=True;
      SysMsg(g_sReSetPasswordMsg,c_Green,t_Hint);
      SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
    end else begin
      SysMsg(g_sPasswordOverLongMsg,c_Red,t_Hint);
    end;
    exit;
  end;
  if m_boReConfigPwd then begin
    m_boReConfigPwd:=False;
    if CompareStr(m_sTempPwd,sData) = 0 then begin
      m_sSystemPwd:=sData;
      m_boPasswordLocked:=True;
      m_sTempPwd:='';
      SysMsg(g_sReSetPasswordOKMsg,c_Blue,t_Hint);
    end else begin
      m_sTempPwd:='';
      SysMsg(g_sReSetPasswordNotMatchMsg,c_Red,t_Hint);
    end;
    exit;
  end;
  if m_boUnLockPwd or m_boUnLockStoragePwd then begin
    if CompareStr(m_sSystemPwd,sData) = 0 then begin
      m_boPasswordLocked:=False;
      if m_boUnLockPwd then begin
        if g_Config.boLockDealAction then m_boCanDeal:=True;
        if g_Config.boLockDropAction then m_boCanDrop:=True;
        if g_Config.boLockWalkAction then m_boCanWalk:=True;
        if g_Config.boLockRunAction then m_boCanRun:=True;
        if g_Config.boLockHitAction then m_boCanHit:=True;
        if g_Config.boLockSpellAction then m_boCanSpell:=True;
        if g_Config.boLockSendMsgAction then m_boCanSendMsg:=True;
        if g_Config.boLockUserItemAction then m_boCanUseItem:=True;
        if g_Config.boLockInObModeAction then begin
          m_boObMode:=False;
          m_boAdminMode:=False;
        end;
        m_boLockLogoned:=True;
        SysMsg(g_sPasswordUnLockOKMsg,c_Blue,t_Hint);
      end;
      if m_boUnLockStoragePwd then begin
        if g_Config.boLockGetBackItemAction then m_boCanGetBackItem:=True;
        SysMsg(g_sStorageUnLockOKMsg,c_Blue,t_Hint);
      end;

    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sUnLockPasswordFailMsg,c_Red,t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
      end;
    end;
    m_boUnLockPwd:=False;
    m_boUnLockStoragePwd:=False;
    exit;
  end;

  if m_boCheckOldPwd then begin
    m_boCheckOldPwd:=False;
    if m_sSystemPwd = sData then begin
      SendMsg(Self,RM_PASSWORD,0,0,0,0,'');
      SysMsg(g_sSetPasswordMsg,c_Green,t_Hint);
      m_boSetStoragePwd:=True;
    end else begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sOldPasswordIncorrectMsg,c_Red,t_Hint);
      if m_btPwdFailCount > 3 then begin
        SysMsg(g_sStoragePasswordLockedMsg,c_Red,t_Hint);
        m_boPasswordLocked:=True;
      end;
    end;
    exit;
  end;
end;

procedure TPlayObject.ClientSeparateItems(bMakeIndex,namount:integer);   //물약
var
 I,inde:Integer;
 sUItem,UserItem:PTUserItem;
 StdItem:TItem;
begin
  if (bMakeIndex <= 0) or (namount < 1) then Exit;
    if not IsEnoughBag then begin
    SysMsg ('콱돨교관綠쒔찮죄。', c_Red,t_Hint);
    Exit;
  end;
  inde := 0;
  for I := 0 to m_ItemList.Count - 1 do begin
    sUItem:=m_ItemList.Items[i];
    if (sUItem = nil) then Continue;
    if (sUItem.MakeIndex = bMakeIndex) and (sUItem.Amount > namount) then begin
      StdItem:=UserEngine.GetStdItem(sUItem.wIndex);
      if sUItem.Amount > StdItem.MaxAmount then begin     //물약 버그 분리
         Dispose(sUItem);
         m_ItemList.Delete (i);
         WeightChanged();
         exit;
      end else begin
         inde := sUItem.Amount - namount;
         sUItem.Amount := namount;
         SendAddItemmode(sUItem,1);    //물약
         New(UserItem);
         if UserEngine.CopyToUserItemFromName(StdItem.Name, UserItem, inde) then begin
           m_ItemList.Add(UserItem);
           SendAddItem(UserItem,1);
           WeightChanged();
         end else begin
           Dispose(UserItem);
         end;
         exit;
      end;
    end;
  end;
end;


procedure TPlayObject.ScatterBagItems(ItemOfCreat: TBaseObject);      //캐릭 유저 가방템 떨굼
var
   i, dropwide: integer;
   drcount, icount: integer;
   pu, newpu: PTUserItem;
   pstd: TItem;
   dellist: TStringList;
   boDropall: Boolean;
   tCode:integer;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::ScatterBagItems d%';
begin
   dellist := nil;
   if m_boNoDropBagItem then begin
      m_boNoDropBagItem := false;
      Exit;
   end;

   if m_boDropDurg or m_PEnvir.Flag.boNODROPITEM then exit;   //환템 드랍

   boDropall:=False;
   if m_btRaceServer = RC_PLAYOBJECT then begin
      dropwide := 2;
      if g_Config.boDieRedScatterBagAll and (PKLevel >= 2 )then boDropall:=True;
      //빨갱이는 다 떨군다.
   end else
      dropwide := 3;

   try
      tCode:=0;
      for i:=m_ItemList.Count-1 downto 0 do begin
        pu := PTUserItem(m_ItemList[i]);
        pstd := UserEngine.GetStdItem (pu.wIndex);
        tCode:=1;
        if pstd = nil then continue;
        tCode:=2;
        //죽었을때 상현주머니는 안떨구게...(sonmg 2004/08/09)
        if (pstd.StdMode = 48) then continue;    //상현아이템
        tCode:=3;
        if (m_btRaceServer = RC_PLAYOBJECT) and ((not pstd.boCanDeathDrop) or (pu.btValue[19] > 0)) then continue; //떨굴 수  없는 아이템(sonmg 2005/03/14)
        tCode:=4;
            if (Random(g_Config.nDieScatterBagRate) = 0) or boDropall then begin
               //갯수 아이템인 경우 일부만 떨어짐
               if pstd.StdMode in [0,1,3,45,46] then begin
                  icount := pu.Amount;
                  drcount := _MAX(1, Random (icount div 2));  //절대로 다 떨어지지 않음
                  icount := _MAX(0, icount - drcount); //수정(sonmg)
                  if drcount > 0 then begin
                     new (newpu);
                     if UserEngine.CopyToUserItemFromName(pstd.Name, newpu) then begin
                        newpu.Amount := drcount;

                        if DropItemDown (newpu,dropwide,True,ItemOfCreat,Self) then begin
                           pu.Amount := icount;

                           if pu.Amount <= 0 then begin
                              pu := PTUserItem(m_ItemList[i]);
                              if m_btRaceServer = RC_PLAYOBJECT then begin
                                 if dellist = nil then dellist := TStringList.Create;
                                 //남은개수 0인 아이템을 지우기 위해 클라이언트에 알림.
                                 tCode:=5;
                                 dellist.AddObject(UserEngine.GetStdItemName (pu.wIndex), TObject(pu.MakeIndex));
                              end;
                              Dispose(PTUserItem(m_ItemList[i]));
                              m_ItemList.Delete (i);
                           end else begin
                              tCode:=6;
                              SendMsg(self, RM_COUNTERITEMCHANGE, 0, pu.MakeIndex, pu.Amount, 0, FilterStdShowName(pstd,pstd.Name));
                           end;
                        end;
                     end;
                     tCode:=7;
                     if newpu <> nil then Dispose( newpu );   // Memory Leak sonmg
                  end;
               end else begin
                  // 몬스터 드롭 광석 순도 조절.
                  tCode:=8;
                  pu := PTUserItem(m_ItemList[i]);
                  if m_btRaceServer <> RC_PLAYOBJECT then begin
                     if pstd.StdMode = 43 then begin
                        pu.Dura := RandomOreDura;
                     end;
                  end;
                  tCode:=9;
                  if DropItemDown (pu, dropwide, TRUE, ItemOfCreat, self) then begin
                     if m_btRaceServer = RC_PLAYOBJECT then begin
                        tCode:=10;
                        if dellist = nil then dellist := TStringList.Create;
                        //떨어뜨린 아이템을 클라이언트에 알림.
                        tCode:=11;
                        dellist.AddObject(UserEngine.GetStdItemName (pu.wIndex), TObject(pu.MakeIndex));
                     end;
                     tCode:=12;
                     Dispose(PTUserItem(m_ItemList[i]));
                     m_ItemList.Delete (i);
                  end;
                  tCode:=13;
               end;

            end;
      end;



      if dellist <> nil then begin
         tCode:=14;
         SendMsg (self, RM_SENDDELITEMLIST, 0, integer(dellist), 0, 0, '');
      end;
   //   if dellist <> nil then FreeAndNil(dellist);
   except
      MainOutMessage (format(sExceptionMsg,[tCode]));
   end;
end;
procedure TPlayObject.RecallHuman(sHumName: String);     //장원 개인 소환
var
  PlayObject:TPlayObject;
  nX,nY,n18,n1C:Integer;
begin
  PlayObject:=UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then begin
    if GetFrontPosition(nX,nY) then begin
      if sub_4C5370(nX,nY,3,n18,n1C) then begin
        PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE,0,0,0,0,'');
        PlayObject.SpaceMove(m_sMapName,n18,n1C,0);
      end;
    end else begin
      SysMsg('늪뒈暠꼇豚冀梁뻥。',c_Red,t_Hint);
    end;
  end else begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer,[sHumName]),c_Red,t_Hint);
  end;
end;

procedure TPlayObject.ReQuestGuildWar(sGuildName: String);
var
  Guild:TGuild;
  WarGuild:pTWarGuild;
  boReQuestOK:Boolean;
begin
  if not IsGuildMaster then begin
    SysMsg('怜唐契삔廊쳔훙꼽옵鹿鉞濡',c_Red,t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then begin
    SysMsg('늪츱즈꼇콘疼늪륩蛟포銶밉찼',c_Red,t_Hint);
    exit;
  end;
  Guild:=g_GuildManager.FindGuild(sGuildName);
  if Guild = nil then begin
    SysMsg('契삔' + sGuildName + '꼇닸瞳。',c_Red,t_Hint);
    exit;
  end;
  if Guild = TGuild(m_MyGuild) then begin
    SysMsg ('콱꼇콘뚤菱성돨契삔랙폅濫轢。',c_Red,t_Hint);
    exit;
  end;
  if g_Config.boNeutralityAttack then begin
    if (Guild.nGuildMode = 0) or (TGuild(m_MyGuild).nGuildMode = 0) then begin
      SysMsg ('콱꼇콘鉞閏ぶ僅☜剋聖',c_Red,t_Hint);
      exit;
    end;
  end;
  if m_nGold < g_Config.nGuildWarPrice then begin
    SysMsg('쏜귑꼇璃。',c_Red,t_Hint);
    exit;
  end;
  boReQuestOK:=False;
  WarGuild:=TGuild(m_MyGuild).AddWarGuild(Guild);
  if WarGuild <> nil then begin
    if Guild.AddWarGuild(TGuild(m_MyGuild)) = nil then begin
      WarGuild.dwWarTick:=0;
    end else begin
      boReQuestOK:=True;
    end;
  end;
  if boReQuestOK then begin
    DecGold(g_Config.nGuildWarPrice);
    GoldChanged();
    UserEngine.SendServerGroupMsg(SS_207,nServerIndex,TGuild(m_MyGuild).sGuildName);
    UserEngine.SendServerGroupMsg(SS_207,nServerIndex,Guild.sGuildName);
  end;     
    
end;
function TPlayObject.CheckDenyLogon():Boolean;
begin
  Result:=False;
  if GetDenyIPaddrList(m_sIPaddr) then begin
    SysMsg(g_sYourIPaddrDenyLogon,c_Red,t_Hint);
    Result:=True;
  end else
  if GetDenyAccountList(m_sUserID) then begin
    SysMsg(g_sYourAccountDenyLogon,c_Red,t_Hint);
    Result:=True;
  end else
  if GetDenyChrNameList(m_sCharName) then begin
    SysMsg(g_sYourCharNameDenyLogon,c_Red,t_Hint);
    Result:=True;
  end;
  if Result then m_boEmergencyClose:=True;
end;

function TPlayObject.CheckHDDLogon(nCode:string): Boolean;   //수정되었습니다.
begin
  Result:=False;
  if GetDenyHDDList(nCode) then begin
    SysMsg(g_sYourHDDDenyLogon,c_Red,t_Hint);
    Result:=True;
  end;

  if Result then m_boEmergencyClose:=True;
end;

procedure TPlayObject.ClientRequestMailList(PlayObject: TPlayObject);
var
  I: Integer;
  MailItem: PNMailItem;
  DBM: TADOQuery;
begin

  FrmDB.UseSQL();
  DBM := FrmDB.Query;

  DBM.SQL.Clear;
  DBM.SQL.Add('SELECT * FROM TBL_MAIL Where FLD_RECIPIENT='''+Self.m_sCharName+''' ORDER BY FLD_ID');
  DBM.Open;

  SendDefMessage(SM_MAILLIST, 0, 0, 0, 0, '');

  new(MailItem);
  for I := 0 to DBM.RecordCount - 1 do begin
    if DBM.eof then break;

    MailItem.Id := DBM.FieldByName('FLD_ID').AsInteger;
    MailItem.Sender := DBM.FieldByName('FLD_SENDER').AsString;
    MailItem.Recipient :=  DBM.FieldByName('FLD_RECIPIENT').AsString;
    MailItem.Mail := DBM.FieldByName('FLD_MAIL').AsString;
    MailItem.Status := DBM.FieldByName('FLD_STATUS').AsInteger;
    MailItem.Date := DBM.FieldByName('FLD_DATE').AsString;

    SendDefMessage(SM_MAIL_LIST, 0, 0, 0, 0, MailItemToString(MailItem));
    DBM.Next;
  end;
  Dispose(MailItem);
  DBM.Close;
end;

procedure TPlayObject.ClientSendMail(ProcessMsg: pTProcessMessage);
var
  FriendObject: TPlayObject;
  DBMc: TADOCommand;
  DBMq: TADOQuery;
  reciever    : String;
  tagmsg      : String;
begin

  tagmsg := GetValidStr3 (ProcessMsg.sMsg,reciever, ['/']);
  FrmDB.UseSQL();
  DBMq := FrmDB.Query;
  DBMq.Close;
  DBMq.SQL.Clear;
  DBMq.SQL.Add('SELECT * FROM TBL_BLOCKLIST WHERE FLD_OWNER = :FLD_OWNER and FLD_NAME = :FLD_NAME');
  DBMq.Parameters.ParamByName('FLD_OWNER').Value := reciever;
  DBMq.Parameters.ParamByName('FLD_NAME').Value := Self.m_sCharName;
  DBMq.Open;

  if DBMq.RecordCount > 0 then begin
    SendDefMessage(SM_MAIL_RESULT, 0, 1, 0, 0, '');      //거부자 등록 여부 메시지
    DBMq.Close;
    exit;
  end;
  DBMq.Close;

  tagmsg := GetValidStr3 (ProcessMsg.sMsg,reciever, ['/']);
  FrmDB.UseSQL();
  DBMc := FrmDB.QueryCommand;
  DBMc.CommandText := 'INSERT INTO TBL_MAIL (FLD_SENDER,FLD_RECIPIENT,FLD_MAIL,FLD_STATUS,FLD_DATE) values (:FLD_SENDER, :FLD_RECIPIENT, :FLD_MAIL, :FLD_STATUS, :FLD_DATE)';
  DBMc.Parameters.ParamByName('FLD_SENDER').Value := Self.m_sCharName;
  DBMc.Parameters.ParamByName('FLD_RECIPIENT').Value := reciever;
  DBMc.Parameters.ParamByName('FLD_MAIL').Value := tagmsg;
  DBMc.Parameters.ParamByName('FLD_STATUS').Value := 0;
  DBMc.Parameters.ParamByName('FLD_DATE').Value := FormatDateTime('yymmddhhnnss',Now );
  DBMc.Execute;
  DBMc.CommandText := '';


  FriendObject := UserEngine.GetPlayObject(reciever);
  if FriendObject <> nil then begin
    TPlayObject(FriendObject).SendDefMessage(SM_MAIL_ALARM, 0, 1, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientMailStatus(ProcessMsg: pTProcessMessage);
var
  nID: Integer;
  nSTATUS : Integer;
  DBM: TADOCommand;
begin
  nID := ProcessMsg.nParam1;
  nSTATUS := ProcessMsg.nParam2;

  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'UPDATE TBL_MAIL SET FLD_STATUS=:FLD_STATUS WHERE FLD_ID = :FLD_ID and FLD_RECIPIENT = :FLD_RECIPIENT';
  DBM.Parameters.ParamByName('FLD_STATUS').Value := nSTATUS;
  DBM.Parameters.ParamByName('FLD_ID').Value := nID;
  DBM.Parameters.ParamByName('FLD_RECIPIENT').Value := Self.m_sCharName;
  DBM.Execute;
  DBM.CommandText := '';

  Self.SendDefMessage(SM_MAIL_INFO, nID, nSTATUS, 0, 0, '');
end;

procedure TPlayObject.ClientDeleteMail(ProcessMsg: pTProcessMessage);
var
  nID: Integer;
  DBM: TADOCommand;
begin
  nID := ProcessMsg.nParam1;

  Self.SendDefMessage(SM_MAIL_INFO, nID, 3, 0, 0, '');

  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'DELETE FROM TBL_MAIL WHERE FLD_ID = :FLD_ID and FLD_RECIPIENT = :FLD_RECIPIENT';
  DBM.Parameters.ParamByName('FLD_ID').Value := nID;
  DBM.Parameters.ParamByName('FLD_RECIPIENT').Value := Self.m_sCharName;
  DBM.Execute;
  DBM.CommandText := '';

end;


procedure TPlayObject.ClientRejectList(PlayObject: TPlayObject);
var
  I, ListCount: Integer;
  RejectList: TList;
  RejectItem: pTBlockItem;

  sMsg : string;
begin
  ListCount := 0;
  sMsg := '';
  RejectList := TList.create;
  RejectList := FrmDB.LoadRejectList(PlayObject.m_sCharName);

  for i := 0 to RejectList.Count -1 do begin
    RejectItem := RejectList[i];
    sMsg := sMsg + IntToStr( RejectItem.Id)+':'+ RejectItem.Name +':'+ '/';
    Inc( ListCount );
  end;

  if ListCount > 0 then
  SendDefMessage(SM_REJECT_LIST, 0, ListCount, 0, 0, sMsg);

  FreeAndNil(RejectList);
end;


procedure TPlayObject.ClientAddReject(ProcessMsg: pTProcessMessage);
var
  DBM: TADOQuery;
  DBMc: TADOCommand;
  RejectObject: TPlayObject;
begin
  if ProcessMsg.sMsg = Self.m_sCharName then begin
    SendDefMessage(SM_REJECT_RESULT, 0, 1, 0, 0, '');  //자기자신
    exit;
  end;

  FrmDB.UseSQL();
  DBM := FrmDB.Query;
  DBM.Close;
  DBM.SQL.Clear;
  DBM.SQL.Add('SELECT * FROM TBL_BLOCKLIST WHERE FLD_OWNER = :FLD_OWNER and FLD_NAME = :FLD_NAME');
  DBM.Parameters.ParamByName('FLD_OWNER').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_NAME').Value := ProcessMsg.sMsg;
  DBM.Open;

  if DBM.RecordCount > 0 then begin
    SendDefMessage(SM_REJECT_RESULT, 0, 2, 0, 0, '');    //이미등록
  end else begin
    RejectObject := UserEngine.GeTPlayObject(ProcessMsg.sMsg);
    if RejectObject <> nil then begin
      SendDefMessage(SM_REJECT_ADD, 0, 0, 0, 0, ProcessMsg.sMsg);

      FrmDB.UseSQL();
      DBMc := FrmDB.QueryCommand;
      DBMc.CommandText := 'INSERT INTO TBL_BLOCKLIST (FLD_OWNER,FLD_NAME) values (:FLD_OWNER, :FLD_NAME)';
      DBMc.Parameters.ParamByName('FLD_OWNER').Value := Self.m_sCharName;
      DBMc.Parameters.ParamByName('FLD_NAME').Value := ProcessMsg.sMsg;
      DBMc.Execute;
      DBMc.CommandText := '';

    end else begin
      SendDefMessage(SM_REJECT_RESULT, 0, 3, 0, 0, ProcessMsg.sMsg);      //접속중이아님
    end;
  end;
  DBM.Close;
end;

procedure TPlayObject.ClientDelReject(ProcessMsg: pTProcessMessage);
var
  DBM: TADOCommand;
begin
  // Assume name is correct, we dont care yet
  SendDefMessage(SM_REJECT_DELETE, 0, 0, 0, 0, ProcessMsg.sMsg);

  // Delete from sql
  FrmDB.UseSQL();
  DBM := FrmDB.QueryCommand;
  DBM.CommandText := 'DELETE FROM TBL_BLOCKLIST WHERE FLD_OWNER = :FLD_OWNER and FLD_NAME = :FLD_NAME';
  DBM.Parameters.ParamByName('FLD_OWNER').Value := Self.m_sCharName;
  DBM.Parameters.ParamByName('FLD_NAME').Value := ProcessMsg.sMsg;
  DBM.Execute;
  DBM.CommandText := '';
end;

procedure TPlayObject.savelipiitemnamestr(ProcessMsg: pTProcessMessage);    //환상점   선물 관심
var
 I,amouin,idx: Integer;
 data,toname,itemmrs:string;
 ShopItem1:PTSeveShopItem;
 opboot:boolean;
begin
  idx := 0;
  if ProcessMsg.sMsg <> '' then begin
    data := DecodeString(ProcessMsg.sMsg);
    data := GetValidStr3 (data, toname, ['\']);
    data := GetValidStr3 (data, itemmrs, ['\']);
    for i:=0 to g_ServerShopList.Count -1  do begin
      if g_ServerShopList[i] = nil then break;
      ShopItem1:= g_ServerShopList.Items[i];
      if ShopItem1.ShopItemName = itemmrs then begin
        opboot := True;
        amouin := ShopItem1.ShopItems.Amount;
       end;
    end;
   idx := FrmDB.LoadGiftsidx(toname);
   if opboot then begin
       if (m_nGameGold >= strtoint(data)) then begin
         if idx >= g_Config.GiftitemIdx then begin
            SendDefMessage(SM_LIPEITEMCOR, 0, 0, 0, 0, toname +'꼇콘疼澗돕쟉膠죄。');
            exit;
         end;
         if FrmDB.savelipiitemn(Self.m_sCharName,itemmrs,toname,amouin,0) then begin
          dec(m_nGameGold,strtoint(data));
           SendGoldInfo(True);
           SendDefMessage(SM_LIPEITEMCOR, 0, 0, 0, 0, toname + ' 못콱箇죄寧숭쟉膠。' + '\' + toname + ' 뎠품쟉膠돨鑒좆槨: ' + intToStr((g_Config.GiftitemIdx - idx) - 1) + '몸。' );
         end;
       end else begin
        SendDefMessage(SM_LIPEITEMCOR, 0, 0, 0, 0, '듐환꼇璃，헝섟珂념令。');
        exit;
       end;
    end;
  end;
end;

procedure TPlayObject.saveMyShopCartstr(ProcessMsg: pTProcessMessage);   //환상점  관심
var
I,amouin: Integer;
itemname:string;
Cartlist:TList;
pCart:pTShopCart;
rboot:Boolean;
begin
 rboot := true;
 Cartlist:=TList.create;
 Cartlist := FrmDB.LoadShopcartItemList(Self.m_sCharName);
 if ProcessMsg.sMsg <> '' then begin
    itemname := DecodeString(ProcessMsg.sMsg);
    amouin := ProcessMsg.nParam1;
   if itemname <> '' then begin
    for I :=0 to Cartlist.Count - 1 do begin
      pCart := Cartlist.Items[i];
      if pCart.Itemname = itemname then begin
       rboot := false;
       break;
      end;
   end;
   if rboot then begin
      if Cartlist.Count < 8 then begin
        if  FrmDB.SaveMyShopCart(Self.m_sCharName,itemname,IntToStr(amouin)) then
         SysMsg(itemname + '綠쒔속흙돕澗꾜죗깊뎠櫓。',c_Green,t_Hint);
      end else begin
          SysMsg('澗꾜죗깊櫓豚冀澗꾜돨離댕膠틔鑒좆槨8몸。',c_Green,t_Hint);
      end;
     end else begin
      SysMsg(itemname + '綠瞳澗꾜죗깊뎠櫓닸瞳。',c_RedWhite,t_Hint);
     end;
   end;
 end;
 FreeAndNil(Cartlist);
end;

procedure TPlayObject.DEllMyShopCartstr(idx:Integer;itemstr:string);   //환상점  관심
var
//DBM: TADOCommand;
Cartlist:TList;
I,inde: Integer;
pCart:pTShopCart;
rname:string;
begin
 if (idx = 1) then begin
  FrmDB.DellMyShopCart(Self.m_sCharName);
  SendDefMessage(SM_MYSHOPCART, 5, 0, 0, 0, '');
  exit;
 end;
 if (idx = 2) then begin
   inde := -1;
   rname:= DecodeString(itemstr);
   Cartlist :=TList.create;
   Cartlist := FrmDB.LoadShopcartItemList(Self.m_sCharName);
   for I :=0 to Cartlist.Count - 1 do begin
     pCart := Cartlist.Items[i];
     if pCart.Itemname = rname then begin
       inde := pCart.Itemidx;
       break;
     end;
   end;
   if inde >= 0 then begin
     FrmDB.DellMyShopCartItem(inde);
     SendDefMessage(SM_MYSHOPCART, 5, 0, 0, 0, '');
   end;
   FreeAndNil(Cartlist);
 end;
end;

procedure TPlayObject.Giftstlisopen(PlayObject: TPlayObject);  //환상점 선물
var
  I: Integer;
  Giftslist:TList;
  dItem1:pTseveGiveItem;
  GiftCn:TItem;
  ClientItem:TClientItem;
  GifttItem:TGiveItem;
  sSendMsg:string;
begin
  sSendMsg:='';
  Giftslist:=TList.create;
  Giftslist := FrmDB.LoadGiftsItemList(PlayObject.m_sCharName);
  if Giftslist.Count < 0 then exit;
    for I :=0 to Giftslist.Count - 1 do begin
     dItem1 := Giftslist.Items[i];
     if dItem1 <> nil then begin
       GiftCn := UserEngine.GetStdItem(dItem1.Itemname);
       if GiftCn <> nil then begin
         GiftCn.GetStandardItem(ClientItem.S);
         ClientItem.Dura:=GiftCn.DuraMax;
         ClientItem.DuraMax:=GiftCn.DuraMax;
         if GiftCn.StdMode in [0,1,3,45,46] then begin    //물약
           if GiftCn.StdMode = 45 then
            ClientItem.Amount := _MIN(dItem1.Itemamon,1000)
            else ClientItem.Amount := _MIN(dItem1.Itemamon,400);
         end else begin
            ClientItem.Amount := 1;
         end;
         GifttItem.Item := ClientItem;
         GifttItem.annid := dItem1.annid;
         GifttItem.mename := dItem1.mename;
         GifttItem.Itemname := dItem1.Itemname;
         GifttItem.toname := dItem1.toname;
         GifttItem.Itemop := dItem1.Itemop;
         sSendMsg:=sSendMsg + EncodeBuffer(@GifttItem,SizeOf(TGiveItem)) + '/';
       end;
     end;
    end;

  if sSendMsg <> '' then begin
   PlayObject.m_DefMsg:=MakeDefaultMsg(SM_GIFTSITEMS,i,0,0,0);
   PlayObject.SendSocket(@m_DefMsg,sSendMsg);
  end;
  if Giftslist <> nil then  FreeAndNil(Giftslist);
end;


procedure TPlayObject.ClienFishName(FishName: String);     //낚시
var
 UserItem : pTUserItem;
 boot:Boolean;
 BaseObject :TBaseObject;
begin
   if FishName <> '' then begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(FishName, UserItem) then begin
      if AddItemToBag(UserItem,boot) then begin
       SysMsg(format('콱딥돕죄%s。',[FishName]),c_GreenWhite,t_Hint);
       m_btFishType := 0;
       SendDefMessage(SM_FISHINC,0,0,0,0,'');
       if boot then
       SendAddItem(UserItem,1);

       if (FishName = '낀淪迲頻돨芎綾') or (FishName = '驗竪커遍') or (FishName = '驗竪켑渥') then begin
          BaseObject := UserEngine.RegenMonsterByName (m_sMapName, m_nCurrX + 1 , m_nCurrY + 1, '뎅彊魁밴');
       end;
     end;
     if g_FunctionNPC <> nil then begin
        g_FunctionNPC.GotoLable(Self,'@Fishing',False);
     end;
     if g_FunctionNPC <> nil then begin
        g_FunctionNPC.GotoLable(Self,'@Fishingitem('+FishName+')',False);
     end;

     end else
     DisPose(UserItem);
     Exit;
   end;
end;

procedure  TPlayObject.ClienIncFishIdx; //낚시 확률 아이템
var
 StdItem:TItem;
begin
  if m_UseItems[U_FISH4].wIndex > 0 then begin   //어군 추가 성공률
    StdItem:=UserEngine.GetStdItem(m_UseItems[U_FISH4].wIndex);
    Inc(m_btFishType, StdItem.AC + Random(StdItem.AC2 - StdItem.AC));
  end;
end;

function  TPlayObject.ClienFishItemIdx:Integer; //낚시 확률 아이템
 function CheckBrigt:integer;    //밤 낮 시간 확인
 begin
   Result:= 0;
    case g_nGameTime of            //아침 저녘 새벽
         0: Result := 15;  //새벽
         1: Result := 9;  //낮
         2: Result := 11;  //저녁
         3: Result := 13;  //밤
    end;
 end;
var
 StdItem:TItem;
begin
  Result := 0;

  Result := Result + CheckBrigt;
  if m_UseItems[U_WEAPON].wIndex > 0 then begin     //낚시대 성공률
    StdItem:=UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
    Result := Result + (StdItem.Accurate * 2);
  end;

  if m_UseItems[U_FISH3].wIndex > 0 then begin   //미끼 성공률
    StdItem:=UserEngine.GetStdItem(m_UseItems[U_FISH3].wIndex);
    Result := Result + StdItem.AC2;
  end;

  if m_UseItems[U_FISH5].wIndex > 0 then begin   //릴 성공률
    StdItem:=UserEngine.GetStdItem(m_UseItems[U_FISH5].wIndex);
    Result := Result + StdItem.AC2;
  end;

  Result := Result + m_btFishType;

  if Result > 100 then   //성공률은 100% 이하로 제한
   Result := 100;
end;

function  TPlayObject.ClienFishItemCheck: Boolean;    //낚시 미끼?
begin
  Result := False;
  if m_UseItems[U_FISH1].wIndex > 0 then
  Result := True;
end;

procedure TPlayObject.ClienFishItemDuraChange;    //낚시 미끼
var
 I:integer;
begin
 if m_UseItems[U_FISH1].wIndex > 0 then begin
   if m_UseItems[U_WEAPON].wIndex > 0 then begin  //낚시대 내구 달기 한번 할때마다 (4000 - 1)
     Dec(m_UseItems[U_WEAPON].Dura,1);
     SendMsg(Self,RM_DURACHANGE,U_WEAPON,m_UseItems[U_WEAPON].Dura,m_UseItems[U_WEAPON].DuraMax,0,'');
   end;

   for I:= U_FISH1 to U_FISH5 do begin
    if m_UseItems[I].wIndex > 0 then begin
       if m_UseItems[I].Dura > 1 then begin
        if I = U_FISH3 then begin
         Dec(m_UseItems[I].Dura,2);
        end else
         Dec(m_UseItems[I].Dura,1);
         SendMsg(Self,RM_DURACHANGE,I,m_UseItems[I].Dura,m_UseItems[I].DuraMax,0,'');
       end else begin
        m_UseItems[I].Dura:=0;
        SendDelItems(@m_UseItems[I]);
        m_UseItems[I].wIndex:=0;
       end;
     end;
   end;
 end;
end;

procedure TPlayObject.ClientUponfish2;        //낚시
var
  nItmeRand ,I ,idx , nItemAdd: Integer;
  LoadList: TStringList;
  FishItem: PTfishing;
begin
  if (g_FishItmeList.Count > 0) then begin
    nItmeRand := 100 - ClienFishItemIdx;  //낚시 아이템 성공률 받아옴..
    LoadList := TStringList.Create;

    for I := 0 to g_FishItmeList.Count - 1 do begin
      FishItem:=g_FishItmeList.Items[I];

      idx := FishItem.Probability;   //문서의 낚시 성공률
      if idx > 100 then      //확률이 100 이상이면 100으로 고정
        idx := 100;

      if idx >= Random(nItmeRand) then  //문서 확률이 나의낚시 아이템 확률보다 크거나 같음 ok
        LoadList.Add(FishItem.FishName);
    end;

    if (LoadList.Count > 0) then begin
      if (g_Config.nFishSuccess + Random(70)) >= nItmeRand then begin
        Randomize;
        nItemAdd:=Random(LoadList.Count-1);
        ClienFishName(Trim(LoadList.Strings[nItemAdd]));
      end else begin
        SysMsg('콱청唐딥돕훨부땜鮫。' ,c_GreenWhite,t_Hint);
        ClienIncFishIdx;
        SendDefMessage(SM_FISHINC,0,1,0,0,'');
      end;
    end;

   FreeAndNil(LoadList);
  end;
end;

procedure TPlayObject.ClientUponfish;        //낚시
var
  nItmeRand ,I ,idx , nItemAdd: Integer;
  LoadList: TStringList;
  FishItem: PTfishing;
begin
  if (g_FishItmeList.Count > 0) then begin
    nItmeRand := 100 - ClienFishItemIdx;  //낚시 아이템 성공률 받아옴..
    LoadList := TStringList.Create;

    for I := 0 to g_FishItmeList.Count - 1 do begin
      FishItem:=g_FishItmeList.Items[I];

      idx := FishItem.Probability;   //문서의 낚시 성공률
      if idx > 100 then      //확률이 100 이상이면 100으로 고정
        idx := 100;

      if idx >= Random(nItmeRand) then  //문서 확률이 나의낚시 아이템 확률보다 크거나 같음 ok
        LoadList.Add(FishItem.FishName);
    end;

    if (LoadList.Count > 0) then begin
      if (g_Config.nFishSuccess + Random(90)) >= nItmeRand then begin
        Randomize;
        nItemAdd:=Random(LoadList.Count-1);
        ClienFishName(Trim(LoadList.Strings[nItemAdd]));
      end else begin
        SysMsg('콱청唐딥돕훨부땜鮫。' ,c_GreenWhite,t_Hint);
        ClienIncFishIdx;
        SendDefMessage(SM_FISHINC,0,1,0,0,'');
      end;
    end;

   FreeAndNil(LoadList);
  end;
end;



procedure TPlayObject.ClientUponfish4;        //낚시
var
  nItmeRand ,I ,idx , nItemAdd: Integer;
  LoadList: TStringList;
  FishItem: PTfishing;
begin
  if (g_FishEventItmeList.Count > 0) then begin
    nItmeRand := 100 - ClienFishItemIdx;  //낚시 아이템 성공률 받아옴..
    LoadList := TStringList.Create;

    for I := 0 to g_FishEventItmeList.Count - 1 do begin
      FishItem:=g_FishEventItmeList.Items[I];

      idx := FishItem.Probability;   //문서의 낚시 성공률
      if idx > 100 then      //확률이 100 이상이면 100으로 고정
        idx := 100;

      if idx >= Random(nItmeRand) then  //문서 확률이 나의낚시 아이템 확률보다 크거나 같음 ok
        LoadList.Add(FishItem.FishName);
    end;

    if (LoadList.Count > 0) then begin
      if (g_Config.nFishSuccess + Random(70)) >= nItmeRand then begin
        Randomize;
        nItemAdd:=Random(LoadList.Count-1);
        ClienFishName(Trim(LoadList.Strings[nItemAdd]));
      end else begin
        SysMsg('콱청唐딥돕훨부땜鮫。' ,c_GreenWhite,t_Hint);
        ClienIncFishIdx;
        SendDefMessage(SM_FISHINC,0,1,0,0,'');
      end;
    end;

   FreeAndNil(LoadList);
  end;
end;

procedure TPlayObject.ClientUponfish3;        //낚시
var
  nItmeRand ,I ,idx , nItemAdd: Integer;
  LoadList: TStringList;
  FishItem: PTfishing;
begin
  if (g_FishEventItmeList.Count > 0) then begin
    nItmeRand := 100 - ClienFishItemIdx;  //낚시 아이템 성공률 받아옴..
    LoadList := TStringList.Create;

    for I := 0 to g_FishEventItmeList.Count - 1 do begin
      FishItem:=g_FishEventItmeList.Items[I];

      idx := FishItem.Probability;   //문서의 낚시 성공률
      if idx > 100 then      //확률이 100 이상이면 100으로 고정
        idx := 100;

      if idx >= Random(nItmeRand) then  //문서 확률이 나의낚시 아이템 확률보다 크거나 같음 ok
        LoadList.Add(FishItem.FishName);
    end;

    if (LoadList.Count > 0) then begin
      if (g_Config.nFishSuccess + Random(90)) >= nItmeRand then begin
        Randomize;
        nItemAdd:=Random(LoadList.Count-1);
        ClienFishName(Trim(LoadList.Strings[nItemAdd]));
      end else begin
        SysMsg('콱청唐딥돕훨부땜鮫。' ,c_GreenWhite,t_Hint);
        ClienIncFishIdx;
        SendDefMessage(SM_FISHINC,0,1,0,0,'');
      end;
    end;

   FreeAndNil(LoadList);
  end;
end;



procedure TPlayObject.ClientGuildMark(MarkImg: Integer);        //문파 마크
var
  Guild:TGuild;
  PlayObject:TPlayObject;
  i,II:integer;
  GuildRank:pTGuildRank;
begin
 if m_nGold >= g_Config.nGuildMarkPrice then begin
  Guild:=TGuild(m_MyGuild);
  Guild.nGuildMark := MarkImg;
  TGuild(m_MyGuild).SaveGuildInfoFile();
  TGuild(m_MyGuild).LoadGuildConfig(TGuild(m_myGuild).sGuildName + '.ini');
  DecGold(g_Config.nGuildMarkPrice);
  GoldChanged();

  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    for II:=0 to GuildRank.MemberList.Count -1 do begin
      PlayObject:=TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject <> nil then begin
        PlayObject.SendRefMsg(RM_USERMARK, 0, PlayObject.GetObjectMark, PlayObject.m_btColumn, PlayObject.m_btJob, '');  //문파 마크
        SendChangeGuildName;
      end;
    end;
  end;
  if MarkImg > 0 then begin
   SysMsg('契삔츰俚綠쒔錦맣。',c_BlueWhite,t_Hint);
  end else
   SysMsg('契삔츰俚綠쒔쓱爻',c_RedWhite,t_Hint);
 end else begin
   SysMsg('쏜귑꼇璃。 (냥굶: ' + inttoStr(g_Config.nGuildMarkPrice) + '쏜귑。)',c_RedWhite,t_Hint);
 end;
end;

procedure TPlayObject.ClientGuildGrowUp(GrowUP,Point: Integer);        //문파성장
var
  GuildRank:pTGuildRank;
  I,II:Integer;
  PlayObject:TPlayObject;
begin
  case GrowUP of
   1: begin
     if TGuild(m_MyGuild).nGrowHP < 5 then begin
       TGuild(m_MyGuild).nGrowHP := TGuild(m_MyGuild).nGrowHP + Point;
       TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
       TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(餉)瓊卉開뻗層횝땀');
     end;
   end;
   2: begin
     if TGuild(m_MyGuild).nGrowMP < 5 then begin
       TGuild(m_MyGuild).nGrowMP := TGuild(m_MyGuild).nGrowMP + Point;
       TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
       TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(침제)瓊卉開뻗層횝땀');
     end;
   end;
   3: begin
     if TGuild(m_MyGuild).nGuildLevel >= 10 then begin
       if TGuild(m_MyGuild).nGrowEXP < 5 then begin
         TGuild(m_MyGuild).nGrowEXP := TGuild(m_MyGuild).nGrowEXP + Point;
         TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
         TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(일족)瓊卉開뻗層횝땀');
       end;
      end else begin
        SysMsg('契삔된섬꼇璃。',c_Red,t_Hint);
        exit;
      end;
   end;
   4: begin
     if TGuild(m_MyGuild).nGuildLevel >= 5 then begin
       if TGuild(m_MyGuild).nGrowAC < 5 then begin
         TGuild(m_MyGuild).nGrowAC := TGuild(m_MyGuild).nGrowAC + Point;
         TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
         TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(훠켐)瓊卉開뻗層횝땀');
       end;
      end else begin
        SysMsg('契삔된섬꼇璃。',c_Red,t_Hint);
        exit;
      end;
   end;
   5: begin
     if TGuild(m_MyGuild).nGuildLevel >= 5 then begin
       if TGuild(m_MyGuild).nGrowMAC < 5 then begin
         TGuild(m_MyGuild).nGrowMAC := TGuild(m_MyGuild).nGrowMAC + Point;
         TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
         TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(聞拳)瓊卉開뻗層횝땀');
       end;
     end else begin
        SysMsg('契삔된섬꼇璃。',c_Red,t_Hint);
        exit;
     end;
   end;
   6: begin
     if TGuild(m_MyGuild).nGuildLevel >= 10 then begin
       if TGuild(m_MyGuild).nGrowPower < 5 then begin
         TGuild(m_MyGuild).nGrowPower := TGuild(m_MyGuild).nGrowPower + Point;
         TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
         TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(澹촐)瓊卉開뻗層횝땀');
       end;
     end else begin
       SysMsg('契삔된섬꼇璃。',c_Red,t_Hint);
       exit;
     end;
   end;
   7: begin
     if TGuild(m_MyGuild).nGuildLevel >= 15 then begin
       if TGuild(m_MyGuild).nGrowLuck < 5 then begin
         TGuild(m_MyGuild).nGrowLuck := TGuild(m_MyGuild).nGrowLuck + Point;
         TGuild(m_MyGuild).nGuildPoint := TGuild(m_MyGuild).nGuildPoint - Point;
         TGuild(m_MyGuild).SendGuildMsg2('(*)契삔세콘(妗頓)瓊卉開뻗層횝땀');
       end;
     end else begin
       SysMsg('契삔된섬꼇璃。',c_Red,t_Hint);
       exit;
     end;
   end;
  end;
  TGuild(m_MyGuild).SaveGuildInfoFile();
  TGuild(m_MyGuild).LoadGuildConfig(TGuild(m_myGuild).sGuildName + '.ini');

  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do begin
    GuildRank:=TGuild(m_MyGuild).m_RankList.Items[I];
    for II:=0 to GuildRank.MemberList.Count -1 do begin
      PlayObject:=TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject = nil then Continue;
        PlayObject.ClientQueryGuildGrow2(Self);
        PlayObject.RecalcGuildLevelAbilitys(GrowUP);
    end;
  end;
end;

procedure TPlayObject.ClientRequestGTList(ProcessMsg: pTProcessMessage);
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientRequestGTList(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientRequestGTList wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientRequestDecoList(ProcessMsg: pTProcessMessage);
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientRequestDecoList(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientRequestDecoList wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientRequestBBSList(ProcessMsg: pTProcessMessage);       //장원게시판
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientRequestBBSMsgList(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientRequestBBSMsgList wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientBuyGT(ProcessMsg: pTProcessMessage);
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientBuyGT(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientBuyGT wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientBuyDecoItem(ProcessMsg: pTProcessMessage);
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientBuyDecoItem(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientBuyDecoItem wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientRequestBBSMsg(ProcessMsg: pTProcessMessage);      //장원게시판
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientRequestBBSMsg(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientRequestBBSMsg wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientPostBBSMsg(ProcessMsg: pTProcessMessage;Body:String);     //장원게시판
var
  Merchant:TMerchant;
  boSticky:boolean;
  msg,str:string;
  count:integer;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    if Body = '' then exit;
    Body := DecodeString(Body);
    if Length(Body) > 255 then begin
      SendMsg(Self,RM_MENU_OK,0,Integer(Self),0,0,'俚륜눔낚법離댕낀똑(255)。');
      exit;
    end;
    msg := body;
    count := 0;
    while (msg <> '' ) and (count < 9) do begin
      msg:=GetValidStr3 (msg, str,[#13]);
      inc(count);
    end;
    if count > 8 then begin
      SendMsg(Self,RM_MENU_OK,0,Integer(Self),0,0,'俚륜눔돨낀똑낚법8몸俚륜。');
      exit;
    end;
    Body:=StringReplace(Body,#039,'a',[rfReplaceAll]);
    boSticky:=False;
    if ProcessMsg.nParam2 = 1 then
      boSticky:=True;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientPostBBSMsg(self,Body,boSticky, makeWord(ProcessMsg.nParam3,ProcessMsg.wParam));

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientPostBBSMsg wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;

procedure TPlayObject.ClientDeleteBBSMsg(ProcessMsg: pTProcessMessage);        //장원게시판
var
  Merchant:TMerchant;
begin
  try
    if m_boDealing or m_boRentaling then exit;
    Merchant:=UserEngine.FindMerchant(TObject(ProcessMsg.nParam1));
    if (Merchant = nil) or
     (Merchant.m_PEnvir <> m_PEnvir) or
     (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
     (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then exit;
      Merchant.ClientDeleteBBSMsg(self,ProcessMsg.nParam2);

  except
  on e: Exception do begin
    MainOutMessage('TUserHumah.ClientRequestBBSMsg wIdent = ' + IntToStr(ProcessMsg.wIdent));
    MainOutMessage(E.Message);
  end;
  end;
end;


procedure TPlayObject.ClientShopCardItem();   //환상점
var
  I,II: Integer;
  Cartlist:TList;
  pCart:pTShopCart;
  ShopItem1:pTSeveShopItem;
  Msg:string;
  ShopItem2:TSeveShopItem;
begin
  Cartlist:=TList.create;
  Cartlist := FrmDB.LoadShopcartItemList(Self.m_sCharName);
  if Cartlist.Count <= 0 then exit;
   for I :=0 to Cartlist.Count - 1 do begin
    pCart := Cartlist.Items[i];
    for ii:=0 to g_ServerShopList.Count -1  do begin
      if g_ServerShopList[ii] = nil then continue;
      ShopItem1:= g_ServerShopList.Items[ii];
      if (ShopItem1 <> nil) and (pCart.Itemname = ShopItem1.ShopItems.S.name) then begin
         ShopItem2.ShopItems := ShopItem1.ShopItems;
         ShopItem2.ShopItemPrice := ShopItem1.ShopItemPrice;
         ShopItem2.shopItemAmount := ShopItem1.shopItemAmount;
         ShopItem2.shopItemjob := ShopItem1.shopItemjob;
         ShopItem2.shopItemnew := ShopItem1.shopItemnew;
         Msg:=Msg + EncodeBuffer(@ShopItem2,SizeOf(TSeveShopItem)) + '/';
      end;
    end; //for ii
  end; //for i
  if Msg <> '' then begin
   m_DefMsg:=MakeDefaultMsg(SM_SHOPITEMLIST2,0,0,0,0);
   SendSocket(@m_DefMsg,Msg);
  end;
  FreeAndNil(Cartlist);
end;


procedure TPlayObject.ClientShopBuyItem(ItemName:string);    //환상점   관심
var
   ShopItem1:PTSeveShopItem;
   ShopItem:tItem;
   UserItem: pTUserItem;
   I,amoin:integer;
   nDateNow: DWord;
   nDateNow2: integer;
   boot:Boolean;
begin

 if m_ItemList.Count < MAXBAGITEM then begin
  EnterCriticalSection(ProcessHumanCriticalSection);
  ItemName:=DecodeString(ItemName);
  for i:=0 to g_ServerShopList.Count -1  do begin
   if g_ServerShopList[i] = nil then continue;
   ShopItem1:= g_ServerShopList.Items[i];
    if (ShopItem1 <> nil) and (ShopItem1.ShopItemName = ItemName) then begin
     if m_nGameGold >= ShopItem1.ShopItemPrice then begin
      new(UserItem);
      amoin := ShopItem1.ShopItems.Amount;
      if UserEngine.CopyToUserItemFromName(ItemName, UserItem, amoin) then begin
        ShopItem:=UserEngine.GetStdItem(UserItem.wIndex);
        if (ShopItem.StdMode in [5,6,7,90,99,12,10,11,15,19,20,21,22,23,24,26,62,64,101,102]) and (ShopItem.DDay > 0) then begin  //반짝
          UserItem.MaxDate:=DateTimeToUnix(IncDay(now(),(ShopItem.DDay)));
          UserItem.btValue[19] := 2;
        end;

        if (ShopItem.StdMode = 2) and (ShopItem.Shape in [18]) then begin  //변신탈
          UserItem.MaxDate:=DateTimeToUnix(IncHour(now(),(ShopItem.DuraMax)));
          UserItem.btValue[19] := 2;
        end;
        if (ShopItem.StdMode = 2) and (ShopItem.Shape in [20,21,23,27]) then begin  //호위병  호위좌사
          UserItem.MaxDate:=DateTimeToUnix(IncDay(now(),(ShopItem.DuraMax)));
          UserItem.btValue[19] := 2;
        end;

        dec(m_nGameGold, shopItem1.ShopItemPrice );
        AddItemToBag(UserItem,boot);
        if boot then
        SendAddItem(UserItem,1);
        SendGoldInfo(True);
        SysMsg('콱뭔찜죄膠틔' + ItemName + '。', c_Green, t_Hint);
        break;
      end else begin
        DisPose(UserItem);
      end;
     end else begin
      SendDefMessage(SM_MYSHOPCART, 0, 0, 0, 0, '듐환꼇璃。');
      break;
     end;
   end;
  end;
   LeaveCriticalSection(ProcessHumanCriticalSection);
 end else begin
   SendDefMessage(SM_MYSHOPCART, 0, 0, 0, 0, '콱돨교관찮죄。');
 end;
end;



{---- Adjust global SVN revision ----}
initialization
  //SVNRevision('$Id: ObjBase.pas 596 2007-04-11 00:14:13Z sean $');
end.

