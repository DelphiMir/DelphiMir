unit FState;

interface

uses
  {svn,} Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs, impimepatch,
  DWinCtl, StdCtrls, DXDraws, Grids, Grobal2, EdCode, clFunc, hUtil32, cliUtil,
  MapUnit, SoundUtil, Actor, nixtime, DateUtils, StrUtils, Wil, MShare, IniFiles, Relationship;

const
   BOTTOMBOARD800 = 1;
   BOTTOMBOARD1024 = 270;

   BOTTOMBOARDHERO800 = 2;
   BOTTOMBOARDHERO1024 = 271;

   VIEWCHATLINE = 4;

   MAXHELPPAGE = 31;
   LISTLINEHEIGHT = 13;
   NEWLISTLINEHEIGHT = 35;
   GROWLINEHEIGHT = 38;   //¹®ÆÄ¼ºÀå
   MAXMENU = 10;
   NEWMAXMENU = 5;
   SHOPMAXMENU = 4;
   SHOPLISTLINEWIDTH = 93;
   HUMWEAPINDEX = 2224;
   // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå
   UPITEMSUCCESSOFFSET = 633;//º¸¿Á
   ITEMSHINEOFFSET = 1130;

   // Ä£±¸ ,ÂÊÁö
   VIEW_MAILSEND     = 1;
   VIEW_MAILREAD     = 2;
   VIEW_MEMO         = 3;

   AdjustAbilHints : array[0..8] of string = (
      '¹¥»÷Á¦',
      'Ä§·¨',
      'µÀÊõ',
      '·ÀÓùÁ¦',
      'Ä§·¨·ÀÓùÁ¦',
      'ÉúÃüÖµ',
      'Ä§·¨Öµ',
      '×¼È·',
      'Ãô½Ý'
   );

type
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmComStorage, dmGuildStorage, dmLock, dmWakeCancel, dmReStore);

  TClickPoint = record
     rc: TRect;
     RStr: string;
  end;
  pTClickPoint = ^TClickPoint;
  TDiceInfo = record
    nDicePoint :Integer;      //0x66C
    nPlayPoint :Integer;      //0x670
    nX         :Integer;      //0x674
    nY         :Integer;      //0x678
    n67C       :Integer;      //0x67C
    n680       :Integer;      //0x680
    dwPlayTick :LongWord;     //0x684
  end;
  pTDiceInfo = ^TDiceInfo;
  TFrmDlg = class(TForm)
    DStateWin: TDWindow;
    DBackground: TDWindow;
    DItemBag: TDWindow;
    DBottom: TDWindow;
    DMyState: TDButton;
    DMyBag: TDButton;
    DMyMagic: TDButton;
    DOption: TDButton;
    DGold: TDButton;
    DChar: TDButton;
    DCloseBag: TDButton;
    DCloseState: TDButton;
    DLogIn: TDWindow;
    DLoginNew: TDButton;
    DLoginOk: TDButton;
    DNewAccount: TDWindow;
    DNewAccountOk: TDButton;
    DLoginClose: TDButton;
    DSelectChr: TDWindow;
    DscSelect1: TDButton;
    DscSelect2: TDButton;
    DscStart: TDButton;
    DscNewChr: TDButton;
    DscEraseChr: TDButton;
    DscCredits: TDButton;
    DscExit: TDButton;
    DCreateChr: TDWindow;
    DccWarrior: TDButton;
    DccWizzard: TDButton;
    DccMonk: TDButton;
    DccAssassin: TDButton;
    DccMale: TDButton;
    DccFemale: TDButton;
    DccOk: TDButton;
    DccClose: TDButton;
    DItemGrid: TDGrid;
    DLoginChgPw: TDButton;
    DMsgDlg: TDWindow;
    DMsgDlgOk: TDButton;
    DMsgDlgYes: TDButton;
    DMsgDlgCancel: TDButton;
    DMsgDlgNo: TDButton;
    DStatus: TDButton;
    DSWNecklace: TDButton;
    DSWLight: TDButton;
    DSWArmRingR: TDButton;
    DSWArmRingL: TDButton;
    DSWRingR: TDButton;
    DSWRingL: TDButton;
    DSWWeapon: TDButton;
    DSWDress: TDButton;
    DSWHelmet: TDButton;
    DSWBujuk: TDButton;
    DSWBelt: TDButton;
    DSWBoots: TDButton;
    DSWCharm: TDButton;
    DChgPw: TDWindow;
    DChgpwOk: TDButton;
    DChgpwCancel: TDButton;
    DMerchantDlg: TDWindow;
    DMerchantDlgClose: TDButton;
    DSellDlg: TDWindow;
    DSellDlgOk: TDButton;
    DSellDlgClose: TDButton;
    DSellDlgSpot: TDButton;
    DStMag1: TDButton;
    DStMag2: TDButton;
    DStMag3: TDButton;
    DStMag4: TDButton;
    DStMag5: TDButton;
    DKeySelDlg: TDWindow;
    DKsIcon: TDButton;
    DKsF1: TDButton;
    DKsF2: TDButton;
    DKsF3: TDButton;
    DKsF4: TDButton;
    DKsNone: TDButton;
    DKsOk: TDButton;
    DBotGroup: TDButton;
    DBotTrade: TDButton;
    DBotMiniMap: TDButton;
    DBotFriend: TDButton;
    DGroupDlg: TDWindow;
    DGrpDlgClose: TDButton;
    DGrpDelegate: TDButton;
    DGrpAddMem: TDButton;
    DGrpDelMem: TDButton;
    DBotLogout: TDButton;
    DBotExit: TDButton;
    DBotGuild: TDButton;
    DStPageUp: TDButton;
    DStPageDown: TDButton;
    DDealRemoteDlg: TDWindow;
    DDealDlg: TDWindow;
    DDRGrid: TDGrid;
    DDGrid: TDGrid;
    DDealOk: TDButton;
    DDealClose: TDButton;
    DDGold: TDButton;
    DDRGold: TDButton;
    DSelServerDlg: TDWindow;
    DSSrvClose: TDButton;
    DSServer1: TDButton;
    DSServer2: TDButton;
    DSServer3: TDButton;
    DSServer4: TDButton;
    DSServer5: TDButton;
    DSServer6: TDButton;
    DSServer7: TDButton;
    DSServer8: TDButton;
    DUserState1: TDWindow;
    DCloseUS1: TDButton;
    DWeaponUS1: TDButton;
    DHelmetUS1: TDButton;
    DNecklaceUS1: TDButton;
    DDressUS1: TDButton;
    DLightUS1: TDButton;
    DArmringRUS1: TDButton;
    DRingRUS1: TDButton;
    DArmringLUS1: TDButton;
    DRingLUS1: TDButton;
    DBujukUS1: TDButton;
    DBeltUS1: TDButton;
    DBootsUS1: TDButton;
    DCharmUS1: TDButton;
    DGuildDlg: TDWindow;
    DGDHome: TDButton;
    DGDList: TDButton;
    DGDChat: TDButton;
    DGDAddMem: TDButton;
    DGDDelMem: TDButton;
    DGDEditNotice: TDButton;
    DGDEditGrade: TDButton;
    DGDAlly: TDButton;
    DGDBreakAlly: TDButton;
    DGDWar: TDButton;
    DGDCancelWar: TDButton;
    DGDUp: TDButton;
    DGDDown: TDButton;
    DGDClose: TDButton;
    DGuildEditNotice: TDWindow;
    DGEClose: TDButton;
    DGEOk: TDButton;
    DNewAccountCancel: TDButton;
    DAdjustAbility: TDWindow;
    DPlusDC: TDButton;
    DPlusMC: TDButton;
    DPlusSC: TDButton;
    DPlusAC: TDButton;
    DPlusMAC: TDButton;
    DPlusHP: TDButton;
    DPlusMP: TDButton;
    DPlusHit: TDButton;
    DPlusSpeed: TDButton;
    DMinusDC: TDButton;
    DMinusMC: TDButton;
    DMinusSC: TDButton;
    DMinusAC: TDButton;
    DMinusMAC: TDButton;
    DMinusMP: TDButton;
    DMinusHP: TDButton;
    DMinusHit: TDButton;
    DMinusSpeed: TDButton;
    DAdjustAbilClose: TDButton;
    DAdjustAbilOk: TDButton;
    DKsF5: TDButton;
    DKsF6: TDButton;
    DKsF7: TDButton;
    DKsF8: TDButton;
    DEngServer1: TDButton;
    DKsConF1: TDButton;
    DKsConF2: TDButton;
    DKsConF3: TDButton;
    DKsConF4: TDButton;
    DKsConF5: TDButton;
    DKsConF6: TDButton;
    DKsConF7: TDButton;
    DKsConF8: TDButton;
    DBotMemo: TDButton;
    DBLDel: TDButton;
    DBLAdd: TDButton;
    DMemoB2: TDButton;
    DMemoB1: TDButton;
    DMailListDlg: TDWindow;
    DBlockListDlg: TDWindow;
    DBLPgUp: TDButton;
    DBLPgDn: TDButton;
    DBlockListClose: TDButton;
    DMemo: TDWindow;
    DMemoClose: TDButton;
    DSales: TDWindow;
    DSalesFind: TDButton;
    DSalesBuy: TDButton;
    DSalesExit: TDButton;
    DSalesPrevPage: TDButton;
    DSalesRefresh: TDButton;
    DSalesNextPage: TDButton;
    DAuctionSpot: TDButton;
    DMLReply: TDButton;
    DMailListPgDn: TDButton;
    DMLRead: TDButton;
    DMailListPgUp: TDButton;
    DMLSend: TDButton;
    DMLDel: TDButton;
    DMLBlock: TDButton;
    DMailListClose: TDButton;
    DBotLover: TDButton;
    DBeltWindow: TDWindow;
    DBelt1: TDButton;
    DBelt2: TDButton;
    DBelt3: TDButton;
    DBelt4: TDButton;
    DBelt5: TDButton;
    DBelt6: TDButton;
    DBeltClose: TDButton;
    DBeltSwap: TDButton;
    DscSelect3: TDButton;
    DLoverWindow: TDWindow;
    DLoverAvailable: TDButton;
    DLoverAsk: TDButton;
    DLoverDivorce: TDButton;
    DLoverExit: TDButton;
    DLoverCaption: TDButton;
    DLoverHeart: TDButton;
    DHeartMyState: TDButton;
    DUSGroup: TDButton;
    DUSFriend: TDButton;
    DUSMail: TDButton;
    DHold: TDButton;
    DGTList: TDWindow;
    DGTListClose: TDButton;
    DGTListPrev: TDButton;
    DGTListNext: TDButton;
    DGTListMail: TDButton;
    DDecoListDlg: TDWindow;
    DDecoListExit: TDButton;
    DDecoListPrev: TDButton;
    DDecoListNext: TDButton;
    DDecoListCancel: TDButton;
    DDecoListBuy: TDButton;
    DBBSListDlg: TDWindow;
    DBBSListClose: TDButton;
    DBBSListPrev: TDButton;
    DBBSListNext: TDButton;
    DBBSListRefresh: TDButton;
    DBBSListOK: TDButton;
    DBBSListWrite: TDButton;
    DBBSListNotice: TDButton;
    DBBSMsgDlg: TDWindow;
    DBBSMsgClose: TDButton;
    DBBSMsgOk: TDButton;
    DBBSMsgMail: TDButton;
    DBBSMsgReply: TDButton;
    DBBSMsgCancel: TDButton;
    DBBSMsgDelete: TDButton;
    DOptions: TDWindow;
    DOptionsClose: TDButton;
    DOptionsSoundOn: TDButton;
    DOptionsEffectOn: TDButton;
    DOptionsEffectOff: TDButton;
    DOptionsSkillBarOn: TDButton;
    DOptionsSkillBarOff: TDButton;
    DOptionsDropViewOn: TDButton;
    DOptionsDropViewOff: TDButton;
    DOptionsSkillMode2: TDButton;
    DOptionsSkillMode1: TDButton;
    DSkillBar: TDWindow;
    DSkillBar1: TDButton;
    DSkillBar2: TDButton;
    DSkillBar3: TDButton;
    DSkillBar4: TDButton;
    DSkillBar5: TDButton;
    DSkillBar6: TDButton;
    DSkillBar7: TDButton;
    DSkillBar8: TDButton;
    DSalesMail: TDButton;
    DHelpWin: TDWindow;
    DHelpClose: TDButton;
    DHelpPrev: TDButton;
    DHelpNext: TDButton;
    DMsgSimpleDlg: TDWindow;
    DMsgSimpleDlgOk: TDButton;
    DMsgSimpleDlgCancel: TDButton;
    DLoginViewKey: TDButton;
    DBotItemShop: TDButton;
    DBotHelp: TDButton;
    DBotRank: TDButton;
    DOptionsNameAllViewOn: TDButton;
    DOptionsNameAllViewOff: TDButton;
    DOptionsHPView2: TDButton;
    DOptionsHPView1: TDButton;
    DItemStore: TDWindow;
    DItemStoreClose: TDButton;
    DStoreGrid: TDGrid;
    DShopMenuDlg: TDWindow;
    DShopMenuClose: TDButton;
    DShopMenuOk: TDButton;
    DShopMenuScrollDown: TDButton;
    DShopMenuScrollUp: TDButton;
    DState: TDButton;
    DSkill: TDButton;
    DBHome: TDButton;
    DBStorage: TDButton;
    DBAuction: TDButton;
    DDealMsgDlg: TDWindow;
    DBotTiger: TDButton;
    DTigerDlg: TDWindow;
    DTigerDlgClose: TDButton;
    DTigerDlgSet: TDButton;
    DSWTiger: TDButton;
    DTigerUS1: TDButton;
    DBotMaster: TDButton;
    DMasterDlg: TDWindow;
    DMasterClose: TDButton;
    DMasterMentor: TDButton;
    DMasterSecession: TDButton;
    DMasterAllow: TDButton;
    DBScreen: TDButton;
    DBReady2: TDButton;
    DBReady3: TDButton;
    DBReady4: TDButton;
    DBotQuest: TDButton;
    DBotReady2: TDButton;
    DUpWapondow: TDWindow;
    DBUpWaponOK: TDButton;
    DBUpWaponexit: TDButton;
    DUpWapItemgrid: TDGrid;
    DBnpcup: TDButton;
    DBnpcex: TDButton;
    DButBagMode1: TDButton;
    DSPETS1: TDButton;
    DSPETS2: TDButton;
    DSPETS3: TDButton;
    DSPETS4: TDButton;
    DSPETS5: TDButton;
    DMacros: TDWindow;
    DMacrosOK: TDButton;
    DMacrosCancel: TDButton;
    DMovenpcbot: TDMoveButton;
    DShopMenuMove: TDMoveButton;
    DWItemSepa: TDWindow;
    ItemSepaOk: TDButton;
    ItemSepaclose: TDButton;
    ItemSepaexit: TDButton;
    Dshoppe1: TDButton;
    Dshoppe2: TDButton;
    Dshoppe3: TDButton;
    Dshoppe4: TDButton;
    Dshoppe5: TDButton;
    DItemShopDlg: TDWindow;
    DCategories1: TDButton;
    DCategories2: TDButton;
    DCategories3: TDButton;
    DCategories4: TDButton;
    DCategories5: TDButton;
    DCategories6: TDButton;
    DCategories7: TDButton;
    DCategories13: TDButton;
    DCategories12: TDButton;
    DCategories11: TDButton;
    DItemShopJobAll: TDButton;
    DItemShopJobWarrior: TDButton;
    DItemShopJobWizard: TDButton;
    DItemShopJobMonk: TDButton;
    DItemShopJobAssas: TDButton;
    DItemShopJobCommon: TDButton;
    Ditemnamert: TDButton;
    DItemShopClose: TDButton;
    buyitemk1: TDButton;
    buyitemk2: TDButton;
    buyitemk3: TDButton;
    buyitemk4: TDButton;
    buyitemk5: TDButton;
    buyitemk6: TDButton;
    buyitemk7: TDButton;
    buyitemk8: TDButton;
    DItemShopListPrev: TDButton;
    DItemShopListNext: TDButton;
    DItemShopGetGift: TDButton;
    DItemShopAddFav: TDButton;
    DItemShopBye: TDButton;
    DItemShopGift: TDButton;
    DItemShopPayMoney: TDButton;
    GiftsDT: TDWindow;
    Giftsdoot1: TDButton;
    Giftsdoot2: TDButton;
    Giftsdoot3: TDButton;
    Giftsdoot4: TDButton;
    Giftsdoot5: TDButton;
    Giftsdoot6: TDButton;
    Giftsdoot7: TDButton;
    Giftsdoot8: TDButton;
    Giftsdoot9: TDButton;
    Giftsdoot10: TDButton;
    Giftsups: TDButton;
    Giftsexs: TDButton;
    GiftsDTEXIT: TDButton;
    DcGameGold: TDButton;
    DRenovates: TDButton;
    DCategories8: TDButton;
    DCategories9: TDButton;
    DCategories10: TDButton;
    DCategories14: TDButton;
    DCategories15: TDButton;
    DCategories16: TDButton;
    DMenuWindows: TDWindow;
    DBotMenu: TDButton;
    DViewMiniMap: TDWindow;
    DBotOption: TDButton;
    DBotBigMap: TDButton;
    DDayBright: TDButton;
    DStMag6: TDButton;
    Dshoppe6: TDButton;
    Dshoppe7: TDButton;
    Dshoppe8: TDButton;
    DUser2: TDButton;
    DUserInfo: TDWindow;
    DUserInfoExit: TDButton;
    DItmeDuraWin: TDWindow;
    DBotDura: TDButton;
    DBReady6: TDButton;
    DBotPlusAbil: TDButton;
    DMake: TDButton;
    DFishDlg: TDWindow;
    DFISH1: TDButton;
    DFISH2: TDButton;
    DFISH3: TDButton;
    DFISH4: TDButton;
    DFISH5: TDButton;
    DFishExit: TDButton;
    DFishProgressDlg: TDWindow;
    DCatch: TDButton;
    DProgressExit: TDButton;
    DCheckEsc: TDButton;
    DAutoFish: TDButton;
    DBotDura2: TDButton;
    DItmeDuraWin2: TDWindow;
    DDiceGame: TDWindow;
    DDiceCurr: TDButton;
    DDiceStart: TDButton;
    DDiceStop: TDButton;
    DDiceNext: TDButton;
    DDiceSelect1: TDButton;
    DDiceSelect2: TDButton;
    DDiceGet: TDButton;
    DDiceClose: TDButton;
    DChangeItem: TDWindow;
    DCloseChange: TDButton;
    DStartChange: TDButton;
    DChangeItem1: TDButton;
    DChangeItem2: TDButton;
    DChangeItem3: TDButton;
    DChangeItem4: TDButton;
    DChangeItem5: TDButton;
    DChangeItem6: TDButton;
    DPrevInfo: TDButton;
    DNextInfo: TDButton;
    DExChangeDlg: TDWindow;
    DExitChange: TDButton;
    DExGoldChange: TDButton;
    DGetExChange: TDButton;
    DExGold: TDButton;
    DExHwan: TDButton;
    DDExGold: TDButton;
    DDExHwan: TDButton;
    DUpWeapon: TDWindow;
    DUpWeaponSpot: TDButton;
    DUpWeapExit: TDButton;
    DStoreGridWin: TDWindow;
    DGStore: TDGrid;
    DStoreOpen: TDButton;
    DStoreCancel: TDButton;
    DStoreWinExit: TDButton;
    DStoreMsgDlg: TDWindow;
    DStoreMsgOk: TDButton;
    DStoreMsgCancel: TDButton;
    DUserStore: TDWindow;
    DUserStoreClose: TDButton;
    DUserStoreBuy: TDButton;
    DGUserStore: TDGrid;
    DStoreGold: TDButton;
    DStoreGGold: TDButton;
    DStoreMsgClosed: TDButton;
    DStoreMacro: TDButton;
    DBotPet: TDButton;
    DComStorage: TDWindow;
    DComStorageExit: TDButton;
    DGetComStorage: TDButton;
    DStorageRefresh: TDButton;
    DCS1: TDButton;
    DCS2: TDButton;
    DCS3: TDButton;
    DCS4: TDButton;
    DCS5: TDButton;
    DCS6: TDButton;
    DCS7: TDButton;
    DCS8: TDButton;
    DGuildStorage: TDWindow;
    DGuildStorageExit: TDButton;
    DGuildStorageRe: TDButton;
    DGetGuildStorage: TDButton;
    DGGuildStorage: TDGrid;
    DRentalDlg: TDWindow;
    DRentalExit: TDButton;
    DRentalList: TDButton;
    DBorrowList: TDButton;
    DReturn: TDButton;
    DWithdraw: TDButton;
    DRental: TDButton;
    DDRentalDlg: TDWindow;
    DRentalAllow: TDButton;
    DRentalDay: TDButton;
    DRentalOk: TDButton;
    DRGrid: TDButton;
    DRentalClose: TDButton;
    DRentalRemoteDlg: TDWindow;
    DRRentalClose: TDButton;
    DRRentalAllow: TDButton;
    DRRGrid: TDButton;
    DRGold: TDButton;
    DRRGold: TDButton;
    DRentalMsgDlg: TDWindow;
    DRRefresh: TDButton;
    DUpCheck: TDWindow;
    DCheckExit: TDButton;
    DCheckSpot: TDButton;
    DCheckOk: TDButton;
    DGuildGrowDlg: TDWindow;
    DGGPage1: TDButton;
    DGGPage2: TDButton;
    DGGrowExit: TDButton;
    DGGrow1: TDButton;
    DGGrow2: TDButton;
    DGGrow3: TDButton;
    DGGrowUp: TDButton;
    DGGrow4: TDButton;
    DGGrow5: TDButton;
    DGGrow6: TDButton;
    DGGrow7: TDButton;
    DGDGrowUp: TDButton;
    DMakeItemDlg: TDWindow;
    DMakeItemDlgClose: TDButton;
    DMakeItemDlgOk: TDButton;
    DMakeItemDlgCancel: TDButton;
    DMakeitemGrid: TDGrid;
    DBHelpGuild: TDButton;
    DLoverMail: TDButton;
    DLoverWhisper: TDButton;
    DWinPet: TDWindow;
    DSommon: TDButton;
    DRelease: TDButton;
    DPetExit: TDButton;
    DBHelpPet: TDButton;
    DPet1: TDButton;
    DPet2: TDButton;
    DPet3: TDButton;
    DPet4: TDButton;
    DPet5: TDButton;
    DPetName: TDButton;
    DPetPickUp: TDButton;
    DPetFood: TDButton;
    DCategories17: TDButton;
    DCategories18: TDButton;
    DCategories19: TDButton;
    DCategories20: TDButton;
    DCategories21: TDButton;
    DPetOption: TDButton;
    DPetOptionDlg: TDWindow;
    DAutoPickUp: TDButton;
    DSavePet: TDButton;
    DCancelPet: TDButton;
    DWeaponItem: TDButton;
    DDressItem: TDButton;
    DHelmatItem: TDButton;
    DBootsItem: TDButton;
    DBeltItem: TDButton;
    DAccessoryItem: TDButton;
    DAllItem: TDButton;
    DGoldItem: TDButton;
    DEtcItem: TDButton;
    DSCostSort: TDButton;
    DSUseSort: TDButton;
    DBotAucFind: TDButton;
    DBotAuction: TDButton;
    DAuc0: TDButton;
    DAuc1: TDButton;
    DAuc2: TDButton;
    DAuc7: TDButton;
    DAuc12: TDButton;
    DAuc18: TDButton;
    DAuc23: TDButton;
    DAuc28: TDButton;
    DAuc29: TDButton;
    DAuc30: TDButton;
    DAuc3: TDButton;
    DAuc4: TDButton;
    DAuc5: TDButton;
    DAuc6: TDButton;
    DAuc8: TDButton;
    DAuc9: TDButton;
    DAuc10: TDButton;
    DAuc11: TDButton;
    DAuc13: TDButton;
    DAuc14: TDButton;
    DAuc15: TDButton;
    DAuc16: TDButton;
    DAuc17: TDButton;
    DAuc19: TDButton;
    DAuc20: TDButton;
    DAuc21: TDButton;
    DAuc22: TDButton;
    DAuc24: TDButton;
    DAuc25: TDButton;
    DAuc26: TDButton;
    DAuc27: TDButton;
    DAuction: TDButton;
    DAuctionCancel: TDButton;
    DAuctionSort: TDButton;
    DMemoB3: TDButton;
    DHelpMail: TDButton;
    DMailRe: TDButton;
    DBotUp: TDButton;
    DExpMode: TDButton;
    DPetEat: TDButton;
    DDisassembleDlg: TDWindow;
    DDisaClose: TDButton;
    DDisassembleSpot: TDButton;
    DDisassembleStart: TDButton;
    DLoverMacro: TDButton;
    DDice1: TDButton;
    DDice2: TDButton;
    DDice3: TDButton;
    DDice4: TDButton;
    DDice5: TDButton;
    DDice6: TDButton;
    DOnAuction: TDWindow;
    DAucItem: TDButton;
    DAuctionClose: TDButton;
    DGetAuction: TDButton;
    DExitAuction: TDButton;
    DAuctionView: TDButton;
    DOffAuction: TDWindow;
    DOffAucItem: TDButton;
    DAucClose: TDButton;
    DOffAuc: TDButton;
    DWndGroup: TDWindow;
    DWndGroupMember: TDWindow;
    DGroupMember1: TDWindow;
    DGroupClose: TDButton;
    DGroupMember2: TDWindow;
    DGroupMember3: TDWindow;
    DGroupMember4: TDWindow;
    DGroupMember7: TDWindow;
    DGroupMember6: TDWindow;
    DGroupMember5: TDWindow;
    DGroupMember8: TDWindow;
    DGroupMember9: TDWindow;
    DGroupMember10: TDWindow;
    DDismantleDlg: TDWindow;
    DDismantleSpot: TDButton;
    DDismantleClose: TDButton;
    DDismantleStart: TDButton;
    DItemWakeUpDlg: TDWindow;
    DItemWakeUp: TDButton;
    DCloseWakeUp: TDButton;
    DWakeUpList: TDWindow;
    DWake1: TDButton;
    DWake2: TDButton;
    DWakePopup: TDButton;
    DWakeUpStart: TDButton;
    DWakeArr1: TDButton;
    DWakeArr2: TDButton;
    DWakeArr3: TDButton;
    DWakeArr4: TDButton;
    DRenewChr: TDWindow;
    DButRenewChr: TDButton;
    DButRenewClose: TDButton;
    DscSelect4: TDButton;
    DBtnSayHear: TDButton;
    DBtnSayAll: TDButton;
    DBtnSayCry: TDButton;
    DBtnSayWhisper: TDButton;
    DBtnSayGroup: TDButton;
    DBtnSayGuild: TDButton;
    DBtnSayLover: TDButton;
    DBtnSayMaster: TDButton;
    DBtnSaySys: TDButton;
    DBotChatTrans: TDButton;
    DTopMsg: TDWindow;
    DccBonze: TDButton;
    DBTCheck1: TDButton;
    DBTCheck2: TDButton;
    DBTCheck3: TDButton;
    DBTCheck4: TDButton;
    DBTCheck5: TDButton;
    DBTCheck6: TDButton;
    DBTCheck7: TDButton;
    DBTCheck8: TDButton;
    DBTCheck9: TDButton;
    DBTCheck10: TDButton;
    DBigMapDlg: TDWindow;
    DMiniMap: TDWindow;
    DOptionsMp3On: TDButton;
    DOptionsFull: TDButton;
    DOptionsWin: TDButton;
    DOptionsHintOn: TDButton;
    DOptionsHintOff: TDButton;
    DSetPassWd: TDWindow;
    DSetPWClose: TDButton;
    DStRePW: TDButton;
    DCheckStPw: TDButton;
    DStScPW: TDButton;
    DStoragePWDlg: TDWindow;
    DStPWClose: TDButton;
    DStPwInput: TDButton;
    DStPwDel: TDButton;
    DStPw0: TDButton;
    DStPw1: TDButton;
    DStPw2: TDButton;
    DStPw3: TDButton;
    DStPw4: TDButton;
    DStPw5: TDButton;
    DStPw6: TDButton;
    DStPw7: TDButton;
    DStPw8: TDButton;
    DStPw9: TDButton;
    DInputStPwd: TDWindow;
    DInputStClose: TDButton;
    DStINPW: TDButton;
    DCheckInPutPw: TDButton;
    DChangeStPw: TDWindow;
    DChRePw: TDButton;
    DChScPw: TDButton;
    DCheckChPw: TDButton;
    DCloseChPw: TDButton;
    DStoragePW: TDButton;
    DOptionsScreen1: TDButton;
    DOptionsScreen2: TDButton;
    DWuxFront: TDButton;
    DWuxNext: TDButton;
    DNameChNP: TDButton;
    DNameMon: TDButton;
    DGroupMember11: TDWindow;
    DGroupMember12: TDWindow;
    DNewSay: TDWindow;
    DSayUpDown: TDUpDown;
    DBTSayMove: TDButton;
    dkSayLock: TDButton;
    DBTFace: TDButton;
    DAuc31: TDButton;
    DItemShopJobBonz: TDButton;
    DAuc32: TDButton;
    DButtonReCallHero: TDButton;
    DButtonMenuHero: TDButton;
    DHeroStateWin: TDWindow;
    DHeroChar: TDButton;
    DHeroStatus: TDButton;
    DHeroState: TDButton;
    DHeroSkill: TDButton;
    DCloseHeroState: TDButton;
    DHeroSWWeapon: TDButton;
    DHeroSWDress: TDButton;
    DHeroItemBag: TDWindow;
    DHeroItemGrid: TDGrid;
    DCloseHeroBag: TDButton;
    DHeroMenu: TDWindow;
    DButtonHeroSkill: TDButton;
    DButtonHeroBag: TDButton;
    DButtonHeroState: TDButton;
    DHeroSWHelmet: TDButton;
    DHeroSWNecklace: TDButton;
    DHeroSWLight: TDButton;
    DHeroSWArmRingL: TDButton;
    DHeroSWArmRingR: TDButton;
    DHeroSWRingL: TDButton;
    DHeroSWRingR: TDButton;
    DHeroSWBujuk: TDButton;
    DHeroSWCharm: TDButton;
    DHeroSWBelt: TDButton;
    DHeroSWBoots: TDButton;
    DBeltHero: TDWindow;
    DBeltHeroSwap: TDButton;
    DBeltHeroClose: TDButton;
    DBelt1Hero: TDButton;
    DBelt2Hero: TDButton;
    DHeroStMag1: TDButton;
    DHeroStMag2: TDButton;
    DHeroStMag3: TDButton;
    DHeroStMag4: TDButton;
    DHeroStMag5: TDButton;
    DHeroStMag6: TDButton;
    DHeroStPageDown: TDButton;
    DHeroStPageUp: TDButton;
    DHeroKeylDlg: TDWindow;
    DKsSNone: TDButton;
    DKsSIcon: TDButton;
    DKsSOk: TDButton;
    DKsSF1: TDButton;
    DKsSF2: TDButton;
    DKsSF3: TDButton;
    DKsSF4: TDButton;
    DKsSF5: TDButton;
    DKsSF6: TDButton;
    DKsSF7: TDButton;
    DHeroSkillBar: TDWindow;
    DHSkillBar1: TDButton;
    DHSkillBar2: TDButton;
    DHSkillBar3: TDButton;
    DHSkillBar4: TDButton;
    DHSkillBar5: TDButton;
    DHSkillBar6: TDButton;
    DHSkillBar7: TDButton;
    DBotAi1: TDButton;
    DBotAi2: TDButton;
    DBotAi3: TDButton;
    DBotAi4: TDButton;
    DHeroControl: TDWindow;
    DHeroHelp: TDButton;
    DHeroCall: TDButton;
    DHeroBack: TDButton;
    DHeroDefen: TDButton;
    DCategories22: TDButton;
    DBHelpWake: TDButton;
    DAutoPot1: TDButton;
    DAutoPot2: TDButton;
    DAuto1: TDButton;
    DAuto2: TDButton;
    DAuto1Per: TDButton;
    DAuto2Per: TDButton;
    DHeroBagUp: TDButton;
    DMakeAdvice: TDButton;
    DGrpAllowGroup: TDCheckBox;
    DGrpCheckGroup: TDCheckBox;
    DCBGroupItemDef: TDCheckBox;
    DCBGroupItemRam: TDCheckBox;
    DGrpMemberList: TDWindow;
    DGrpCheckHero: TDCheckBox;
    DGrpUserList: TDWindow;
    DGdUserUp: TDButton;
    DGdUserDown: TDButton;
    DGpMove: TDMoveButton;
    DHeroStoreGrid: TDGrid;
    DStore1: TDButton;
    DStore2: TDButton;
    DBCompound: TDButton;


    procedure DBottomInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DBottomDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMyStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOptionClick();
    procedure DItemBagDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure FormCreate(Sender: TObject);
    procedure DCharDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLoginNewDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DscSelect1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSalesCancelDirectPaintt(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DItemGridDblClick(Sender: TObject);
    procedure DMsgDlgOkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMsgDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMsgDlgKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DBackgroundBackgroundClick(Sender: TObject);
    procedure DItemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure FormDestroy(Sender: TObject);
    procedure DBelt1DblClick(Sender: TObject);
    procedure SwapBujuk(idx: integer);   //ºÎÀû
    procedure DLoginCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLoginOkClick(Sender: TObject; X, Y: Integer);
    procedure DLoginNewClick(Sender: TObject; X, Y: Integer);
    procedure DLoginChgPwClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountOkClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountCancelClick(Sender: TObject; X, Y: Integer);
    procedure DccCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgpwOkClick(Sender: TObject; X, Y: Integer);
    procedure DscSelect1Click(Sender: TObject; X, Y: Integer);
    procedure DCloseStateClick(Sender: TObject; X, Y: Integer);
    procedure DCharClick(Sender: TObject; X, Y: Integer);
    procedure DStatusClick(Sender: TObject; X, Y: Integer);
    procedure DStateClick(Sender: TObject; X, Y: Integer);
    procedure DSkillClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DCloseBagClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DMyStateClick(Sender: TObject; X, Y: Integer);
    procedure DStateWinClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMerchantDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DSellDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DSellOk();
    procedure DGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSWLightDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBackgroundMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLoginNewClickSound(Sender: TObject;
      Clicksound: TClickSound);
    procedure DStMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DKsIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKsF1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKsOkClick(Sender: TObject; X, Y: Integer);
    procedure DKsF1Click(Sender: TObject; X, Y: Integer);
    procedure DKeySelDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotGroupDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpDelegateClick(Sender: TObject; X, Y: Integer);
    procedure DGroupDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGrpAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGrpDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DBotLogoutClick(Sender: TObject; X, Y: Integer);
    procedure DBotExitClick(Sender: TObject; X, Y: Integer);
    procedure DStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DDealOkClick(Sender: TObject; X, Y: Integer);
    procedure DDealCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotTradeClick(Sender: TObject; X, Y: Integer);
    procedure DDealRemoteDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDealDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DDGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DDRGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSServer1Click(Sender: TObject; X, Y: Integer);
    procedure DSSrvCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotMiniMapClick(Sender: TObject; X, Y: Integer);
    procedure DUserState1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCloseUS1Click(Sender: TObject; X, Y: Integer);
    procedure DNecklaceUS1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotGuildClick(Sender: TObject; X, Y: Integer);
    procedure DGuildDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGDUpClick(Sender: TObject; X, Y: Integer);
    procedure DGDDownClick(Sender: TObject; X, Y: Integer);
    procedure DGDCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGDHomeClick(Sender: TObject; X, Y: Integer);
    procedure DGDListClick(Sender: TObject; X, Y: Integer);
    procedure DGDAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditGradeClick(Sender: TObject; X, Y: Integer);
    procedure DGECloseClick(Sender: TObject; X, Y: Integer);
    procedure DGEOkClick(Sender: TObject; X, Y: Integer);
    procedure DGuildEditNoticeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGDChatClick(Sender: TObject; X, Y: Integer);
    procedure DGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DNewAccountDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilityDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
    procedure DPlusDCClick(Sender: TObject; X, Y: Integer);
    procedure DMinusDCClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
    procedure DBotPlusAbilDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DUserState1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DEngServer1Click(Sender: TObject; X, Y: Integer);
    procedure DGDAllyClick(Sender: TObject; X, Y: Integer);
    procedure DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
    procedure DSelServerDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBotFriendClick(Sender: TObject; X, Y: Integer);


    procedure DMemoB1Click(Sender: TObject; X, Y: Integer);
    procedure DSalesDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSalesCancelDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSalesCloseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSalesPrevPageClick(Sender: TObject; X, Y: Integer);
    procedure DSalesNextPageClick(Sender: TObject; X, Y: Integer);
    procedure DSalesRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DSalesClick(Sender: TObject; X, Y: Integer);
    procedure DSalesBuyClick(Sender: TObject; X, Y: Integer);
    procedure DSalesExitClick(Sender: TObject; X, Y: Integer);
    procedure ClearRentalDlg; //´ë¿©
    procedure ClearRentalDlg2; //´ë¿©
    procedure ClearAuctionDlg;
    procedure ClearDiceDlg; //Ç÷·æ»óÀÚ
    procedure ClearWakeDlg;
    procedure ClearShopDlg;  //È¯»óÁ¡
    procedure ClearComStorageDlg; //°ø¿ëÃ¢°í
    procedure ClearGuildStorageDlg; //¹®ÆÄÃ¢°í
    procedure ClearPetDlg;     //¿µ¹°
    procedure DSalesFindClick(Sender: TObject; X, Y: Integer);
    procedure DBotMemoClick(Sender: TObject; X, Y: Integer);
    procedure DMailListDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMailListDlgPostDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBlockListDlgPostDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBeltSwapClick(Sender: TObject; X, Y: Integer);
    procedure DBeltCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotLoverClick(Sender: TObject; X, Y: Integer);
    procedure DBeltWindowMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGroupDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCreateChrDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure GetPageInfo(pList: Pointer; var PageNumber: Integer; var PageTotal: Integer; var PageRef: Integer);
    procedure GetPageInfo20(pList: Pointer; var PageNumber: Integer; var PageTotal: Integer; var PageRef: Integer);
    procedure DMemoCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGenericMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLoverWindowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLoverExitClick(Sender: TObject; X, Y: Integer);
    procedure DLoverAvailableClick(Sender: TObject; X, Y: Integer);
    procedure DLoverAskClick(Sender: TObject; X, Y: Integer);
    procedure DLoverDivorceClick(Sender: TObject; X, Y: Integer);
    procedure DLoverWindowMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMailListDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMailListPgUpClick(Sender: TObject; X, Y: Integer);
    procedure DMailListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMailListDlgDblClick(Sender: TObject);
    procedure DMLReplyClick(Sender: TObject; X, Y: Integer);
    procedure BBSTextNotify(Sender: TObject);
    procedure EdSalesEditKeyPress (Sender: TObject; var Key: Char);
    procedure CostSalesEditKeyPress (Sender: TObject; var Key: Char);
    procedure EdShopEditKeyPress (Sender: TObject; var Key: Char);
    procedure EStoragePW1KeyPress(Sender: TObject; var Key: Char);
    procedure DMLReadClick(Sender: TObject; X, Y: Integer);
    procedure DMLDelClick(Sender: TObject; X, Y: Integer);
    procedure DMemoB3Click(Sender: TObject; X, Y: Integer);
    procedure DBeltWindowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBLAddClick(Sender: TObject; X, Y: Integer);
    procedure DBLDelClick(Sender: TObject; X, Y: Integer);
    procedure DBlockListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DBlockListDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBLPgUpClick(Sender: TObject; X, Y: Integer);
    procedure DMLBlockClick(Sender: TObject; X, Y: Integer);
    procedure DBlockListDlgMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBotMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHoldClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DGTListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGTListCloseClick(Sender: TObject; X, Y: Integer);
    procedure ClearGTlist();
    procedure ClearDecolist();
    procedure ClearBBSList();      //Àå¿ø°Ô½ÃÆÇ
    procedure DGTListClick(Sender: TObject; X, Y: Integer);
    procedure DGTListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DGTListNextClick(Sender: TObject; X, Y: Integer);
    procedure DGTListDblClick(Sender: TObject);
    procedure DDecoListNextClick(Sender: TObject; X, Y: Integer);
    procedure DDecoListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DDecoListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DDecoListExitClick(Sender: TObject; X, Y: Integer);
    procedure DDecoListDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDecoListBuyClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBBSListDlgClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListNextClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListOKClick(Sender: TObject; X, Y: Integer);
    procedure DBBSMsgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBBSMsgDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBBSListWriteClick(Sender: TObject; X, Y: Integer);
    procedure DBBSListNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DBBSMsgOkClick(Sender: TObject; X, Y: Integer);
    procedure DBBSMsgReplyClick(Sender: TObject; X, Y: Integer);
    procedure DBBSMsgDeleteClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsCloseClick(Sender: TObject; X, Y: Integer);

    procedure DOptionsDropViewOnClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsDropViewOffClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsEffectOffClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsEffectOnClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsSkillBarOffClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsSkillBarOnClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsSkillMode1Click(Sender: TObject; X, Y: Integer);
    procedure DOptionsSkillMode2Click(Sender: TObject; X, Y: Integer);
    procedure DSkillBarDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSkillBarMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUSGroupClick(Sender: TObject; X, Y: Integer);
    procedure DUSFriendClick(Sender: TObject; X, Y: Integer);
    procedure DUSMailClick(Sender: TObject; X, Y: Integer);
    procedure DSalesMailClick(Sender: TObject; X, Y: Integer);
    procedure DSelectChrClick(Sender: TObject; X, Y: Integer);
    procedure DLoginViewKeyClick(Sender: TObject; X, Y: Integer);
    procedure DMsgSimpleDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DMsgSimpleDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMsgSimpleDlgKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DBotHelpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotHelpClick(Sender: TObject; X, Y: Integer);
    procedure DHelpCloseClick(Sender: TObject; X, Y: Integer);
    procedure DHelpWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOptionsNameAllViewOnClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsNameAllViewOffClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsHPView1Click(Sender: TObject; X, Y: Integer);
    procedure DOptionsHPView2Click(Sender: TObject; X, Y: Integer);
    procedure DHelpPrevClick(Sender: TObject; X, Y: Integer);
    procedure DHelpNextClick(Sender: TObject; X, Y: Integer);
    procedure DGTListMailClick(Sender: TObject; X, Y: Integer);
    procedure DShopMenuDlgClick(Sender: TObject; X, Y: Integer);
    procedure DShopMenuDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DShopMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DShopMenuScrollUpClick(Sender: TObject; X, Y: Integer);
    procedure DShopMenuScrollDownClick(Sender: TObject; X, Y: Integer);
    procedure DShopMenuOkClick(Sender: TObject; X, Y: Integer);
    procedure DShopMenuCloseClick(Sender: TObject; X, Y: Integer);
    procedure DDcJunsaBuffDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemStoreDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DStoreGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DStoreGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DItemStoreCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotQuestClick(Sender: TObject; X, Y: Integer);

    procedure DGDWarClick(Sender: TObject; X, Y: Integer);
    procedure DGDCancelWarClick(Sender: TObject; X, Y: Integer);
    procedure DBHomeClick(Sender: TObject; X, Y: Integer);
    procedure DBStorageClick(Sender: TObject; X, Y: Integer);
    procedure DBAuctionClick(Sender: TObject; X, Y: Integer);
    procedure DDealMsgDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotTigerClick(Sender: TObject; X, Y: Integer);  //È£¶ûÀÌ
    procedure DTigerDirectPaint(Sender: TObject;   //È£¶ûÀÌ
      dsurface: TDirectDrawSurface);
    procedure DTigerDlgDirectPaint(Sender: TObject;       //È£¶ûÀÌ
      dsurface: TDirectDrawSurface);
    procedure DTigerDlgCloseClick(Sender: TObject; X, Y: Integer);   //È£¶ûÀÌ
    procedure DTigerDlgSetClick(Sender: TObject; X, Y: Integer);    //È£¶ûÀÌ
    procedure DTigerDlgSetDirectPaint(Sender: TObject;           //È£¶ûÀÌ
      dsurface: TDirectDrawSurface);
    procedure DMasterWindowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotMasterClick(Sender: TObject; X, Y: Integer);
    procedure DMasterWindowMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DMasterExitClick(Sender: TObject; X, Y: Integer);
    procedure DMasterAvailableDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMasterDivorceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMasterAllowClick(Sender: TObject; X, Y: Integer);
    procedure DMentorClick(Sender: TObject; X, Y: Integer);
    procedure DMasterSecessionClick(Sender: TObject; X, Y: Integer);
    procedure DMasterAllowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLoverHeartDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeartMyStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBScreenClick(Sender: TObject; X, Y: Integer);
    procedure DBReady2Click(Sender: TObject; X, Y: Integer);
    procedure DBReady3Click(Sender: TObject; X, Y: Integer);
    procedure DBReady4Click(Sender: TObject; X, Y: Integer);


    procedure DTigerDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUpWapondowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPrevStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBUpWaponOKClick(Sender: TObject; X, Y: Integer);
    procedure DBUpWaponexitClick(Sender: TObject; X, Y: Integer);
    procedure DUpWapItemgridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DUpWapItemgridGridSelect(Sender: TObject; X, Y: integer; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DUpWapItemgridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DBotGoldClick(Sender: TObject; X, Y: Integer);
    procedure DBotRankClick(Sender: TObject; X, Y: Integer);
    procedure DPrevSortDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSalesMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBotReady2Click(Sender: TObject; X, Y: Integer);
    procedure DBnpcupClick(Sender: TObject; X, Y: Integer);
    procedure DButBagMode1Click(Sender: TObject; X, Y: Integer);
    procedure DButBagMode1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DNewAccountOkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChgPwDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBackgroundDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMovenpcbotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMovenpcbotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DShopMenuMoveDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DShopMenuMoveMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DMacrosDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMacrosKeyPress(Sender: TObject; var Key: Char);
    procedure DMacrosOKDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMacrosOKClick(Sender: TObject; X, Y: Integer);
    procedure DMacrosCancelClick(Sender: TObject; X, Y: Integer);
    procedure ToggleMacrosFieldVisability;
    procedure DSPETS1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSPETS1Click(Sender: TObject; X, Y: Integer);
    procedure DSPETS1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWItemSepaDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure ItemSepaOkClick(Sender: TObject; X, Y: Integer);
    procedure ItemSepacloseClick(Sender: TObject; X, Y: Integer);
    procedure ItemSepaexitClick(Sender: TObject; X, Y: Integer);
    procedure Dshoppe1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure Dshoppe1Click(Sender: TObject; X, Y: Integer);
    procedure DBotItemShopClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGotoLeftDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemShopDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DRenovatesDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRenovatesClick(Sender: TObject; X, Y: Integer);
    procedure GiftsDTClick(Sender: TObject; X, Y: Integer);
    procedure GiftsDTDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure GiftsDTMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DlipioutDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure Giftsdoot1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure Giftsdoot1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure Giftsdoot1Click(Sender: TObject; X, Y: Integer);
    procedure GiftsupsClick(Sender: TObject; X, Y: Integer);
    procedure GiftsDTEXITClick(Sender: TObject; X, Y: Integer);
    procedure DCategories1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCategories1Click(Sender: TObject; X, Y: Integer);
    procedure DCategories11Click(Sender: TObject; X, Y: Integer);
    procedure DCategories12Click(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobAllDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemShopJobAllClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobWarriorClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobWizardClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobMonkClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobAssasClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobCommonClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopCloseClick(Sender: TObject; X, Y: Integer);
    procedure buyitemk1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure buyitemk1Click(Sender: TObject; X, Y: Integer);
    procedure DItemShopListPrevClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopGetGiftDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemShopGetGiftClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopAddFavClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopByeClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopGiftClick(Sender: TObject; X, Y: Integer);
    procedure DCategories6DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCategories6Click(Sender: TObject; X, Y: Integer);
    procedure DLogInDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DscStartDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DccOkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBHomeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotMenuClick(Sender: TObject; X, Y: Integer);
    procedure DMenuWindowsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DScrollBottomDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotOptionClick(Sender: TObject; X, Y: Integer);
    procedure DViewMiniMapMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DViewMiniMapDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotBigMapClick(Sender: TObject; X, Y: Integer);
    procedure DDayBrightDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure Dshoppe1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DShopMenuOkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUser2Click(Sender: TObject; X, Y: Integer);
    procedure DUserInfoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUserInfoExitClick(Sender: TObject; X, Y: Integer);
    procedure DUserInfoMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure buyitemk1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DItmeDuraWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotDuraClick(Sender: TObject; X, Y: Integer);
    procedure DDealDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMakeClick(Sender: TObject; X, Y: Integer);
    procedure DFishDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DFishDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DFishExitClick(Sender: TObject; X, Y: Integer);
    procedure DFISH1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DFISH1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DFISH1Click(Sender: TObject; X, Y: Integer);
    procedure DFishProgressDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DProgressExitClick(Sender: TObject; X, Y: Integer);
    procedure DCatchClick(Sender: TObject; X, Y: Integer);
    procedure DCatchDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DFishProgressDlgMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DCheckEscClick(Sender: TObject; X, Y: Integer);
    procedure DCheckEscDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAutoFishDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAutoFishClick(Sender: TObject; X, Y: Integer);
    procedure DItmeDuraWin2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotDura2Click(Sender: TObject; X, Y: Integer);
    procedure DDiceGameDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDiceStartDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDiceCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChangeItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItemMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DStartChangeClick(Sender: TObject; X, Y: Integer);
    procedure DCloseChangeClick(Sender: TObject; X, Y: Integer);
    procedure DChangeItem1Click(Sender: TObject; X, Y: Integer);
    procedure DChangeItem1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItem1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DChangeItem2Click(Sender: TObject; X, Y: Integer);
    procedure DChangeItem2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItem2MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DChangeItem3Click(Sender: TObject; X, Y: Integer);
    procedure DChangeItem3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItem3MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DChangeItem4Click(Sender: TObject; X, Y: Integer);
    procedure DChangeItem4DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItem4MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DChangeItem5Click(Sender: TObject; X, Y: Integer);
    procedure DChangeItem5DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItem5MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DChangeItem6Click(Sender: TObject; X, Y: Integer);
    procedure DChangeItem6DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChangeItem6MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DPrevInfoClick(Sender: TObject; X, Y: Integer);
    procedure DUser2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DExChangeDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DExitChangeClick(Sender: TObject; X, Y: Integer);
    procedure DExGoldChangeClick(Sender: TObject; X, Y: Integer);
    procedure DExGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DExGoldClick(Sender: TObject; X, Y: Integer);
    procedure DExHwanClick(Sender: TObject; X, Y: Integer);
    procedure DDExHwanClick(Sender: TObject; X, Y: Integer);
    procedure DDExGoldClick(Sender: TObject; X, Y: Integer);
    procedure DGetExChangeClick(Sender: TObject; X, Y: Integer);
    procedure DUpWeaponDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUpWeaponSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUpWeaponSpotClick(Sender: TObject; X, Y: Integer);
    procedure DUpWeaponSpotMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DStoreGridWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreCloseClick(Sender: TObject; X, Y: Integer);
    procedure DStoreDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGStoreGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DGStoreGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DGStoreGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DStoreMsgDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreMsgOkClick(Sender: TObject; X, Y: Integer);
    procedure DUserStoreMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUserStoreDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUserStoreCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGUserStoreGridMouseMove(Sender: TObject; X, Y: integer; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGUserStoreGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DGUserStoreGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DUserStoreBuyClick(Sender: TObject; X, Y: Integer);
    procedure DStoreCancelClick(Sender: TObject; X, Y: Integer);
    procedure DStoreOpenClick(Sender: TObject; X, Y: Integer);
    procedure DStoreGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreGGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreGoldClick(Sender: TObject; X, Y: Integer);
    procedure DStoreGGoldClick(Sender: TObject; X, Y: Integer);
    procedure DStoreMacroDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreMacroClick(Sender: TObject; X, Y: Integer);
    procedure DComStorageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DComStorageMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DComStorageExitClick(Sender: TObject; X, Y: Integer);
    procedure DGetComStorageClick(Sender: TObject; X, Y: Integer);
    procedure DStorageRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DCS1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCS1Click(Sender: TObject; X, Y: Integer);
    procedure DCS1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGuildStorageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGuildStorageMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DGuildStorageExitClick(Sender: TObject; X, Y: Integer);
    procedure DGuildStorageReClick(Sender: TObject; X, Y: Integer);
    procedure DGetGuildStorageClick(Sender: TObject; X, Y: Integer);
    procedure DGGuildStorageGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DGGuildStorageGridSelect(Sender: TObject; X, Y: integer; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGGuildStorageGridMouseMove(Sender: TObject; X, Y: integer; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DRentalDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRentalListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRentalDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DRentalListClick(Sender: TObject; X, Y: Integer);
    procedure DBorrowListClick(Sender: TObject; X, Y: Integer);
    procedure DRentalExitClick(Sender: TObject; X, Y: Integer);
    procedure DRentalClick(Sender: TObject; X, Y: Integer);
    procedure DDRentalDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDRentalDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DRentalCloseClick(Sender: TObject; X, Y: Integer);
    procedure DRGridClick(Sender: TObject; X, Y: Integer);
    procedure DRGridDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRGridMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DRGoldClick(Sender: TObject; X, Y: Integer);
    procedure DRGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRentalOkClick(Sender: TObject; X, Y: Integer);
    procedure DRentalRemoteDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRentalRemoteDlgMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DRRGridDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRRGridMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DRRGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRRentalCloseClick(Sender: TObject; X, Y: Integer);
    procedure DRRentalAllowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DRentalMsgDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DReturnClick(Sender: TObject; X, Y: Integer);
    procedure DWithdrawClick(Sender: TObject; X, Y: Integer);
    procedure DRRefreshClick(Sender: TObject; X, Y: Integer);
    procedure DUpCheckDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckSpotClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckSpotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCheckExitClick(Sender: TObject; X, Y: Integer);
    procedure DCheckOkClick(Sender: TObject; X, Y: Integer);
    procedure DUpCheckMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUpWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGuildGrowDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGuildGrowDlgClick(Sender: TObject; X, Y: Integer);
    procedure DGuildGrowDlgMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DGGPage1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGGPage1Click(Sender: TObject; X, Y: Integer);
    procedure DGGPage2Click(Sender: TObject; X, Y: Integer);
    procedure DGGrowExitClick(Sender: TObject; X, Y: Integer);
    procedure DGGrow1Click(Sender: TObject; X, Y: Integer);
    procedure DGGrowUpClick(Sender: TObject; X, Y: Integer);
    procedure DGDGrowUpClick(Sender: TObject; X, Y: Integer);
    procedure DMakeItemDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMakeItemDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMakeItemDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DMakeitemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DMakeitemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DMakeitemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DBHelpGuildClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsSoundOnDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOptionsSoundOnMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DOptionsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DOptionsDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLoverMailClick(Sender: TObject; X, Y: Integer);
    procedure DLoverWhisperClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsSoundOnMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DOptionClick1(Sender: TObject; X, Y: Integer);
    procedure DWinPetDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPetExitClick(Sender: TObject; X, Y: Integer);
    procedure DBotPetClick(Sender: TObject; X, Y: Integer);
    procedure DBHelpPetClick(Sender: TObject; X, Y: Integer);
    procedure DWinPetMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DPet1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPet1Click(Sender: TObject; X, Y: Integer);
    procedure DReleaseClick(Sender: TObject; X, Y: Integer);
    procedure DSommonClick(Sender: TObject; X, Y: Integer);
    procedure DSommonDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPetNameClick(Sender: TObject; X, Y: Integer);
    procedure DPetPickUpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPetOptionClick(Sender: TObject; X, Y: Integer);
    procedure DCancelPetClick(Sender: TObject; X, Y: Integer);
    procedure DPetOptionDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSavePetClick(Sender: TObject; X, Y: Integer);
    procedure DPetOptionDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DAutoPickUpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAutoPickUpClick(Sender: TObject; X, Y: Integer);
    procedure DSUseSortDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSUseSortClick(Sender: TObject; X, Y: Integer);
    procedure DSCostSortDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSCostSortClick(Sender: TObject; X, Y: Integer);
    procedure DitemnamertClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DSalesMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DAuc0DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAuc3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAuc0Click(Sender: TObject; X, Y: Integer);
    procedure DAuctionSortClick(Sender: TObject; X, Y: Integer);
    procedure DAuctionSortDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotAuctionClick(Sender: TObject; X, Y: Integer);
    procedure DBotAucFindDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSalesKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DAuctionSpotClick(Sender: TObject; X, Y: Integer);
    procedure DAuctionSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAuctionSpotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DAuctionCancelClick(Sender: TObject; X, Y: Integer);
    procedure DAuctionClick(Sender: TObject; X, Y: Integer);
    procedure DMailListCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMailListDlgMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMemoClick(Sender: TObject; X, Y: Integer);
    procedure DMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DBlockListCloseClick(Sender: TObject; X, Y: Integer);

    procedure DMLSendClick(Sender: TObject; X, Y: Integer);
    procedure DMLSendMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMLReplyMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMLReadMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMLDelMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMLBlockMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHelpMailClick(Sender: TObject; X, Y: Integer);
    procedure DMailReMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMailReClick(Sender: TObject; X, Y: Integer);
    procedure DBotUpClick(Sender: TObject; X, Y: Integer);
    procedure DItemStoreMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DExpModeClick(Sender: TObject; X, Y: Integer);
    procedure DDisassembleDlgMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DDisaCloseClick(Sender: TObject; X, Y: Integer);
    procedure DDisassembleSpotClick(Sender: TObject; X, Y: Integer);
    procedure DDisassembleStartClick(Sender: TObject; X, Y: Integer);
    procedure DDisassembleSpotMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DDisassembleSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDisassembleDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLoverMacroClick(Sender: TObject; X, Y: Integer);
    procedure DBReady6Click(Sender: TObject; X, Y: Integer);
    procedure DDiceCurrDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDiceCurrMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DDiceGameMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DDiceStartClick(Sender: TObject; X, Y: Integer);
    procedure DDiceStopClick(Sender: TObject; X, Y: Integer);
    procedure DDiceSelect1Click(Sender: TObject; X, Y: Integer);
    procedure DDiceSelect1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDiceNextDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDiceGetClick(Sender: TObject; X, Y: Integer);
    procedure DDiceNextMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DDice1Click(Sender: TObject; X, Y: Integer);
    procedure DDice1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOnAuctionDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAuctionCloseClick(Sender: TObject; X, Y: Integer);
    procedure DOnAuctionMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DAucItemClick(Sender: TObject; X, Y: Integer);
    procedure DAucItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAucItemMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGetAuctionClick(Sender: TObject; X, Y: Integer);
    procedure DExitAuctionClick(Sender: TObject; X, Y: Integer);
    procedure DAuctionViewClick(Sender: TObject; X, Y: Integer);
    procedure DGetAuctionDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOffAuctionDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAucCloseClick(Sender: TObject; X, Y: Integer);
    procedure DOffAucItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOffAucItemMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DOffAuctionClick(Sender: TObject; X, Y: Integer);
    procedure DOffAucClick(Sender: TObject; X, Y: Integer);
    procedure DWndGroupMemberDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGroupCloseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGroupCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGroupMember1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGroupMember1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DSellDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWndGroupMemberMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWndGroupMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DDismantleDlgMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DDismantleDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDismantleSpotClick(Sender: TObject; X, Y: Integer);
    procedure DDismantleSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDismantleCloseClick(Sender: TObject; X, Y: Integer);
    procedure DDismantleStartClick(Sender: TObject; X, Y: Integer);
    procedure DItemWakeUpDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemWakeUpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCloseWakeUpClick(Sender: TObject; X, Y: Integer);
    procedure DWakeUpListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWakeUpListMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWakeUpListClick(Sender: TObject; X, Y: Integer);
    procedure DWake1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWake1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWakePopupClick(Sender: TObject; X, Y: Integer);
    procedure DWakeUpStartClick(Sender: TObject; X, Y: Integer);
    procedure DWakeArr1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWakeArr1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWakeArr1Click(Sender: TObject; X, Y: Integer);
    procedure DItemWakeUpDlgMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DItemWakeUpDlgMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DItemWakeUpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DItemWakeUpClick(Sender: TObject; X, Y: Integer);
    procedure DDismantleSpotMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DRenewChrClick(Sender: TObject; X, Y: Integer);
    procedure DRenewChrDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DButRenewChrDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBtnSayAllMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBtnSayAllMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBtnSayAllDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotChatTransClick(Sender: TObject; X, Y: Integer);
    procedure DTopMsgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBTCheck1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBTCheck1Click(Sender: TObject; X, Y: Integer);
    procedure DBigMapDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBigMapDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBigMapDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBigMapDlgKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DMiniMapDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMiniMapMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMiniMapMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMiniMapKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DMerchantDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DOptionsMp3OnDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOptionsMp3OnMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DOptionsMp3OnMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DOptionsFullClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsWinClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsHintOnClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsHintOffClick(Sender: TObject; X, Y: Integer);
    procedure DSetPassWdDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSetPWCloseClick(Sender: TObject; X, Y: Integer);
    procedure DStRePWClick(Sender: TObject; X, Y: Integer);
    procedure DCheckStPwClick(Sender: TObject; X, Y: Integer);
    procedure DStScPWClick(Sender: TObject; X, Y: Integer);
    procedure DStoragePWDlgMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DStPWCloseClick(Sender: TObject; X, Y: Integer);
    procedure DStPwInputClick(Sender: TObject; X, Y: Integer);
    procedure DStPwDelClick(Sender: TObject; X, Y: Integer);
    procedure DStPw0DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStPw0Click(Sender: TObject; X, Y: Integer);
    procedure DInputStPwdDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DInputStCloseClick(Sender: TObject; X, Y: Integer);
    procedure DCheckInPutPwClick(Sender: TObject; X, Y: Integer);
    procedure DChangeStPwDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChRePwClick(Sender: TObject; X, Y: Integer);
    procedure DCloseChPwClick(Sender: TObject; X, Y: Integer);
    procedure DCheckChPwClick(Sender: TObject; X, Y: Integer);
    procedure DStoragePWClick(Sender: TObject; X, Y: Integer);
    procedure DOptionsScreen1Click(Sender: TObject; X, Y: Integer);
    procedure DOptionsScreen2Click(Sender: TObject; X, Y: Integer);
    procedure DNewAccountCancelDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStoreGridWinMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DNameChNPClick(Sender: TObject; X, Y: Integer);
    procedure DNameMonClick(Sender: TObject; X, Y: Integer);
    procedure DNewSayDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DNewSayInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DNewSayMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DNewSayMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBTSayMoveMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure dkSayLockClick(Sender: TObject; X, Y: Integer);
    procedure dkSayLockDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBTFaceClick(Sender: TObject; X, Y: Integer);
    procedure DItemShopJobBonzClick(Sender: TObject; X, Y: Integer);
    procedure DButtonReCallHeroClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStateWinMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroCharClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStatusClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DHeroSkillClick(Sender: TObject; X, Y: Integer);
    procedure DCloseHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DHeroSWWeaponDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroSWWeaponMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DCloseHeroBagClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemBagDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DHeroItemGridGridMouseMove(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DHeroItemGridGridSelect(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DHeroItemGridDblClick(Sender: TObject);
    procedure DHeroMenuMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DButtonHeroSkillClick(Sender: TObject; X, Y: Integer);
    procedure DButtonHeroBagClick(Sender: TObject; X, Y: Integer);
    procedure DButtonHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DButtonMenuHeroClick(Sender: TObject; X, Y: Integer);
    procedure DBeltHeroDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBeltHeroMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBeltHeroSwapClick(Sender: TObject; X, Y: Integer);
    procedure DBeltHeroCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1HeroDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBelt1HeroMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBelt1HeroClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1HeroDblClick(Sender: TObject);
    procedure DHeroStMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DHeroStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DHeroKeylDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKsSF1Click(Sender: TObject; X, Y: Integer);
    procedure DKsSIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKsSOkClick(Sender: TObject; X, Y: Integer);
    procedure DKsSF1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroSkillBarDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHSkillBar1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBotAi1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotAi1Click(Sender: TObject; X, Y: Integer);
    procedure DBotAi1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroControlMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroHelpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroCallClick(Sender: TObject; X, Y: Integer);
    procedure DHeroBackClick(Sender: TObject; X, Y: Integer);
    procedure DHeroDefenClick(Sender: TObject; X, Y: Integer);
    procedure DHeroHelpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroHelpClick(Sender: TObject; X, Y: Integer);
    procedure DBHelpWakeClick(Sender: TObject; X, Y: Integer);
    procedure DAutoPot1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAutoPot1Click(Sender: TObject; X, Y: Integer);
    procedure DAutoPot1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DAuto1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAuto1Click(Sender: TObject; X, Y: Integer);
    procedure DAuto1PerDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAuto1PerClick(Sender: TObject; X, Y: Integer);
    procedure DHeroBagUpClick(Sender: TObject; X, Y: Integer);
    procedure DMakeAdviceClick(Sender: TObject; X, Y: Integer);
    procedure DGrpCheckGroupClick(Sender: TObject; X, Y: Integer);
    procedure DCBGroupItemDefClick(Sender: TObject; X, Y: Integer);
    procedure DGrpMemberListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGrpMemberListMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DGrpMemberListMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DGrpMemberListDblClick(Sender: TObject);
    procedure DGrpCheckHeroClick(Sender: TObject; X, Y: Integer);
    procedure DGrpUserListDblClick(Sender: TObject);
    procedure DGrpUserListMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DGrpUserListMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGdUserUpClick(Sender: TObject; X, Y: Integer);
    procedure DGpMoveMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);

    procedure DGpMoveDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStoreGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
    procedure DHeroStoreGridGridMouseMove(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DStore1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStore1Click(Sender: TObject; X, Y: Integer);
    procedure DStore2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStoreGridGridSelect(Sender: TObject; X, Y, ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DStore1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBCompoundClick(Sender: TObject; X, Y: Integer);


  private
    DlgTemp: TList;
    magcur, magtop: integer;
    EdDlgEdit: TEdit;
    Memo: TMemo;

    ViewDlgEdit: Boolean;
    msglx, msgly: integer;
    ShopMenuTop: integer;

    MagKeyID,MagKeyIcon, MagKeyCurKey: integer;
    MagKeyMagName: string;

    MagHKeyID, MagHKeyIcon, MagHKeyCurKey: Integer;
    MagHKeyMagName: string;

    BackupMemoMail : string;
    MagicPage: integer;

    m_FishTime: LongWord;      //³¬½Ã
    FishFrame : integer;     //³¬½Ã

    m_FishTime2: LongWord;      //³¬½Ã
    FishFrame2 : integer;     //³¬½Ã

    m_Time: LongWord; //È£¶ûÀÌ
    BlinkTime: longword;
    BlinkCount: integer;  //º¸³Ê½º Æ÷ÀÎÆ® ¹öÆ°

    m_nCurFrame : integer;
    m_nMaxFrame : integer;
    {item shine animations}
    aiShineFrame:  Array[0..13] of integer;
    aiShineTime:   Array[0..13] of LongInt;
    //È¯»óÁ¡
    newimgIndex: integer;
    newimgtime: longword;
    shopbuysrt: string;
    shopbuyamoin:Integer;
    shopcisk: string;
    shopbuypier: string;
    shopitemstr:array[0..5] of String;
    //----------

    procedure DSayMoveSize(Y: Integer);
    procedure HideAllControls;
    procedure RestoreHideControls;
    procedure PageChanged;
    procedure HeroPageChanged;
    procedure RentalPageChanged;       //´ë¿©Ã¢ ÆäÀÌÁö
    procedure GrowPageChanged;    //¹®ÆÄ¼ºÀå ÆäÀÌÁö

    procedure ExChangePageChanged;    //È¯Àü
    procedure RentalItemReturnBag (mitem: TClientItem);       //´ë¿©
    procedure DealItemReturnBag (mitem: TClientItem);       //°Å·¡
    procedure DealItemReturnBag2 (mitem: TClientItem);     //°Å·¡
    procedure DealZeroGold;

  public
    SayDlgDown: Boolean;

    GrowPage :Integer;   //¹®ÆÄ¼ºÀå ÆäÀÌÁö
    UserInfoPage :Integer;   //»ó´ë¹æ Á¤º¸ Ã¢
    RentalPage :Integer;   //´ë¿©Ã¢

    RentalMode :Integer;   //´ë¿© ¸ðµå

    ExChangePage :Integer; //È¯Àü
    m_boStoreGold:Integer; //°³ÀÎ»óÁ¡

    m_dwBlinkTime: LongWord;
    m_boViewBlink: Boolean;
    TempsList: TList;
    MaxLineHeight: Integer;
    StatePage: integer;
    HeroStatePage: Integer;
    BagPage: integer;
    HelpPage: integer;
    MsgText: string;
    DialogSize: integer;
    m_boMouseMove:Boolean;

    m_nDiceCount:Integer;
    m_boPlayDice:Boolean;
    m_Dice:array[0..9] of TDiceInfo;

    btWuXin: Byte;

    RenewChrIdx: Integer;

    MerchantName: string;
    MerchantFace: integer;
    MDlgPoints: TList;
    MDlgsier: TList;
    SelectMenuStr: string;
    LastestClickTime: longword;
    SpotDlgMode: TSpotDlgMode;

    //È¯»óÁ¡
    Giftsidxts: integer;
    Giftsstrcls:integer;
    Giftsitemstr:array[0..6] of String;

    GroupListIndex: Integer;
    GroupListMoveIndex: Integer;
    UserListIndex: Integer;
    UserListMoveIndex: Integer;
    GroupIndex: Integer;
    GroupIndexMax: Integer;
    RefGroupList: TStringList;

    EdStoreMsgEdit:TEdit;
    EdStoreMacrosEdit:TEdit;
    EdStoreDlgEdit:TEdit; //°³ÀÎ»óÁ¡ °¡°Ý

    //------------
    MenuList: TList; //list of PTClientGoods
    MenuIndex: integer;
    GrowIndex: integer; //¹®ÆÄ¼ºÀå
    ShopMenuIndex: integer;
    CurDetailItem: string;
    g_WakeUpItem: Integer;
    g_WakeUpMode: Integer;
    AuctionMenuIndex: Integer;      //À§Å¹
    g_AucIndex :Integer;            //À§Å¹
    AuctionPage :Integer;           //À§Å¹
    ComStorageMenuIndex: Integer;  //°ø¿ëÃ¢°í
    GuildStorageIndex: Integer;  //¹®ÆÄÃ¢°í
    GameShopIndex: Integer;  //È¯»óÁ¡
    GTListMenuIndex: Integer;
    MenuTopLine: integer;
    BoNoDisplayMaxDura: Boolean;

    m_boChangeGroup: Boolean;

    FSayNameIndex: Integer;

    NewAccountTitle: string;
    NameMakeItem   : string[14];       //Á¦Á¶½ºÃÄ
    BoMakeItemMenu : Boolean;       //Á¦Á¶½ºÃÄ

    BoPCItemMenu : Boolean;
    // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå     //º¸¿Á
    BoUpItemEffect: Boolean;
    CurUpItemEffect: integer;
    UpItemOffset  : integer;
    UpItemMaxFrame  : integer;
    upeffecttime: longword;

    {¸ÅÅ©·Î}
    EdMacro1: TEdit;
    EdMacro2: TEdit;
    EdMacro3: TEdit;
    EdMacro4: TEdit;
    EdMacro5: TEdit;
    EdMacro6: TEdit;
    EdMacro7: TEdit;
    EdMacro8: TEdit;
    strlMacros: TStringList;
    MacrosX:  integer;
    MacrosY:  integer;



    DlgEditText: string;
    StoreDlgEditText: string;   //°³ÀÎ»óÁ¡
    UserState1: TUserStateInfo;
    GuildGrow1: TGuildGrowUp;   //¹®ÆÄ¼ºÀå

    GuildMode: Integer;
    Guild: string;
    GuildFlag: string;
    GuildCommanderMode: Boolean;
    GuildStrs: TStringList;
    GuildStrs2: TStringList;
    GuildNotice: TStringList;
    GuildMembers: TStringList;
    GuildTopLine: integer;
    GuildEditHint: string;
    GuildChats: TStringList;
    BoGuildChat: Boolean;

    pClickName: pTClickName;
    nClickNameIndex: Integer;
    pClickItem: pTClickItem;
    nClickItemIndex: Integer;
    pClickIndex: Integer;

    EdSalesEdit: TEdit;     //À§Å¹ °Ë»öÃ¢
    EdShopEdit: TEdit;     //È¯»óÁ¡ °Ë»öÃ¢
    CostSalesEdit: TEdit;     //À§Å¹ °¡°ÝÃ¢
    BBSMemo: TMemo;

    ESitemName:TEdit;      //¹°¾à ºÐ¸® ÅØ½ºÆ®
    EStoragePW1:TEdit;     //Ã¢°í¾ÏÈ£
    EStoragePW2:TEdit;
    EStoragePW3:TEdit;
    EdHeroName :TEdit;

    // 2003/04/15 Ä£±¸, ÂÊÁö

    // 2003/04/15 Ä£±¸, ÂÊÁö
    edCharID : TEdit;
    memoMail : TMemo;
    
    MemoCharID    : string;
    MemoDate      : string;

    BlackListPage : integer;
    MailPage      : integer;
    BlockPage     : integer;
    CurrentMail   : integer;     //¸ÞÀÏ

    CurrentBlock  : integer;
    ViewFriends   : boolean;
    ViewWindowNo  : integer;
    ViewWindowData: integer;
    FriendDlgDblClicked  : Boolean;
    MailListDlgDblClicked: Boolean;

    BBSSticky: integer;

    LastBeltDoubleClick: integer;
    LastHeroBeltDoubleClick: integer;
    HintList: TStringList;
    Initialized: Boolean;
    Initialized2: Boolean;
    m_TopMsgList: TStringList;

    Heromagtop: Integer;
    HeroMagicPage: Integer;
    procedure Initialize;
    procedure InitializeEx();
    procedure DoBeltSetup;
    procedure DoBeltHeroSetup;
    procedure OpenMyStatus;
    procedure OpenUserState (UserState: TUserStateInfo);
    procedure OpenHeroStatus;
    procedure OpenGuildGrow (GuildGrow: TGuildGrowUp);  //¹®ÆÄ¼ºÀå
    procedure OpenGuildGrow2 (GuildGrow: TGuildGrowUp);  //¹®ÆÄ¼ºÀå
    procedure OpenItemBag;
    procedure ViewBottomBox (visible: Boolean);
    procedure CancelItemMoving;
    procedure CancelHeroItemMoving;
    procedure CancelItemMoving2;  //¿©°ü
    procedure CancelItemAuto;
    procedure OpenSayItemShow(mitem: TClientItem);
    procedure DropMovingItem;
    procedure OpenAdjustAbility;

    procedure RefCheckButtonXY();

    procedure ShowSelectServerDlg;
    function  DMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function  DSimpleMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function  DSimpleMessageDlg2 (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    function  MakeItemDlgShow ( msgstr: string ): TModalResult;  //Á¦Á¶½ºÃÄ
    procedure ShowMDlg (face: integer; mname, msgstr: string);
    procedure ShowGuildDlg;
    procedure ShowGuildEditNotice;
    procedure ShowGuildEditGrade;

    procedure ResetMenuDlg;
    procedure ShowNewShopMenuDlg;
    procedure ShowShopSellDlg;
    procedure ShowHeroControl;
    procedure ShowStoreDlg;
    procedure CloseDSellDlg;

    procedure ShowScStoragePW;
    procedure ShowSetStoragePW;
    procedure ShowInputStoragePW;

    procedure CloseDisassembleDlg;
    procedure ShowDisassembleDlg;
    procedure ShowDismantleDlg;
    procedure CloseDismantleDlg;
    procedure ShowWakeUp;
    procedure CloseItemWakeUpDlg;
    procedure CloseMDlg;
    procedure CloseItemMarketDlg; //À§Å¹ Á¾·á
    procedure SafeCloseDlg; //Á¦Á¶½ºÃÄ
    procedure ShowDUpWapon(anpc: integer);    //Àç·Ã
    procedure ShowCheckWapon(anpc: integer);    //Á¦·Ã È®ÀÎ
    procedure CloseDUpWapon;     //Àç·Ã
    procedure CloseDUpWapon2;    //Á¦·Ã È®ÀÎ

    procedure CancelChanging();  //º¯È¯
    procedure CancelChanging2();  //º¯È¯

    procedure ToggleShowRentalDlg;  //´ë¿©Ã¢

    procedure ToggleShowGroupDlg;
    // 2003/04/15 Ä£±¸, ÂÊÁö
    procedure ToggleShowMailListDlg;
    procedure ToggleShowBlockListDlg;
    procedure ShowEditMail;              //¸ÞÀÏ

    procedure ToggleShowTigerDlg;      //È£¶ûÀÌ
    procedure ToggleShowLoverDlg;     //¿¬ÀÎ ½ºÃÄ
    procedure ToggleShowMasterDlg;     //»çÁ¦ ½ºÃÄ
    procedure ToggleShowPetDlg;   //¿µ¹°
    procedure ToggleOptionPetDlg;   //¿µ¹°¿É¼Ç

    procedure OpenRentalDlg(mode:integer);   //´ë¿©
    procedure CloseRentalDlg;    //´ë¿©


    procedure OpenDealDlg;
    procedure CloseDealDlg;
    procedure SetChatFocus;

    procedure SetGroupWnd();

    procedure OpenHelpWin;

    procedure OpenAction;     //°æ¸Å
    procedure CloseAction;    //°æ¸Å

    procedure OpenAuc;
    procedure CloseAuc;

    procedure ShowDiceGame;     //Ç÷·æ»óÀÚ
    procedure DiceImages;
    procedure OpenItemShopDBl;     //È¯»óÁ¡
    procedure openshopitemint;          //È¯»óÁ¡
    procedure Reductionshopitemkey;      //È¯»óÁ¡
    procedure newimgmode;              //È¯»óÁ¡
    procedure closeGiftsDTListDlg;     //È¯»óÁ¡

    procedure OpenStoreDlg;     //°³ÀÎ»óÁ¡
    procedure CloseStoreDlg;    //°³ÀÎ»óÁ¡

    procedure OpenUserStoreDlg;       //°³ÀÎ»óÁ¡
    procedure CloseUserStoreDlg;      //°³ÀÎ»óÁ¡

    procedure CloseHeroAllWindows;

    function DStoreMessageDlg(): TModalResult;

    function AutoTimeIdx:Integer;    //³¬½Ã ³¬±â¹öÆ° ÀÌ¹ÌÁö
    function AutoTimeIdx2:Integer;    //³¬½Ã ³¬±â¹öÆ° ÀÌ¹ÌÁö


    procedure ToggleRentalDlg;  //´ë¿©Ã¢
    procedure ToggleRentalDlg2;  //´ë¿©Ã¢
    procedure ToggleAuctionWindow;    //À§Å¹
    procedure ToggleComStorageWindow; //°ø¿ëÃ¢°í
    procedure ToggleGuildStorageWindow; //¹®ÆÄÃ¢°í

    procedure SoldOutGoods (itemserverindex: integer);
    procedure DelStorageItem (itemserverindex: integer);

    procedure GetMouseItemHint(Actor: TActor; MouseItem: pTClientItem);
    procedure GetMouseMagicInfo(var Magim:nMagicType);   //¹«°øÁ¤º¸
    procedure GetGrowInfo (var iname: sItemMome; idx: integer);   //¹®ÆÄ¼ºÀå

    procedure SetMagicKeyDlg (magid,icon: integer; magname: string; var curkey: word);
    procedure SetHeroMagicKeyDlg(magid,icon: Integer; magname: string; var curkey: Word);
    procedure AddGuildChat (str: string);
    function  ConvertEscChar(str: string) : string;

    procedure UpgradeItemEffect(wResult : word);  //º¸¿Á
    procedure UpgradeItemEffect2;  //º¸¿Á

    procedure ToggleGTListWindow;
    procedure ToggleDecoListWindow;
    procedure ToggleBBSListWindow;      //Àå¿ø°Ô½ÃÆÇ
    procedure ToggleBBSMsgWindow;      //Àå¿ø°Ô½ÃÆÇ
    procedure ChackMsgstrMond; //»óÀÎ

    procedure ShowCreateHeroNew;
    procedure CloseCreateHero;
    procedure CreateHeroOk;
  end;

var
  FrmDlg: TFrmDlg;

implementation

uses
   ClMain, {MShare,} Share, SDK, IntroScn, Bass, FState2;
{$R *.DFM}


{
   ##  g_MovingItem.Index
      1~n : °¡¹æÃ¢ÀÇ ¾ÆÀÌÅÛ ¼ø¼­
      -1~-24 : ÀåÂøÃ¢¿¡¼­ÀÇ ¾ÆÀÌÅÛ ¼ø¼­
      -91 : ÀÏ¹ÝºÐÇØ ¾ÆÀÌÅÛ
      -93 : ºÐÇØ ¾ÆÀÌÅÛ
      -94 : È¯ÀüÃ¢ÀÇ ¹ÐÈ¯
      -95 : ¹ÐÈ¯
      -96 : È¯ÀüÃ¢ÀÇ µ·
      -97 : ±³È¯Ã¢ÀÇ µ·
      -98 : µ·

      -99 : ÆÈ±â Ã¢¿¡¼­ÀÇ ¾ÆÀÌÅÛ ¼ø¼­
      -26~35: ±³È¯Ã¢¿¡¼­ÀÇ ¾ÆÀÌÅÛ ¼ø¼­
      -36 : ´ë¿©Ã¢

      -46~51: Á¦Á¶Ã¢
      -52 : °æ¸ÅÃ¢
      -53~54 : ¿µ¿õ ÀÚµ¿¹°¾à
}



procedure TFrmDlg.FormCreate(Sender: TObject); //¹ÐÈ¯
Var
 i :integer;
begin
   Initialized := False;
   Initialized2 := False;
   StatePage := 0;
   BagPage := 0;
   HeroStatePage := 0;

    //-------È¯»óÁ¡-------
   for i:=0 to 5 do begin
    shopitemstr[i] := '';
   end;
   for i:=0 to 6 do begin
    Giftsitemstr[i] := '';
   end;

      {item shine}
   for i := 0 to 13 do
   begin
     aiShineFrame[i] := Random(9);
     aiShineTime[i] := GetTickCount;
   end;
   RefGroupList := TStringList.Create;

   {¸ÅÅ©·Î}
   strlMacros := TStringList.Create;

   shopbuysrt :='';
   shopbuyamoin := 1;
   shopbuypier := '';
   Giftsidxts := 0;
   Giftsstrcls := -1;
//----------------
   GrowPage := 0;     //¹®ÆÄ¼ºÀå
   UserInfoPage := 0;
   RentalPage := 0; //´ë¿©Ã¢
   RentalMode := 0; //´ë¿©¸ðµå

   ExChangePage :=0; //È¯Àü
   m_boStoreGold:=0; //°³ÀÎ»óÁ¡

   MaxLineHeight := 0;
   DlgTemp := TList.Create;
   DialogSize := 1;
   m_nDiceCount:=0;
   m_boPlayDice:=False;
   magcur := 0;
   magtop := 0;
   MDlgPoints := TList.Create;
   MDlgsier := TList.Create;
   SelectMenuStr := '';
   MenuList := TList.Create;
   MenuIndex := -1;
   GrowIndex := 0;  //¹®ÆÄ¼ºÀå
   m_nStorageMode := 0;
   m_Storemode := 0;
   ShopMenuIndex := -1;
   AuctionMenuIndex := 0;
   AuctionPage := 0;
   g_AucIndex := 0;
   GameShopIndex := 0;
   ComStorageMenuIndex := 0;
   GuildStorageIndex := 0;
   MenuTopLine := 0;
   BoNoDisplayMaxDura := FALSE;

   m_boChangeGroup := False;

   BoMakeItemMenu := FALSE;        //Á¦Á¶½ºÃÄ
   NameMakeItem := '';              //Á¦Á¶½ºÃÄ
   BoPCItemMenu := FALSE;

   MagicPage := 0;
   // 2003/04/15 Ä£±¸, ÂÊÁö
   BlackListPage := 0;
   MailPage      := 0;
   BlockPage     := 0;
   CurrentMail   := -1;      //¸ÞÀÏ

   CurrentBlock  := -1;
   ViewFriends   := TRUE;
   ViewWindowNo  := 0;
   ViewWindowData:= 0;

   m_dwBlinkTime := GetTickCount;
   m_boViewBlink := False;
   TempsList := TList.Create;

   GroupListIndex := -1;
   UserListIndex := -1;
   UserListMoveIndex := -1;
   GroupListMoveIndex := -1;
   GroupIndex := 0;

   BlinkTime := GetTickCount;
   BlinkCount := 0;
   FSayNameIndex := 0;

   m_FishTime:= GetTickCount;    //³¬½Ã
   FishFrame :=0;             //³¬½Ã

   m_FishTime2:= GetTickCount;    //³¬½Ã
   FishFrame2 :=0;             //³¬½Ã

   m_Time := GetTickCount;  //È£¶ûÀÌ
   m_nCurFrame := 0;
   m_nMaxFrame := 16;
   g_UpWapon.S.Name := ''; //Àç·Ã¹«±â
   g_SellDlgItem.S.Name := '';
   GuildMode := 0;
   Guild := '';
   GuildFlag := '';
   GuildCommanderMode := FALSE;
   GuildStrs := TStringList.Create;
   GuildStrs2 := TStringList.Create;
   GuildNotice := TStringList.Create;
   GuildMembers := TStringList.Create;
   GuildChats := TStringList.Create;

   HintList := TStringList.Create;
   m_TopMsgList := TStringList.Create;

   HeroMagicPage := 0;
   Heromagtop := 0;

   EdSalesEdit := TEdit.Create (FrmMain.Owner);
   with EdSalesEdit do begin                        //À§Å¹ °Ë»öÃ¢
      Parent := FrmMain; Color := clBlack; Font.Color := clWhite; Font.Name := g_sCurFontName; Font.Size := 10;
      Ctl3d := FALSE; BorderStyle := bsNone; Visible := FALSE;  MaxLength := 20;
      OnKeyPress := EdSalesEditKeyPress;  Width := 100;  Height := 12;
   end;

   CostSalesEdit := TEdit.Create (FrmMain.Owner);
   with CostSalesEdit do begin                        //À§Å¹ °¡°ÝÃ¢
      Parent := FrmMain; Color := clBlack; Font.Color := clWhite; Font.Name := g_sCurFontName; Font.Size := 10;
      Ctl3d := FALSE; BorderStyle := bsNone; Visible := FALSE;  MaxLength := 20; Text:='0';
      OnKeyPress := CostSalesEditKeyPress;  Width := 100;  Height := 12;
   end;

   EdShopEdit := TEdit.Create (FrmMain.Owner);
   with EdShopEdit do begin                        //È¯»óÁ¡ °Ë»öÃ¢
      Parent := FrmMain; Color := clBlack; Font.Color := clWhite;  Font.Name := g_sCurFontName; Font.Size := 10;
      Ctl3d := FALSE; BorderStyle := bsNone; Visible := FALSE; MaxLength := 20;
      OnKeyPress := EdShopEditKeyPress;  Width := 100; Height := 12;
   end;

   EdDlgEdit := TEdit.Create (FrmMain.Owner);
   with EdDlgEdit do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Name := g_sCurFontName;
      Font.Size := 10;
      MaxLength := 77;
      Height := 16;
      Ctl3d := FALSE;
      BorderStyle := bsSingle;
      Visible := FALSE;
   end;



   EdStoreDlgEdit := TEdit.Create(FrmMain.Owner); //°³ÀÎ»óÁ¡
   with EdStoreDlgEdit do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Name := g_sCurFontName;
      Font.Color := clWhite;
      Font.Size := 10;
      MaxLength := 100;
      Width := 350;
      Height := 14;
      Ctl3d := FALSE;
      BorderStyle := bsSingle;
      Visible := FALSE;
   end;


   EdStoreMsgEdit  := TEdit.Create(FrmMain.Owner); //°³ÀÎ»óÁ¡
   with EdStoreMsgEdit do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Name := g_sCurFontName;
      Font.Color := clWhite;
      Font.Size := 8;
      MaxLength := 85;
      Width := 165;
      Height := 8;
      Ctl3d := FALSE;
      BorderStyle := bsNone;
      Visible := FALSE;
   end;
   EdStoreMacrosEdit := TEdit.Create(FrmMain.Owner); //°³ÀÎ»óÁ¡
   with EdStoreMacrosEdit do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Name := g_sCurFontName;
      Font.Color := clWhite;
      Font.Size := 8;
      MaxLength := 90;
      Width := 165;
      Height := 8;
      Ctl3d := FALSE;
      BorderStyle := bsNone;
      Visible := FALSE;
   end;

   ESitemName:= TEdit.Create (FrmMain.Owner);  //¹°¾à ºÐ¸® ÅØ½ºÆ®
   with ESitemName do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Name := g_sCurFontName;
      Font.Size := 10;
      MaxLength := 30;
      Ctl3d := FALSE;
      BorderStyle := bsNone;
      Visible := FALSE;
      Width := 140;
      Height := 12;
   end;

   EdHeroName := TEdit.Create(frmMain.Owner);
   with EdHeroName do begin
    Parent := frmMain;
    Height := 14;
    Width := 135;
    BorderStyle := bsNone;
    Color := clblack;
    Font.Color := clWhite;
    Font.Name := g_sCurFontName;
    Font.Size := 10;
    MaxLength := 14;
    Ctl3d := FALSE;
    Visible := False;
   end;

   EStoragePW1 := TEdit.Create(frmMain.Owner);
   with EStoragePW1 do begin
    Parent := frmMain;  Height := 12;
    BorderStyle := bsNone; Color := clblack; Font.Color := clWhite; MaxLength := 6;
    PasswordChar := '*'; Visible := False; OnKeyPress := EStoragePW1KeyPress;
    Font.Name := g_sCurFontName;
   end;

   EStoragePW2 := TEdit.Create(frmMain.Owner);
   with EStoragePW2 do begin
    Parent := frmMain;  Height := 12;
    BorderStyle := bsNone; Color := clblack; Font.Color := clWhite; MaxLength := 6;
    PasswordChar := '*'; Visible := False; OnKeyPress := EStoragePW1KeyPress;
    Font.Name := g_sCurFontName;
   end;

   EStoragePW3 := TEdit.Create(frmMain.Owner);
   with EStoragePW3 do begin
    Parent := frmMain;  Height := 12;
    BorderStyle := bsNone; Color := clblack; Font.Color := clWhite; MaxLength := 6;
    PasswordChar := '*'; Visible := False; OnKeyPress := EStoragePW1KeyPress;
    Font.Name := g_sCurFontName;
   end;

   Memo := TMemo.Create (FrmMain.Owner);
   with Memo do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Name := g_sCurFontName;
      Font.Size := 10;
      Ctl3d := FALSE;
      BorderStyle := bsNone;
      Visible := FALSE;
   end;

   // 2003/04/15 Ä£±¸, ÂÊÁö
   edCharID := TEdit.Create (FrmMain.Owner);
   with edCharID do begin
      Parent := FrmMain;  Color := clBlack; Font.Color := clWhite; Font.Size := 10; MaxLength := 14;
      Height := 16; Ctl3d := FALSE;  Font.Name := g_sCurFontName;
      BorderStyle := bsNone;  Visible := FALSE;
   end;

   memoMail := TMemo.Create (FrmMain.Owner);
   with memoMail do begin
      Parent := FrmMain;  Color := clBlack; Font.Color := clWhite; Font.Size := 10; MaxLength := 255;
      Ctl3d := FALSE; Font.Name := g_sCurFontName;
      BorderStyle := bsNone; Visible := FALSE;
   end;


   BBSMemo := TMemo.Create (FrmMain.Owner);
   with BBSMemo do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Name := g_sCurFontName;
      Font.Size := 10;
      Ctl3d := FALSE;
      BorderStyle := bsNone;
      Visible := FALSE;
      OnChange := BBSTextNotify;
   end;

   EdMacro1 := TEdit.Create(FrmMain.Owner);
  with EdMacro1 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 212 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Name := g_sCurFontName;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro2 := TEdit.Create(FrmMain.Owner);
  with EdMacro2 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 238 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Font.Name := g_sCurFontName;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro3 := TEdit.Create(FrmMain.Owner);
  with EdMacro3 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 264 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Font.Name := g_sCurFontName;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro4 := TEdit.Create(FrmMain.Owner);
  with EdMacro4 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 290 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Name := g_sCurFontName;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro5 := TEdit.Create(FrmMain.Owner);
  with EdMacro5 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 316 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Name := g_sCurFontName;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro6 := TEdit.Create(FrmMain.Owner);
  with EdMacro6 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 342 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Name := g_sCurFontName;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro7 := TEdit.Create(FrmMain.Owner);
  with EdMacro7 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 369 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Color   := clWhite;
    Font.Name := g_sCurFontName;
    Font.Color := clBlack;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
  EdMacro8 := TEdit.Create(FrmMain.Owner);
  with EdMacro8 do begin
    Parent  := FrmMain;
    Height  := 14;
    Width   := 416;
    Left    := 250 + (g_FScreenWidth - 800) div 2;
    Top     := 395 - 90 + (g_FScreenHeight - 600) div 2;
    BorderStyle := bsNone;
    Font.Name := g_sCurFontName;
    Color   := clWhite;
    Font.Color := clBlack;
    Font.Size := 9;
    MaxLength := 128;
    Visible := False;
    Ctl3d      := False;
  end;
end;

procedure TFrmDlg.FormDestroy(Sender: TObject);
begin
   TempsList.Free;
   RefGroupList.Free;
   DlgTemp.Free;
   MDlgPoints.Free;
   MDlgsier.Free;
   MenuList.Free;
   FreeAndNil(GuildStrs);
   FreeAndNil(GuildStrs2);
   FreeAndNil(GuildNotice);
   FreeAndNil(GuildMembers);
   FreeAndNil(GuildChats);
   FreeAndNil(HintList);
   FreeAndNil(m_TopMsgList);
   FreeAndNil(strlMacros);
end;

procedure TFrmDlg.HideAllControls;
var
   i: integer;
   c: TControl;
begin
   DlgTemp.Clear;
   with FrmMain do
      for i:=0 to ControlCount-1 do begin
         c := Controls[i];
         if c is TEdit then
            if (c.Visible) and (c <> EdDlgEdit) then begin
               DlgTemp.Add (c);
               c.Visible := FALSE;
            end;
      end;
end;

procedure TFrmDlg.RestoreHideControls;
var
   i: integer;
   c: TControl;
begin
   for i:=0 to DlgTemp.Count-1 do begin
      TControl(DlgTemp[i]).Visible := TRUE;
   end;
end;

procedure TFrmDlg.Initialize;          //°ÔÀÓÀ» ¸®½ºÅä¾îÇÒ¶§¸¶´Ù È£ÃâµÊ
var
   i: integer;
   d: TDirectDrawSurface;
begin
   if csDesigning in ComponentState then Exit;
   if Initialized then Exit;

   g_DWinMan.ClearAll;


   DBackground.Left := 0;
   DBackground.Top := 0;
   DBackground.Width := g_FScreenWidth;
   DBackground.Height := g_FScreenHeight;
   DBackground.Background := TRUE;
   g_DWinMan.AddDControl (DBackground, TRUE);

   {-----------------------------------------------------------}

   d := g_WMainImages.Images[360];
   if d <> nil then begin
      DMsgDlg.SetImgIndex (g_WMainImages, 360);
      DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DMsgDlgOk.SetImgIndex (g_WTitleImages, 200);
   DMsgDlgYes.SetImgIndex (g_WTitleImages, 206);
   DMsgDlgCancel.SetImgIndex (g_WTitleImages, 203);
   DMsgDlgNo.SetImgIndex (g_WTitleImages, 210);
   DMsgDlgOk.Top := 106;
   DMsgDlgYes.Top := 106;
   DMsgDlgCancel.Top := 106;
   DMsgDlgNo.Top := 106;

   d := g_WMainImages.Images[990];
   if d <> nil then begin
      DMsgSimpleDlg.SetImgIndex (g_WMainImages, 990);
      DMsgSimpleDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DMsgSimpleDlg.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DMsgSimpleDlgOk.SetImgIndex (g_WTitleImages, 116);
   DMsgSimpleDlgCancel.SetImgIndex (g_WTitleImages, 183);
   DMsgSimpleDlgOk.Top := 96;
   DMsgSimpleDlgCancel.Top := 96;


   d := g_WAresImages.Images[231];
   if d <> nil then begin
     DRenewChr.SetImgIndex(g_WAresImages, 231);
     DRenewChr.Left := (g_FScreenWidth - d.Width) div 2;
     DRenewChr.Top := (g_FScreenHeight - d.Height) div 2;
   end;
    DButRenewClose.SetImgIndex(g_WMain2Images, 360);
    DButRenewClose.Left := 333;
    DButRenewClose.Top := 3;
    DButRenewChr.SetImgIndex(g_WAresImages, 228);
    DButRenewChr.Left := 130;
    DButRenewChr.Top := 278;

   {-----------------------------------------------------------}
   if not g_InterfaceMode then begin
     d := g_WMainImages.Images[1084];
     if d <> nil then begin
       DLogIn.SetImgIndex (g_WMainImages, 1084);
       DLogIn.Left := (g_FScreenWidth - d.Width) div 2; //237;
       DLogIn.Top := (g_FScreenHeight - d.Height) div 2; //190;
     end;
     DLoginNew.SetImgIndex (g_WTitleImages, 323);
     DLoginNew.Left := 65;
     DLoginNew.Top  := 163;
     DLoginOk.SetImgIndex (g_WTitleImages, 320);
     DLoginOk.Left := 226;
     DLoginOk.Top := 82;
     DLoginChgPw.SetImgIndex (g_WTitleImages, 326);
     DLoginChgPw.Left := 167;
     DLoginChgPw.Top  := 163;
     DLoginClose.SetImgIndex (g_WTitleImages, 329);
     DLoginClose.Left := 167;
     DLoginClose.Top := 190;
     DLoginViewKey.SetImgIndex (g_WTitleImages, 332);
     DLoginViewKey.Left := 65;
     DLoginViewKey.Top := 190;
   end else begin
     d := g_WNewLoginImages.Images[664];
     if d <> nil then begin
       DLogIn.SetImgIndex (g_WNewLoginImages, 664);
       DLogIn.Left := (g_FScreenWidth - d.Width) div 2; //237;
       DLogIn.Top := (g_FScreenHeight - d.Height) div 2; //190;
     end;
     DLoginNew.SetImgIndex (g_WNewLoginImages, 588);
     DLoginNew.Left := 150;
     DLoginNew.Top  := 392;
     DLoginOk.SetImgIndex (g_WNewLoginImages, 669);
     DLoginOk.Left := 325;
     DLoginOk.Top := 340;
     DLoginChgPw.SetImgIndex (g_WNewLoginImages, 591);
     DLoginChgPw.Left := 330;
     DLoginChgPw.Top  := 392;
     DLoginClose.SetImgIndex (g_WNewLoginImages, 585);
     DLoginClose.Left := 510;
     DLoginClose.Top := 392;
     DLoginViewKey.SetImgIndex (g_WNewLoginImages, 623);
     DLoginViewKey.Left := 330;
     DLoginViewKey.Top := 438;
   end;
   {-----------------------------------------------------------}
   if not g_InterfaceMode then begin
      d := g_WMainImages.Images[256];
      if d <> nil then begin
         DSelServerDlg.SetImgIndex (g_WMainImages, 256);
         DSelServerDlg.Left := (g_FScreenWidth - d.Width) div 2;
         DSelServerDlg.Top := (g_FScreenHeight - d.Height) div 2;
      end;
      DSSrvClose.SetImgIndex (g_WMain2Images, 360);
      DSSrvClose.Left := 277;
      DSSrvClose.Top := 8;

      DSServer1.SetImgIndex (g_WMain2Images, 2);
      DSServer1.Left := 40;
      DSServer1.Top  := 75;

      DSServer2.SetImgIndex (g_WMain2Images, 2);
      DSServer2.Left := 48;
      DSServer2.Top  := 100;

      DSServer3.SetImgIndex (g_WMain2Images, 2);
      DSServer3.Left := 48;
      DSServer3.Top  := 145;

      DSServer4.SetImgIndex (g_WMain2Images, 2);
      DSServer4.Left := 48;
      DSServer4.Top  := 190;

      DSServer5.SetImgIndex (g_WMain2Images, 2);
      DSServer5.Left := 48;
      DSServer5.Top  := 235;

      DSServer6.SetImgIndex (g_WMain2Images, 2);
      DSServer6.Left := 48;
      DSServer6.Top  := 300;

      DSServer7.SetImgIndex (g_WMain2Images, 2);
      DSServer7.Left := 48;
      DSServer7.Top  := 345;

      DSServer8.SetImgIndex (g_WMain2Images, 2);
      DSServer8.Left := 48;
      DSServer8.Top  := 390;

      DEngServer1.Visible := FALSE;
      DSServer1.Visible := FALSE;
      DSServer2.Visible := FALSE;
      DSServer3.Visible := FALSE;
      DSServer4.Visible := FALSE;
      DSServer5.Visible := FALSE;
      DSServer6.Visible := FALSE;
      DSServer7.Visible := FALSE;
      DSServer8.Visible := FALSE;
   end else begin
      d := g_WNewLoginImages.Images[666];
      if d <> nil then begin
         DSelServerDlg.SetImgIndex (g_WNewLoginImages, 666);
         DSelServerDlg.Left := (g_FScreenWidth - d.Width) div 2;
         DSelServerDlg.Top := (g_FScreenHeight - d.Height) div 2;
      end;
      DSSrvClose.SetImgIndex (g_WMain2Images, 360);
      DSSrvClose.Left := 230;
      DSSrvClose.Top := 8;

      DSServer1.SetImgIndex (g_WNewLoginImages, 656);
      DSServer1.Left := 48;
      DSServer1.Top  := 55;

      DSServer2.SetImgIndex (g_WNewLoginImages, 656);
      DSServer2.Left := 48;
      DSServer2.Top  := 100;

      DSServer3.SetImgIndex (g_WNewLoginImages, 656);
      DSServer3.Left := 48;
      DSServer3.Top  := 145;

      DSServer4.SetImgIndex (g_WNewLoginImages, 656);
      DSServer4.Left := 48;
      DSServer4.Top  := 190;

      DSServer5.SetImgIndex (g_WNewLoginImages, 656);
      DSServer5.Left := 48;
      DSServer5.Top  := 235;

      DSServer6.SetImgIndex (g_WNewLoginImages, 656);
      DSServer6.Left := 48;
      DSServer6.Top  := 300;

      DSServer7.SetImgIndex (g_WNewLoginImages, 656);
      DSServer7.Left := 48;
      DSServer7.Top  := 345;

      DSServer8.SetImgIndex (g_WNewLoginImages, 656);
      DSServer8.Left := 48;
      DSServer8.Top  := 390;

      DEngServer1.Visible := FALSE;
      DSServer1.Visible := FALSE;
      DSServer2.Visible := FALSE;
      DSServer3.Visible := FALSE;
      DSServer4.Visible := FALSE;
      DSServer5.Visible := FALSE;
      DSServer6.Visible := FALSE;
      DSServer7.Visible := FALSE;
      DSServer8.Visible := FALSE;
   end;

   {-----------------------------------------------------------}

   //¾ÆÀÌµð»ý¼º ÀÌ¹ÌÁö
   d := g_WNewLoginImages.Images[681];
   if d <> nil then begin
      DNewAccount.SetImgIndex (g_WNewLoginImages, 681);
      DNewAccount.Left := (g_FScreenWidth - d.Width) div 2;
      DNewAccount.Top := (g_FScreenHeight - d.Height) div 2;
   end;

   DNewAccountOk.SetImgIndex (g_WNewLoginImages, 682);
   DNewAccountOk.Left := 79;
   DNewAccountOk.Top := 356;
   DNewAccountCancel.SetImgIndex (g_WNewLoginImages, 683);
   DNewAccountCancel.Left := 183;
   DNewAccountCancel.Top := 356;

   {-----------------------------------------------------------}

   //ÆÐ½º¿öµå º¯°æ ÀÌ¹ÌÁö
   d := g_WNewLoginImages.Images[678];
   if d <> nil then begin
      DChgPw.SetImgIndex (g_WNewLoginImages, 678);
      DChgPw.Left := (g_FScreenWidth - d.Width) div 2;
      DChgPw.Top  := (g_FScreenHeight - d.Height) div 2;
   end;
   DChgpwOk.SetImgIndex (g_WNewLoginImages, 679);
   DChgPwOk.Left := 79;
   DChgPwOk.Top := 170;
   DChgpwCancel.SetImgIndex (g_WNewLoginImages, 680);
   DChgPwCancel.Left := 183;
   DChgPwCancel.Top := 170;

   {-----------------------------------------------------------}

   //ÄÉ¸¯ÅÍ ¼±ÅÃÃ¢ ºÎºÐ
   DSelectChr.Left := 0;
   DSelectChr.Top := 0;
   DSelectChr.Width := g_FScreenWidth;
   DSelectChr.Height := g_FScreenHeight;

   if not g_InterfaceMode then begin
   DscStart.SetImgIndex (g_WTitleImages, 340);         //ÓÎÏ·¿ªÊ¼°´¼ü
   DscNewChr.SetImgIndex (g_WTitleImages, 343);
   DscEraseChr.SetImgIndex (g_WTitleImages, 346);
   DscCredits.SetImgIndex (g_WAresImages, 228);
   DscExit.SetImgIndex (g_WTitleImages, 352);

   DscStart.Left := GetScreenX(110);
   DscStart.Top := GetScreenY2(568);

   DscNewChr.Left := GetScreenX(230);
   DscNewChr.Top := GetScreenY2(568);

   DscEraseChr.Left := GetScreenX(350);
   DscEraseChr.Top := GetScreenY2(568);

   DscCredits.Left := GetScreenX(470);
   DscCredits.Top := GetScreenY2(568);

   DscExit.Left := GetScreenX(590);
   DscExit.Top := GetScreenY2(568);
   end else begin
   DscStart.SetImgIndex (g_WNewLoginImages, 672);
   DscNewChr.SetImgIndex (g_WNewLoginImages, 576);
   DscEraseChr.SetImgIndex (g_WNewLoginImages, 582);
   DscCredits.SetImgIndex (g_WNewLoginImages, 579);
   DscExit.SetImgIndex (g_WNewLoginImages, 585);

   DscStart.Left := GetScreenX(324);
   DscStart.Top := GetScreenY(480);

   DscNewChr.Left := GetScreenX(42);
   DscNewChr.Top := GetScreenY(544);

   DscEraseChr.Left := GetScreenX(232);
   DscEraseChr.Top := GetScreenY(544);

   DscCredits.Left := GetScreenX(430);
   DscCredits.Top := GetScreenY(544);

   DscExit.Left := GetScreenX(618);
   DscExit.Top := GetScreenY(544);
   end;
   {-----------------------------------------------------------}

   //Ä³¸¯ÅÍ »ý¼º
   if not g_InterfaceMode then begin
   d := g_WMainImages.Images[73];
   if d <> nil then begin
      DCreateChr.SetImgIndex (g_WMainImages, 73);
      DCreateChr.Left := (g_FScreenWidth - d.Width) div 2;
      DCreateChr.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DccWarrior.SetImgIndex (g_WMainImages, 2426);
   DccWizzard.SetImgIndex (g_WMainImages, 2429);
   DccMonk.SetImgIndex (g_WMainImages, 2432);
   DccAssassin.SetImgIndex (g_WMainImages, 2435);
   DccBonze.SetImgIndex (g_WAresImages, 497);
   DccMale.SetImgIndex (g_WMainImages, 2420);
   DccFemale.SetImgIndex (g_WMainImages, 2423);
   DccOk.SetImgIndex (g_WTitleImages, 360);
   DccClose.SetImgIndex (g_WTitleImages, 363);

   DccWarrior.Left := 323;
   DccWarrior.Top := 296;
   DccWizzard.Left := 373;
   DccWizzard.Top := 296;
   DccMonk.Left := 423;
   DccMonk.Top := 296;
   DccAssassin.Left := 473;
   DccAssassin.Top := 296;
   DccBonze.Left := 523;
   DccBonze.Top := 296;
   DccMale.Left := 323;
   DccMale.Top := 343;
   DccFemale.Left := 373;
   DccFemale.Top := 343;
   DccOk.Left := 152;
   DccOk.Top := 426;
   DccClose.Left := 380;
   DccClose.Top := 426;

   DWuxFront.Visible := False;
   DWuxNext.Visible := False;

   end else begin

   d := g_WNewLoginImages.Images[638];
   if d <> nil then begin
      DCreateChr.SetImgIndex (g_WNewLoginImages, 638);
      DCreateChr.Left := (g_FScreenWidth - d.Width) div 2;
      DCreateChr.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DccWarrior.SetImgIndex (g_WNewLoginImages, 596);
   DccWizzard.SetImgIndex (g_WNewLoginImages, 599);
   DccMonk.SetImgIndex (g_WNewLoginImages, 602);
   DccAssassin.SetImgIndex (g_WNewLoginImages, 605);
   DccBonze.SetImgIndex (g_WNewLoginImages, 611);
   DccMale.SetImgIndex (g_WNewLoginImages, 617);
   DccFemale.SetImgIndex (g_WNewLoginImages, 620);
   DccOk.SetImgIndex (g_WNewLoginImages, 639);
   DccClose.SetImgIndex (g_WNewLoginImages, 642);

   DccWarrior.Left := 57;
   DccWarrior.Top := 68;

   DccWizzard.Left := 113;
   DccWizzard.Top := 68;

   DccMonk.Left := 170;
   DccMonk.Top := 68;

   DccAssassin.Left := 57;
   DccAssassin.Top := 124;

   DccBonze.Left := 113;
   DccBonze.Top := 124;

   DccMale.Left := 85;
   DccMale.Top := 200;

   DccFemale.Left := 141;
   DccFemale.Top := 200;

   DccOk.Left := 58;
   DccOk.Top := 398;
   DccClose.Left := 148;
   DccClose.Top := 398;

   DWuxFront.SetImgIndex(g_WNewLoginImages, 684);
   DWuxNext.SetImgIndex(g_WNewLoginImages, 687);

   DWuxFront.Left := 85;
   DWuxFront.Top := 288;
   DWuxNext.Left := 172;
   DWuxNext.Top := 288;
   end;


   {-----------------------------------------------------------}



   //ÄÉ¸¯ÅÍ»óÅÂÃ¢
   d := g_WTitleImages.Images[504];
   if d <> nil then begin
      DStateWin.SetImgIndex (g_WTitleImages, 504);
      DStateWin.Left := g_FScreenWidth - d.Width;
      DStateWin.Top := 0;
   end;
      DSWNecklace.Left := 214;
      DSWNecklace.Top  := 190;
      DSWNecklace.Width := 34;
      DSWNecklace.Height := 31;

      DSWHelmet.Left := 214;
      DSWHelmet.Top  := 98;
      DSWHelmet.Width := 34;
      DSWHelmet.Height := 31;

      DSWLight.Left := 214;
      DSWLight.Top  := 226;
      DSWLight.Width := 34;
      DSWLight.Height := 31;

      DSWArmRingR.Left := 19;
      DSWArmRingR.Top  := 262;
      DSWArmRingR.Width := 34;
      DSWArmRingR.Height := 31;

      DSWArmRingL.Left := 214;
      DSWArmRingL.Top  := 262;
      DSWArmRingL.Width := 34;
      DSWArmRingL.Height := 31;

      DSWRingR.Left := 19;
      DSWRingR.Top  := 298;
      DSWRingR.Width := 34;
      DSWRingR.Height := 31;

      DSWRingL.Left := 214;
      DSWRingL.Top  := 298;
      DSWRingL.Width := 34;
      DSWRingL.Height := 31;

      DSWWeapon.Left := 134{46};
      DSWWeapon.Top  := 98{136};
      DSWWeapon.Width := 34;
      DSWWeapon.Height := 31;

      DSWDress.Left := 174;
      DSWDress.Top  := 98;
      DSWDress.Width := 34;
      DSWDress.Height := 31;

      DSWBujuk.Left := 18;
      DSWBujuk.Top  := 332;
      DSWBujuk.Width := 34;
      DSWBujuk.Height := 31;

      DSWBelt.Left := 96;
      DSWBelt.Top  := 332;
      DSWBelt.Width := 34;
      DSWBelt.Height := 31;

      DSWBoots.Left := 57;
      DSWBoots.Top  := 332;
      DSWBoots.Width := 34;
      DSWBoots.Height := 31;

      DSWCharm.Left := 134;
      DSWCharm.Top  := 332;
      DSWCharm.Width := 34;
      DSWCharm.Height := 31;

      DSWTiger.Left := 213;   //È£¶ûÀÌ
      DSWTiger.Top  := 154;
      DSWTiger.Width := 34;
      DSWTiger.Height := 31;

      DStMag1.Left := 52;
      DStMag1.Top := 130;
      DStMag1.Width := 31;
      DStMag1.Height := 33;

      DStMag2.Left := 52;
      DStMag2.Top := 163;
      DStMag2.Width := 31;
      DStMag2.Height := 33;

      DStMag3.Left := 52;
      DStMag3.Top := 196;
      DStMag3.Width := 31;
      DStMag3.Height := 33;

      DStMag4.Left := 52;
      DStMag4.Top := 229;
      DStMag4.Width := 31;
      DStMag4.Height := 33;

      DStMag5.Left := 52;
      DStMag5.Top := 262;
      DStMag5.Width := 31;
      DStMag5.Height := 33;

      DStMag6.Left := 52;
      DStMag6.Top := 295;
      DStMag6.Width := 31;
      DStMag6.Height := 33;

      DStPageUp.SetImgIndex (g_WMain2Images, 240);
      DStPageUp.Left := 89;
      DStPageUp.Top  := 339;

      DStPageDown.SetImgIndex (g_WMain2Images, 243);
      DStPageDown.Left := 155;
      DStPageDown.Top  := 339;

   DCloseState.SetImgIndex (g_WMain2Images, 360);
   DCloseState.Left := 240;
   DCloseState.Top := 2;

   DChar.SetImgIndex (g_WTitleImages, 500);
   DStatus.SetImgIndex (g_WTitleImages, 501);
   DState.SetImgIndex (g_WTitleImages, 502);
   DSkill.SetImgIndex (g_WTitleImages, 503);
   DChar.Left := 8;
   DChar.Top := 70;
   DStatus.Left := 70;
   DStatus.Top := 70;
   DState.Left := 132;
   DState.Top := 70;
   DSkill.Left := 194;
   DSkill.Top := 70;

   DHeartMyState.SetImgIndex (g_WMainImages, 604);


   {-----------------------------------------------------------}

  //¿µ¿õ»óÅÂÃ¢
  d := g_WTitleImages.Images[505];
  if d <> nil then begin
    DHeroStateWin.SetImgIndex(g_WTitleImages, 505);
    DHeroStateWin.Left := 0;
    DHeroStateWin.Top := 0;
  end;
  DCloseHeroState.SetImgIndex(g_WMain2Images, 360);
  DCloseHeroState.Left := 240;
  DCloseHeroState.Top := 2;

  DHeroChar.SetImgIndex (g_WTitleImages, 500);
  DHeroStatus.SetImgIndex (g_WTitleImages, 501);
  DHeroState.SetImgIndex (g_WTitleImages, 502);
  DHeroSkill.SetImgIndex (g_WTitleImages, 503);
  DHeroChar.Left := 8;
  DHeroChar.Top := 70;
  DHeroStatus.Left := 70;
  DHeroStatus.Top := 70;
  DHeroState.Left := 132;
  DHeroState.Top := 70;
  DHeroSkill.Left := 194;
  DHeroSkill.Top := 70;

  DHeroStMag1.Left := 52;
  DHeroStMag1.Top := 130;
  DHeroStMag1.Width := 31;
  DHeroStMag1.Height := 33;

  DHeroStMag2.Left := 52;
  DHeroStMag2.Top := 163;
  DHeroStMag2.Width := 31;
  DHeroStMag2.Height := 33;

  DHeroStMag3.Left := 52;
  DHeroStMag3.Top := 196;
  DHeroStMag3.Width := 31;
  DHeroStMag3.Height := 33;

  DHeroStMag4.Left := 52;
  DHeroStMag4.Top := 229;
  DHeroStMag4.Width := 31;
  DHeroStMag4.Height := 33;

  DHeroStMag5.Left := 52;
  DHeroStMag5.Top := 262;
  DHeroStMag5.Width := 31;
  DHeroStMag5.Height := 33;

  DHeroStMag6.Left := 52;
  DHeroStMag6.Top := 295;
  DHeroStMag6.Width := 31;
  DHeroStMag6.Height := 33;

  DHeroStPageUp.SetImgIndex(g_WMain2Images, 240);
  DHeroStPageUp.Left := 89;
  DHeroStPageUp.Top := 339;

  DHeroStPageDown.SetImgIndex(g_WMain2Images, 243);
  DHeroStPageDown.Left := 155;
  DHeroStPageDown.Top := 339;

  DHeroSWWeapon.Left := 134;
  DHeroSWWeapon.Top := 98;
  DHeroSWWeapon.Width := 34;
  DHeroSWWeapon.Height := 31;

  DHeroSWDress.Left := 174;
  DHeroSWDress.Top := 98;
  DHeroSWDress.Width := 34;
  DHeroSWDress.Height := 31;

  DHeroSWNecklace.Left := 214;
  DHeroSWNecklace.Top := 190;
  DHeroSWNecklace.Width := 34;
  DHeroSWNecklace.Height := 31;

  DHeroSWHelmet.Left := 214;
  DHeroSWHelmet.Top := 98;
  DHeroSWHelmet.Width := 34;
  DHeroSWHelmet.Height := 31;

  DHeroSWLight.Left := 214;
  DHeroSWLight.Top := 226;
  DHeroSWLight.Width := 34;
  DHeroSWLight.Height := 31;

  DHeroSWArmRingR.Left := 19;
  DHeroSWArmRingR.Top := 262;
  DHeroSWArmRingR.Width := 34;
  DHeroSWArmRingR.Height := 31;

  DHeroSWArmRingL.Left := 214;
  DHeroSWArmRingL.Top := 262;
  DHeroSWArmRingL.Width := 34;
  DHeroSWArmRingL.Height := 31;

  DHeroSWRingR.Left := 19;
  DHeroSWRingR.Top := 298;
  DHeroSWRingR.Width := 34;
  DHeroSWRingR.Height := 31;

  DHeroSWRingL.Left := 214;
  DHeroSWRingL.Top := 298;
  DHeroSWRingL.Width := 34;
  DHeroSWRingL.Height := 31;

  DHeroSWBujuk.Left := 18;
  DHeroSWBujuk.Top := 334;
  DHeroSWBujuk.Width := 34;
  DHeroSWBujuk.Height := 31;

  DHeroSWBelt.Left := 96;
  DHeroSWBelt.Top := 332;
  DHeroSWBelt.Width := 34;
  DHeroSWBelt.Height := 31;

  DHeroSWBoots.Left := 57;
  DHeroSWBoots.Top := 332;
  DHeroSWBoots.Width := 34;
  DHeroSWBoots.Height := 31;

  DHeroSWCharm.Left := 134;
  DHeroSWCharm.Top := 332;
  DHeroSWCharm.Width := 34;
  DHeroSWCharm.Height := 31;

  {-------------------------------------------------------------}
   d := g_WMainImages.Images[140];
     if d <> nil then begin
        DHeroControl.SetImgIndex(g_WMain2Images, 140);
        DHeroControl.Left := 149;
        DHeroControl.Top  := g_FScreenHeight - 138;
     end;

     DHeroHelp.SetImgIndex(g_WMain2Images, 141);
     DHeroHelp.Left := 12;
     DHeroHelp.Top := 4;

     DHeroCall.SetImgIndex(g_WMain2Images, 149);
     DHeroCall.Left := 26;
     DHeroCall.Top := 5;

     DHeroBack.SetImgIndex(g_WMain2Images, 153);
     DHeroBack.Left := 45;
     DHeroBack.Top := 5;

     DHeroDefen.SetImgIndex(g_WMain2Images, 145);
     DHeroDefen.Left := 61;
     DHeroDefen.Top := 5;


  {-------------------------------------------------------------}


  d := g_WMainImages.Images[1422];
  if d <> nil then begin
    DHeroItemBag.SetImgIndex(g_WMainImages, 1422);
    DHeroItemBag.Left := g_FScreenWidth - d.Width;
    DHeroItemBag.Top := 0;
    DHeroItemBag.Width := d.Width;
    DHeroItemBag.Height := d.Height;
  end;

  DHeroBagUp.SetImgIndex (g_WMain2Images, 277);
  DHeroBagUp.Left := 285;
  DHeroBagUp.Top := 194;

  DHeroItemGrid.Left := 14;
  DHeroItemGrid.Top := 22;
  DHeroItemGrid.Width := 285;
  DHeroItemGrid.Height := 32 * 5;

  DCloseHeroBag.SetImgIndex(g_WMain2Images, 360);
  DCloseHeroBag.Left := 303;
  DCloseHeroBag.Top := 1;

  DAuto1.SetImgIndex(g_WTitleImages, 560);
  DAuto1.Left := 59;
  DAuto1.Top := 207;

  DAuto1Per.Left := 59;
  DAuto1Per.Top := 233;
  DAuto1Per.Width := 60;
  DAuto1Per.Height := 20;

  DAuto2.SetImgIndex(g_WTitleImages, 560);
  DAuto2.Left := 207;
  DAuto2.Top := 207;

  DAuto2Per.Left := 207;
  DAuto2Per.Top := 233;
  DAuto2Per.Width := 60;
  DAuto2Per.Height := 20;

  DAutoPot1.Left := 122;
  DAutoPot1.Top := 213;
  DAutoPot1.Width := 32;
  DAutoPot1.Height := 29;

  DAutoPot2.Left := 166;
  DAutoPot2.Top := 213;
  DAutoPot2.Width := 32;
  DAutoPot2.Height := 29;

  d := g_WMainImages.Images[2179];
  if d <> nil then begin
    DHeroMenu.Left := g_FScreenWidth - 160;
    DHeroMenu.Top := 12;
    DHeroMenu.SetImgIndex(g_WMainImages, 2179);
  end;

  DButtonHeroSkill.SetImgIndex(g_WMainImages, 2173);
  DButtonHeroSkill.Left := 3;
  DButtonHeroSkill.Top := 3;

  DButtonHeroBag.SetImgIndex(g_WMainImages, 2170);
  DButtonHeroBag.Left := 3;
  DButtonHeroBag.Top := 20;

  DButtonHeroState.SetImgIndex(g_WMainImages, 2176);
  DButtonHeroState.Left := 3;
  DButtonHeroState.Top := 37;

   {-----------------------------------------------------------}
   //¾ÆÀÌÅÛ ³»±¸µµ
   d := g_WMainImages.Images[2161];
   if d <> nil then begin
      DItmeDuraWin.SetImgIndex (g_WMainImages, 2161);
      DItmeDuraWin.Left := g_FScreenWidth - 60;
      DItmeDuraWin.Top  := 226;
   end;

   //¾ÆÀÌÅÛ ³»±¸µµ2
   d := g_WMainImages.Images[2161];
   if d <> nil then begin
      DItmeDuraWin2.SetImgIndex (g_WMainImages, 2161);
      DItmeDuraWin2.Left := g_FScreenWidth - 60;
      DItmeDuraWin2.Top  := 310;
   end;
   {-----------------------------------------------------------}

   //»ó´ë¹æ Á¤º¸
   d := g_WMain2Images.Images[314];
   if d <> nil then begin
      DUserInfo.SetImgIndex (g_WMain2Images, 314);
      DUserInfo.Left := (g_FScreenWidth - d.Width) div 2;
      DUserInfo.Top  := (g_FScreenHeight - d.Height) div 2;
   end;
   DUserInfoExit.SetImgIndex (g_WMain2Images, 360);
   DUserInfoExit.Left := 251;
   DUserInfoExit.Top := 2;

   DPrevInfo.SetImgIndex(g_WMain2Images, 240);
   DPrevInfo.Left := 95;
   DPrevInfo.Top := 293;

   DNextInfo.SetImgIndex(g_WMain2Images, 243);
   DNextInfo.Left := 164;
   DNextInfo.Top := 293;

   //»ó´ë¹æ ¾ÆÀÌÅÛ Âø¿ë »óÅÂÃ¢
   d := g_WMainImages.Images[371];
   if d <> nil then begin
      DUserState1.SetImgIndex (g_WMainImages, 430);
      DUserState1.Left := 200;
      DUserState1.Top := 0;
   end;

      DWeaponUS1.Left := 134;    //¹«±â
      DWeaponUS1.Top  := 98;
      DWeaponUS1.Width := 34;
      DWeaponUS1.Height := 31;

      DDressUS1.Left := 174;    //¿Ê
      DDressUS1.Top  := 98;
      DDressUS1.Width := 34;
      DDressUS1.Height := 31;

      DHelmetUS1.Left := 214;    //Åõ±¸
      DHelmetUS1.Top  := 98;
      DHelmetUS1.Width := 34;
      DHelmetUS1.Height := 31;

      DNecklaceUS1.Left := 214;    //¸ñ°Å¸®
      DNecklaceUS1.Top  := 190;
      DNecklaceUS1.Width := 34;
      DNecklaceUS1.Height := 31;

      DLightUS1.Left := 214;           //È¶ºÒ
      DLightUS1.Top  := 226;
      DLightUS1.Width := 34;
      DLightUS1.Height := 31;

      DArmRingRUS1.Left := 19;      //¿À¸¥ÂÊÆÈÂî
      DArmRingRUS1.Top  := 262;
      DArmRingRUS1.Width := 34;
      DArmRingRUS1.Height := 31;

      DArmRingLUS1.Left := 214;       //¿ÞÂÊÆÈÂî
      DArmRingLUS1.Top  := 262;
      DArmRingLUS1.Width := 34;
      DArmRingLUS1.Height := 31;
      
      DRingRUS1.Left := 19;              //¿À¸¥ÂÊ¹ÝÁö
      DRingRUS1.Top  := 298;
      DRingRUS1.Width := 34;
      DRingRUS1.Height := 31;

      DRingLUS1.Left := 214;             //¿ÞÂÊ¹ÝÁö
      DRingLUS1.Top  := 298;
      DRingLUS1.Width := 34;
      DRingLUS1.Height := 31;

      DBujukUS1.Left := 18;
      DBujukUS1.Top  := 332;                 //ºÎÀû
      DBujukUS1.Width := 34;
      DBujukUS1.Height := 31;

      DBootsUS1.Left := 57;
      DBootsUS1.Top  := 332;                 //½Å¹ß
      DBootsUS1.Width := 34;
      DBootsUS1.Height := 31;

      DBeltUS1.Left := 96;                     //º§Æ®
      DBeltUS1.Top  := 332;
      DBeltUS1.Width := 34;
      DBeltUS1.Height := 31;

      DCharmUS1.Left := 134;
      DCharmUS1.Top  := 332;
      DCharmUS1.Width := 34;               //¼öÈ£¼®
      DCharmUS1.Height := 31;

      DTigerUS1.Left := 213;       //È£¶ûÀÌ
      DTigerUS1.Top  := 154;
      DTigerUS1.Width := 34;
      DTigerUS1.Height := 31;

   // »ó´ë¹æÃ¢ ÇÁ·£µå, ÂÊÁö , ±×·ì
   DUSFriend.Left := 86;    //Ä£±¸
   DUSFriend.Top := 379;
   DUSFriend.SetImgIndex (g_WMainImages, 431);

   DUSGroup.Left := 118;     //±×·ì
   DUSGroup.Top := 379;
   DUSGroup.SetImgIndex (g_WMainImages, 434);

   DUSMail.Left := 150;        //ÂÊÁö
   DUSMail.Top := 379;
   DUSMail.SetImgIndex (g_WMainImages, 437);


   DCloseUS1.SetImgIndex (g_WMain2Images, 360);
   DCloseUS1.Left := 240;
   DCloseUS1.Top := 2;   //´Ý±â


   DUser2.SetImgIndex (g_WTitleImages, 406);
   DUser2.Left := 226;
   DUser2.Top := 32;   //´Ý±â

   DLoverHeart.SetImgIndex (g_WMainImages, 604);
  {-------------------------------------------------------------}

   //°¡¹æÃ¢
   DItemBag.SetImgIndex (g_WTitleImages, 196);
   DItemBag.Left := 0;
   DItemBag.Top := 0;
    //°¡¹æÅÛ ÁÂÇ¥ ¼³Á¤ Ã¹¹øÂ°
   DItemGrid.Left := 8;
   DItemGrid.Top  := 37;
   DItemGrid.Width := 295;
   DItemGrid.Height := 162;

   BoUpItemEffect := FALSE;       //º¸¿Á
   DButBagMode1.SetImgIndex (g_WTitleImages, 197);
   DButBagMode1.Left := 7;
   DButBagMode1.Top  := 7;

   DGold.SetImgIndex (g_WMainImages, 29);
   DGold.Left := 25;
   DGold.Top  := 210;

   DBotUp.SetImgIndex (g_WMain2Images, 277);
   DBotUp.Left := 259;
   DBotUp.Top := 2;

   DClosebag.SetImgIndex (g_WMain2Images, 360);
   DCloseBag.Left := 289;
   DCloseBag.Top := 3;
   DCloseBag.Width := 15;
   DCloseBag.Height := 20;
  {-------------------------------------------------------------}
  //Àå¿ø¸ñ·Ï
  DGTList.SetImgIndex(g_WMainImages, 680);
  DGTList.Left := 0;
  DGTList.Top := 223;

  DGTListClose.SetImgIndex(g_WMain2Images, 360);
  DGTListClose.Left := 544;
  DGTListClose.Top := 3;

  DGTListPrev.SetImgIndex(g_WMain2Images, 240);
  DGTListPrev.Left :=240;
  DGTListPrev.Top := 211;

  DGTListNext.SetImgIndex(g_WMain2Images, 243);
  DGTListNext.Left :=310;
  DGTListNext.Top := 211;

  DGTListMail.SetImgIndex(g_WMainImages, 666);
  DGTListMail.Left :=385;
  DGTListMail.Top := 207;

  //»óÇö ÁÖ¸Ó´Ï
  DDecoListDlg.SetImgIndex(g_WMainImages, 702);
  DDecoListDlg.Left := 0;
  DDecoListDlg.Top  := 20;

  DDecoListExit.SetImgIndex(g_WMain2Images, 360);
  DDecoListExit.Left := 573;
  DDecoListExit.Top  := 4;

  DDecoListPrev.SetImgIndex(g_WMain2Images, 240);
  DDecoListPrev.Left := 247;
  DDecoListPrev.Top  := 384;

  DDecoListNext.SetImgIndex(g_WMain2Images, 243);
  DDecoListNext.Left := 365;
  DDecoListNext.Top  := 384;

  DDecoListBuy.SetImgIndex (g_WTitleImages, 312);
  DDecoListBuy.Left := 194;
  DDecoListBuy.Top  := 323;

  DDecoListCancel.SetImgIndex (g_WTitleImages, 315);
  DDecoListCancel.Left := 194;
  DDecoListCancel.Top  := 350;


  //Àå¿ø°Ô½ÃÆÇ
  DBBSListDlg.SetImgIndex(g_WMainImages, 688);
  DBBSListDlg.Left := 0;
  DBBSListDlg.Top  := 40;

  DBBSListClose.SetImgIndex(g_WMain2Images, 360);
  DBBSListClose.Left := 464;
  DBBSListClose.Top  := 3;

  DBBSListPrev.SetImgIndex(g_WMain2Images, 240);
  DBBSListPrev.Left := 214;
  DBBSListPrev.Top  := 272;

  DBBSListNext.SetImgIndex(g_WMain2Images, 243);
  DBBSListNext.Left := 282;
  DBBSListNext.Top  := 272;

  DBBSListRefresh.SetImgIndex(g_WMainImages, 663);
  DBBSListRefresh.Left := 380;
  DBBSListRefresh.Top  := 292;

  DBBSListOk.SetImgIndex(g_WTitleImages, 296);
  DBBSListOk.Left := 128;
  DBBSListOk.Top  := 292;

  DBBSListWrite.SetImgIndex(g_WTitleImages, 370);
  DBBSListWrite.Left := 212;
  DBBSListWrite.Top  := 292;

  DBBSListNotice.SetImgIndex(g_WTitleImages, 373);
  DBBSListNotice.Left := 296;
  DBBSListNotice.Top  := 292;

  //Àå¿ø°Ô½Ã±Û
  DBBSMsgDlg.SetImgIndex(g_WMainImages, 689);
  DBBSMsgDlg.Left := 200;
  DBBSMsgDlg.Top  := 150;

  DBBSMsgClose.SetImgIndex(g_WMain2Images, 360);
  DBBSMsgClose.Left := 324;
  DBBSMsgClose.Top  := 3;

  DBBSMsgDelete.SetImgIndex(g_WTitleImages, 376);
  DBBSMsgDelete.Left :=38;
  DBBSMsgDelete.Top  := 222;

  DBBSMsgMail.SetImgIndex(g_WMainImages, 663);
  DBBSMsgMail.Left := 87;
  DBBSMsgMail.Top  := 222;

  DBBSMsgReply.SetImgIndex(g_WTitleImages, 379);
  DBBSMsgReply.Left := 120;
  DBBSMsgReply.Top  := 222;

  DBBSMsgOk.SetImgIndex(g_WTitleImages, 382);
  DBBSMsgOk.Left := 168;
  DBBSMsgOk.Top  := 222;

  DBBSMsgCancel.SetImgIndex(g_WTitleImages, 385);
  DBBSMsgCancel.Left := 216;
  DBBSMsgCancel.Top  := 222;



  {-----------------------------------------------------------}
  {¸ÅÅ©·Î}
  d := g_WMainImages.Images[210];
  if d <> nil then begin
    DMacros.Left := (g_FScreenWidth - d.Width) div 2;
    DMacros.Top := (g_FScreenHeight - d.Height) div 2 - 80;
    DMacros.SetImgIndex(g_WMainImages, 210);
  end;
  MacrosX := DMacros.Left;
  MacrosY := DMacros.Top;

  DMacrosOK.SetImgIndex(g_WTitleImages, 156);
  DMacrosOK.Left := 190;
  DMacrosOK.Top := 280;

  DMacrosCancel.SetImgIndex(g_WTitleImages, 363);
  DMacrosCancel.Left := 368;
  DMacrosCancel.Top := 280;

  {-----°ø¿ëÃ¢°í--------------------------------------------------}

   DComStorage.SetImgIndex (g_WMainImages, 1110);
   DComStorage.Left := 80;
   DComStorage.Top := 200;

   DGetComStorage.SetImgIndex (g_WTitleImages, 270);
   DGetComStorage.Left := 208;
   DGetComStorage.Top := 185;

   DComStorageExit.SetImgIndex (g_WMain2Images, 360);
   DComStorageExit.Left := 312;
   DComStorageExit.Top := 3;

   DStorageRefresh.SetImgIndex(g_WMainImages, 663);
   DStorageRefresh.Left := 170;
   DStorageRefresh.Top := 185;

   DCS1.Left := 108;
   DCS1.Top := 43;
   DCS1.Width := 37;
   DCS1.Height := 34;

   DCS2.Left := 151;
   DCS2.Top := 43;
   DCS2.Width := 37;
   DCS2.Height := 34;

   DCS3.Left := 195;
   DCS3.Top := 43;
   DCS3.Width := 37;
   DCS3.Height := 34;

   DCS4.Left := 73;
   DCS4.Top := 85;
   DCS4.Width := 37;
   DCS4.Height := 34;

   DCS5.Left := 112;
   DCS5.Top := 85;
   DCS5.Width := 37;
   DCS5.Height := 34;

   DCS6.Left := 151;
   DCS6.Top := 85;
   DCS6.Width := 37;
   DCS6.Height := 34;

   DCS7.Left := 190;
   DCS7.Top := 85;
   DCS7.Width := 37;
   DCS7.Height := 34;

   DCS8.Left := 228;
   DCS8.Top := 85;
   DCS8.Width := 37;
   DCS8.Height := 34;

  {-----¹®ÆÄÃ¢°í--------------------------------------------------}

   DGuildStorage.SetImgIndex (g_WMain2Images, 300);
   DGuildStorage.Left := 0;
   DGuildStorage.Top := 0;

   DGetGuildStorage.SetImgIndex (g_WTitleImages, 270);
   DGetGuildStorage.Left := 302;
   DGetGuildStorage.Top := 457;

   DGuildStorageExit.SetImgIndex (g_WMain2Images, 360);
   DGuildStorageExit.Left := 370;
   DGuildStorageExit.Top := 4;

   DGuildStorageRe.SetImgIndex(g_WMainImages, 663);
   DGuildStorageRe.Left := 270;
   DGuildStorageRe.Top := 457;

   DGGuildStorage.Left := 12;
   DGGuildStorage.Top  := 120;
   DGGuildStorage.Width := 370;
   DGGuildStorage.Height := 165;


  {-------------------------------------------------------------}
  //À§Å¹

   DSales.SetImgIndex (g_WTitleImages, 690);
   DSales.Left := 0;
   DSales.Top := 0;

   DSalesExit.SetImgIndex (g_WMain2Images, 360);   //À§Å¹ Á¾·á
   DSalesExit.Left := 466;
   DSalesExit.Top := 3;


   DBotAucFind.SetImgIndex (g_WTitleImages, 692);   //°Ë»ö¹öÆ°
   DBotAucFind.Left := 9;
   DBotAucFind.Top := 32;

   DBotAuction.SetImgIndex (g_WTitleImages, 695);   //À§Å¹¹öÆ°
   DBotAuction.Left := 104;
   DBotAuction.Top := 32;


   DAuc0.SetImgIndex(g_WMain2Images, 920);  //ÀüÃ¼
   DAuc0.Left:=7;
   DAuc0.Top:=60;
   DAuc1.SetImgIndex(g_WMain2Images, 920);  //¹«±â
   DAuc1.Left:=7;
   DAuc1.Top:=60+24;

   DAuc2.SetImgIndex(g_WMain2Images, 920);    //¹æ¾î±¸
   DAuc2.Left:=7;
   DAuc2.Top:=60+24*2;
   DAuc3.SetImgIndex(g_WMain2Images, 922);  //Åõ±¸
   DAuc3.Left:=7;
   DAuc3.Top:=60+24*3;
   DAuc4.SetImgIndex(g_WMain2Images, 922);  //°©¿Ê
   DAuc4.Left:=7;
   DAuc4.Top:=60+24*4;
   DAuc5.SetImgIndex(g_WMain2Images, 922);    //Çã¸®¶ì
   DAuc5.Left:=7;
   DAuc5.Top:=60+24*5;
   DAuc6.SetImgIndex(g_WMain2Images, 922);    //½Å¹ß
   DAuc6.Left:=7;
   DAuc6.Top:=60+24*6;

   DAuc7.SetImgIndex(g_WMain2Images, 920);    //Àå½Å±¸
   DAuc7.Left:=7;
   DAuc7.Top:=60+24*3;
   DAuc8.SetImgIndex(g_WMain2Images, 922);  //¸ñ°ÉÀÌ
   DAuc8.Left:=7;
   DAuc8.Top:=60+24*4;
   DAuc9.SetImgIndex(g_WMain2Images, 922);  //¹ÝÁö
   DAuc9.Left:=7;
   DAuc9.Top:=60+24*5;
   DAuc10.SetImgIndex(g_WMain2Images, 922);    //ÆÈÂî&Àå°©
   DAuc10.Left:=7;
   DAuc10.Top:=60+24*6;
   DAuc11.SetImgIndex(g_WMain2Images, 922);    //¼öÈ£¼®
   DAuc11.Left:=7;
   DAuc11.Top:=60+24*7;


   DAuc12.SetImgIndex(g_WMain2Images, 920);    //¼Ò¸ðÇ°
   DAuc12.Left:=7;
   DAuc12.Top:=60+24*4;
   DAuc13.SetImgIndex(g_WMain2Images, 922);  //È¸º¹
   DAuc13.Left:=7;
   DAuc13.Top:=60+24*5;
   DAuc14.SetImgIndex(g_WMain2Images, 922);  //°­È­
   DAuc14.Left:=7;
   DAuc14.Top:=60+24*6;
   DAuc15.SetImgIndex(g_WMain2Images, 922);    //¼ö¸®
   DAuc15.Left:=7;
   DAuc15.Top:=60+24*7;
   DAuc16.SetImgIndex(g_WMain2Images, 922);    //ÀÌµ¿¼­
   DAuc16.Left:=7;
   DAuc16.Top:=60+24*8;
   DAuc17.SetImgIndex(g_WMain2Images, 922);    //±âÅ¸
   DAuc17.Left:=7;
   DAuc17.Top:=60+24*9;


   DAuc18.SetImgIndex(g_WMain2Images, 920);    //Àåºñ°­È­
   DAuc18.Left:=7;
   DAuc18.Top:=60+24*5;
   DAuc19.SetImgIndex(g_WMain2Images, 922);  //º¸¿Á
   DAuc19.Left:=7;
   DAuc19.Top:=60+24*6;
   DAuc20.SetImgIndex(g_WMain2Images, 922);  //½ÅÁÖ
   DAuc20.Left:=7;
   DAuc20.Top:=60+24*7;
   DAuc21.SetImgIndex(g_WMain2Images, 922);    //Ãàº¹ÀÇ±â¸§
   DAuc21.Left:=7;
   DAuc21.Top:=60+24*8;
   DAuc22.SetImgIndex(g_WMain2Images, 922);    //±¤¼®
   DAuc22.Left:=7;
   DAuc22.Top:=60+24*9;
   DAuc32.SetImgIndex(g_WMain2Images, 922);    //°¢¼º
   DAuc32.Left:=7;
   DAuc32.Top:=60+24*10;


   DAuc23.SetImgIndex(g_WMain2Images, 920);    //¹«°øÃ¥
   DAuc23.Left:=7;
   DAuc23.Top:=60+24*6;
   DAuc24.SetImgIndex(g_WMain2Images, 922);  //Àü»ç°è¿­
   DAuc24.Left:=7;
   DAuc24.Top:=60+24*7;
   DAuc25.SetImgIndex(g_WMain2Images, 922);  //¼ú»ç°è¿­
   DAuc25.Left:=7;
   DAuc25.Top:=60+24*8;
   DAuc26.SetImgIndex(g_WMain2Images, 922);    //µµ»ç°è¿­
   DAuc26.Left:=7;
   DAuc26.Top:=60+24*9;
   DAuc27.SetImgIndex(g_WMain2Images, 922);    //ÀÚ°´°è¿­
   DAuc27.Left:=7;
   DAuc27.Top:=60+24*10;
   DAuc31.SetImgIndex(g_WMain2Images, 922);    //½Â·Á°è¿­
   DAuc31.Left:=7;
   DAuc31.Top:=60+24*11;

   DAuc28.SetImgIndex(g_WMain2Images, 920);    //Äù½ºÆ®
   DAuc28.Left:=7;
   DAuc28.Top:=60+24*7;

   DAuc29.SetImgIndex(g_WMain2Images, 920);    //±âÅ¸
   DAuc29.Left:=7;
   DAuc29.Top:=60+24*8;

   DAuc30.SetImgIndex(g_WMain2Images, 920);    //ÃÊ±âÈ­
   DAuc30.Left:=7;
   DAuc30.Top:=60+24*15;


   DAuctionSort.SetImgIndex (g_WTitleImages, 696);   //À§Å¹ °¡°ÝÁ¤·Ä
   DAuctionSort.Left := 312;
   DAuctionSort.Top := 60;

   DSalesBuy.SetImgIndex (g_WTitleImages, 703);     //À§Å¹ÇÑ¹°Ç°±¸¸Å
   DSalesBuy.Left := 378;
   DSalesBuy.Top := 448;

   DSalesFind.SetImgIndex (g_WTitleImages, 480);     //À§Å¹¹°Ç°°Ë»ö
   DSalesFind.Left := 122;
   DSalesFind.Top := 448;

   DSalesMail.SetImgIndex (g_WMainImages, 620);    //À§Å¹ÂÊÁö
   DSalesMail.Left := 171;
   DSalesMail.Top := 448;

   DSalesRefresh.SetImgIndex(g_WMainImages, 663);    //À§Å¹»õ·Î°íÄ§
   DSalesRefresh.Left := 199;
   DSalesRefresh.Top := 448;

   DSalesNextPage.SetImgIndex(g_WMain2Images, 243);
   DSalesNextPage.Left := 322;
   DSalesNextPage.Top := 420;

   DSalesPrevPage.SetImgIndex(g_WMain2Images, 240);
   DSalesPrevPage.Left := 253;
   DSalesPrevPage.Top := 420;

   DAuction.SetImgIndex(g_WTitleImages, 700);        //À§Å¹ÇÏ±â
   DAuction.Left := 14;
   DAuction.Top := 192;

   DAuctionCancel.SetImgIndex(g_WTitleImages, 590);  //À§Å¹Ãë¼Ò
   DAuctionCancel.Left := 68;
   DAuctionCancel.Top := 192;

    //À§Å¹ ¾ÆÀÌÅÛ ÀÌ¹ÌÁö
   DAuctionSpot.Left := 50;
   DAuctionSpot.Top := 105;
   DAuctionSpot.Width := 34;
   DAuctionSpot.Height := 30;

   {-----------------------------------------------------------}
   //¿É¼ÇÃ¢

   DOptions.SetImgIndex (g_WAresImages, 285);
   DOptions.Left := (g_FScreenWidth div 2) - ((DOptions.Width) div 2);
   DOptions.Top := (g_FScreenHeight div 2) - ((DOptions.Height) div 2) - 65;

   DOptionsClose.SetImgIndex (g_WMain2Images, 360);
   DOptionsClose.Left := 233;
   DOptionsClose.Top := 3;

   DOptionsSkillMode1.Left := 161;
   DOptionsSkillMode1.Top := 42;

   DOptionsSkillMode2.Left := 203;
   DOptionsSkillMode2.Top := 42;

   DOptionsSkillBarOn.Left := 161;
   DOptionsSkillBarOn.Top := 67;

   DOptionsSkillBarOff.Left := 203;
   DOptionsSkillBarOff.Top := 67;

   DOptionsEffectOn.Left := 161;
   DOptionsEffectOn.Top := 92;

   DOptionsEffectOff.Left := 203;
   DOptionsEffectOff.Top := 92;

   DOptionsSoundOn.Left := 161;
   DOptionsSoundOn.Top := 115;

   DOptionsMp3On.Left := 161;
   DOptionsMp3On.Top := 141;

   DOptionsDropViewOn.Left := 161;
   DOptionsDropViewOn.Top := 166;

   DOptionsDropViewOff.Left := 203;
   DOptionsDropViewOff.Top := 166;

   DOptionsNameAllViewOn.Left := 161;
   DOptionsNameAllViewOn.Top := 191;

   DOptionsNameAllViewOff.Left := 203;
   DOptionsNameAllViewOff.Top := 191;

   DNameChNP.Left := 120;
   DNameChNP.Top := 216;

   DNameMon.Left := 203;
   DNameMon.Top := 216;

   DOptionsHPView1.Left := 161;
   DOptionsHPView1.Top := 241;

   DOptionsHPView2.Left := 203;
   DOptionsHPView2.Top := 241;

   DOptionsFull.Left := 161;
   DOptionsFull.Top := 267;

   DOptionsWin.Left := 203;
   DOptionsWin.Top := 267;

   DOptionsHintOn.Left := 161;
   DOptionsHintOn.Top := 292;

   DOptionsHintOff.Left := 203;
   DOptionsHintOff.Top := 292;

   DOptionsScreen1.Left := 161;
   DOptionsScreen1.Top := 316;

   DOptionsScreen2.Left := 203;
   DOptionsScreen2.Top := 316;

   {-----------------------------------------------------------}
   //¹«°ø¹Ù
   DSkillBar.Left := 0;
   DSkillBar.Top := 0;

   DSkillBar1.Left := 15;
   DSkillBar1.Top := 3;

   DSkillBar2.Left :=40;
   DSkillBar2.Top := 3;

   DSkillBar3.Left := 65;
   DSkillBar3.Top := 3;

   DSkillBar4.Left := 90;
   DSkillBar4.Top := 3;

   DSkillBar5.Left := 115;
   DSkillBar5.Top := 3;

   DSkillBar6.Left := 140;
   DSkillBar6.Top := 3;

   DSkillBar7.Left := 165;
   DSkillBar7.Top := 3;

   DSkillBar8.Left := 190;
   DSkillBar8.Top := 3;

   {-----------------------------------------------------------}

   //¹«°ø¹Ù
   DHeroSkillBar.Left := DSkillBar.Width + 1;
   DHeroSkillBar.Top := 0;

   DHSkillBar1.Left := 3;
   DHSkillBar1.Top := 3;

   DHSkillBar2.Left :=28;
   DHSkillBar2.Top := 3;

   DHSkillBar3.Left := 53;
   DHSkillBar3.Top := 3;

   DHSkillBar4.Left := 78;
   DHSkillBar4.Top := 3;

   DHSkillBar5.Left := 103;
   DHSkillBar5.Top := 3;

   DHSkillBar6.Left := 128;
   DHSkillBar6.Top := 3;

   DHSkillBar7.Left := 153;
   DHSkillBar7.Top := 3;
   {-----------------------------------------------------------}

   DTopMsg.Left := 240;
   DTopMsg.Top := 28;
   DTopMsg.Width := 320 + (g_FScreenWidth - DEFSCREENWIDTH);
   DTopMsg.Height := 16;

   //ÇÏ´Ü Dbottom ºÎºÐ
   if g_FScreenWidth = 800 then begin
     d := g_WMainImages.Images[BOTTOMBOARD800];       //ÀÎÅÍÆäÀÌ½º DBottom ºÎºÐ
   end else begin
     d := g_WAresImages.Images[BOTTOMBOARD1024];
   end;
   if d <> nil then begin
      DBottom.Left := 0;
      DBottom.Top  := g_FScreenHeight - d.Height;
      DBottom.Width := d.Width;
      DBottom.Height := d.Height;
   end;

   {-----------------------------------------------------------}

   DBTCheck1.SetImgIndex(g_WAresImages, 201);
   DBTCheck1.Left := 380;
   DBTCheck1.Top := -(DBottom.Top - 162) - 61;

   DBTCheck2.SetImgIndex(g_WAresImages, 201);
   DBTCheck2.Left := 380;
   DBTCheck2.Top := -(DBottom.Top - 162) - 61;

   DBTCheck3.SetImgIndex(g_WAresImages, 201);
   DBTCheck3.Left := 380;
   DBTCheck3.Top := -(DBottom.Top - 162) - 61;

   DBTCheck4.SetImgIndex(g_WAresImages, 201);
   DBTCheck4.Left := 380;
   DBTCheck4.Top := -(DBottom.Top - 162) - 61;

   DBTCheck5.SetImgIndex(g_WAresImages, 201);
   DBTCheck5.Left := 380;
   DBTCheck5.Top := -(DBottom.Top - 162) - 61;

   DBTCheck6.SetImgIndex(g_WAresImages, 201);
   DBTCheck6.Left := 380;
   DBTCheck6.Top := -(DBottom.Top - 162) - 61;

   DBTCheck7.SetImgIndex(g_WAresImages, 201);
   DBTCheck7.Left := 380;
   DBTCheck7.Top := -(DBottom.Top - 162) - 61;

   DBTCheck8.SetImgIndex(g_WAresImages, 201);
   DBTCheck8.Left := 380;
   DBTCheck8.Top := -(DBottom.Top - 162) - 61;

   DBTCheck9.SetImgIndex(g_WAresImages, 201);
   DBTCheck9.Left := 380;
   DBTCheck9.Top := -(DBottom.Top - 162) - 61;

   DBTCheck10.SetImgIndex(g_WAresImages, 201);
   DBTCheck10.Left := 380;
   DBTCheck10.Top := -(DBottom.Top - 162) - 61;



   //ÀÎÅÍÆäÀÌ½º
   DMyState.SetImgIndex (g_WMainImages, 1900);
   DMyState.Left := g_FScreenWidth - 120;
   DMyState.Top := 76;
   DMyBag.SetImgIndex (g_WMainImages, 1903);
   DMyBag.Left := g_FScreenWidth - 96;
   DMyBag.Top := 76;
   DMyMagic.SetImgIndex (g_WMainImages, 1906);
   DMyMagic.Left := g_FScreenWidth - 73;
   DMyMagic.Top := 76;
   DBotQuest.SetImgIndex (g_WMainImages,1909);      //ÁØºñÁß
   DBotQuest.Left := g_FScreenWidth - 50;
   DBotQuest.Top := 76;
   DOption.SetImgIndex (g_WMainImages, 1912);
   DOption.Left := g_FScreenWidth - 28;
   DOption.Top := 76;

   DButtonMenuHero.SetImgIndex(g_WMainImages, 2164);
   DButtonMenuHero.Left := g_FScreenWidth - 159;
   DButtonMenuHero.Top := 65;

   DButtonReCallHero.SetImgIndex(g_WMainImages, 2167);
   DButtonReCallHero.Left := g_FScreenWidth - 159;
   DButtonReCallHero.Top := 89;


   if DSayUpDown.DParent <> nil then DSayUpDown.DParent.DelChild(DSayUpDown);
   DSayUpDown.DParent := DNewSay;
   DNewSay.AddChild(DSayUpDown);


   DNewSay.Left := 230;
   DNewSay.Height := 2 + (SAYLISTHEIGHT) * 4;
   DNewSay.Top := g_FScreenHeight - DNewSay.Height - FrmDlg.DBottom.Height + 102;
   if g_FScreenWidth = DEFSCREENWIDTH then
     DNewSay.Width := DEFSCREENWIDTH - 396        //Ã¤ÆÃ ±Û
   else DNewSay.Width := DEFSCREENWIDTH - 172;

   DSayUpDown.SetImgIndex(g_WAresImages, 356);
   DSayUpDown.Top := 4;
   DSayUpDown.Left := DNewSay.Width - DSayUpDown.Width - 4;
   DSayUpDown.Height := DNewSay.Height - 15 + 8;

   DSayUpDown.UpButton.SetImgIndex(g_WAresImages, 366);
   DSayUpDown.DownButton.SetImgIndex(g_WAresImages, 369);
   DSayUpDown.MoveButton.SetImgIndex(g_WAresImages, 363);

   DBTSayMove.SetImgIndex(g_WMainImages, 2057);          //Ã¤ÆÃÃ¢ Å©±âº¯µ¿
   DBTSayMove.Left := DNewSay.Width - DBTSayMove.Width - 9;
   DBTSayMove.Top := DNewSay.Height - 64;

   DBotChatTrans.SetImgIndex(g_WMainImages, 2004);
   DBotChatTrans.Left := DBTSayMove.Left - DBotChatTrans.Width + 3;
   DBotChatTrans.Top := DNewSay.Height - 64;

   DBotOption.SetImgIndex(g_WMainImages, 2007);
   DBotOption.Left := DBotChatTrans.Left - DBotOption.Width + 3;
   DBotOption.Top := DNewSay.Height - 64;

   dkSayLock.SetImgIndex(g_WMainImages, 2060);
   dkSayLock.Left := DBotChatTrans.Left - dkSayLock.Width + 3;
   dkSayLock.Top := DNewSay.Height - 64;

   DBTFace.SetImgIndex(g_WMainImages, 1967);
   DBTFace.Left := dkSayLock.Left - DBTFace.Width + 3;
   DBTFace.Top := DNewSay.Height - 64;


   DBtnSayAll.SetImgIndex (g_WMainImages,2060);         //¸¶À»ÀÌµ¿ ¹öÆ°
   DBtnSayAll.Left := 242;
   DBtnSayAll.Top := DNewSay.Height - 64;
   DBtnSayAll.AppendData := Pointer(Integer(us_All));

   DBtnSayHear.SetImgIndex(g_WMainImages, 2036);
   DBtnSayHear.Left := 12;
   DBtnSayHear.Top := DNewSay.Height - 64;
   DBtnSayHear.AppendData := Pointer(Integer(us_Hear));

   DBtnSayCry.SetImgIndex(g_WMainImages, 2039);
   DBtnSayCry.Left := DBtnSayHear.Left + DBtnSayHear.Width - 2;
   DBtnSayCry.Top := DNewSay.Height - 64;
   DBtnSayCry.AppendData := Pointer(Integer(us_Cry));

   DBtnSayWhisper.SetImgIndex(g_WMainImages, 2042);
   DBtnSayWhisper.Left := DBtnSayCry.Left + DBtnSayCry.Width - 2;
   DBtnSayWhisper.Top := DNewSay.Height - 64;
   DBtnSayWhisper.AppendData := Pointer(Integer(us_Whisper));

   DBtnSayLover.SetImgIndex(g_WMainImages, 2045);
   DBtnSayLover.Left := DBtnSayWhisper.Left + DBtnSayWhisper.Width - 2;
   DBtnSayLover.Top := DNewSay.Height - 64;
   DBtnSayLover.AppendData := Pointer(Integer(us_Lover));

   DBtnSayMaster.SetImgIndex(g_WMainImages, 2048);
   DBtnSayMaster.Left := DBtnSayLover.Left + DBtnSayLover.Width - 2;
   DBtnSayMaster.Top := DNewSay.Height - 64;
   DBtnSayMaster.AppendData := Pointer(Integer(us_Master));

   DBtnSayGroup.SetImgIndex(g_WMainImages, 2051);
   DBtnSayGroup.Left := DBtnSayMaster.Left + DBtnSayMaster.Width - 2;
   DBtnSayGroup.Top := DNewSay.Height - 64;
   DBtnSayGroup.AppendData := Pointer(Integer(us_Group));

   DBtnSayGuild.SetImgIndex(g_WMainImages, 2054);
   DBtnSayGuild.Left := DBtnSayGroup.Left + DBtnSayGroup.Width - 2;
   DBtnSayGuild.Top := DNewSay.Height - 64;
   DBtnSayGuild.AppendData := Pointer(Integer(us_Guild));

   DBtnSaySys.SetImgIndex(g_WMainImages, 2063);
   DBtnSaySys.Left := DBtnSayGuild.Left + DBtnSayGuild.Width - 2;
   DBtnSaySys.Top := DNewSay.Height - 64;
   DBtnSaySys.AppendData := Pointer(Integer(us_sys));


   DBReady6.SetImgIndex (g_WAresImages,372);         //ÁØºñÁß..
   DBReady6.Left := 12;
   DBReady6.Top := DNewSay.Height - 80;

   DBotPlusAbil.SetImgIndex (g_WAresImages,393);         //ÁØºñÁß..
   DBotPlusAbil.Left := 12 + 28;
   DBotPlusAbil.Top := DNewSay.Height - 80;

   DBHome.SetImgIndex (g_WAresImages,402);         //¸¶À»ÀÌµ¿ ¹öÆ°
   DBHome.Left := 12 + (28 * 0);
   DBHome.Top := DNewSay.Height - 80;

   DBStorage.SetImgIndex (g_WAresImages,375);         //º¸³Ê½º Æ÷ÀÎÆ®
   DBStorage.Left :=  12 + (28 * 3);
   DBStorage.Top := DNewSay.Height - 80;

   DBAuction.SetImgIndex (g_WAresImages,378);         //À§Å¹ ¹öÆ°
   DBAuction.Left :=  12 + (28 * 4);
   DBAuction.Top := DNewSay.Height - 80;

   DBScreen.SetImgIndex (g_WAresImages,381);         //ÁØºñÁß..
   DBScreen.Left := 12 + (28 * 1);
   DBScreen.Top := DNewSay.Height - 80;

   DExpMode.SetImgIndex (g_WAresImages,384);
   DExpMode.Left := 12 + (28 * 2);
   DExpMode.Top := DNewSay.Height - 80;

   DBReady4.SetImgIndex (g_WAresImages,387);
   DBReady4.Left := 12 + (28 * 3);
   DBReady4.Top := DNewSay.Height - 80;

   DLoverMacro.SetImgIndex (g_WAresImages,390);
   DLoverMacro.Left := 12 + (28 * 4);
   DLoverMacro.Top := DNewSay.Height - 80;

   DBReady3.SetImgIndex (g_WAresImages,393);         //ÁØºñÁß..
   DBReady3.Left := 12 + (28 * 5);
   DBReady3.Top := DNewSay.Height - 80;

   DPetEat.SetImgIndex (g_WAresImages,396);
   DPetEat.Left := 12 + (28 * 6);
   DPetEat.Top := DNewSay.Height - 80;

   DBReady2.SetImgIndex (g_WAresImages,399);         //ÁØºñÁß..
   DBReady2.Left := 12 + (28 * 7);
   DBReady2.Top := DNewSay.Height - 80;

   DMakeAdvice.SetImgIndex (g_WAresImages,436);         //ÁØºñÁß..
   DMakeAdvice.Left := 12 + (28 * 12);
   DMakeAdvice.Top := DNewSay.Height - 80;

   DBCompound.SetImgIndex (g_WAresImages,640);         //ÁØºñÁß..
   DBCompound.Left := 12 + (28 * 13);
   DBCompound.Top := DNewSay.Height - 80;


   DAuctionView.SetImgIndex(g_WMainImages, 2057);
   DAuctionView.Left := 5;
   DAuctionView.Top := - 7;
   DAuctionView.DontDrawUp := True;



   DBotItemShop.SetImgIndex (g_WMainImages,826);
   DBotItemShop.Left := g_FScreenWidth - 104;
   DBotItemShop.Top := 34;
   DBotItemShop.DontDrawUp := True;

   DBotMenu.SetImgIndex(g_WMainImages, 1960);
   DBotMenu.Left:= g_FScreenWidth - 56;
   DBotMenu.Top:= 34;
   DBotMenu.DontDrawUp := True;


   DBotAi1.SetImgIndex(g_WMainImages, 1840);
   DBotAi1.Left := 159;
   DBotAi1.Top := 36;
   DBotAi2.SetImgIndex(g_WMainImages, 1841);
   DBotAi2.Left := 177;
   DBotAi2.Top := 36;
   DBotAi3.SetImgIndex(g_WMainImages, 1842);
   DBotAi3.Left := 195;
   DBotAi3.Top := 36;
   DBotAi4.SetImgIndex(g_WMainImages, 1843);
   DBotAi4.Left := 213;
   DBotAi4.Top := 36;


   d := g_WMainImages.Images[583];
   if d <> nil then begin
      DLoverWindow.SetImgIndex (g_WMainImages, 583);
      DLoverWindow.Left := (g_FScreenWidth - d.Width) div 2;
      DLoverWindow.Top := (g_FScreenHeight - d.Height) div 2;
      DLoverWindow.Width := 324;
      DLoverWindow.Height := 228;

      DLoverAvailable.SetImgIndex (g_WMainImages, 610);
      DLoverAvailable.Top := 164;
      DLoverAvailable.Left := 68;

      DLoverAsk.SetImgIndex (g_WMainImages, 600);
      DLoverAsk.Top := 164;
      DLoverAsk.Left := 96;

      DLoverDivorce.SetImgIndex (g_WMainImages, 620);
      DLoverDivorce.Top := 164;
      DLoverDivorce.Left := 124;

      DLoverMail.SetImgIndex (g_WMainImages, 437);
      DLoverMail.Top := 164;
      DLoverMail.Left := 152;

      DLoverWhisper.SetImgIndex (g_WMainImages, 566);
      DLoverWhisper.Top := 164;
      DLoverWhisper.Left := 180;

      DLoverExit.SetImgIndex (g_WMain2Images, 360);
      DLoverExit.Top := 3;
      DLoverExit.Left := 259;

      DLoverCaption.SetImgIndex (g_WTitleImages, 52);
      DLoverCaption.Top := 5;
      DLoverCaption.Left := 32;
   end;


   d := g_WMainImages.Images[170];
   if d <> nil then begin
      DMasterDlg.SetImgIndex (g_WMainImages, 170);
      DMasterDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DMasterDlg.Top := (g_FScreenHeight - d.Height ) div 2;
      DMasterDlg.Width := 324;
      DMasterDlg.Height := 228;

      DMasterAllow.SetImgIndex(g_WMainImages,114);
      DMasterAllow.Left := 34;
      DMasterAllow.Top := 177;

      DMasterMentor.SetImgIndex(g_WTitleImages, 213);
      DMasterMentor.Left := 68;
      DMasterMentor.Top := 177;

      DMasterSecession.SetImgIndex(g_WTitleImages, 216);
      DMasterSecession.Left := 142;
      DMasterSecession.Top  := 177;

      DMasterClose.SetImgIndex(g_WMain2Images, 360);
      DMasterClose.Left:=  219;
      DMasterClose.Top := 3;

   end;

   {-----------------------------------------------------------}
     d := g_WMainImages.Images[2091];
     if d <> nil then begin
        DViewMiniMap.SetImgIndex(g_WMainImages, 2091);
        DViewMiniMap.Left := g_FScreenWidth - 126; //674;
        DViewMiniMap.Top  := 0;
        DViewMiniMap.Width := d.Width;
        DViewMiniMap.Height := d.Height;
     end;
     DBotMemo.SetImgIndex (g_WMainImages,2099);
     DBotMemo.Left := 5;
     DBotMemo.Top := 21;
     DBotMemo.DontDrawUp := True;
     DBotMiniMap.SetImgIndex (g_WMainImages, 2102);
     DBotMiniMap.Left := 109;
     DBotMiniMap.Top := 3;

     DDayBright.SetImgIndex(g_WMainImages, 2093);  //»õº®
     DDayBright.Left := 101;
     DDayBright.Top := 21;

     DBotBigMap.SetImgIndex (g_WMainImages,2096);
     DBotBigMap.Left := 26;
     DBotBigMap.Top := 21;

     DBotDura.SetImgIndex (g_WMainImages,2110);
     DBotDura.Left := 84;
     DBotDura.Top := 47;

     DBotDura2.SetImgIndex (g_WMainImages,2114);
     DBotDura2.Left := 100;
     DBotDura2.Top := 47;

   {---------------------------------------------------------}

   DBigMapDlg.Left := (g_FScreenWidth - 565) div 2;       //Å«¸Ê
   DBigMapDlg.Top := (g_FScreenHeight - 370) div 2 - 50;
   DBigMapDlg.Width := 565;
   DBigMapDlg.Height := 370;

   DMiniMap.Left := g_FScreenWidth-123;     
   DMiniMap.Top := 22;
   DMiniMap.Width := 120;
   DMiniMap.Height := 108;


   d := g_WMainImages.Images[310];
   if d <> nil then begin
   //milo
      DMerchantDlg.Left := 0;
      DMerchantDlg.Top := 0;
      DMerchantDlg.SetImgIndex (g_WMainImages, 310);
   end;
   DMerchantDlgClose.Left := 413;
   DMerchantDlgClose.Top := 4;
   DMerchantDlgClose.SetImgIndex (g_WMain2Images, 360);
   DBnpcup.SetImgIndex (g_WMain2Images, 197);      //»óÀÎ
   DBnpcup.Left := 416;
   DBnpcup.Top := 35;
   DBnpcex.SetImgIndex (g_WMain2Images, 207);
   DBnpcex.Left := 416;
   DBnpcex.Top := 175;
   DMovenpcbot.SetImgIndex(g_WMain2Images, 205);
   DMovenpcbot.Left := 416;
   DMovenpcbot.Top := 50;
   {-----------------------------------------------------------}


   d := g_WMainImages.Images[1000];
   if d <> nil then begin
      DShopMenuDlg.Left := 0;
      DShopMenuDlg.Top  := 223;
      DShopMenuDlg.SetImgIndex (g_WMainImages, 1000);
   end;

   Dshoppe1.Left := 10;
   Dshoppe1.Top := 34;
   Dshoppe1.Width := 205;
   Dshoppe1.Height := 32;

   Dshoppe2.Left := 10;
   Dshoppe2.Top := 34+33;
   Dshoppe2.Width := 205;
   Dshoppe2.Height := 32;

   Dshoppe3.Left := 10;
   Dshoppe3.Top := 34+33*2;
   Dshoppe3.Width := 205;
   Dshoppe3.Height := 32;

   Dshoppe4.Left := 10;
   Dshoppe4.Top := 34+33*3;
   Dshoppe4.Width := 205;
   Dshoppe4.Height := 32;

   Dshoppe5.Left := 10;
   Dshoppe5.Top := 34+33*4;
   Dshoppe5.Width := 205;
   Dshoppe5.Height := 32;

   Dshoppe6.Left := 10;
   Dshoppe6.Top := 34+33*5;
   Dshoppe6.Width := 205;
   Dshoppe6.Height := 32;


   Dshoppe7.Left := 10;
   Dshoppe7.Top := 34+33*6;
   Dshoppe7.Width := 205;
   Dshoppe7.Height := 32;


   Dshoppe8.Left := 10;
   Dshoppe8.Top := 34+33*7;
   Dshoppe8.Width := 205;
   Dshoppe8.Height := 32;


   DShopMenuOk.SetImgIndex (g_WTitleImages, 453);
   DShopMenuOk.Left := 72;
   DShopMenuOk.Top := 304;
   DShopMenuClose.SetImgIndex (g_WMain2Images, 360);
   DShopMenuClose.Left := 216;
   DShopMenuClose.Top := 3;

   DShopMenuScrollUp.SetImgIndex (g_WMain2Images, 197);
   DShopMenuScrollUp.Left := 219;
   DShopMenuScrollUp.Top := 35;
   DShopMenuScrollDown.SetImgIndex (g_WMain2Images, 207);
   DShopMenuScrollDown.Left := 219;
   DShopMenuScrollDown.Top := 284;
   DShopMenuMove.SetImgIndex (g_WMain2Images, 205);
   DShopMenuMove.Left := 219;
   DShopMenuMove.Top := 50;
   {-----------------------------------------------------------}

   d := g_WMain2Images.Images[351];
   if d <> nil then begin
      DUpWeapon.Left := 265;
      DUpWeapon.Top  := 224;
      DUpWeapon.SetImgIndex (g_WMain2Images, 351);
   end;

   DUpWeaponSpot.Left := 27;
   DUpWeaponSpot.Top  := 67;
   DUpWeaponSpot.Width := 61;
   DUpWeaponSpot.Height := 52;

   DUpWeapExit.Left := 150;
   DUpWeapExit.Top := 3;
   DUpWeapExit.SetImgIndex (g_WMain2Images, 360);


   d := g_WMain2Images.Images[351];
   if d <> nil then begin
      DUpCheck.Left := 5;
      DUpCheck.Top  := 224;
      DUpCheck.SetImgIndex (g_WMain2Images, 351);
   end;

   DCheckSpot.Left := 27;
   DCheckSpot.Top  := 67;
   DCheckSpot.Width := 61;
   DCheckSpot.Height := 52;

   DCheckExit.Left := 150;
   DCheckExit.Top := 3;
   DCheckExit.SetImgIndex (g_WMain2Images, 360);

   DCheckOk.Left := 114;
   DCheckOk.Top := 62;
   DCheckOk.SetImgIndex(g_WTitleImages, 180);

   {-----------------------------------------------------------}

   d := g_WMainImages.Images[392];
   if d <> nil then begin
      DSellDlg.Left := 265;
      DSellDlg.Top  := 224;
      DSellDlg.SetImgIndex (g_WMainImages, 392);
   end;
   DSellDlgOk.Left := 114;
   DSellDlgOk.Top := 62;
   DSellDlgOk.SetImgIndex (g_WTitleImages, 290);
   DSellDlgClose.Left := 144;
   DSellDlgClose.Top := 9;
   DSellDlgClose.SetImgIndex (g_WMain2Images, 360);
   DHold.Left := 114;
   DHold.Top := 36;
   DHold.SetImgIndex (g_WTitleImages, 293);
   DSellDlgSpot.Left := 27;
   DSellDlgSpot.Top  := 67;
   DSellDlgSpot.Width := 61;
   DSellDlgSpot.Height := 52;

   {-----------------------------------------------------------}


   d := g_WMainImages.Images[710];
   if d <> nil then begin
      DKeySelDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DKeySelDlg.Top  := (g_FScreenHeight - d.Height) div 2;
      DKeySelDlg.SetImgIndex (g_WMainImages, 710);
   end;
   DKsIcon.Left := 16;//50; 34
   DKsIcon.Top := 16;//36;  20
   DKsF1.SetImgIndex (g_WMainImages, 1657);
   DKsF1.Left := 17;     //35
   DKsF1.Top  := 58;    //22
   DKsF2.SetImgIndex (g_WMainImages, 1657);
   DKsF2.Left := 22 + 27;
   DKsF2.Top  := 58;
   DKsF3.SetImgIndex (g_WMainImages, 1657);
   DKsF3.Left := 54 + 27;
   DKsF3.Top  := 58;
   DKsF4.SetImgIndex (g_WMainImages, 1657);
   DKsF4.Left := 86 + 27;
   DKsF4.Top  := 58;
   DKsF5.SetImgIndex (g_WMainImages, 1657);
   DKsF5.Left := 125 + 25;
   DKsF5.Top  := 58;
   DKsF6.SetImgIndex (g_WMainImages, 1657);
   DKsF6.Left := 157 + 25;
   DKsF6.Top  := 58;
   DKsF7.SetImgIndex (g_WMainImages, 1657);
   DKsF7.Left := 189 + 25;
   DKsF7.Top  := 58;
   DKsF8.SetImgIndex (g_WMainImages, 1657);
   DKsF8.Left := 221 + 25;
   DKsF8.Top := 58;

   DKsConF1.SetImgIndex (g_WMainImages, 1657);
   DKsConF1.Left := 17;
   DKsConF1.Top  := 95;
   DKsConF2.SetImgIndex (g_WMainImages, 1657);
   DKsConF2.Left := 22 + 27;
   DKsConF2.Top  := 95;
   DKsConF3.SetImgIndex (g_WMainImages, 1657);
   DKsConF3.Left := 54 + 27;
   DKsConF3.Top  := 95;
   DKsConF4.SetImgIndex (g_WMainImages, 1657);
   DKsConF4.Left := 86 + 27;
   DKsConF4.Top  := 95;
   DKsConF5.SetImgIndex (g_WMainImages, 1657);
   DKsConF5.Left := 125 + 25;
   DKsConF5.Top  := 95;
   DKsConF6.SetImgIndex (g_WMainImages, 1657);
   DKsConF6.Left := 157 + 25;
   DKsConF6.Top  := 95;
   DKsConF7.SetImgIndex (g_WMainImages, 1657);
   DKsConF7.Left := 189 + 25;
   DKsConF7.Top  := 95;
   DKsConF8.SetImgIndex (g_WMainImages, 1657);
   DKsConF8.Left := 221 + 25;
   DKsConF8.Top := 95;


   DKsNone.SetImgIndex (g_WTitleImages, 287);
   DKsNone.Left := 285;
   DKsNone.Top  := 62;

   DKsOk.SetImgIndex (g_WTitleImages, 290);
   DKsOk.Left := 285;
   DKsOk.Top  := 98;


    {-----------------------------------------------------------}


   d := g_WMainImages.Images[1640];
   if d <> nil then begin
      DHeroKeylDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DHeroKeylDlg.Top  := (g_FScreenHeight - d.Height) div 2;
      DHeroKeylDlg.SetImgIndex (g_WMainImages, 1640);
   end;
   DKsSIcon.Left := 16;//50; 34
   DKsSIcon.Top := 16;//36;  20
   DKsSF1.SetImgIndex (g_WMainImages, 1657);
   DKsSF1.Left := 36;     //35
   DKsSF1.Top  := 77;    //22
   DKsSF2.SetImgIndex (g_WMainImages, 1657);
   DKsSF2.Left := 68;
   DKsSF2.Top  := 77;
   DKsSF3.SetImgIndex (g_WMainImages, 1657);
   DKsSF3.Left := 100;
   DKsSF3.Top  := 77;
   DKsSF4.SetImgIndex (g_WMainImages, 1657);
   DKsSF4.Left := 132;
   DKsSF4.Top  := 77;
   DKsSF5.SetImgIndex (g_WMainImages, 1657);
   DKsSF5.Left := 164;
   DKsSF5.Top  := 77;
   DKsSF6.SetImgIndex (g_WMainImages, 1657);
   DKsSF6.Left := 196;
   DKsSF6.Top  := 77;
   DKsSF7.SetImgIndex (g_WMainImages, 1657);
   DKsSF7.Left := 228;
   DKsSF7.Top  := 77;

   DKsSNone.SetImgIndex (g_WTitleImages, 287);
   DKsSNone.Left := 285;
   DKsSNone.Top  := 62;

   DKsSOk.SetImgIndex (g_WTitleImages, 290);
   DKsSOk.Left := 285;
   DKsSOk.Top  := 98;
   {-----------------------------------------------------------}

   d := g_WAresImages.Images[439];
   if d <> nil then begin
      DGroupDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DGroupDlg.Top  := (g_FScreenHeight - d.Height) div 2;
      DGroupDlg.SetImgIndex (g_WAresImages, 439);
   end;
   DGrpDlgClose.SetImgIndex (g_WMain2Images, 360);
   DGrpDlgClose.Left := 263;
   DGrpDlgClose.Top := 4;

   DGrpAllowGroup.SetImgIndex (g_WAresImages, 453);
   DGrpAllowGroup.Left := 25;
   DGrpAllowGroup.Top := 54;
   DGrpCheckGroup.SetImgIndex(g_WAresImages, 453);
   DGrpCheckGroup.Left := 25;
   DGrpCheckGroup.Top := 73;
   DCBGroupItemDef.SetImgIndex(g_WAresImages, 455);
   DCBGroupItemDef.Left := 166;
   DCBGroupItemDef.Top := 56;
   DCBGroupItemRam.SetImgIndex(g_WAresImages, 455);
   DCBGroupItemRam.Left := 166;
   DCBGroupItemRam.Top := 76;
   DGrpCheckHero.SetImgIndex(g_WAresImages, 453);
   DGrpCheckHero.Left := 166;
   DGrpCheckHero.Top := 100;

   DGdUserUp.SetImgIndex(g_WAresImages, 440);
   DGdUserUp.Top := 260;
   DGdUserUp.Left := 260;
   DGdUserDown.SetImgIndex(g_WAresImages, 443);
   DGdUserDown.Top := 362;
   DGdUserDown.Left := 260;
   DGpMove.SetImgIndex(g_WAresImages, 446);
   DGpMove.Top := 276;
   DGpMove.Left := 260;

   DGrpMemberList.Left := 20;
   DGrpMemberList.Top := 110;
   DGrpMemberList.Width := 238;
   DGrpMemberList.Height := 65;

   DGrpUserList.Left := 20;
   DGrpUserList.Top := 261;
   DGrpUserList.Width := 222;
   DGrpUserList.Height := 118;

   DGrpAddMem.SetImgIndex (g_WTitleImages, 133);
   DGrpAddMem.Left := 20;
   DGrpAddMem.Top := 230;
   DGrpDelMem.SetImgIndex (g_WTitleImages, 136);
   DGrpDelMem.Left := 80;
   DGrpDelMem.Top := 230;
   DGrpDelegate.SetImgIndex (g_WTitleImages, 760);
   DGrpDelegate.Left := 140;
   DGrpDelegate.Top := 230;

    {-----------------------------------------------------------}
   d := g_WMainImages.Images[160];   //È£¶ûÀÌÃ¢
   if d <> nil then begin
      DTigerDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DTigerDlg.Top  := 0;
      DTigerDlg.SetImgIndex (g_WMainImages, 167);
   end;
   DTigerDlgClose.SetImgIndex (g_WMain2Images, 360);     //È£¶ûÀÌÃ¢
   DTigerDlgClose.Left := 297;
   DTigerDlgClose.Top := 3;
   DTigerDlgSet.SetImgIndex (g_WMainImages, 155);
   DTigerDlgSet.Left := 254;
   DTigerDlgSet.Top := 70;
   //È£¶ûÀÌ
   DSPETS1.Left := 37;
   DSPETS1.Top  := 324;
   DSPETS1.Width := 34;
   DSPETS1.Height := 31;

   DSPETS2.Left := 91;
   DSPETS2.Top  := 324;
   DSPETS2.Width := 34;
   DSPETS2.Height := 31;

   DSPETS3.Left := 145;
   DSPETS3.Top  := 324;
   DSPETS3.Width := 34;
   DSPETS3.Height := 31;

   DSPETS4.Left := 199;
   DSPETS4.Top  := 324;
   DSPETS4.Width := 34;
   DSPETS4.Height := 31;

   DSPETS5.Left := 253;
   DSPETS5.Top  := 324;
   DSPETS5.Width := 34;
   DSPETS5.Height := 31;

 {-----------------------------------------------------------}

  d := g_WMainImages.Images[661];    //º¯È¯
  if d <> nil then begin
   DChangeItem.SetImgIndex(g_WMainImages, 661);
   DChangeItem.Left := (g_FScreenWidth - d.Width) div 2;
   DChangeItem.Top := (g_FScreenHeight - d.Height) div 2;
  end;

  DStartChange.SetImgIndex(g_WTitleImages, 496);
  DStartChange.Left := 34;
  DStartChange.Top := 177;

  DCloseChange.SetImgIndex(g_WTitleImages, 385);
  DCloseChange.Left := 234;
  DCloseChange.Top := 177;

  DChangeItem1.Left := 50;
  DChangeItem1.Top  := 56;
  DChangeItem1.Width := 34;
  DChangeItem1.Height := 30;

  DChangeItem2.Left := 85;
  DChangeItem2.Top  := 56;
  DChangeItem2.Width := 34;
  DChangeItem2.Height := 30;

  DChangeItem3.Left := 120;
  DChangeItem3.Top  := 56;
  DChangeItem3.Width := 34;
  DChangeItem3.Height := 30;

  DChangeItem4.Left := 155;
  DChangeItem4.Top  := 56;
  DChangeItem4.Width := 34;
  DChangeItem4.Height := 30;

  DChangeItem5.Left := 190;
  DChangeItem5.Top  := 56;
  DChangeItem5.Width := 34;
  DChangeItem5.Height := 30;

  DChangeItem6.Left := 225;
  DChangeItem6.Top  := 56;
  DChangeItem6.Width := 34;
  DChangeItem6.Height := 30;

 {-----------------------------------------------------------}


   //---------³¬½Ã Ã¢-----

   d := g_WMainImages.Images[1340];
   if d <> nil then begin
      DFishDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DFishDlg.Top  := (g_FScreenHeight - d.Height) div 2;
      DFishDlg.SetImgIndex (g_WMainImages, 1340);
   end;
   DFishExit.SetImgIndex (g_WMain2Images, 360);
   DFishExit.Left := 175;
   DFishExit.Top := 3;

   DFISH1.Left := 17;   //³¬½ËÁÙ°ú ¹Ù´Ã
   DFISH1.Top  := 203;
   DFISH1.Width := 34;
   DFISH1.Height := 31;

   DFISH2.Left := 17;     //Âî
   DFISH2.Top  := 241;
   DFISH2.Width := 34;
   DFISH2.Height := 31;

   DFISH3.Left := 57;    //¹Ì³¢
   DFISH3.Top  := 241;
   DFISH3.Width := 34;
   DFISH3.Height := 31;

   DFISH4.Left := 97;  //¾î±ºÅ½Áö±â
   DFISH4.Top  := 241;
   DFISH4.Width := 34;
   DFISH4.Height := 31;

   DFISH5.Left := 137;     //¸±
   DFISH5.Top  := 241;
   DFISH5.Width := 34;
   DFISH5.Height := 31;
   {-----------------------------------------------------------}

   //³¬½Ã ÁøÇàÃ¢-----------
   d := g_WMainImages.Images[1341];
   if d <> nil then begin
      DFishProgressDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DFishProgressDlg.Top  := 290;
      DFishProgressDlg.SetImgIndex (g_WMainImages, 1341);
   end;
   DProgressExit.SetImgIndex (g_WMain2Images, 360);
   DProgressExit.Left := 217;
   DProgressExit.Top := 5;

   DCatch.SetImgIndex (g_WTitleImages, 149);
   DCatch.Left := 46;
   DCatch.Top := 94;

   DCheckEsc.SetImgIndex(g_WMainImages, 1346);
   DCheckEsc.Left := 140;
   DCheckEsc.Top := 34;

   DAutoFish.SetImgIndex (g_WTitleImages, 143);
   DAutoFish.Left := 108;
   DAutoFish.Top := 94;

   {-----------------------------------------------------------}
   //°Å·¡Ã¢
   d := g_WMainImages.Images[389];
   if d <> nil then begin
      DDealDlg.Left := g_FScreenWidth - d.Width;
      DDealDlg.Top  := 280;
      DDealDlg.SetImgIndex (g_WMainImages, 389);
   end;
   DDGrid.Left := 14;
   DDGrid.Top  := 56-16;
   DDGrid.Width := 36 * 5;
   DDGrid.Height := 33 * 2;
   DDealOk.SetImgIndex (g_WTitleImages, 440);
   DDealOk.Left := 129;
   DDealOk.Top := 120;  //65
   DDealClose.SetImgIndex (g_WMain2Images, 360);
   DDealClose.Left := 180;
   DDealClose.Top := 3;
   DDGold.SetImgIndex (g_WMainImages, 28);
   DDGold.Left := 20;
   DDGold.Top  := 122;

   d := g_WMainImages.Images[237];     //±³È¯°Å·¡
   if d <> nil then begin
      DDealMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DDealMsgDlg.Top  := 50;
      DDealMsgDlg.SetImgIndex (g_WMainImages, 237);
   end;


   //»ó´ë¹æ °Å·¡Ã¢
   d := g_WMainImages.Images[390];
   if d <> nil then begin
      DDealRemoteDlg.Left := DDealDlg.Left - d.Width;
      DDealRemoteDlg.Top  := 90;
      DDealRemoteDlg.SetImgIndex (g_WMainImages, 390);
   end;
   DDRGrid.Left := 14;
   DDRGrid.Top  := 56-16;
   DDRGrid.Width := 36 * 5;
   DDRGrid.Height := 33 * 2;
   DDRGold.SetImgIndex (g_WMainImages, 28);
   DDRGold.Left := 20;
   DDRGold.Top  := 122;

   {-----------------------------------------------------------}
   //¹®ÆÄ¼ºÀå
   d := g_WTitleImages.Images[518];
   if d <> nil then begin
      DGuildGrowDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DGuildGrowDlg.Top := (g_FScreenHeight - d.Height) div 2;
      DGuildGrowDlg.SetImgIndex (g_WTitleImages, 518);
   end;
   DGGPage1.Left := 12;
   DGGPage1.Top := 37;
   DGGPage1.SetImgIndex(g_WTitleImages, 547);

   DGGPage2.Left := 83;
   DGGPage2.Top := 37;
   DGGPage2.SetImgIndex(g_WTitleImages, 549);

   DGGrowUp.Left := 116;
   DGGrowUp.Top := 402;
   DGGrowUp.SetImgIndex(g_WTitleImages, 550);


   DBHelpGuild.Left := 248;
   DBHelpGuild.Top  := 6;
   DBHelpGuild.SetImgIndex (g_WMain2Images, 257);


   DGGrowExit.Left := 281;
   DGGrowExit.Top  := 4;
   DGGrowExit.SetImgIndex (g_WMain2Images, 360);

   DGGrow1.Left := 18;
   DGGrow1.Top := 88;
   DGGrow1.SetImgIndex (g_WGSkillImages, 0);        //»ý¸í

   DGGrow2.Left := 18;
   DGGrow2.Top := 126;
   DGGrow2.SetImgIndex (g_WGSkillImages, 3);        //¸¶·Â

   DGGrow3.Left := 18;
   DGGrow3.Top := 164;
   DGGrow3.SetImgIndex (g_WGSkillImages, 42);       //³ë·Ã

   DGGrow4.Left := 18;
   DGGrow4.Top := 202;
   DGGrow4.SetImgIndex (g_WGSkillImages, 12);       //ÀÎ³»

   DGGrow5.Left := 18;
   DGGrow5.Top := 240;
   DGGrow5.SetImgIndex (g_WGSkillImages, 15);       //¸í»ó

   DGGrow6.Left := 18;
   DGGrow6.Top := 278;
   DGGrow6.SetImgIndex (g_WGSkillImages, 18);       //¿ë¸Í

   DGGrow7.Left := 18;
   DGGrow7.Top := 316;
   DGGrow7.SetImgIndex (g_WGSkillImages, 21);       //Çà¿î

   {-----------------------------------------------------------}
   //¹®ÆÄÃ¢
   d := g_WMainImages.Images[180];
   if d <> nil then begin
      DGuildDlg.Left := 0;
      DGuildDlg.Top := 0;
      DGuildDlg.SetImgIndex (g_WMainImages, 180);
   end;
   DGDClose.Left := 563;
   DGDClose.Top  := 6;
   DGDClose.SetImgIndex (g_WMain2Images, 360);
   DGDHome.Left := 30;
   DGDHome.Top  := 373;
   DGDHome.SetImgIndex (g_WTitleImages, 226);
   DGDList.Left := 30;
   DGDList.Top  := 400;
   DGDList.SetImgIndex (g_WTitleImages, 233);

   DGDGrowUp.Left := 114;
   DGDGrowUp.Top  := 373;
   DGDGrowUp.SetImgIndex (g_WTitleImages, 447);

   DGDChat.Left := 114;
   DGDChat.Top  := 400;
   DGDChat.SetImgIndex (g_WTitleImages, 236);
   DGDAddMem.Left := 198;
   DGDAddMem.Top  := 373;
   DGDAddMem.SetImgIndex (g_WTitleImages, 240);
   DGDDelMem.Left := 198;
   DGDDelMem.Top  := 400;
   DGDDelMem.SetImgIndex (g_WTitleImages, 243);
   DGDEditNotice.Left := 282;
   DGDEditNotice.Top  := 373;
   DGDEditNotice.SetImgIndex (g_WTitleImages, 246);
   DGDEditGrade.Left := 282;
   DGDEditGrade.Top  := 400;
   DGDEditGrade.SetImgIndex (g_WTitleImages, 250);
   DGDAlly.Left := 366;
   DGDAlly.Top  := 373;
   DGDAlly.SetImgIndex (g_WTitleImages, 253);
   DGDBreakAlly.Left := 366;
   DGDBreakAlly.Top  := 400;
   DGDBreakAlly.SetImgIndex (g_WTitleImages, 256);

   DGDWar.Left := 450;
   DGDWar.Top  := 373;
   DGDWar.SetImgIndex (g_WTitleImages, 543);
   DGDCancelWar.Left := 450;
   DGDCancelWar.Top  := 400;
   DGDCancelWar.SetImgIndex (g_WTitleImages, 540);

   DGDUp.Left := 565;
   DGDUp.Top  := 37;
   DGDUp.SetImgIndex (g_WMain2Images, 197);
   DGDDown.Left := 565;
   DGDDown.Top  := 353;
   DGDDown.SetImgIndex (g_WMain2Images, 207);

   //¹®ÆÄ°øÁöÀå
   DGuildEditNotice.SetImgIndex (g_WMainImages, 204);
   DGEOk.SetImgIndex (g_WTitleImages, 296);
   DGEOk.Left := 484;
   DGEOk.Top := 301;
   DGEClose.SetImgIndex (g_WMain2Images, 360);
   DGEClose.Left := 566;
   DGEClose.Top := 1;

   {-----------------------------------------------------------}
   //º¸³Ê½º Æ÷ÀÎÆ®
   DAdjustAbility.SetImgIndex (g_WMainImages, 960);
   DAdjustAbilClose.SetImgIndex (g_WMain2Images, 360);
   DAdjustAbilClose.Left := 289;
   DAdjustAbilClose.Top := 3;
   DAdjustAbilOk.SetImgIndex (g_WTitleImages, 296);
   DAdjustAbilOk.Left := 114;
   DAdjustAbilOk.Top := 437;

   DPlusDC.SetImgIndex (g_WMain2Images, 197);
   DPlusDC.Left := 217;
   DPlusDC.Top := 60;
   DPlusMC.SetImgIndex (g_WMain2Images, 197);
   DPlusMC.Left := 217;
   DPlusMC.Top := 85;
   DPlusSC.SetImgIndex (g_WMain2Images, 197);
   DPlusSC.Left := 217;
   DPlusSC.Top := 110;
   DPlusAC.SetImgIndex (g_WMain2Images, 197);
   DPlusAC.Left := 217;
   DPlusAC.Top := 135;
   DPlusMAC.SetImgIndex (g_WMain2Images, 197);
   DPlusMAC.Left := 217;
   DPlusMAC.Top := 160;
   DPlusHP.SetImgIndex (g_WMain2Images, 197);
   DPlusHP.Left := 217;
   DPlusHP.Top := 185;
   DPlusMP.SetImgIndex (g_WMain2Images, 197);
   DPlusMP.Left := 217;
   DPlusMP.Top := 210;
   DPlusHit.SetImgIndex (g_WMain2Images, 197);
   DPlusHit.Left := 217;
   DPlusHit.Top := 235;
   DPlusSpeed.SetImgIndex (g_WMain2Images, 197);
   DPlusSpeed.Left := 217;
   DPlusSpeed.Top := 260;

   DMinusDC.SetImgIndex (g_WMain2Images, 207);
   DMinusDC.Left := 232;
   DMinusDC.Top := 60;
   DMinusMC.SetImgIndex (g_WMain2Images, 207);
   DMinusMC.Left := 232;
   DMinusMC.Top := 85;
   DMinusSC.SetImgIndex (g_WMain2Images, 207);
   DMinusSC.Left := 232;
   DMinusSC.Top := 110;
   DMinusAC.SetImgIndex (g_WMain2Images, 207);
   DMinusAC.Left := 232;
   DMinusAC.Top := 135;
   DMinusMAC.SetImgIndex (g_WMain2Images, 207);
   DMinusMAC.Left := 232;
   DMinusMAC.Top := 160;
   DMinusHP.SetImgIndex (g_WMain2Images, 207);
   DMinusHP.Left := 232;
   DMinusHP.Top := 185;
   DMinusMP.SetImgIndex (g_WMain2Images, 207);
   DMinusMP.Left := 232;
   DMinusMP.Top := 210;
   DMinusHit.SetImgIndex (g_WMain2Images, 207);
   DMinusHit.Left := 232;
   DMinusHit.Top := 235;
   DMinusSpeed.SetImgIndex (g_WMain2Images, 207);
   DMinusSpeed.Left := 232;
   DMinusSpeed.Top := 260;


   {-----------------------------------------------------------}
   //Á¦Á¶½ºÃÄ ´ÙÀÌ¾ó·Î±× Ã¢
   d := g_WMainImages.Images[661];
   if d <> nil then begin
      DMakeItemDlg.SetImgIndex (g_WMainImages, 661);
      DMakeItemDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DMakeItemDlg.Top := (g_FScreenHeight - d.Height) div 2;
   end;

   DMakeitemGrid.Left := 50;
   DMakeitemGrid.Top  := 54;
   DMakeitemGrid.Width := 224;//240;//286;
   DMakeitemGrid.Height := 34;//40;//80;

//   lx := 163;//234;
//   ly := 109;//141;

   DMakeItemDlgCancel.SetImgIndex (g_WTitleImages, 385);
   DMakeItemDlgCancel.Left := 234;//lx;
   DMakeItemDlgCancel.Top  := 177;//ly;
   DMakeItemDlgCancel.Visible := True;
//   lx := lx - 70;

   DMakeItemDlgOk.SetImgIndex (g_WTitleImages, 266);
   DMakeItemDlgOk.Left := 34;//lx;
   DMakeItemDlgOk.Top  := 177;//ly;
   DMakeItemDlgOk.Visible := True;


   DMakeItemDlgClose.SetImgIndex (g_WMain2Images, 360);
   DMakeItemDlgClose.Left := 285;//319;
   DMakeItemDlgClose.Top  := 3;
   DMakeItemDlgClose.Visible := True;

   DMakeItemDlg.Floating := True;


   //º§Æ® È¸Àü
   g_boVerticalBelt := False;
   g_boVerticaHerolBelt := False;
   g_boModeC := 0;

   DoBeltSetup;
   DoBeltHeroSetup;

   //ÂÊÁö
   d := g_WTitleImages.Images[670];
   if d <> nil then begin
      DMailListDlg.SetImgIndex (g_WTitleImages, 670);
      DMailListDlg.Left := g_FScreenWidth - d.Width;
      DMailListDlg.Top := 0;
   end;

   DMailListClose.SetImgIndex(g_WMain2Images, 360);
   DMailListClose.Left:=282;
   DMailListClose.Top:=4;

   DMailRe.SetImgIndex (g_WMain2Images, 277);
   DMailRe.Left := 217;
   DMailRe.Top  := 3;

   DHelpMail.SetImgIndex (g_WMain2Images, 257);
   DHelpMail.Left := 252;
   DHelpMail.Top  := 4;

   DMailListPgUp.SetImgIndex(g_WMain2Images, 240);
   DMailListPgUp.Left:=100;
   DMailListPgUp.Top:=388;
   DMailListPgDn.SetImgIndex(g_WMain2Images, 243);
   DMailListPgDn.Left:=184;
   DMailListPgDn.Top:=388;


   DMLSend.SetImgIndex(g_WMainImages, 666);
   DMLSend.Left:=70;
   DMLSend.Top:=413;
   DMLReply.SetImgIndex(g_WMainImages, 569);
   DMLReply.Left:=102;
   DMLReply.Top:=413;
   DMLRead.SetImgIndex(g_WMainImages, 572);
   DMLRead.Left:=134;
   DMLRead.Top:=413;
   DMLDel.SetImgIndex(g_WMainImages, 557);
   DMLDel.Left:=166;
   DMLDel.Top:=413;
   DMLBlock.SetImgIndex(g_WMainImages, 520);
   DMLBlock.Left:=198;
   DMLBlock.Top:=413;

   // Block List
   d := g_WTitleImages.Images[199];
   if d <> nil then begin
      DBlockListDlg.SetImgIndex (g_WTitleImages, 199);
      DBlockListDlg.Left := g_FScreenWidth - 260;
      DBlockListDlg.Top := 268;
   end;
   DBlockListClose.SetImgIndex(g_WMain2Images, 360);
   DBlockListClose.Left:=237;
   DBlockListClose.Top:=3;

   DBLPgUp.SetImgIndex(g_WMain2Images, 240);
   DBLPgUp.Left:=94;
   DBLPgUp.Top:=218;
   DBLPgDn.SetImgIndex(g_WMain2Images, 243);
   DBLPgDn.Left:=158;
   DBLPgDn.Top:=218;

   DBLAdd.SetImgIndex(g_WMainImages, 554);
   DBLAdd.Left:=124;
   DBLAdd.Top:=241;
   DBLDel.SetImgIndex(g_WMainImages, 557);
   DBLDel.Left:=156;
   DBLDel.Top:=241;

   //¸Þ¸ð
   d := g_WTitleImages.Images[671];
   if d <> nil then begin
      DMemo.SetImgIndex (g_WTitleImages, 671);
      DMemo.Left := g_FScreenWidth - d.Width - DMailListDlg.Width;
      DMemo.Top := 0;
   end;

   DMemoClose.SetImgIndex(g_WMain2Images, 360);
   DMemoClose.Left:=208;
   DMemoClose.Top:=3;
   DMemoB1.SetImgIndex(g_WTitleImages, 190);
   DMemoB1.Left:=15;
   DMemoB1.Top:=265;
   DMemoB2.SetImgIndex(g_WTitleImages, 193);
   DMemoB2.Left:=151;
   DMemoB2.Top:=265;
   DMemoB3.SetImgIndex(g_WTitleImages, 686);
   DMemoB3.Left:=81;
   DMemoB3.Top:=265;

   d := g_WMainImages.Images[920];
   if d <> nil then begin
      DHelpWin.SetImgIndex (g_WMainImages, 920);
      DHelpWin.Left := (g_FScreenWidth - d.Width) div 2;
      DHelpWin.Top := 0;
   end;
   DHelpClose.SetImgIndex(g_WMain2Images, 360);
   DHelpClose.Left:=509;
   DHelpClose.Top:=3;
   DHelpPrev.SetImgIndex(g_WMain2Images, 240);
   DHelpPrev.Left:=184;
   DHelpPrev.Top:=482;
   DHelpNext.SetImgIndex(g_WMain2Images, 243);
   DHelpNext.Left:=325;
   DHelpNext.Top:=482;

  {-----------------------------------------------------------}

   //È¯»óÁ¡
   d := g_WMainImages.Images[780];
   if d <> nil then begin
      DItemShopDlg.SetImgIndex (g_WMainImages, 780);
      DItemShopDlg.Left := 0;
      DItemShopDlg.Top := 0;
   end;

   DSUseSort.Left := 354;   //°¡°ÝÁ¤·Ä »ç¿ëÀ¯¹«
   DSUseSort.Top := 52;
   DSUseSort.Width := 15;
   DSUseSort.Height := 15;

   DSCostSort.SetImgIndex(g_WMainImages, 794);  //°¡°Ý
   DSCostSort.Left:=374;
   DSCostSort.Top:=51;

   DCategories1.SetImgIndex(g_WMainImages, 790);  //½Å±Ô
   DCategories1.Left:=26;
   DCategories1.Top:=78;
   DCategories2.SetImgIndex(g_WMainImages, 790);  //ÀüÃ¼
   DCategories2.Left:=26;
   DCategories2.Top:=78+21;
   DCategories3.SetImgIndex(g_WMainImages, 790);    //º¸Á¶
   DCategories3.Left:=26;
   DCategories3.Top:=78+21*2;

   DCategories4.SetImgIndex(g_WMainImages, 790);     //ÆÐÅ°Áö
   DCategories4.Left:=26;
   DCategories4.Top:=78+21*3;
   DCategories5.SetImgIndex(g_WMainImages, 790);      //Æ¯º°
   DCategories5.Left:=26;
   DCategories5.Top:=78+21*4;
   DCategories22.SetImgIndex(g_WMainImages, 790);      //¿µ¹°
   DCategories22.Left:=26;
   DCategories22.Top:=78+21*5;
   DCategories17.SetImgIndex(g_WMainImages, 790);      //¿µ¹°
   DCategories17.Left:=26;
   DCategories17.Top:=78+21*6;

   DCategories6.SetImgIndex(g_WMainImages, 817);     //º¸Á¶ - ¹°¾à
   DCategories6.Left:=26;
   DCategories6.Top:=141;
   DCategories7.SetImgIndex(g_WMainImages, 817);     //º¸Á¶ - ÁÖ¹®¼­
   DCategories7.Left:=26;
   DCategories7.Top:=141+17*1;
   DCategories8.SetImgIndex(g_WMainImages, 817);     //º¸Á¶ - ±âÅ¸
   DCategories8.Left:=26;
   DCategories8.Top:=141+17*2;

   DCategories9.SetImgIndex(g_WMainImages, 817);     //Æ¯º° - ¾Æ¹ÙÅ¸
   DCategories9.Left:=26;
   DCategories9.Top:=166+17*1;
   DCategories10.SetImgIndex(g_WMainImages, 817);    //Æ¯º° - Ã¤ÆÃ
   DCategories10.Left:=26;
   DCategories10.Top:=166+17*2;
   DCategories14.SetImgIndex(g_WMainImages, 817);    //Æ¯º° - Å»°Í
   DCategories14.Left:=26;
   DCategories14.Top:=166+17*3;
   DCategories15.SetImgIndex(g_WMainImages, 817);    //Æ¯º° - Æê
   DCategories15.Left:=26;
   DCategories15.Top:=166+17*4;
   DCategories16.SetImgIndex(g_WMainImages, 817);    //Æ¯º° - ±âÅ¸
   DCategories16.Left:=26;
   DCategories16.Top:=166+17*5;

   DCategories18.SetImgIndex(g_WMainImages, 817);    //¿µ¹° - ¿µ¹°¾Ë
   DCategories18.Left:=26;
   DCategories18.Top:=187+17*1;
   DCategories19.SetImgIndex(g_WMainImages, 817);    //¿µ¹° - ¸ÔÀÌ
   DCategories19.Left:=26;
   DCategories19.Top:=187+17*2;
   DCategories20.SetImgIndex(g_WMainImages, 817);    //¿µ¹° - ±â´É
   DCategories20.Left:=26;
   DCategories20.Top:=187+17*3;
   DCategories21.SetImgIndex(g_WMainImages, 817);    //¿µ¹° - ±âÅ¸
   DCategories21.Left:=26;
   DCategories21.Top:=187+17*4;

   //°ü½É
   DCategories11.SetImgIndex(g_WMainImages, 834);
   DCategories11.Left:=26;
   DCategories11.Top:=399;
   DCategories12.SetImgIndex(g_WMainImages, 790);
   DCategories12.Left:=26;
   DCategories12.Top:=399-21;
   DCategories13.SetImgIndex(g_WMainImages, 790);
   DCategories13.Left:=26;
   DCategories13.Top:=399-21*2;
   //----------
   {-------8°³ ¸®½ºÆ®---------}
  buyitemk1.Left := 148;
  buyitemk1.Top := 106;
  buyitemk1.Width := 91;
  buyitemk1.Height := 113;

  buyitemk2.Left := 148 + 92;
  buyitemk2.Top := 106;
  buyitemk2.Width := 91;
  buyitemk2.Height := 113;

  buyitemk3.Left := 148 + 92 * 2;
  buyitemk3.Top := 106;
  buyitemk3.Width := 91;
  buyitemk3.Height := 113;

  buyitemk4.Left := 148 + 92 * 3;
  buyitemk4.Top := 106;
  buyitemk4.Width := 91;
  buyitemk4.Height := 113;

  buyitemk5.Left := 148;
  buyitemk5.Top := 221;
  buyitemk5.Width := 91;
  buyitemk5.Height := 113;

  buyitemk6.Left := 148 + 92;
  buyitemk6.Top := 221;
  buyitemk6.Width := 91;
  buyitemk6.Height := 113;

  buyitemk7.Left := 148 + 92 * 2;
  buyitemk7.Top := 221;
  buyitemk7.Width := 91;
  buyitemk7.Height := 113;

  buyitemk8.Left := 148 + 92 * 3;
  buyitemk8.Top := 221;
  buyitemk8.Width := 91;
  buyitemk8.Height := 113;

   Ditemnamert.SetImgIndex (g_WMainImages, 781);
   Ditemnamert.Left := 617;
   Ditemnamert.Top  := 45;

  DcGameGold.SetImgIndex(g_WMainImages, 810);
  DcGameGold.Left := 639;
  DcGameGold.Top := 435; 

  DRenovates.SetImgIndex(g_WMainImages, 796);
  DRenovates.Left := 496;
  DRenovates.Top := 78;
   {--------ÎïÆ··ÖÀà----------}
   DItemShopClose.SetImgIndex(g_WMainImages, 86);
   DItemShopClose.Left:=670;
   DItemShopClose.Top:=17;
   DItemShopJobAll.SetImgIndex(g_WMainImages, 801);
   DItemShopJobAll.Left:=115;
   DItemShopJobAll.Top:=47;
   DItemShopJobWarrior.SetImgIndex(g_WMainImages, 803);
   DItemShopJobWarrior.Left:=149;
   DItemShopJobWarrior.Top:=47;
   DItemShopJobWizard.SetImgIndex(g_WMainImages, 805);
   DItemShopJobWizard.Left:=183;
   DItemShopJobWizard.Top:=47;
   DItemShopJobMonk.SetImgIndex(g_WMainImages, 807);
   DItemShopJobMonk.Left:=217;
   DItemShopJobMonk.Top:=47;
   DItemShopJobAssas.SetImgIndex(g_WMainImages, 778);
   DItemShopJobAssas.Left:=251;
   DItemShopJobAssas.Top:=47;
   DItemShopJobBonz.SetImgIndex(g_WAresImages, 412);
   DItemShopJobBonz.Left:=285;
   DItemShopJobBonz.Top:=47;
   DItemShopJobCommon.SetImgIndex(g_WMainImages, 809);
   DItemShopJobCommon.Left:=319;
   DItemShopJobCommon.Top:=47;

   //ÏÂÃæµÄ¹¦ÄÜ°´Å¥
   DItemShopGetGift.SetImgIndex(g_WMainImages, 768);
   DItemShopGetGift.Left:=202;
   DItemShopGetGift.Top:=430;
   DItemShopAddFav.SetImgIndex(g_WMainImages, 831);
   DItemShopAddFav.Left:=243;
   DItemShopAddFav.Top:=430;
   DItemShopBye.SetImgIndex(g_WMainImages, 787);
   DItemShopBye.Left:=284;
   DItemShopBye.Top:=430;
   DItemShopGift.SetImgIndex(g_WMainImages, 789);
   DItemShopGift.Left:=325;
   DItemShopGift.Top:=430;
   DItemShopPayMoney.SetImgIndex(g_WMainImages, 833);
   DItemShopPayMoney.Left:=366;
   DItemShopPayMoney.Top:=430;

   DItemShopListPrev.SetImgIndex(g_WMainImages, 798);
   DItemShopListPrev.Left:=345;
   DItemShopListPrev.Top:=402;
   DItemShopListNext.SetImgIndex(g_WMainImages, 799);
   DItemShopListNext.Left:=412;
   DItemShopListNext.Top:=402;


   //ÊÕÀñÆ·----------------------
   d := g_WMainImages.Images[820];
   if d <> nil then begin
    GiftsDT.Left := (g_FScreenWidth - d.Width) div 2;
    GiftsDT.Top  := (g_FScreenHeight - d.Height) div 2;
    GiftsDT.SetImgIndex (g_WMainImages, 820);
   end;
   GiftsDTEXIT.SetImgIndex (g_WMainImages, 86);
   GiftsDTEXIT.Left := 375;
   GiftsDTEXIT.Top := 17;
   Giftsups.SetImgIndex (g_WMainImages, 798); //Giftsexs
   Giftsups.Left := 167;
   Giftsups.Top := 390;
   Giftsexs.SetImgIndex (g_WMainImages, 799);
   Giftsexs.Left := 234;
   Giftsexs.Top := 390;

   Giftsdoot1.Left := 346;
   Giftsdoot1.Top  := 116;
   Giftsdoot1.Width := 23;
   Giftsdoot1.Height := 18;

   Giftsdoot2.Left := 346;
   Giftsdoot2.Top  := 116+19;
   Giftsdoot2.Width := 23;
   Giftsdoot2.Height := 18;

   Giftsdoot3.Left := 346;
   Giftsdoot3.Top  := 116+19*2;
   Giftsdoot3.Width := 23;
   Giftsdoot3.Height := 18;

   Giftsdoot4.Left := 346;
   Giftsdoot4.Top  := 116+19*3;
   Giftsdoot4.Width := 23;
   Giftsdoot4.Height := 18;

   Giftsdoot5.Left := 346;
   Giftsdoot5.Top  := 116+19*4;
   Giftsdoot5.Width := 23;
   Giftsdoot5.Height := 18;

   Giftsdoot6.Left := 346;
   Giftsdoot6.Top  := 116+19*5;
   Giftsdoot6.Width := 23;
   Giftsdoot6.Height := 18;

   Giftsdoot7.Left := 346;
   Giftsdoot7.Top  := 116+19*6;
   Giftsdoot7.Width := 23;
   Giftsdoot7.Height := 18;

   Giftsdoot8.Left := 346;
   Giftsdoot8.Top  := 116+19*7;
   Giftsdoot8.Width := 23;
   Giftsdoot8.Height := 18;

   Giftsdoot9.Left := 346;
   Giftsdoot9.Top  := 116+19*8;
   Giftsdoot9.Width := 23;
   Giftsdoot9.Height := 18;

   Giftsdoot10.Left := 346;
   Giftsdoot10.Top  := 116+19*9;
   Giftsdoot10.Width := 23;
   Giftsdoot10.Height := 18;




   //¿µ¹°¿É¼Ç--------------------------------------
   d := g_WTitleImages.Images[469];
   if d <> nil then begin
      DPetOptionDlg.SetImgIndex (g_WTitleImages, 469);
      DPetOptionDlg.Left := 623;
      DPetOptionDlg.Top := 91;
   end;

   DSavePet.SetImgIndex(g_WTitleImages, 586);
   DSavePet.Left:=10;
   DSavePet.Top:=280;

   DCancelPet.SetImgIndex(g_WTitleImages, 590);
   DCancelPet.Left:=58;
   DCancelPet.Top:=280;

   DAllItem.SetImgIndex(g_WMain2Images, 534);
   DAllItem.Left:=16;
   DAllItem.Top:=15;

   DGoldItem.SetImgIndex(g_WMain2Images, 534);
   DGoldItem.Left:=16;
   DGoldItem.Top:=45;

   DWeaponItem.SetImgIndex(g_WMain2Images, 534);
   DWeaponItem.Left:=16;
   DWeaponItem.Top:=75;

   DDressItem.SetImgIndex(g_WMain2Images, 534);
   DDressItem.Left:=16;
   DDressItem.Top:=105;

   DHelmatItem.SetImgIndex(g_WMain2Images, 534);
   DHelmatItem.Left:=16;
   DHelmatItem.Top:=135;

   DBootsItem.SetImgIndex(g_WMain2Images, 534);
   DBootsItem.Left:=16;
   DBootsItem.Top:=165;

   DBeltItem.SetImgIndex(g_WMain2Images, 534);
   DBeltItem.Left:=16;
   DBeltItem.Top:=195;

   DAccessoryItem.SetImgIndex(g_WMain2Images, 534);
   DAccessoryItem.Left:=16;
   DAccessoryItem.Top:=225;

   DEtcItem.SetImgIndex(g_WMain2Images, 534);
   DEtcItem.Left:=16;
   DEtcItem.Top:=255;

   //¿µ¹°------------------------------------------
   d := g_WTitleImages.Images[468];
   if d <> nil then begin
      DWinPet.SetImgIndex (g_WTitleImages, 468);
      DWinPet.Left := (g_FScreenWidth - d.Width) div 2;
      DWinPet.Top := 30;
   end;
   DPetExit.SetImgIndex(g_WMain2Images, 360);
   DPetExit.Left:=425;
   DPetExit.Top:=3;

   DSommon.SetImgIndex(g_WTitleImages, 576);
   DSommon.Left:=104;
   DSommon.Top:=217;

   DRelease.SetImgIndex(g_WTitleImages, 583);
   DRelease.Left:=274;
   DRelease.Top:=217;

   DPetName.SetImgIndex(g_WTitleImages, 570);
   DPetName.Left:=340;
   DPetName.Top:=50;

   DPetOption.SetImgIndex(g_WTitleImages, 573);
   DPetOption.Left:=373;
   DPetOption.Top:=159;

   DAutoPickUp.SetImgIndex(g_WTitleImages, 610);
   DAutoPickUp.Left:=373;
   DAutoPickUp.Top:=185;

   DBHelpPet.SetImgIndex(g_WMain2Images, 257);
   DBHelpPet.Left:=384;
   DBHelpPet.Top:=6;

   DPetPickUp.SetImgIndex(g_WMain2Images, 532);
   DPetPickUp.Left:=177;
   DPetPickUp.Top:=118;

   DPetFood.SetImgIndex(g_WMain2Images, 533);
   DPetFood.Left:=177;
   DPetFood.Top:=142;

   DPet1.Left := 42;
   DPet1.Top := 259;
   DPet1.Width := 37;
   DPet1.Height := 32;

   DPet2.Left := 123;
   DPet2.Top := 259;
   DPet2.Width := 37;
   DPet2.Height := 32;

   DPet3.Left := 204;
   DPet3.Top := 259;
   DPet3.Width := 37;
   DPet3.Height := 32;

   DPet4.Left := 285;
   DPet4.Top := 259;
   DPet4.Width := 37;
   DPet4.Height := 32;

   DPet5.Left := 366;
   DPet5.Top := 259;
   DPet5.Width := 37;
   DPet5.Height := 32;

   //----------------------------------------------
   //==============°¢¼º
   d := g_WTitleImages.Images[710];
   if d <> nil then begin
    DItemWakeUpDlg.Left := 0;
    DItemWakeUpDlg.Top  := 0;
    DItemWakeUpDlg.SetImgIndex (g_WTitleImages, 710);
   end;

   DBHelpWake.SetImgIndex(g_WMain2Images, 257);
   DBHelpWake.Left := 182;
   DBHelpWake.Top := 5;

   DCloseWakeUp.SetImgIndex (g_WMain2Images, 360);
   DCloseWakeUp.Left := 213;
   DCloseWakeUp.Top := 5;

   DItemWakeUp.Width := 34;
   DItemWakeUp.Height := 30;
   DItemWakeUp.Left := 114;
   DItemWakeUp.Top := 76;

   DWakePopup.SetImgIndex(g_WMain2Images, 363);
   DWakePopup.Left := 183;
   DWakePopup.Top := 153;

   DWakeUpList.SetImgIndex(g_WAresImages, 19);
   DWakeUpList.Top := 170;
   DWakeUpList.Left := 60;
   DWakeUpList.Height := DWakeUpList.Height;

   DWakeUpStart.SetImgIndex(g_WTitleImages, 712);
   DWakeUpStart.Top := 376;
   DWakeUpStart.Left := 75;

   DWake1.Left := 50;
   DWake1.Top := 190;
   DWake1.Width := 36;
   DWake1.Height := 32;

   DWake2.Left :=  50;
   DWake2.Top :=  229;
   DWake2.Width := 36;
   DWake2.Height := 32;

   DWakeArr1.Left := 42;
   DWakeArr1.Top := 322;
   DWakeArr1.Width := 36;
   DWakeArr1.Height := 32;

   DWakeArr2.Left := 86;
   DWakeArr2.Top := 322;
   DWakeArr2.Width := 36;
   DWakeArr2.Height := 32;

   DWakeArr3.Left := 138;
   DWakeArr3.Top := 322;
   DWakeArr3.Width := 36;
   DWakeArr3.Height := 32;

   DWakeArr4.Left := 182;
   DWakeArr4.Top := 322;
   DWakeArr4.Width := 36;
   DWakeArr4.Height := 32;


   //==================

   //----------------------------------------------
   d := g_WMainImages.Images[586];
   if d <> nil then begin
      DItemStore.SetImgIndex (g_WMainImages, 586);
      DItemStore.Left := 0;
      DItemStore.Top := 0;
   end;
   DItemStoreClose.SetImgIndex(g_WMain2Images, 360);
   DItemStoreClose.Left:=363;
   DItemStoreClose.Top:=3;

   DStore1.SetImgIndex(g_WTitleImages, 743);
   DStore1.Left := 10;
   DStore1.Top := 36;
   DStore2.SetImgIndex(g_WTitleImages, 745);
   DStore2.Left := 80;
   DStore2.Top := 36;

   DStoragePW.SetImgIndex(g_WTitleImages, 113);
   DStoragePW.Left := 316;
   DStoragePW.Top := 32;

   DStoreGrid.Left := 9;
   DStoreGrid.Top  := 60;
   DStoreGrid.Width := 368;
   DStoreGrid.Height := 264;

   DHeroStoreGrid.Left := 9;
   DHeroStoreGrid.Top  := 60;
   DHeroStoreGrid.Width := 368;
   DHeroStoreGrid.Height := 264;
  {-----------------------------------------------------------}

   d := g_WMainImages.Images[1104];
   if d <> nil then begin
      DSetPassWd.SetImgIndex (g_WMainImages, 1104);
      DSetPassWd.Left := (g_FScreenWidth - d.Width) div 2;
      DSetPassWd.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DSetPWClose.SetImgIndex (g_WMain2Images, 360);
   DSetPWClose.Left := 279;
   DSetPWClose.Top  := 3;
   DStRePW.SetImgIndex(g_WTitleImages, 120);
   DStRePW.Left := 40;
   DStRePW.Top := 193;
   DStScPW.SetImgIndex(g_WTitleImages, 113);
   DStScPW.Left := 124;
   DStScPW.Top := 193;
   DCheckStPw.SetImgIndex(g_WTitleImages, 290);
   DCheckStPw.Left := 208;
   DCheckStPw.Top := 193;

   d := g_WMainImages.Images[1101];
   if d <> nil then begin
      DStoragePWDlg.SetImgIndex (g_WMainImages, 1101);
      DStoragePWDlg.Left := DSetPassWd.Left - d.Width;
      DStoragePWDlg.Top := DSetPassWd.Top;
   end;
   DStPWClose.SetImgIndex (g_WMain2Images, 360);
   DStPWClose.Left := 154;
   DStPWClose.Top  := 1;
   DStPw0.SetImgIndex (g_WMainImages, 1106);
   DStPw0.Left := 24;
   DStPw0.Top  := 46;
   DStPw1.SetImgIndex (g_WMainImages, 1106);
   DStPw1.Left := 50;
   DStPw1.Top  := 46;
   DStPw2.SetImgIndex (g_WMainImages, 1106);
   DStPw2.Left := 76;
   DStPw2.Top  := 46;
   DStPw3.SetImgIndex (g_WMainImages, 1106);
   DStPw3.Left := 102;
   DStPw3.Top  := 46;
   DStPw4.SetImgIndex (g_WMainImages, 1106);
   DStPw4.Left := 128;
   DStPw4.Top  := 46;

   DStPw5.SetImgIndex (g_WMainImages, 1106);
   DStPw5.Left := 24;
   DStPw5.Top  := 73;
   DStPw6.SetImgIndex (g_WMainImages, 1106);
   DStPw6.Left := 50;
   DStPw6.Top  := 73;
   DStPw7.SetImgIndex (g_WMainImages, 1106);
   DStPw7.Left := 76;
   DStPw7.Top  := 73;
   DStPw8.SetImgIndex (g_WMainImages, 1106);
   DStPw8.Left := 102;
   DStPw8.Top  := 73;
   DStPw9.SetImgIndex (g_WMainImages, 1106);
   DStPw9.Left := 128;
   DStPw9.Top  := 73;

   DStPwDel.SetImgIndex (g_WTitleImages, 540);
   DStPwDel.Left := 20;
   DStPwDel.Top  := 119;

   DStPwInput.SetImgIndex (g_WTitleImages, 543);
   DStPwInput.Left := 94;
   DStPwInput.Top  := 119;


   d := g_WMainImages.Images[1103];
   if d <> nil then begin
      DInputStPwd.SetImgIndex (g_WMainImages, 1103);
      DInputStPwd.Left := (g_FScreenWidth - d.Width) div 2;
      DInputStPwd.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DInputStClose.SetImgIndex (g_WMain2Images, 360);
   DInputStClose.Left := 203;
   DInputStClose.Top  := 3;
   DStINPW.SetImgIndex(g_WTitleImages, 113);
   DStINPW.Left := 68;
   DStINPW.Top := 74;
   DCheckInPutPw.SetImgIndex(g_WTitleImages, 290);
   DCheckInPutPw.Left := 138;
   DCheckInPutPw.Top := 74;

   d := g_WMainImages.Images[1105];
   if d <> nil then begin
      DChangeStPw.SetImgIndex (g_WMainImages, 1105);
      DChangeStPw.Left := (g_FScreenWidth - d.Width) div 2;
      DChangeStPw.Top := (g_FScreenHeight - d.Height) div 2;
   end;
   DCloseChPw.SetImgIndex (g_WMain2Images, 360);
   DCloseChPw.Left := 277;
   DCloseChPw.Top  := 3;
   DChRePw.SetImgIndex(g_WTitleImages, 120);
   DChRePw.Left := 218;
   DChRePw.Top := 221;
   DChScPw.SetImgIndex(g_WTitleImages, 113);
   DChScPw.Left := 96;
   DChScPw.Top := 221;
   DCheckChPw.SetImgIndex(g_WTitleImages, 290);
   DCheckChPw.Left := 156;
   DCheckChPw.Top := 221;
   {-------------------------------------------------------------}


   {-----------------------¹°¾à----------------------}
   d := g_WMainImages.Images[660];     //¹°¾à
   if d <> nil then begin
      DWItemSepa.Left := (g_FScreenWidth - d.Width) div 2;
      DWItemSepa.Top  := (g_FScreenHeight - d.Height) div 2;
      DWItemSepa.SetImgIndex (g_WMainImages, 660);
   end;
   ItemSepaexit.SetImgIndex (g_WMain2Images, 360);
   ItemSepaexit.Left := 298;
   ItemSepaexit.Top := 5;

   ItemSepaOk.SetImgIndex (g_WTitleImages, 116);
   ItemSepaOk.Left := 142;
   ItemSepaOk.Top := 124;

   ItemSepaclose.SetImgIndex (g_WTitleImages, 183);
   ItemSepaclose.Left := 196;
   ItemSepaclose.Top := 124;
 {--------------------Ç÷·æ»óÀÚ------------------}

   d := g_WMainImages.Images[260];     //Ç÷·æ»óÀÚ
   if d <> nil then begin
      DDiceGame.Left := (g_FScreenWidth - d.Width) div 2;
      DDiceGame.Top  := (g_FScreenHeight - d.Height) div 2;
      DDiceGame.SetImgIndex (g_WMainImages, 260);
   end;

   DDiceStart.SetImgIndex (g_WTitleImages, 412);
   DDiceStart.Left := 89;
   DDiceStart.Top := 105;

   DDiceStop.SetImgIndex (g_WTitleImages, 415);
   DDiceStop.Left := 217;
   DDiceStop.Top := 105;

   DDiceCurr.Left := 35;
   DDiceCurr.Top := 98;
   DDiceCurr.Width := 54;
   DDiceCurr.Height := 48;

   DDiceNext.Left := 289;
   DDiceNext.Top := 98;
   DDiceNext.Width := 54;
   DDiceNext.Height := 48;

   DDiceGet.SetImgIndex (g_WTitleImages, 400);
   DDiceGet.Left := 276;
   DDiceGet.Top := 221;

   DDiceClose.SetImgIndex (g_WTitleImages, 403);
   DDiceClose.Left := 276;
   DDiceClose.Top := 221;

   DDiceSelect1.SetImgIndex (g_WMainImages, 300);
   DDiceSelect1.Left := 54;
   DDiceSelect1.Top := 170;

   DDiceSelect2.SetImgIndex (g_WMainImages, 302);
   DDiceSelect2.Left := 182;
   DDiceSelect2.Top := 170;

   DDice1.SetImgIndex (g_WMainImages, 270);
   DDice1.Left := 44;
   DDice1.Top := 170;
   DDice2.SetImgIndex (g_WMainImages, 272);
   DDice2.Left := 86;
   DDice2.Top := 170;
   DDice3.SetImgIndex (g_WMainImages, 274);
   DDice3.Left := 128;
   DDice3.Top := 170;
   DDice4.SetImgIndex (g_WMainImages, 276);
   DDice4.Left := 170;
   DDice4.Top := 170;
   DDice5.SetImgIndex (g_WMainImages, 278);
   DDice5.Left := 212;
   DDice5.Top := 170;
   DDice6.SetImgIndex (g_WMainImages, 280);
   DDice6.Left := 254;
   DDice6.Top := 170;


   d := g_WAresImages.Images[123];     //°æ¸Å
   if d <> nil then begin
      DOffAuction.Left := (d.Width - 15) + (g_FScreenWidth - d.Width) div 2;
      DOffAuction.Top  := (g_FScreenHeight - d.Height) div 2;
      DOffAuction.SetImgIndex (g_WAresImages, 123);
   end;

   DAucClose.SetImgIndex (g_WMain2Images, 360);
   DAucClose.Left := 250;
   DAucClose.Top := 3;

   DOffAuc.SetImgIndex (g_WAresImages, 119);
   DOffAuc.Left := (DOffAuction.Width - DOffAuc.Width) div 2;
   DOffAuc.Top := 292;


   DOffAucItem.Left := 25;
   DOffAucItem.Top  := 70;
   DOffAucItem.Width := 36;
   DOffAucItem.Height := 33;


   d := g_WAresImages.Images[124];     //°æ¸Å
   if d <> nil then begin
      DOnAuction.Left := (d.Width - 15) + (g_FScreenWidth - d.Width) div 2;
      DOnAuction.Top  := (g_FScreenHeight - d.Height) div 2;
      DOnAuction.SetImgIndex (g_WAresImages, 124);
   end;

   DAuctionClose.SetImgIndex (g_WMain2Images, 360);
   DAuctionClose.Left := 250;
   DAuctionClose.Top := 3;

   DGetAuction.SetImgIndex (g_WTitleImages, 630);
   DGetAuction.Left := 95;
   DGetAuction.Top := 292;

   DAucItem.Left := 25;
   DAucItem.Top  := 70;
   DAucItem.Width := 36;
   DAucItem.Height := 33;

 {---------------------------------------------}
   //°³ÀÎ»óÁ¡

   d := g_WAresImages.Images[283];   //°³ÀÎ»óÁ¡
   if d <> nil then begin
      DStoreGridWin.Left := 150;
      DStoreGridWin.Top  := (g_FScreenHeight - d.Height) div 2 - 100;
      DStoreGridWin.SetImgIndex (g_WAresImages, 283);
   end;
   DStoreWinExit.SetImgIndex (g_WMain2Images, 360);
   DStoreWinExit.Left := 250;
   DStoreWinExit.Top := 3;

   DGStore.Left := 25;
   DGStore.Top  := 84;
   DGStore.Width := 226;
   DGStore.Height := 121;

   DStoreMacro.SetImgIndex(g_WMainImages, 1346);
   DStoreMacro.Left := 22;
   DStoreMacro.Top := 290;

   DStoreOpen.SetImgIndex(g_WTitleImages, 382);
   DStoreOpen.Left := 122;
   DStoreOpen.Top := 286;

   DStoreCancel.SetImgIndex(g_WTitleImages, 385);
   DStoreCancel.Left := 196;
   DStoreCancel.Top := 286;


   //==============±×·ì¿ø
   d := g_WAresImages.Images[131];
   if d <> nil then begin
     DWndGroup.SetImgIndex(g_WAresImages, 131);
     DWndGroup.Left := 0;
     DWndGroup.Top := 55;
   end;
   DWndGroupMember.SetImgIndex(g_WAresImages, 131);
   DWndGroupMember.Left := 0;
   DWndGroupMember.Top := 18;
   DWndGroupMember.Width := 150;
   DWndGroupMember.Height := 450;

   DGroupClose.SetImgIndex(g_WAresImages, 132);
   DGroupClose.Left := 60;
   DGroupClose.Top := 1;

   DGroupMember1.SetImgIndex(g_WAresImages, 415);
   DGroupMember1.Left := 0;
   DGroupMember1.Top := 0;

   DGroupMember2.SetImgIndex(g_WAresImages, 415);
   DGroupMember2.Left := 0;
   DGroupMember2.Top := 35;

   DGroupMember3.SetImgIndex(g_WAresImages, 415);
   DGroupMember3.Left := 0;
   DGroupMember3.Top := 70;

   DGroupMember4.SetImgIndex(g_WAresImages, 415);
   DGroupMember4.Left := 0;
   DGroupMember4.Top := 105;

   DGroupMember5.SetImgIndex(g_WAresImages, 415);
   DGroupMember5.Left := 0;
   DGroupMember5.Top := 140;

   DGroupMember6.SetImgIndex(g_WAresImages, 415);
   DGroupMember6.Left := 0;
   DGroupMember6.Top := 175;

   DGroupMember7.SetImgIndex(g_WAresImages, 415);
   DGroupMember7.Left := 0;
   DGroupMember7.Top := 210;

   DGroupMember8.SetImgIndex(g_WAresImages, 415);
   DGroupMember8.Left := 0;
   DGroupMember8.Top := 245;

   DGroupMember9.SetImgIndex(g_WAresImages, 415);
   DGroupMember9.Left := 0;
   DGroupMember9.Top := 280;

   DGroupMember10.SetImgIndex(g_WAresImages, 415);
   DGroupMember10.Left := 0;
   DGroupMember10.Top := 315;

   DGroupMember11.SetImgIndex(g_WAresImages, 415);
   DGroupMember11.Left := 0;
   DGroupMember11.Top := 350;

   DGroupMember12.SetImgIndex(g_WAresImages, 415);
   DGroupMember12.Left := 0;
   DGroupMember12.Top := 385;

   //==============ºÐÇØ
   d := g_WTitleImages.Images[711];
   if d <> nil then begin
    DDisassembleDlg.Left := 0;
    DDisassembleDlg.Top  := 223;
    DDisassembleDlg.SetImgIndex (g_WTitleImages, 711);
   end;
   DDisassembleStart.SetImgIndex (g_WTitleImages, 715);
   DDisassembleStart.Left := 62;
   DDisassembleStart.Top := 189;

   DDisaClose.SetImgIndex (g_WMain2Images, 360);
   DDisaClose.Left := 168;
   DDisaClose.Top := 4;

   DDisassembleSpot.Width := 34;
   DDisassembleSpot.Height := 30;
   DDisassembleSpot.Left := 86;
   DDisassembleSpot.Top := 94;


   //==================

   //==============ºÐÇØ
   d := g_WTitleImages.Images[711];
   if d <> nil then begin
    DDismantleDlg.Left := 0;
    DDismantleDlg.Top  := 223;
    DDismantleDlg.SetImgIndex (g_WTitleImages, 711);
   end;
   DDismantleStart.SetImgIndex (g_WTitleImages, 715);
   DDismantleStart.Left := 62;
   DDismantleStart.Top := 189;

   DDismantleClose.SetImgIndex (g_WMain2Images, 360);
   DDismantleClose.Left := 168;
   DDismantleClose.Top := 4;

   DDismantleSpot.Width := 34;
   DDismantleSpot.Height := 30;
   DDismantleSpot.Left := 86;
   DDismantleSpot.Top := 94;
   //==================

   d := g_WAresImages.Images[284];
   if d <> nil then begin
    DStoreMsgDlg.Left := DStoreGridWin.Left + DStoreGridWin.Width + 5;
    DStoreMsgDlg.Top  := (g_FScreenHeight - d.Height) div 2;
    DStoreMsgDlg.SetImgIndex (g_WAresImages, 284);
   end;
   DStoreMsgOk.SetImgIndex (g_WTitleImages, 200);
   DStoreMsgOk.Left := 210;
   DStoreMsgOk.Top := 144;

   DStoreMsgCancel.SetImgIndex (g_WTitleImages, 203);
   DStoreMsgCancel.Left := 290;
   DStoreMsgCancel.Top := 144;

   DStoreGold.SetImgIndex (g_WMainImages, 231);
   DStoreGold.Left := 9;
   DStoreGold.Top := 29;

   DStoreGGold.SetImgIndex (g_WMainImages, 231);
   DStoreGGold.Left := 105;
   DStoreGGold.Top := 29;

   DStoreMsgClosed.SetImgIndex(g_WMain2Images, 360);
   DStoreMsgClosed.Left := 376;
   DStoreMsgClosed.Top := 4;

   //===============°³ÀÎ»óÁ¡=======»ó´ë¹æÀÌº¼°æ¿ì======
   d := g_WAresImages.Images[6];   //°³ÀÎ»óÁ¡
   if d <> nil then begin
      DUserStore.Left := (g_FScreenWidth - d.Width) div 2;
      DUserStore.Top := (g_FScreenHeight - d.Height) div 2;
      DUserStore.SetImgIndex (g_WAresImages, 6);
   end;
   DUserStoreClose.SetImgIndex(g_WMain2Images, 360);
   DUserStoreClose.Left := 250;
   DUserStoreClose.Top := 3;

   DGUserStore.Left := 25;
   DGUserStore.Top  := 84;
   DGUserStore.Width := 226;
   DGUserStore.Height := 121;

   DUserStoreBuy.SetImgIndex(g_WTitleImages, 483);
   DUserStoreBuy.Left := 110;
   DUserStoreBuy.Top := 285;

 {---------------------------------------------}
   //Àç·Ã
   d := g_WMainImages.Images[1002];   //Àç·Ã
   if d <> nil then begin
      DUpWapondow.Left := 0;
      DUpWapondow.Top  := 223;
      DUpWapondow.SetImgIndex (g_WMainImages, 1002);
   end;
   DBUpWaponexit.SetImgIndex (g_WMain2Images, 360);
   DBUpWaponexit.Left := 139;
   DBUpWaponexit.Top := 4;

   DBUpWaponOK.SetImgIndex (g_WTitleImages, 160);
   DBUpWaponOK.Left := 60;
   DBUpWaponOK.Top := 177;

   DUpWapItemgrid.Left := 12;
   DUpWapItemgrid.Top  := 37;
   DUpWapItemgrid.Width := 139;
   DUpWapItemgrid.Height := 131;

   //´ë¿©Ã¢========================================================

   d := g_WMainImages.Images[230];
   if d <> nil then begin
     DRentalDlg.SetImgIndex (g_WMainImages, 230);
     DRentalDlg.Left := (g_FScreenWidth - d.Width) div 2;
     DRentalDlg.Top := (g_FScreenHeight - d.Height) div 2;
   end;

   DRentalExit.SetImgIndex(g_WMain2Images, 360);
   DRentalExit.Left := 376;
   DRentalExit.Top := 4;

   DRentalList.SetImgIndex(g_WTitleImages,420);
   DRentalList.Left := 8;
   DRentalList.Top := 32;

   DBorrowList.SetImgIndex(g_WTitleImages,422);
   DBorrowList.Left := 104;
   DBorrowList.Top := 32;

   DReturn.SetImgIndex(g_WTitleImages,430);
   DReturn.Left := 17;
   DReturn.Top := 144;

   DWithdraw.SetImgIndex(g_WTitleImages,434);
   DWithdraw.Left := 17;
   DWithdraw.Top := 144;

   DRental.SetImgIndex(g_WTitleImages,424);
   DRental.Left := 310;
   DRental.Top := 144;

   DRRefresh.SetImgIndex(g_WMainImages,663);
   DRRefresh.Left := 280;
   DRRefresh.Top := 144;


   //´ë¿©Ã¢
   d := g_WMainImages.Images[238];
   if d <> nil then begin
      DDRentalDlg.Left := g_FScreenWidth - d.Width;
      DDRentalDlg.Top  := 280;
      DDRentalDlg.SetImgIndex (g_WMainImages, 238);
   end;
   DRGrid.Left := 16;
   DRGrid.Top  := 34;
   DRGrid.Width := 37;
   DRGrid.Height := 33;

   DRentalAllow.SetImgIndex (g_WMainImages, 250);
   DRentalAllow.Left := 18;
   DRentalAllow.Top := 76;

   DRentalDay.SetImgIndex (g_WTitleImages, 444);
   DRentalDay.Left := 48;
   DRentalDay.Top := 76;

   DRentalOk.SetImgIndex (g_WTitleImages, 440);
   DRentalOk.Left := 129;
   DRentalOk.Top := 76;

   DRentalClose.SetImgIndex (g_WMain2Images, 360);
   DRentalClose.Left := 180;
   DRentalClose.Top := 3;

   DRGold.SetImgIndex (g_WMainImages, 28);
   DRGold.Left := 20;
   DRGold.Top  := 44;

   d := g_WMainImages.Images[237];     //±³È¯°Å·¡
   if d <> nil then begin
      DRentalMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
      DRentalMsgDlg.Top  := 50;
      DRentalMsgDlg.SetImgIndex (g_WMainImages, 237);
   end;

   //»ó´ë¹æ ´ë¿©Ã¢
   d := g_WMainImages.Images[238];
   if d <> nil then begin
      DRentalRemoteDlg.Left := DDRentalDlg.Left - d.Width;
      DRentalRemoteDlg.Top  := 90;
      DRentalRemoteDlg.SetImgIndex (g_WMainImages, 238);
   end;
   DRRGrid.Left := 16;
   DRRGrid.Top  := 34;
   DRRGrid.Width := 37;
   DRRGrid.Height := 33;

   DRRGold.SetImgIndex (g_WMainImages, 28);
   DRRGold.Left := 20;
   DRRGold.Top  := 44;

   DRRentalClose.SetImgIndex (g_WMain2Images, 360);
   DRRentalClose.Left := 180;
   DRRentalClose.Top := 3;

   DRRentalAllow.SetImgIndex (g_WMainImages, 250);
   DRRentalAllow.Left := 18;
   DRRentalAllow.Top := 76;


   {---------------------------------------------}

   d := g_WMainImages.Images[430];
   if d <> nil then begin
     DMenuWindows.SetImgIndex (g_WMain2Images, 430);
     DMenuWindows.Left := g_FScreenWidth - 55; // 745;
     DMenuWindows.Top := g_FScreenHeight - 397; //203;
   end;
   DBotExit.SetImgIndex (g_WTitleImages,633);
   DBotExit.Left := 3;
   DBotExit.Top := 12;
   DBotExit.DontDrawUp := True;
   DBotLogout.SetImgIndex (g_WTitleImages,636);
   DBotLogout.Left := 3;
   DBotLogout.Top := 31;
   DBotLogout.DontDrawUp := True;
   DBotHelp.SetImgIndex (g_WMainImages,1970);
   DBotHelp.Left := 3;
   DBotHelp.Top := 50;
   DBotHelp.DontDrawUp := True;

   DBotTrade.SetImgIndex (g_WMainImages,1973);  //±³È¯ ¹öÆ°
   DBotTrade.Left := 3;
   DBotTrade.Top := 69;
   DBotTrade.DontDrawUp := True;

   DBotRank.SetImgIndex(g_WMainImages,2000);   //·©Å· ¹öÆ°
   DBotRank.Left :=3;
   DBotRank.Top := 88;

   DBotRank.DontDrawUp := True;
   DMake.SetImgIndex (g_WMainImages,1997);  //Á¦ÀÛ±â¼ú
   DMake.Left := 3;
   DMake.Top := 107;
   DMake.DontDrawUp := True;

   DBotPet.SetImgIndex (g_WMain2Images,431); //¿µ¹°
   DBotPet.Left := 3;
   DBotPet.Top := 126;
   DBotPet.DontDrawUp := True;

   DBotTiger.SetImgIndex (g_WMainImages,1976); //È£¶ûÀÌ
   DBotTiger.Left := 3;
   DBotTiger.Top := 145;
   DBotTiger.DontDrawUp := True;
   DBotReady2.SetImgIndex (g_WMainImages,1979);      //ÁØºñÁß
   DBotReady2.Left := 3;
   DBotReady2.Top := 164;
   DBotReady2.DontDrawUp := True;
   DBotFriend.SetImgIndex (g_WMainImages,1982);
   DBotFriend.Left := 3;
   DBotFriend.Top := 183;
   DBotFriend.DontDrawUp := True;
   DBotLover.SetImgIndex (g_WMainImages,1985);
   DBotLover.Left := 3;
   DBotLover.Top := 202;
   DBotLover.DontDrawUp := True;
   DBotMaster.SetImgIndex (g_WMainImages,1988);      //»çÁ¦
   DBotMaster.Left := 3;
   DBotMaster.Top := 221;
   DBotMaster.DontDrawUp := True;
   DBotGroup.SetImgIndex (g_WMainImages,1991);
   DBotGroup.Left := 3;
   DBotGroup.Top := 240;
   DBotGroup.DontDrawUp := True;
   DBotGuild.SetImgIndex (g_WMainImages,1994);
   DBotGuild.Left := 3;
   DBotGuild.Top := 259;
   DBotGuild.DontDrawUp := True;
   {---------------------------------------------}
   //È¯Àü
   d := g_WMainImages.Images[1104];
   if d <> nil then begin
     DExChangeDlg.SetImgIndex (g_WMainImages, 1104);
     DExChangeDlg.Left := (g_FScreenWidth - d.Width) div 2;
     DExChangeDlg.Top := (g_FScreenHeight - d.Height) div 2;
   end;

   DExitChange.SetImgIndex(g_WMain2Images, 360);
   DExitChange.Left := 279;
   DExitChange.Top := 2;

   DGetExChange.SetImgIndex(g_WTitleImages, 496);
   DGetExChange.Left := 210;
   DGetExChange.Top := 192;

   DExGoldChange.SetImgIndex(g_WTitleImages, 523);
   DExGoldChange.Left := 42;
   DExGoldChange.Top := 192;

   DExGold.SetImgIndex (g_WMainImages, 28);
   DExGold.Left := 35;
   DExGold.Top  := 103;

   DExHwan.SetImgIndex (g_WMainImages, 28);
   DExHwan.Left := 35;
   DExHwan.Top  := 103;

   DDExGold.SetImgIndex (g_WMainImages, 28);
   DDExGold.Left := 35;
   DDExGold.Top  := 157;

   DDExHwan.SetImgIndex (g_WMainImages, 28);
   DDExHwan.Left := 35;
   DDExHwan.Top  := 157;
   Initialized := True;
end;

procedure TFrmDlg.InitializeEx;
begin
  if csDesigning in ComponentState then Exit;
  if Initialized2 then Exit;

  DTopMsg.SetSurface(FrmMain.DXDraw.DDraw,nil);

  Initialized2 := True;
end;

procedure TFrmDlg.DoBeltSetup;
var
   d: TDirectDrawSurface;
begin
  DBelt1.Width := 32;
  DBelt1.Height := 29;
  DBelt2.Width := 32;
  DBelt2.Height := 29;
  DBelt3.Width := 32;
  DBelt3.Height := 29;
  DBelt4.Width := 32;
  DBelt4.Height := 29;
  DBelt5.Width := 32;
  DBelt5.Height := 29;
  DBelt6.Width := 32;
  DBelt6.Height := 29;

  DBeltSwap.DontDrawUp := True;
  DBeltClose.DontDrawUp := True;

  if g_boVerticalBelt then begin         //º§Æ®Ã¢
    d := g_WMainImages.Images[1944];
    if d <> nil then begin
      DBeltWindow.SetImgIndex (g_WMainImages, 1944);
      DBeltWindow.Left := 0;
      DBeltWindow.Top := g_FScreenHeight - 456;
    end;

    DBelt1.Left := 4;
    DBelt1.Top := 13;

    DBelt2.Left := 4;
    DBelt2.Top := 48;

    DBelt3.Left := 4;
    DBelt3.Top := 83;

    DBelt4.Left := 4;
    DBelt4.Top := 118;

    DBelt5.Left := 4;
    DBelt5.Top := 153;

    DBelt6.Left := 4;
    DBelt6.Top := 188;

    DBeltSwap.SetImgIndex (g_WMainImages, 1938);
    DBeltSwap.Top := 222;
    DBeltSwap.Left := 19;

    DBeltClose.SetImgIndex (g_WMainImages, 1935);
    DBeltClose.Top := 222;
    DBeltClose.Left := 3;
  end
  else begin                           //º§Æ®Ã¢
    d := g_WMainImages.Images[1932];
    if d <> nil then begin
      DBeltWindow.SetImgIndex (g_WMainImages, 1932);
      DBeltWindow.Left := 242;
      if g_FScreenHeight = DEFSCREENHEIGHT then
       DBeltWindow.Top := 498 - DNewSay.Height - 14       //Ã¤ÆÃ ±Û
      else DBeltWindow.Top :=  666 - DNewSay.Height - 14;
    end;

    DBelt1.Left := 12;
    DBelt1.Top := 5;

    DBelt2.Left := 47;
    DBelt2.Top := 5;

    DBelt3.Left := 82;
    DBelt3.Top := 5;

    DBelt4.Left := 117;
    DBelt4.Top := 5;

    DBelt5.Left := 152;
    DBelt5.Top := 5;

    DBelt6.Left := 187;
    DBelt6.Top := 5;

    DBeltSwap.SetImgIndex (g_WMainImages, 1926);
    DBeltSwap.Top := 3;
    DBeltSwap.Left := 222;

    DBeltClose.SetImgIndex (g_WMainImages, 1923);
    DBeltClose.Top := 21;
    DBeltClose.Left := 222;
  end;
end;


procedure TFrmDlg.DoBeltHeroSetup;
var
   d: TDirectDrawSurface;
begin
  DBelt1Hero.Width := 32;
  DBelt1Hero.Height := 29;
  DBelt2Hero.Width := 32;
  DBelt2Hero.Height := 29;

  if g_boVerticaHerolBelt then begin         //º§Æ®Ã¢
    d := g_WMainImages.Images[1943];
    if d <> nil then begin
      DBeltHero.SetImgIndex (g_WMainImages, 1943);
      DBeltHero.Left := g_FScreenWidth - d.Width;
      DBeltHero.Top := 184;
    end;

    DBelt1Hero.Left := 4;
    DBelt1Hero.Top := 13;

    DBelt2Hero.Left := 4;
    DBelt2Hero.Top := 48;

    DBeltHeroSwap.SetImgIndex (g_WMainImages, 1938);
    DBeltHeroSwap.Top := 83;
    DBeltHeroSwap.Left := 19;

    DBeltHeroClose.SetImgIndex (g_WMainImages, 1935);
    DBeltHeroClose.Top := 83;
    DBeltHeroClose.Left := 3;

  end
  else begin                           //º§Æ®Ã¢
    d := g_WMainImages.Images[1921];
    if d <> nil then begin
      DBeltHero.SetImgIndex (g_WMainImages, 1921);
      DBeltHero.Left := 242 + 240 + 2;
      if g_FScreenHeight = DEFSCREENHEIGHT then
       DBeltHero.Top := 498 - DNewSay.Height - 14       //Ã¤ÆÃ ±Û
      else DBeltHero.Top :=  666 - DNewSay.Height - 14;
    end;

    DBelt1Hero.Left := 12;
    DBelt1Hero.Top := 5;

    DBelt2Hero.Left := 47;
    DBelt2Hero.Top := 5;

    DBeltHeroSwap.SetImgIndex (g_WMainImages, 1926);
    DBeltHeroSwap.Top := 3;
    DBeltHeroSwap.Left := 83;

    DBeltHeroClose.SetImgIndex (g_WMainImages, 1923);
    DBeltHeroClose.Top := 21;
    DBeltHeroClose.Left := 83;
  end;
end;
{------------------------------------------------------------------------}

procedure TFrmDlg.OpenMyStatus;
var
  str : String;
begin
   str := Copy(fLover.GetDisplay(0), length(STR_LOVER)+1, 6);
   if str = '' then DHeartMyState.Visible := False
   else DHeartMyState.Visible := True;

   DStateWin.Visible := not DStateWin.Visible;
  // Append2Tick:= GetTickCount;
   PageChanged;
end;

procedure TFrmDlg.OpenUserState (UserState: TUserStateInfo);
begin
   UserState1 := UserState;
   if UserState1.bExistLover then  DLoverHeart.Visible := True
   else DLoverHeart.Visible := False;
   DUserState1.Visible := TRUE;
 //  Append2Tick:= GetTickCount;
end;

procedure TFrmDlg.OpenHeroStatus;
begin
  DHeroStateWin.Visible := not DHeroStateWin.Visible;
  HeroPageChanged;
end;

procedure TFrmDlg.OpenGuildGrow (GuildGrow: TGuildGrowUp);  //¹®ÆÄ¼ºÀå
begin
   GuildGrow1 := GuildGrow;
   GrowPage := 0;
   GrowPageChanged;
   DGuildGrowDlg.Visible := TRUE;
end;

procedure TFrmDlg.OpenGuildGrow2 (GuildGrow: TGuildGrowUp);  //¹®ÆÄ¼ºÀå
begin
   GuildGrow1 := GuildGrow;
end;

procedure TFrmDlg.OpenItemBag;
begin
   DItemBag.Visible := not DItemBag.Visible;
   if DItemBag.Visible then
      ArrangeItemBag;
end;

procedure TFrmDlg.ViewBottomBox (visible: Boolean);
begin
   DBottom.Visible := visible;
end;

procedure TFrmDlg.CancelItemMoving;
var
   idx, n: integer;
begin
   if (g_MovingItem.Owner = DHeroStateWin) or (g_MovingItem.Owner = DHeroItemBag) then begin
     CancelHeroItemMoving;
     exit;
   end;
   if g_boItemMoving then begin
      g_boItemMoving := FALSE;
      idx := g_MovingItem.Index;
      if idx < 0 then begin
        if idx = -99 then begin
          AddItemBag (g_MovingItem.Item);
          Exit;
        end;
        if (idx <= -26) and (idx > -36) then begin    //°Å·¡
          AddDealItem (g_MovingItem.Item);
        end else begin
          if (idx = -36) then begin    //´ë¿©
            AddRentalItem (g_MovingItem.Item);
          end else begin
            if (idx <= -46) and (idx > -52) then begin    //Á¦Á¶½ºÃÄ
              AddMakeItem (g_MovingItem.Item);
            end else begin
              n := -(idx+1);
              if n in [0..MAXUSEITEM] then begin          //¾ÆÀÌÅÛ °¹¼ö
                g_UseItems[n] := g_MovingItem.Item;
              end;
            end;
          end;
        end;
      end else begin
        if (idx >= 500) and (idx < 600) then begin
          n := idx - 500;
          if n in [0..STORAGELIMIT-1] then begin
            if g_StoreItem[n].S.Name = '' then begin
              g_StoreItem[n] := g_MovingItem.Item;
            end else begin
              AddItemStore(g_MovingItem.Item);
            end;
          end;
        end else begin
          if (idx >= 600) then begin
            n := idx - 600;
            if n in [0..STORAGELIMIT-1] then begin
              if g_HeroStoreItem[n].S.Name = '' then begin
                g_HeroStoreItem[n] := g_MovingItem.Item;
              end else begin
                AddItemHeroStore(g_MovingItem.Item);
              end;
            end;
          end else begin
            if idx in [0..MAXBAGITEM-1] then begin
              if g_ItemArr[idx].S.Name = '' then begin
                g_ItemArr[idx] := g_MovingItem.Item;
              end else begin
                AddItemBag (g_MovingItem.Item);
              end;
            end;
          end;
        end;
      end;
      g_MovingItem.Item.S.Name := '';
   end;
   ArrangeItemBag;
end;



procedure TFrmDlg.CancelHeroItemMoving;
var
  Idx, n: Integer;
begin
  if g_boItemMoving then begin
    g_boItemMoving := False;
    Idx := g_MovingItem.Index;
    if Idx < 0 then begin
      if (Idx <= -26) and (Idx > -36) then begin
        AddDealItem(g_MovingItem.Item);
      end else begin
        if (idx = -36) then begin    //´ë¿©
          AddRentalItem (g_MovingItem.Item);
        end else begin
          if (idx <= -46) and (idx > -52) then begin    //Á¦Á¶½ºÃÄ
            AddMakeItem (g_MovingItem.Item);
          end else begin
            n := -(Idx + 1);
            if n in [0..MAXHEROUSEITEM] then begin
              g_HeroUseItems[n] := g_MovingItem.Item;
            end;
          end;
        end;
      end;
    end else begin
      if (idx >= 500) and (idx < 600) then begin
        n := idx - 500;
        if n in [0..STORAGELIMIT-1] then begin
          if g_StoreItem[n].S.Name = '' then begin
            g_StoreItem[n] := g_MovingItem.Item;
          end else begin
            AddItemStore(g_MovingItem.Item);
          end;
        end;
      end else begin
        if idx >= 600 then begin
          n := idx - 600;
          if n in [0..STORAGELIMIT-1] then begin
            if g_HeroStoreItem[n].S.Name = '' then begin
              g_HeroStoreItem[n] := g_MovingItem.Item;
            end else begin
              AddItemHeroStore(g_MovingItem.Item);
            end;
          end;
        end else begin
          if Idx in [0..MAXHEROBAGITEM - 1] then begin
            if g_HeroItemArr[Idx].s.Name = '' then begin
              g_HeroItemArr[Idx] := g_MovingItem.Item;
            end else begin
              AddHeroItemBag(g_MovingItem.Item);
            end;
          end;
        end;
      end;
    end;
    g_MovingItem.Item.s.Name := '';
  end;
  ArrangeHeroItemBag;
end;

procedure TFrmDlg.CancelItemMoving2;      //¿©°ü
var
   idx, n: integer;
begin
  if g_boItemMoving then begin
    g_boItemMoving := FALSE;
    idx := g_MovingItem.Index;
    if (idx >= 500) and (idx < 600) then begin
      n := idx - 500;
      if n in [0..STORAGELIMIT-1] then begin
        if g_StoreItem[n].S.Name = '' then begin
          g_StoreItem[n] := g_MovingItem.Item;
        end else begin
          AddItemStore(g_MovingItem.Item);
        end;
      end;
    end else begin
      if idx >= 600 then begin
        n := idx - 600;
        if n in [0..STORAGELIMIT-1] then begin
          if g_HeroStoreItem[n].S.Name = '' then begin
            g_HeroStoreItem[n] := g_MovingItem.Item;
          end else begin
            AddItemHeroStore(g_MovingItem.Item);
          end;
        end;
      end;
    end;
    g_MovingItem.Item.S.Name := '';
  end;
end;


procedure TFrmDlg.CancelItemAuto;
var
  idx, n: integer;
begin
  if g_boItemMoving then begin
    g_boItemMoving := FALSE;
    idx := g_MovingItem.Index;
    if (idx = -53) or (idx = -54) then begin
      n := idx + 53;
      if n in [0,1] then begin
        if g_AutoPotItems[n].S.Name = '' then begin
          g_AutoPotItems[n] := g_MovingItem.Item;
        end else begin
          AddAutoItem(g_MovingItem.Item);
        end;
      end;
    end;
    g_MovingItem.Item.S.Name := '';
  end;
end;


procedure TFrmDlg.OpenSayItemShow(mitem: TClientItem);
var
  nWhere: Integer;
  List: TStringList;
begin
  g_MouseItem := mitem;
  if (g_MouseItem.s.Name <> '') then begin
    nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
    if (nWhere >= 0) then begin
      List := TStringList.Create;
      try
        GetMouseItemHint(g_MySelf, @g_MouseItem);
        List.AddStrings(HintList);

        GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
        if HintList.Count > 0 then begin
          HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];     //°¡¹æ
        end;
        if HintList.Count > 0 then begin
          DScreen.ShowHintL(DNewSay.Left, DNewSay.Top, List, HintList, True);
        end;
        HintList.Clear;
      finally
        FreeAndNil(List);
      end;
      g_MouseItem.s.Name := '';
    end else begin
      GetMouseItemHint(g_MySelf, @g_MouseItem);
      if HintList.Count > 0 then begin
        DScreen.ShowHintB(DNewSay.Left, DNewSay.Top, HintList, True);
      end;
    end;
  end;
end;

procedure TFrmDlg.DropMovingItem;     //¾ÆÀÌÅÛ ¹ö¸²
begin
   if g_boItemMoving then begin
      g_boItemMoving := FALSE;
      if g_MovingItem.Item.S.Name <> '' then begin
        if g_MovingItem.Item.S.StdMode in [0,1,3,45,46] then begin
          if DMakeItemDlg.Visible then begin
             DMessageDlg ('Äú²»ÄÜ¶ªÆúÔÚÖÆÔì¹ý³ÌÖÐ¿ÉÄÜÖØµþµÄÎïÆ·¡£', [mbOk]);
             g_boItemMoving := True;
             CancelItemMoving;
             Exit;
          end;
        end;
        if (g_MovingItem.Item.S.btValue[19] = 1) then begin   //´ë¿© ¾ÆÀÌÅÛ
          if mrOk = DSimpleMessageDlg2 ('Äú²»ÄÜ¶ªÆúÔÚÖÆÔì¹ý³ÌÖÐ¿ÉÄÜÖØµþµÄÎïÆ·¡£', [mbOK]) then begin
            AddItemBag(g_MovingItem.Item);
            g_MovingItem.Item.S.Name := '';
          end;
        end else
        if (g_MovingItem.Item.S.btValue[19] > 2) then begin   //ºÀÀÎ ¾ÆÀÌÅÛ
          if mrOk = DSimpleMessageDlg2 ('Äã²»ÄÜ¶ªÆú·âÓ¡µÄÎïÆ·¡£', [mbOK]) then begin
            AddItemBag(g_MovingItem.Item);
            g_MovingItem.Item.S.Name := '';
          end;
        end else
        if (g_MovingItem.Owner = DHeroItemBag) then begin
          AddHeroItemBag (g_MovingItem.Item);
          g_MovingItem.Item.S.Name := '';
        end else
        if (g_MovingItem.Owner = DItemBag) then begin
          if (g_MovingItem.Item.S.DropDell) or (g_MovingItem.Item.S.btValue[19] = 2) then begin   //¹ÝÂ¦ ¾ÆÀÌÅÛ ¹ö¸®¸é »èÁ¦
            if mrOk = DSimpleMessageDlg ('µ±Ç°ÎïÆ·¶ªÆú¾Í»áÏûÊ§£¬\ÄãÈ·¶¨Òª¶ªÆúÕâ¼þÎïÆ·Âð£¿', [mbOK, mbCancel]) then begin
              FrmMain.SendDropItem (g_MovingItem.Item.S.Name, g_MovingItem.Item.MakeIndex)   //¾ÆÀÌÅÛ ¹ö¸²
            end else begin
              AddItemBag(g_MovingItem.Item);
              g_MovingItem.Item.S.Name := '';
            end;
          end else
          if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨Òª¶ªÆúÕâ¼þÎïÆ·Âð£¿', [mbYes, mbNo]) then begin
            FrmMain.SendDropItem (g_MovingItem.Item.S.Name, g_MovingItem.Item.MakeIndex);   //¾ÆÀÌÅÛ ¹ö¸²
            AddDropItem (g_MovingItem.Item);
            g_MovingItem.Item.S.Name := '';
          end else begin  //¾È¹ö¸±.
            AddItemBag (g_MovingItem.Item);
            g_MovingItem.Item.S.Name := '';
          end;
        end;
      end;
   end;
end;

procedure TFrmDlg.OpenAdjustAbility;
begin
  if not DAdjustAbility.Visible then begin
   DAdjustAbility.Left := 0;
   DAdjustAbility.Top := 0;
   g_nSaveBonusPoint := g_nBonusPoint;
   FillChar (g_BonusAbilChg, sizeof(TNakedAbility), #0);
  end;
  if DAdjustAbility.Visible then g_nBonusPoint := g_nSaveBonusPoint;
  DAdjustAbility.Visible := not DAdjustAbility.Visible;
end;
//¶ª½ð±Òµ½µØÉÏ
procedure TFrmDlg.DBackgroundBackgroundClick(Sender: TObject);
var
   dropgold, mj: integer;
   valstr: string;
   Aucbuff : pTAucbuffItem; //°æ¸Å
   i , YSize:integer;
begin
   if g_boItemMoving then begin
      DBackground.WantReturn := TRUE;
      if g_MovingItem.Item.S.Name = g_sGoldName then begin
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name := '';
         DialogSize := 1;
         DMessageDlg ('ÇëÊäÈëÄãÒª¶ªÆúµÄ½ð±ÒµÄÊýÁ¿...', [mbOk, mbAbort]);
         GetValidStrVal (DlgEditText, valstr, [' ']);
         dropgold := Str_ToInt (valstr, 0);
         FrmMain.SendDropGold (dropgold);
      end;
      mj := g_MovingItem.Index;
       if mj >= 500 then begin   //¿©°ü
         CancelItemMoving;
         DMessageDlg ('²Ö¿âÖÐµÄÎïÆ·²»ÄÜÖ±½Ó¶ªÆú¡£',[mbOk]);
         Exit;
       end else
       if mj >= 0 then
         DropMovingItem;
   end;


   for I := 0 to g_AucList.Count - 1 do begin    //°æ¸Å
      Aucbuff := pTAucbuffItem(g_AucList.Items[I]);
      If (Aucbuff <> nil) and AuctionView then begin
        if DSkillBar.Visible then YSize := 25
        else YSize := 0;
        if (g_nMouseX >= 10 + (i*45)) and (g_nMouseX <= 40 + (i*45)) and (g_nMouseY >= 9 + YSize) and (g_nMouseY <= 44 + YSize) then begin   //°æ¸ÅÀ§Ä¡
          nAucItemIndex := i;
          OpenAuc;
        end;
      end;
    end;
end;

procedure TFrmDlg.DBackgroundMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   if g_boItemMoving then begin
      DBackground.WantReturn := TRUE;
   end;
end;
{------------------------------------------------------------------------}
     ///¸Þ½ÃÁö ´ÙÀÌ¾ó·Î±× ¹Ú½º
function  TFrmDlg.DMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
const
   XBase = 340;
var
  I: Integer;
   lx, ly: integer;
   d: TDirectDrawSurface;
  procedure ShowDice();
  var
    I: Integer;
    bo05:Boolean;
  begin
    if m_nDiceCount = 1 then begin
      if m_Dice[0].n67C < 20 then begin
        if GetTickCount - m_Dice[0].dwPlayTick > 100 then begin
          if m_Dice[0].n67C div 5 = 4 then begin
            m_Dice[0].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[0].nPlayPoint:=m_Dice[0].n67C div 5 + 8;
          end;
          m_Dice[0].dwPlayTick:=GetTickCount();
          Inc(m_Dice[0].n67C);
        end;
        exit;
      end;//00491461
      m_Dice[0].nPlayPoint:= m_Dice[0].nDicePoint;
      if GetTickCount - m_Dice[0].dwPlayTick > 1500 then begin
        DMsgDlg.Visible:=False;
      end;
      exit;
    end;//004914AD
    
    bo05:=True;
    for I := 0 to m_nDiceCount - 1 do begin
      if m_Dice[I].n67C < m_Dice[I].n680 then begin
        if GetTickCount - m_Dice[I].dwPlayTick > 100 then begin
          if m_Dice[I].n67C div 5 = 4 then begin
            m_Dice[I].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[I].nPlayPoint:=m_Dice[I].n67C div 5 + 8;
          end;
          m_Dice[I].dwPlayTick:=GetTickCount();
          Inc(m_Dice[I].n67C);
        end;
        bo05:=False;
      end else begin  //004915E4
        m_Dice[I].nPlayPoint:= m_Dice[I].nDicePoint;
        if GetTickCount - m_Dice[I].dwPlayTick < 2000 then begin
          bo05:=False;
        end;
      end;
    end; //for
    if bo05 then begin
      DMsgDlg.Visible:=False;
    end;
      
  end;
begin

   lx := XBase;
   ly := 126;
   case DialogSize of
      0:
         begin
            d := g_WMainImages.Images[381];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 381);
               DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
               DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
               msglx := 39;
               msgly := 38;
               lx := 90;
               ly := 36;
            end;
         end;
      1:
         begin
            d := g_WMainImages.Images[360];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 360);
               DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
               DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
               msglx := 26;
               msgly := 25;
               lx := XBase;
               ly := 157;
            end;
         end;
      2:
         begin
            d := g_WMainImages.Images[380];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 380);
               DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
               DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
               //¹«¸æ´°¿Ú
               msglx := 33;
               msgly := 25;
               lx := 145;
               ly := 425;
            end;
         end;
   end;
   MsgText := msgstr;
   ViewDlgEdit := FALSE;
   DMsgDlg.Floating := TRUE;
   DMsgDlgOk.Visible := FALSE;
   DMsgDlgYes.Visible := FALSE;
   DMsgDlgCancel.Visible := FALSE;
   DMsgDlgNo.Visible := FALSE;
   DMsgDlg.Left := (g_FScreenWidth - DMsgDlg.Width) div 2;
   DMsgDlg.Top := (g_FScreenHeight - DMsgDlg.Height) div 2;

   for I := 0 to m_nDiceCount - 1 do begin
     m_Dice[I].n67C:=0;
     m_Dice[I].n680:=Random(m_nDiceCount + 2) * 5 + 10;
     m_Dice[I].nPlayPoint:=1;
     m_Dice[I].dwPlayTick:=GetTickCount();
   end;

   if mbCancel in DlgButtons then begin
      DMsgDlgCancel.Left := lx;
      DMsgDlgCancel.Top := ly;
      DMsgDlgCancel.Visible := TRUE;
      lx := lx - 100;
   end;
   if mbNo in DlgButtons then begin
      DMsgDlgNo.Left := lx;
      DMsgDlgNo.Top := ly;
      DMsgDlgNo.Visible := TRUE;
      lx := lx - 100;
   end;
   if mbYes in DlgButtons then begin
      DMsgDlgYes.Left := lx;
      DMsgDlgYes.Top := ly;
      DMsgDlgYes.Visible := TRUE;
      lx := lx - 100;
   end;
   if (mbOk in DlgButtons) or (lx = XBase) then begin
      DMsgDlgOk.Left := lx;
      DMsgDlgOk.Top := ly;
      DMsgDlgOk.Visible := TRUE;
      lx := lx - 100;
   end;
   HideAllControls;
   DMsgDlg.ShowModal;
   if mbAbort in DlgButtons then begin
      ViewDlgEdit := TRUE;
      DMsgDlg.Floating := FALSE;
      with EdDlgEdit do begin
         Text := '';
         Width := DMsgDlg.Width - 70;
         Left := (g_FScreenWidth - EdDlgEdit.Width) div 2;
         Top  := (g_FScreenHeight - EdDlgEdit.Height) div 2 - 10;
      end;
   end;
   Result := mrOk;

   while TRUE do begin
      if not DMsgDlg.Visible then break;
      //FrmMain.DXTimerTimer (self, 0);
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;

      {if g_boMsgDlgTimeCheck then begin     //¿¬±¸
         if MsgDlgClickTime < GetTickCount then begin
            DMsgDlg.DialogResult := mrNo;
            g_boMsgDlgTimeCheck := False;
            MsgDlgClickTime := GetTickCount;
            DMsgDlg.Visible := False;
            break;
         end;
      end;  }

      if m_nDiceCount > 0 then begin
        m_boPlayDice:=True;

        for I := 0 to m_nDiceCount - 1 do begin
          m_Dice[I].nX:=((DMsgDlg.Width div 2 + 6) - ((m_nDiceCount * 32 + m_nDiceCount) div 2)) + (I * 32 + I);
          m_Dice[I].nY:=DMsgDlg.Height div 2 - 14;
        end;
        ShowDice();
      end;
      if Application.Terminated then exit;
   end;

   EdDlgEdit.Visible := FALSE;
   RestoreHideControls;
   DlgEditText := EdDlgEdit.Text;
   if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
   ViewDlgEdit := FALSE;
   Result := DMsgDlg.DialogResult;
   DialogSize := 1;
   m_nDiceCount:=0;
   m_boPlayDice:=False;
   SetImeMode (EdDlgEdit.Handle, imSAlpha);
end;

function  TFrmDlg.DSimpleMessageDlg2 (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
const
   XBase = 384;
var
  I: Integer;
   lx, ly: integer;
   d: TDirectDrawSurface;
  procedure ShowDice();
  var
    I: Integer;
    bo05:Boolean;
  begin
    if m_nDiceCount = 1 then begin
      if m_Dice[0].n67C < 20 then begin
        if GetTickCount - m_Dice[0].dwPlayTick > 100 then begin
          if m_Dice[0].n67C div 5 = 4 then begin
            m_Dice[0].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[0].nPlayPoint:=m_Dice[0].n67C div 5 + 8;
          end;
          m_Dice[0].dwPlayTick:=GetTickCount();
          Inc(m_Dice[0].n67C);
        end;
        exit;
      end;//00491461
      m_Dice[0].nPlayPoint:= m_Dice[0].nDicePoint;
      if GetTickCount - m_Dice[0].dwPlayTick > 1500 then begin
        DMsgDlg.Visible:=False;
      end;
      exit;
    end;//004914AD
    
    bo05:=True;
    for I := 0 to m_nDiceCount - 1 do begin
      if m_Dice[I].n67C < m_Dice[I].n680 then begin
        if GetTickCount - m_Dice[I].dwPlayTick > 100 then begin
          if m_Dice[I].n67C div 5 = 4 then begin
            m_Dice[I].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[I].nPlayPoint:=m_Dice[I].n67C div 5 + 8;
          end;
          m_Dice[I].dwPlayTick:=GetTickCount();
          Inc(m_Dice[I].n67C);
        end;
        bo05:=False;
      end else begin  //004915E4
        m_Dice[I].nPlayPoint:= m_Dice[I].nDicePoint;
        if GetTickCount - m_Dice[I].dwPlayTick < 2000 then begin
          bo05:=False;
        end;
      end;
    end; //for
    if bo05 then begin
      DMsgDlg.Visible:=False;
    end;
      
  end;
begin

   lx := XBase;
   ly := 126;

   d := g_WMainImages.Images[990];
   if d <> nil then begin
    DMsgDlg.SetImgIndex (g_WMainImages, 990);
    DMsgDlg.Left := (g_FScreenWidth - d.Width) div 2;
    DMsgDlg.Top := (g_FScreenHeight - d.Height) div 2;
    msglx := 26;
    msgly := 25;
    lx := 232;
    ly := 96;
   end;

   MsgText := msgstr;
   ViewDlgEdit := FALSE;
   DMsgDlg.Floating := TRUE;
   DMsgDlgOk.Visible := FALSE;
   DMsgDlgYes.Visible := FALSE;
   DMsgDlgCancel.Visible := FALSE;
   DMsgDlgNo.Visible := FALSE;
   DMsgDlg.Left := (g_FScreenWidth - DMsgDlg.Width) div 2;
   DMsgDlg.Top := (g_FScreenHeight - DMsgDlg.Height) div 2;

   for I := 0 to m_nDiceCount - 1 do begin
     m_Dice[I].n67C:=0;
     m_Dice[I].n680:=Random(m_nDiceCount + 2) * 5 + 10;
     m_Dice[I].nPlayPoint:=1;
     m_Dice[I].dwPlayTick:=GetTickCount();
   end;

   if mbCancel in DlgButtons then begin
      DMsgDlgCancel.SetImgIndex (g_WTitleImages, 183);
      DMsgDlgCancel.Left := lx;
      DMsgDlgCancel.Top := ly;
      DMsgDlgCancel.Visible := TRUE;
      lx := lx - 60;
   end;
   if mbNo in DlgButtons then begin
      DMsgDlgNo.SetImgIndex (g_WTitleImages, 183);
      DMsgDlgNo.Left := lx;
      DMsgDlgNo.Top := ly;
      DMsgDlgNo.Visible := TRUE;
      lx := lx - 60;
   end;
   if mbYes in DlgButtons then begin
      DMsgDlgYes.SetImgIndex (g_WTitleImages, 116);
      DMsgDlgYes.Left := lx;
      DMsgDlgYes.Top := ly;
      DMsgDlgYes.Visible := TRUE;
      lx := lx - 60;
   end;
   if (mbOk in DlgButtons) or (lx = XBase) then begin
      DMsgDlgOk.SetImgIndex (g_WTitleImages, 116);
      DMsgDlgOk.Left := lx;
      DMsgDlgOk.Top := ly;
      DMsgDlgOk.Visible := TRUE;
      lx := lx - 60;
   end;
   HideAllControls;
   DMsgDlg.ShowModal;
   if mbAbort in DlgButtons then begin
      ViewDlgEdit := TRUE;
      DMsgDlg.Floating := FALSE;
      with EdDlgEdit do begin
         Text := '';
         Width := DMsgDlg.Width - 70;
         Left := (g_FScreenWidth - EdDlgEdit.Width) div 2;
         Top  := (g_FScreenHeight - EdDlgEdit.Height) div 2 - 10;
      end;
   end;
   Result := mrOk;

   while TRUE do begin
      if not DMsgDlg.Visible then break;
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;

     { if g_boMsgDlgTimeCheck then begin     //¿¬±¸
         if MsgDlgClickTime < GetTickCount then begin
            DMsgDlg.DialogResult := mrNo;
            g_boMsgDlgTimeCheck := False;
            MsgDlgClickTime := GetTickCount;
            DMsgDlg.Visible := False;
            break;
         end;
      end;     }

      if m_nDiceCount > 0 then begin
        m_boPlayDice:=True;

        for I := 0 to m_nDiceCount - 1 do begin
          m_Dice[I].nX:=((DMsgDlg.Width div 2 + 6) - ((m_nDiceCount * 32 + m_nDiceCount) div 2)) + (I * 32 + I);
          m_Dice[I].nY:=DMsgDlg.Height div 2 - 14;
        end;
        ShowDice();
      end;
      if Application.Terminated then exit;
   end;

   EdDlgEdit.Visible := FALSE;
   RestoreHideControls;

   DlgEditText := EdDlgEdit.Text;
   if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
   ViewDlgEdit := FALSE;
   Result := DMsgDlg.DialogResult;
   m_nDiceCount:=0;
   m_boPlayDice:=False;
   SetImeMode (EdDlgEdit.Handle, imSAlpha);
end;


function  TFrmDlg.DSimpleMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
const
   XBase = 384;
var
  I: Integer;
  lx, ly: integer;
  d: TDirectDrawSurface;
begin
  begin
     d := g_WMainImages.Images[990];
       if d <> nil then begin
         DMsgSimpleDlg.SetImgIndex (g_WMainImages, 990);
         DMsgSimpleDlg.Left := (g_FScreenWidth - d.Width) div 2;
         DMsgSimpleDlg.Top := (g_FScreenHeight - d.Height) div 2;
         msglx := 26;
         msgly := 25;
         lx := 232;
         ly := 96;
       end;
     end;
   MsgText := msgstr;
   ViewDlgEdit := FALSE;
   DMsgSimpleDlg.Floating := TRUE;
   DMsgSimpleDlgOk.Visible := FALSE;
   DMsgSimpleDlgCancel.Visible := FALSE;
   DMsgSimpleDlg.Left := (g_FScreenWidth - DMsgSimpleDlg.Width) div 2;
   DMsgSimpleDlg.Top := (g_FScreenHeight - DMsgSimpleDlg.Height) div 2;

   if g_MySelf.m_boDeath then begin
      FrmDlg.DMsgSimpleDlg.Left := 0;
      FrmDlg.DMsgSimpleDlg.Top := 0;
   end;

   if mbCancel in DlgButtons then begin
      DMsgSimpleDlgCancel.Left := lx;
      DMsgSimpleDlgCancel.Top := ly;
      DMsgSimpleDlgCancel.Visible := TRUE;
      lx := lx - 60;
   end;
   if (mbOk in DlgButtons) or (lx = XBase) then begin
      DMsgSimpleDlgOk.Left := lx;
      DMsgSimpleDlgOk.Top := ly;
      DMsgSimpleDlgOk.Visible := TRUE;
      lx := lx - 60;
   end;
   HideAllControls;
   DMsgSimpleDlg.ShowModal;
   if mbAbort in DlgButtons then begin
      ViewDlgEdit := TRUE;
      DMsgSimpleDlg.Floating := FALSE;
      with EdDlgEdit do begin
         Text := '';
         Width := DMsgDlg.Width - 70;
         Left := (g_FScreenWidth - EdDlgEdit.Width) div 2;
         Top  := (g_FScreenHeight - EdDlgEdit.Height) div 2 - 10;
      end;
   end;
   Result := mrOk;

   while TRUE do begin
      if not DMsgSimpleDlg.Visible then break;
      //FrmMain.DXTimerTimer (self, 0);
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then exit;
   end;

   EdDlgEdit.Visible := FALSE;
   RestoreHideControls;
   SetImeMode (EdDlgEdit.Handle, imSAlpha);
   DlgEditText := EdDlgEdit.Text;
   if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
   ViewDlgEdit := FALSE;
   Result := DMsgSimpleDlg.DialogResult;
end;

procedure TFrmDlg.DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMsgDlgOk then DMsgDlg.DialogResult := mrOk;
   if Sender = DMsgDlgYes then DMsgDlg.DialogResult := mrYes;
   if Sender = DMsgDlgCancel then DMsgDlg.DialogResult := mrCancel;
   if Sender = DMsgDlgNo then DMsgDlg.DialogResult := mrNo;
   DMsgDlg.Visible := FALSE;

  // g_boMsgDlgTimeCheck := False;
 //  MsgDlgClickTime := GetTickCount;
 //  DMsgDlg.Visible := FALSE;
end;

procedure TFrmDlg.DMsgDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = 13 then begin
      if DMsgDlgOk.Visible and not (DMsgDlgYes.Visible or DMsgDlgNo.Visible) then begin
         DMsgDlg.DialogResult := mrOk;
         DMsgDlg.Visible := FALSE;
      end;
      if DMsgDlgYes.Visible and not (DMsgDlgOk.Visible or DMsgDlgCancel.Visible) then begin
         DMsgDlg.DialogResult := mrYes;
         DMsgDlg.Visible := FALSE;
      end;
   end;
   if Key = 27 then begin
      if DMsgDlgNo.Visible then begin
         DMsgDlg.DialogResult := mrNo;
         DMsgDlg.Visible := FALSE;
      end;
      if DMsgDlgCancel.Visible then begin
         DMsgDlg.DialogResult := mrCancel;
         DMsgDlg.Visible := FALSE;
      end;
   end;
end;

//Á¢¼ÓÇÒ½Ã ¼­¹ö¿ÀÇÂ È®ÀÎ (¼­¹ö»ö ±¸ºÐ)
procedure TFrmDlg.DMsgDlgOkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  tStr:String;
  Color:TColor;
  nStatus:Integer;
begin
try
   nStatus:=-1;
   with Sender as TDButton do begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 2]
      end else
      if MouseMoveing then begin
        d := WLib.Images[FaceIndex + 1];
      end else
        d := WLib.Images[FaceIndex];

      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);


      if (Name = 'DSServer1') and (g_ServerList.Count >= 1) then begin
        tStr:=g_ServerList.Strings[0];
        nStatus:=Integer(g_ServerList.Objects[0]);
      end;
      if (Name = 'DSServer2') and (g_ServerList.Count >= 2) then begin
        tStr:=g_ServerList.Strings[1];
        nStatus:=Integer(g_ServerList.Objects[1]);
      end;
      if (Name = 'DSServer3') and (g_ServerList.Count >= 3) then begin
        tStr:=g_ServerList.Strings[2];
        nStatus:=Integer(g_ServerList.Objects[2]);
      end;
      if (Name = 'DSServer4') and (g_ServerList.Count >= 4) then begin
        tStr:=g_ServerList.Strings[3];
        nStatus:=Integer(g_ServerList.Objects[3]);
      end;
      if (Name = 'DSServer5') and (g_ServerList.Count >= 5) then begin
        tStr:=g_ServerList.Strings[4];
        nStatus:=Integer(g_ServerList.Objects[4]);
      end;
      if (Name = 'DSServer6') and (g_ServerList.Count >= 6) then begin
        tStr:=g_ServerList.Strings[5];
        nStatus:=Integer(g_ServerList.Objects[5]);
      end;
      if (Name = 'DSServer7') and (g_ServerList.Count >= 7) then begin
        tStr:=g_ServerList.Strings[6];
        nStatus:=Integer(g_ServerList.Objects[6]);
      end;
      if (Name = 'DSServer8') and (g_ServerList.Count >= 8) then begin
        tStr:=g_ServerList.Strings[7];
        nStatus:=Integer(g_ServerList.Objects[7]);
      end;
      Color:=$008CEFF7;
      case nStatus of
        0: begin
          tStr:=tStr;
          Color:=clDkGray;
        end;
        1: begin
          tStr:=tStr ;
          Color:=$008CEFF7;
        end;
        2: begin
          tStr:=tStr ;
          Color:=clGreen;
        end;
        3: begin
          tStr:=tStr;
          Color:=clMaroon;
        end;
        4: begin
          tStr:=tStr ;
          Color:=clRed;
        end;
      end;
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Size :=12;
          dsurface.Canvas.Font.Style:=[fsBold];
          if TDButton(Sender).Downed then begin
            BoldTextOut (dsurface, SurfaceX(Left + (d.Width - dsurface.Canvas.TextWidth(tStr)) div 2) + 1, SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(tStr)) div 2) + 2, Color{clYellow}, clBlack, tStr);
          end else begin
            BoldTextOut (dsurface, SurfaceX(Left + (d.Width - dsurface.Canvas.TextWidth(tStr)) div 2), SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(tStr)) div 2) + 1, Color{clYellow}, clBlack, tStr);
          end;
          dsurface.Canvas.Font.Style:=[];
          dsurface.Canvas.Font.Size :=9;
          dsurface.Canvas.Release;
   end;
except
  on e: Exception do begin
    ShowMessage(E.Message);
  end;
end;
end;

procedure TFrmDlg.DMsgDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I: Integer;
  d: TDirectDrawSurface;
  ly: integer;
  str, data: string;
  nX,nY:Integer;
begin
   with Sender as TDWindow do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      if m_boPlayDice then begin
        for I := 0 to m_nDiceCount - 1 do begin
          d:=g_WBagItemImages.GetCachedImage(m_Dice[I].nPlayPoint + 376 - 1,nX,nY);
          if d <> nil then begin
            dsurface.Draw (SurfaceX(Left) + m_Dice[I].nX + nX - 7, SurfaceY(Top) + m_Dice[I].nY + nY {+ 38}, d.ClientRect, d, TRUE);
          end;
        end;
      end;

      ly := msgly;
      str := MsgText;
      while TRUE do begin
         if str = '' then break;
         str := GetValidStr3 (str, data, ['\']);
         if data <> '' then
            SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
            BoldTextOut (dsurface, SurfaceX(Left+msglx), SurfaceY(Top+ly), clWhite, clBlack, data);
            dsurface.Canvas.Release;
         ly := ly + 16;
      end;
   end;
   if ViewDlgEdit then begin
      if not EdDlgEdit.Visible then begin
         SetImeMode (EdDlgEdit.Handle, imSHanguel);
         EdDlgEdit.Visible := TRUE;
         EdDlgEdit.SetFocus;
      end;
   end;
end;

{------------------------------------------------------------------------}

procedure TFrmDlg.DLogInDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e,f,g: TDirectDrawSurface;
begin
   with DLogIn do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      if not g_InterfaceMode then begin
        e := g_WTitleImages.Images[30];
        if e <> nil then
          dsurface.Draw (SurfaceX(Left+105), SurfaceY(Top+5), e.ClientRect, e, TRUE);

        f := g_WTitleImages.Images[31];
        if f <> nil then
          dsurface.Draw (SurfaceX(Left+50), SurfaceY(Top+83), f.ClientRect, f, TRUE);

        g := g_WTitleImages.Images[32];
        if g <> nil then
          dsurface.Draw (SurfaceX(Left+50), SurfaceY(Top+105), g.ClientRect, g, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DLoginNewDirectPaint(Sender: TObject;    //·Î±×ÀÎ Ã¢
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else
         d := WLib.Images[FaceIndex];


         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;



procedure TFrmDlg.DLoginNewClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewClick;
end;

procedure TFrmDlg.DLoginOkClick(Sender: TObject; X, Y: Integer);
begin
     LoginScene.OkClick;
end;

procedure TFrmDlg.DLoginCloseClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.Close;
end;

procedure TFrmDlg.DLoginChgPwClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.ChgPwClick;
end;

procedure TFrmDlg.DLoginNewClickSound(Sender: TObject;
  Clicksound: TClickSound);
begin
   case Clicksound of
      csNorm:  PlaySound (s_norm_button_click);
      csStone: PlaySound (s_rock_button_click);
      csGlass: PlaySound (s_glass_button_click);
   end;
end;

{------------------------------------------------------------------------}

procedure TFrmDlg.ShowSelectServerDlg;
begin
   case g_ServerList.Count of
     1:begin
         DSServer1.Visible:=True;
         if not g_InterfaceMode then begin
           DSServer1.Top:=205;
         end else begin
           DSServer1.Top:=175;
         end;
         DSServer2.Visible:=False;
         DSServer3.Visible:=False;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
         DSServer7.Visible:=False;
         DSServer8.Visible:=False;
       end;
     2:begin
         DSServer1.Visible:=True;
         DSServer1.Top:=190;
         DSServer2.Visible:=True;
         DSServer2.Top:=235;
         DSServer3.Visible:=False;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
         DSServer7.Visible:=False;
         DSServer8.Visible:=False;
       end;
     3:begin
         DSServer1.Visible:=True;
         DSServer1.Top:=175;
         DSServer2.Visible:=True;
         DSServer2.Top:=220;
         DSServer3.Visible:=True;
         DSServer3.Top:=265;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
         DSServer7.Visible:=False;
         DSServer8.Visible:=False;
       end;
     4:begin
         DSServer1.Visible:=True;
         DSServer1.Top:=160;
         DSServer2.Visible:=True;
         DSServer2.Top:=205;
         DSServer3.Visible:=True;
         DSServer3.Top:=250;
         DSServer4.Visible:=True;
         DSServer4.Top:=295;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
         DSServer7.Visible:=False;
         DSServer8.Visible:=False;
       end;
     5:begin
         DSServer1.Visible:=True;
         DSServer1.Top:=145;
         DSServer2.Visible:=True;
         DSServer2.Top:=190;
         DSServer3.Visible:=True;
         DSServer3.Top:=235;
         DSServer4.Visible:=True;
         DSServer4.Top:=280;
         DSServer5.Visible:=True;
         DSServer5.Top:=325;
         DSServer6.Visible:=False;
         DSServer7.Visible:=False;
         DSServer8.Visible:=False;
       end;
     6:begin
         DSServer1.Visible:=True;
         DSServer1.Top:=125;
         DSServer2.Visible:=True;
         DSServer2.Top:=170;
         DSServer3.Visible:=True;
         DSServer3.Top:=215;
         DSServer4.Visible:=True;
         DSServer4.Top:=260;
         DSServer5.Visible:=True;
         DSServer5.Top:=305;
         DSServer6.Visible:=True;
         DSServer6.Top:=350;
         DSServer7.Visible:=False;
         DSServer8.Visible:=False;
       end;
     7:begin
         DSServer1.Visible:=True;
         DSServer1.Top:=100;
         DSServer2.Visible:=True;
         DSServer2.Top:=145;
         DSServer3.Visible:=True;
         DSServer3.Top:=190;
         DSServer4.Visible:=True;
         DSServer4.Top:=235;
         DSServer5.Visible:=True;
         DSServer5.Top:=280;
         DSServer6.Visible:=True;
         DSServer6.Top:=325;
         DSServer7.Visible:=True;
         DSServer7.Top:=370;
         DSServer8.Visible:=False;
       end;
     8:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=True;
         DSServer7.Visible:=True;
         DSServer8.Visible:=True;
       end;
     else begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=True;
         DSServer7.Visible:=True;
         DSServer8.Visible:=True;
       end;
   end;
   DSelServerDlg.Visible:=TRUE;

   if g_boAutoLogin then FrmMain.SendSelectServer(g_ServerList.Strings[0]);
end;

procedure TFrmDlg.DSelServerDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var  
   d, e: TDirectDrawSurface;
begin
   with DSelServerDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      if not g_InterfaceMode then begin
        e := g_WTitleImages.Images[50];
        if e <> nil then
          dsurface.Draw (SurfaceX(Left + 88), SurfaceY(Top+7), e.ClientRect, e, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DSServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
   svname := '';
   if Sender = DSServer1 then begin
     svname:=g_ServerList.Strings[0];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer2 then begin
     svname:=g_ServerList.Strings[1];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer3 then begin
     svname:=g_ServerList.Strings[2];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer4 then begin
     svname:=g_ServerList.Strings[3];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer5 then begin
     svname:=g_ServerList.Strings[4];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer6 then begin
     svname:=g_ServerList.Strings[5];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer7 then begin
     svname:=g_ServerList.Strings[6];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer8 then begin
     svname:=g_ServerList.Strings[7];
     g_sServerMiniName:=svname;
   end;
   if svname <> '' then begin
      FrmMain.SendSelectServer (svname);
      DSelServerDlg.Visible := FALSE;
   end;
end;

procedure TFrmDlg.DEngServer1Click(Sender: TObject; X, Y: Integer);
var
   svname: string;
begin
   svname := 'ÁúµÄ´«Ëµ2';
   g_sServerMiniName := svname;

   if svname <> '' then begin
      FrmMain.SendSelectServer (svname);
      DSelServerDlg.Visible := FALSE;
      g_sServerName := svname;
   end;
end;


procedure TFrmDlg.DSSrvCloseClick(Sender: TObject; X, Y: Integer);
begin
   DSelServerDlg.Visible := FALSE;
   FrmMain.Close;
end;

{------------------------------------------------------------------------}

procedure TFrmDlg.DNewAccountOkClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewAccountOk;
end;

procedure TFrmDlg.DNewAccountCancelClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewAccountClose;
end;

procedure TFrmDlg.DNewAccountDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   i: integer;
begin

     with DNewAccount do begin
       d := WLib.Images[FaceIndex];
       if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
        with dsurface.Canvas do begin
          SetBkMode (Handle, TRANSPARENT);
          BoldTextOut (dsurface, SurfaceX(Left) + 233, SurfaceY(Top)+ 80, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 233, SurfaceY(Top)+ 102, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 233, SurfaceY(Top)+ 124, clLime, clBlack, '(*)');

          BoldTextOut (dsurface, SurfaceX(Left) + 233, SurfaceY(Top)+ 164, clLime, clBlack, '(*)');

          BoldTextOut (dsurface, SurfaceX(Left) + 233, SurfaceY(Top)+ 186, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 253, SurfaceY(Top)+ 187, clWhite, clBlack, '1980/1/1');

          BoldTextOut (dsurface, SurfaceX(Left) + 280, SurfaceY(Top)+ 249, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 280, SurfaceY(Top)+ 271, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 280, SurfaceY(Top)+ 293, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 280, SurfaceY(Top)+ 315, clLime, clBlack, '(*)');

          BoldTextOut (dsurface, SurfaceX(Left) + 100, SurfaceY(Top)+ 334, clLime, clBlack, '(*)');
          BoldTextOut (dsurface, SurfaceX(Left) + 123, SurfaceY(Top)+ 334, clWhite, clBlack, ': ±ØÐëÊäÈëµÄÊÂÏî¡£');
          Release;
        end;
     end;
end;

{------------------------------------------------------------------------}

procedure TFrmDlg.DChgpwOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DChgpwOk then LoginScene.ChgpwOk;
   if Sender = DChgpwCancel then LoginScene.ChgpwCancel;
end;

{------------------------------------------------------------------------}

procedure TFrmDlg.DscSelect1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (Left, Top, d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DscStartDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   dd: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         dd := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         dd := WLib.Images[FaceIndex + 1];
      end else begin
         dd := WLib.Images[FaceIndex];
      end;

      if dd <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), dd.ClientRect, dd, TRUE);

      if (Sender = DscStart) and g_boReSelConnect then begin
        dsurface.FillRectAlpha(g_ClientRect, clblack, 150);
        if GetTickCount - g_dwReSelConnectTick > 150 then begin
          g_dwReSelConnectTick := GetTickCount;
          g_ClientRect.Top := g_ClientRect.Top + 1;
          if g_ClientRect.Top > g_ClientRect.Bottom then begin
            g_boReSelConnect := False;
            Enabled := True;
          end;
        end;
      end;

   end;
end;

procedure TFrmDlg.DscSelect1Click(Sender: TObject; X, Y: Integer);
begin
  if not FrmDlg.DCreateChr.Visible then begin
   if Sender = DscSelect1 then SelectChrScene.SelChrSelect1Click;
   if Sender = DscSelect2 then SelectChrScene.SelChrSelect2Click;
   if Sender = DscSelect3 then SelectChrScene.SelChrSelect3Click;
   if Sender = DscSelect4 then SelectChrScene.SelChrSelect4Click;
   if (Sender = DscStart) and (DscStart.Enabled) then SelectChrScene.SelChrStartClick;
   if Sender = DscNewChr then SelectChrScene.SelChrNewChrClick;
   if Sender = DscEraseChr then SelectChrScene.SelChrEraseChrClick;
   if Sender = DscCredits then SelectChrScene.SelChrCreditsClick;
   if Sender = DscExit then SelectChrScene.SelChrExitClick;
   if Sender = DButRenewChr then SelectChrScene.SelRenewChr;
   if Sender = DButRenewClose then SelectChrScene.ChangeSelectChrState(scSelectChr);
  end;
end;

{------------------------------------------------------------------------}

//ÄÉ¸¯ÅÍ »ý¼º ÀÌ¹ÌÁö  ºÎºÐ
procedure TFrmDlg.DSalesCancelDirectPaintt(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then begin
           dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DccCloseClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DccClose then SelectChrScene.SelChrNewClose;
   if Sender = DccWarrior then SelectChrScene.SelChrNewJob (0);
   if Sender = DccWizzard then SelectChrScene.SelChrNewJob (1);
   if Sender = DccMonk then SelectChrScene.SelChrNewJob (2);
   if Sender = DccAssassin then SelectChrScene.SelChrNewJob (3);
   if Sender = DccBonze then SelectChrScene.SelChrNewJob (4);
   if Sender = DccMale then SelectChrScene.SelChrNewm_btSex (0);
   if Sender = DccFemale then SelectChrScene.SelChrNewm_btSex (1);
   if Sender = DccOk then SelectChrScene.SelChrNewOk;

   if (Sender = DWuxFront) or (Sender = DWuxNext) then begin
    if (Sender = DWuxFront) then begin
      if btWuXin > 0 then Dec(btWuXin);
    end
    else if (Sender = DWuxNext) then begin
      if btWuXin < 9 then Inc(btWuXin);
    end;
    SelectChrScene.SelChrHair(btWuXin);
  end;
end;

{------------------------------------------------------------------------}

{------------------------------------------------------------------------}
               //ÄÉ¸¯ÅÍ»óÅÂÃ¢
procedure TFrmDlg.DStateWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   i, l, m, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv, X, Y,tx: integer;
   pm,magic: PTClientMagic;
   d, e: TDirectDrawSurface;
   hcolor, old, keyimg,img: integer;
   iname, d1, d2, d3, d4: string;
   useable: Boolean;
   output,fstr:string;
   sMsg:String;
   nHintX,nHintY:Integer;
   Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
begin
   if g_MySelf = nil then exit;
   img := 0;
   with DStateWin do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      if g_nGuildMark <> 0 then begin
        d := g_WGuildImages.Images[g_nGuildMark];
        if d <> nil then
         DrawBlendEx (dsurface, SurfaceX(Left + 17) , SurfaceY(Top + 12), d, 0, 0, d.Width, d.Height,0);
      end;

      case g_MySelf.m_btJob of
       0,5: d := g_WMainImages.Images[100];
       1,6: d := g_WMainImages.Images[101];
       2,7: d := g_WMainImages.Images[102];
       3,8: d := g_WMainImages.Images[103];
       4,9: d := g_WAresImages.Images[406];
      end;
      if d <> nil then
       dsurface.Draw (SurfaceX(Left + 15), SurfaceY(Top + 33), d.ClientRect, d, TRUE);

      case StatePage of
         0: begin   // Ä³¸¯ÅÍ »óÅÂÃ¢ 0
         if g_MySelf <> nil then
         if g_MySelf.m_btJob = 5 then begin     //º®Ç÷Àü»ç »óÅÂÃ¢
            pgidx := 379;
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WMainImages.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[500];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+8), SurfaceY(Top+70), d.ClientRect, d, TRUE);
         if g_MySelf.m_btMask in [20, 21] then begin
            if g_MySelf.m_btMask = 20 then begin
              pgidx := 930;
              bbx := Left + 28;
              bby := Top + 120;

              d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

              d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
            end else begin
              pgidx := 932;
              bbx := Left + 48;
              bby := Top + 135;

              d := g_WMain2Images.Images[933];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
            end;
            d := g_WMain2Images.Images[pgidx];
              if d <> nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
          end else begin
            if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
              d := g_WMainImages.Images[320 + g_MySelf.m_btSex];
            end else
            d := g_WMainImages.Images[g_MySelf.m_btJob * 2 + 320 + g_MySelf.m_btSex];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx+4), SurfaceY(bby+64), d.ClientRect, d, TRUE);
          end;
            bbx := Left + 8{bbx + 18};
            bby := Top - 23{bby + 60};
            if g_UseItems[U_DRESS].S.Name <> '' then begin
               idx := g_UseItems[U_DRESS].S.Looks;
               if idx >= 0 then begin
                  if g_MySelf.m_btSex = 1 then begin
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                      if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                        e := g_WMain2Images.GetCachedImage(1219, ax, ay);
                      if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                        e := g_WMain2Images.GetCachedImage(1229, ax, ay);
                      d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
                    end else begin
                      if idx = 86 then
                        e := g_WMain2Images.GetCachedImage(1211, ax, ay);
                      if idx = 605 then
                        e := g_WMain2Images.GetCachedImage(1221, ax, ay);
                      d := FrmMain.GetWStateWarrWoImg(idx,ax,ay);
                    end;
                  end else begin
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                      if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                        e := g_WMain2Images.GetCachedImage(1218, ax, ay);
                      if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                        e := g_WMain2Images.GetCachedImage(1228, ax, ay);
                      d := FrmMain.GetWStateComManImg(idx,ax,ay);
                    end else begin
                      if idx = 85 then
                        e := g_WMain2Images.GetCachedImage(1210, ax, ay);
                      if idx = 595 then
                        e := g_WMain2Images.GetCachedImage(1220, ax, ay);
                      d := FrmMain.GetWStateWarrManImg(idx,ax,ay);
                    end;
                  end;
                  if g_MySelf.m_btMask in [20, 21] then begin
                    d := nil;  e := nil;
                  end;
                    if d <> nil then
                    if g_MySelf.m_btSex = 0 then begin
                      if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        if e <> nil then begin
                          if idx = 85 then
                            dsurface.Draw (SurfaceX(bbx+ax-23), SurfaceY(bby+ay-12), e.ClientRect, e, TRUE);
                          if idx = 595 then
                            dsurface.Draw (SurfaceX(bbx+ax-70), SurfaceY(bby+ay-19), e.ClientRect, e, TRUE);
                        end;
                        dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay+ 25), d.ClientRect, d, TRUE);
                      end else begin
                        if e <> nil then begin
                          if idx = 85 then
                            dsurface.Draw (SurfaceX(bbx+ax-3), SurfaceY(bby+ay-14), e.ClientRect, e, TRUE);
                          if idx = 595 then
                            dsurface.Draw (SurfaceX(bbx+ax-45), SurfaceY(bby+ay-18), e.ClientRect, e, TRUE);
                        end;
                        dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+ 25), d.ClientRect, d, TRUE);
                      end;
                    end else begin
                      if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        if e <> nil then begin
                          if idx = 86 then
                            dsurface.Draw (SurfaceX(bbx+ax-36), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                          if idx = 605 then
                            dsurface.Draw (SurfaceX(bbx+ax-61), SurfaceY(bby+ay- 23), e.ClientRect, e, TRUE);
                        end;
                        dsurface.Draw (SurfaceX(bbx+ax-18), SurfaceY(bby+ay+ 20), d.ClientRect, d, TRUE);
                      end else begin
                        if e <> nil then begin
                          if idx = 86 then
                            dsurface.Draw (SurfaceX(bbx+ax-68), SurfaceY(bby+ay- 10), e.ClientRect, e, TRUE);
                          if idx = 605 then
                            dsurface.Draw (SurfaceX(bbx+ax-77), SurfaceY(bby+ay- 20), e.ClientRect, e, TRUE);
                        end;
                        dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+ 20), d.ClientRect, d, TRUE);
                      end;
                    end;
               end;
            end;
            //º®Ç÷Àü»ç »óÅÂÃ¢ Çì¾î
            idx := 460 + g_MySelf.m_btHair div 2;
            if g_MySelf.m_btSex = 1 then
            idx := 500 + g_MySelf.m_btHair div 2;

            if g_UseItems[U_HELMET].S.Name <> '' then begin
               idx := g_UseItems[U_HELMET].S.Looks;
               if idx >= 0 then begin
                 if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

                 end else begin
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115]  then begin
                   d := FrmMain.GetWStateComManImg(idx,ax,ay);
                  end else
                   d := FrmMain.GetWStateWarrManImg(idx,ax,ay);
                  if g_MySelf.m_btSex = 1 then
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115]  then begin
                    d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
                  end else
                   d := FrmMain.GetWStateWarrWoImg(idx,ax,ay);
                 end;
                   if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                  end else
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax-18), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE)
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE)
               end;
               idx := 0;
            end;

            if idx > 0 then begin
              if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

              end else
               d := g_WMainImages.GetCachedImage (idx, ax, ay);
               if g_MySelf.m_btMask in [20, 21] then d := nil;
               if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                    dsurface.Draw (SurfaceX(bbx+ax - 16), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                  end else
                    dsurface.Draw (SurfaceX(bbx+ax - 15), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                  end else
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                    dsurface.Draw (SurfaceX(bbx+ax - 18), SurfaceY(bby+ay + 21), d.ClientRect, d, TRUE);
                  end else
                    dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 21), d.ClientRect, d, TRUE);
            end;
            if g_UseItems[U_WEAPON].S.Name <> '' then begin       //»óÅÂÃ¢ÀÛ¾÷
               idx := g_UseItems[U_WEAPON].S.Looks;
               if idx >= 0 then begin
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                   d := FrmMain.GetWStateComManImg(idx,ax,ay);
                  end else
                   d := FrmMain.GetWStateWarrManImg(idx,ax,ay);
               if g_MySelf.m_btSex = 1 then
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                    d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
                  end else
                   d := FrmMain.GetWStateWarrWoImg(idx,ax,ay);
                   if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                     if g_MySelf.m_btSex = 0 then begin
                      if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                       dsurface.Draw (SurfaceX(bbx+ax - 17), SurfaceY(bby+ay + 24), d.ClientRect, d, TRUE)
                      end else
                       dsurface.Draw (SurfaceX(bbx+ax - 13), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                     end else
                      if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                       dsurface.Draw (SurfaceX(bbx+ax - 17), SurfaceY(bby+ay + 19), d.ClientRect, d, TRUE);
                      end else
                       dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
                if (g_UseItems[U_WEAPON].S.WEffect > 0) then begin
                  if (g_UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 17), SurfaceY(bby + ay + 24), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 17), SurfaceY(bby + ay + 19), d, 1);
                    end;
                  end else begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect - 72) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Warrior_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Warrior_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 13), SurfaceY(bby + ay + 25), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 22), SurfaceY(bby + ay + 19), d, 1);
                    end;
                  end;

                end;
              end;
            end;



         end else begin


         if g_MySelf <> nil then
         if g_MySelf.m_btJob = 6 then begin     //È«Çö¼ú»ç »óÅÂÃ¢
            pgidx := 379;
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WMainImages.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[500];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+8), SurfaceY(Top+70), d.ClientRect, d, TRUE);

          if g_MySelf.m_btMask in [20, 21] then begin
            if g_MySelf.m_btMask = 20 then begin
              pgidx := 930;
              bbx := Left + 28;
              bby := Top + 120;

              d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

              d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);

            end else begin
              pgidx := 932;
              bbx := Left + 48;
              bby := Top + 135;

              d := g_WMain2Images.Images[933];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
            end;
            d := g_WMain2Images.Images[pgidx];
              if d <> nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
          end else begin
            if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
            d := g_WMainImages.Images[320 + g_MySelf.m_btSex];
            end else
            d := g_WMainImages.Images[g_MySelf.m_btJob * 2 + 320 + g_MySelf.m_btSex];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx+10), SurfaceY(bby+68), d.ClientRect, d, TRUE);
          end;
            bbx := Left + 8;
            bby := Top - 23;
            if g_UseItems[U_DRESS].S.Name <> '' then begin
               idx := g_UseItems[U_DRESS].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btSex = 1 then begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1219, ax, ay);
                     if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1229, ax, ay);
                     d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
                   end else begin
                     if idx = 86 then
                       e := g_WMain2Images.GetCachedImage(1213, ax, ay);
                     if idx = 605 then
                       e := g_WMain2Images.GetCachedImage(1223, ax, ay);
                     d := FrmMain.GetWStateWizWoImg(idx,ax,ay);
                   end;
                 end else begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1218, ax, ay);
                     if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1228, ax, ay);
                     d := FrmMain.GetWStateComManImg(idx,ax,ay);
                   end else begin
                     if idx = 85 then
                       e := g_WMain2Images.GetCachedImage(1212, ax, ay);
                     if idx = 595 then
                       e := g_WMain2Images.GetCachedImage(1222, ax, ay);
                     d := FrmMain.GetWStateWizManImg(idx,ax,ay);
                   end;
                 end;
                 if g_MySelf.m_btMask in [20, 21] then begin
                   d := nil; e := nil;
                 end;
                 if d <> nil then
                   if g_MySelf.m_btSex = 0 then begin
                     if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                       if e <> nil then begin
                         if idx = 85 then
                           dsurface.Draw (SurfaceX(bbx+ax-17), SurfaceY(bby+ay-8), e.ClientRect, e, TRUE);
                         if idx = 595 then
                           dsurface.Draw (SurfaceX(bbx+ax-64), SurfaceY(bby+ay-15), e.ClientRect, e, TRUE);
                       end;
                       dsurface.Draw (SurfaceX(bbx+ax-10), SurfaceY(bby+ay + 29), d.ClientRect, d, TRUE)
                     end else begin
                       if e <> nil then begin
                         if idx = 85 then
                           dsurface.Draw (SurfaceX(bbx+ax-41), SurfaceY(bby+ay-6), e.ClientRect, e, TRUE);
                         if idx = 595 then
                           dsurface.Draw (SurfaceX(bbx+ax-65), SurfaceY(bby+ay-14), e.ClientRect, e, TRUE);
                       end;
                       dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay + 29), d.ClientRect, d, TRUE)
                     end;
                   end else begin
                     if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                       if e <> nil then begin
                         if idx = 86 then
                           dsurface.Draw (SurfaceX(bbx+ax-30), SurfaceY(bby+ay- 9), e.ClientRect, e, TRUE);
                         if idx = 605 then
                           dsurface.Draw (SurfaceX(bbx+ax-55), SurfaceY(bby+ay- 19), e.ClientRect, e, TRUE);
                       end;
                       dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay + 24), d.ClientRect, d, TRUE);
                     end else begin
                       if e <> nil then begin
                         if idx = 86 then
                           dsurface.Draw (SurfaceX(bbx+ax-47), SurfaceY(bby+ay- 10), e.ClientRect, e, TRUE);
                         if idx = 605 then
                           dsurface.Draw (SurfaceX(bbx+ax-61), SurfaceY(bby+ay- 19), e.ClientRect, e, TRUE);
                       end;
                       dsurface.Draw (SurfaceX(bbx+ax-13), SurfaceY(bby+ay + 24), d.ClientRect, d, TRUE);
                     end;
                   end;
               end;
            end;
            //È«Çö¼ú»ç »óÅÂÃ¢ Çì¾î Åõ±¸
            idx := 460 + g_MySelf.m_btHair div 2;
            if g_MySelf.m_btSex = 1 then
            idx := 500 + g_MySelf.m_btHair div 2;
            if g_UseItems[U_HELMET].S.Name <> '' then begin //Åõ±¸
               idx := g_UseItems[U_HELMET].S.Looks;
               if idx >= 0 then begin
                 if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

                 end else begin
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComManImg(idx,ax,ay);
                 end else
                  d := FrmMain.GetWStateWizManImg(idx,ax,ay);
                 if g_MySelf.m_btSex = 1 then
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
                 end else
                  d := FrmMain.GetWStateWizWoImg(idx,ax,ay);
                 end;
                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 9), SurfaceY(bby+ay + 29), d.ClientRect, d, TRUE)
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax - 15), SurfaceY(bby+ay + 29), d.ClientRect, d, TRUE)
                  end else
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 12), SurfaceY(bby+ay + 23), d.ClientRect, d, TRUE);
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax - 13), SurfaceY(bby+ay + 23), d.ClientRect, d, TRUE);
               end;
               idx := 0;
            end;
            if idx > 0 then begin    //Çì¾î
              if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

              end else
               d := g_WMainImages.GetCachedImage (idx, ax, ay);
               if g_MySelf.m_btMask in [20, 21] then d := nil;
               if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                      dsurface.Draw (SurfaceX(bbx+ax - 9), SurfaceY(bby+ay + 29), d.ClientRect, d, TRUE)
                    end else
                      dsurface.Draw (SurfaceX(bbx+ax - 15), SurfaceY(bby+ay + 29), d.ClientRect, d, TRUE)
                  end else
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 12), SurfaceY(bby+ay + 24), d.ClientRect, d, TRUE);
                   end else
                     dsurface.Draw (SurfaceX(bbx+ax - 14), SurfaceY(bby+ay + 24), d.ClientRect, d, TRUE);
            end;
            if g_UseItems[U_WEAPON].S.Name <> '' then begin   //¹«±â      //»óÅÂÃ¢ÀÛ¾÷
               idx := g_UseItems[U_WEAPON].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComManImg(idx,ax,ay);
                 end else
                  d := FrmMain.GetWStateWizManImg(idx,ax,ay);
               if g_MySelf.m_btSex = 1 then
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
                 end else
                  d := FrmMain.GetWStateWizWoImg(idx,ax,ay);
                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                     if g_MySelf.m_btSex = 0 then begin
                       if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        dsurface.Draw (SurfaceX(bbx+ax - 11), SurfaceY(bby+ay + 27), d.ClientRect, d, TRUE)
                       end else
                        dsurface.Draw (SurfaceX(bbx+ax - 16), SurfaceY(bby+ay + 22), d.ClientRect, d, TRUE)
                     end else
                       if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                         dsurface.Draw (SurfaceX(bbx+ax - 10), SurfaceY(bby+ay + 23), d.ClientRect, d, TRUE);
                       end else
                         dsurface.Draw (SurfaceX(bbx+ax - 13), SurfaceY(bby+ay + 19), d.ClientRect, d, TRUE);
                if (g_UseItems[U_WEAPON].S.WEffect > 0) then begin
                  if (g_UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 11), SurfaceY(bby + ay + 27), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 10), SurfaceY(bby + ay + 23), d, 1);
                    end;
                  end else begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect - 77) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Wizard_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Wizard_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 16), SurfaceY(bby + ay + 23), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 13), SurfaceY(bby + ay + 19), d, 1);
                    end;
                  end;
                end;
              end;
            end;



         end else begin


         if g_MySelf <> nil then
         if g_MySelf.m_btJob = 7 then begin     //ÀÍ¼±µµ»ç »óÅÂÃ¢
            pgidx := 379;
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WMainImages.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[500];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+8), SurfaceY(Top+70), d.ClientRect, d, TRUE);
          if g_MySelf.m_btMask in [20, 21] then begin
            if g_MySelf.m_btMask = 20 then begin
              pgidx := 930;
              bbx := Left + 28;
              bby := Top + 120;

              d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

              d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
            end else begin
              pgidx := 932;
              bbx := Left + 48;
              bby := Top + 135;

              d := g_WMain2Images.Images[933];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
            end;
            d := g_WMain2Images.Images[pgidx];
              if d <> nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
          end else begin
            if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
            d := g_WMainImages.Images[320 + g_MySelf.m_btSex];
            end else
            d := g_WMainImages.Images[g_MySelf.m_btJob * 2 + 320 + g_MySelf.m_btSex];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx+10), SurfaceY(bby+64), d.ClientRect, d, TRUE);
          end;

            bbx := Left + 8;
            bby := Top - 23;
            if g_UseItems[U_DRESS].S.Name <> '' then begin
               idx := g_UseItems[U_DRESS].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btSex = 1 then begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1219, ax, ay);
                     if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1229, ax, ay);
                     d := FrmMain.GetWStateComWomanImg(idx,ax,ay)
                   end else begin
                     if idx = 86 then
                       e := g_WMain2Images.GetCachedImage(1215, ax, ay);
                     if idx = 605 then
                       e := g_WMain2Images.GetCachedImage(1225, ax, ay);
                     d := FrmMain.GetWStateMonkWoImg(idx,ax,ay);
                   end;
                 end else begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1218, ax, ay);
                     if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1228, ax, ay);
                     d := FrmMain.GetWStateComManImg(idx,ax,ay);
                   end else begin
                     if idx = 85 then
                       e := g_WMain2Images.GetCachedImage(1214, ax, ay);
                     if idx = 595 then
                       e := g_WMain2Images.GetCachedImage(1224, ax, ay);
                     d := FrmMain.GetWStateMonkManImg(idx,ax,ay);
                   end;
                 end;
                 if g_MySelf.m_btMask in [20, 21] then begin
                   d := nil; e := nil;
                 end;
                 if d <> nil then
                 if g_MySelf.m_btSex = 0 then begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if e <> nil then begin
                       if idx = 85 then
                         dsurface.Draw (SurfaceX(bbx+ax-17), SurfaceY(bby+ay-12), e.ClientRect, e, TRUE);
                       if idx = 595 then
                         dsurface.Draw (SurfaceX(bbx+ax-64), SurfaceY(bby+ay-19), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-10), SurfaceY(bby+ay+ 25), d.ClientRect, d, TRUE);
                   end else begin
                     if e <> nil then begin
                       if idx = 85 then
                         dsurface.Draw (SurfaceX(bbx+ax-38), SurfaceY(bby+ay-13), e.ClientRect, e, TRUE);
                       if idx = 595 then
                         dsurface.Draw (SurfaceX(bbx+ax-58), SurfaceY(bby+ay-16), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+ 25), d.ClientRect, d, TRUE);
                   end;
                 end else begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if e <> nil then begin
                       if idx = 86 then
                         dsurface.Draw (SurfaceX(bbx+ax-30), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                       if idx = 605 then
                         dsurface.Draw (SurfaceX(bbx+ax-55), SurfaceY(bby+ay- 23), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+ 20), d.ClientRect, d, TRUE);
                   end else begin
                     if e <> nil then begin
                       if idx = 86 then
                         dsurface.Draw (SurfaceX(bbx+ax-44), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                       if idx = 605 then
                         dsurface.Draw (SurfaceX(bbx+ax-58), SurfaceY(bby+ay- 22), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+ 20), d.ClientRect, d, TRUE);
                   end;
                 end;
               end;
            end;
            //ÀÍ¼±µµ»ç »óÅÂÃ¢ Çì¾î
            idx := 460 + g_MySelf.m_btHair div 2;
            if g_MySelf.m_btSex = 1 then
            idx := 500 + g_MySelf.m_btHair div 2;
            if g_UseItems[U_HELMET].S.Name <> '' then begin
               idx := g_UseItems[U_HELMET].S.Looks;
               if idx >= 0 then begin
                 if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

                 end else begin
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComManImg(idx,ax,ay);
                 end else
                  d := FrmMain.GetWStateMonkManImg(idx,ax,ay);
                 if g_MySelf.m_btSex = 1 then
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComWomanImg(idx,ax,ay)
                 end else
                  d := FrmMain.GetWStateMonkWoImg(idx,ax,ay);
                 end;
                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                     if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                       dsurface.Draw (SurfaceX(bbx+ax - 9), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
                     end else
                       dsurface.Draw (SurfaceX(bbx+ax - 11), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
                  end else
                     if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                       dsurface.Draw (SurfaceX(bbx+ax - 12), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
                     end else
                       dsurface.Draw (SurfaceX(bbx+ax - 15), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
               end;
               idx := 0;
            end;
            if idx > 0 then begin             //Åõ±¸
               d := g_WMainImages.GetCachedImage (idx, ax, ay);
               if g_MySelf.m_btMask in [20, 21] then d := nil;
               if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                    dsurface.Draw (SurfaceX(bbx+ax - 9), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                   end else
                    dsurface.Draw (SurfaceX(bbx+ax - 11), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                  end else
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                    dsurface.Draw (SurfaceX(bbx+ax - 12), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
                   end else
                    dsurface.Draw (SurfaceX(bbx+ax - 15), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
            end;
            if g_UseItems[U_WEAPON].S.Name <> '' then begin  //¹«±â     //»óÅÂÃ¢ÀÛ¾÷
               idx := g_UseItems[U_WEAPON].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComManImg(idx,ax,ay);
                 end else
                  d := FrmMain.GetWStateMonkManImg(idx,ax,ay);
               if g_MySelf.m_btSex = 1 then
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComWomanImg(idx,ax,ay)
                 end else
                  d := FrmMain.GetWStateMonkWoImg(idx,ax,ay);
                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                     if g_MySelf.m_btSex = 0 then begin
                       if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        dsurface.Draw (SurfaceX(bbx+ax - 11), SurfaceY(bby+ay + 23), d.ClientRect, d, TRUE)
                       end else
                        dsurface.Draw (SurfaceX(bbx+ax - 11), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                     end else
                       if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        dsurface.Draw (SurfaceX(bbx+ax - 10), SurfaceY(bby+ay + 19), d.ClientRect, d, TRUE);
                       end else
                        dsurface.Draw (SurfaceX(bbx+ax - 15), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);

                if (g_UseItems[U_WEAPON].S.WEffect > 0) then begin
                  if (g_UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 11), SurfaceY(bby + ay + 23), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 10), SurfaceY(bby + ay + 19), d, 1);
                    end;
                  end else begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect - 81) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Monk_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Monk_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 11), SurfaceY(bby + ay + 25), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 15), SurfaceY(bby + ay + 20), d, 1);
                    end;
                  end;
                end;
              end;
            end;



         end else begin



         if g_MySelf <> nil then
         if g_MySelf.m_btJob = 8 then begin     //ºñ¿¬ÀÚ°´ »óÅÂÃ¢
            pgidx := 379;
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WMainImages.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[500];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+8), SurfaceY(Top+70), d.ClientRect, d, TRUE);

          if g_MySelf.m_btMask in [20, 21] then begin
            if g_MySelf.m_btMask = 20 then begin
              pgidx := 930;
              bbx := Left + 28;
              bby := Top + 120;

              d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

              d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);

            end else begin
              pgidx := 932;
              bbx := Left + 48;
              bby := Top + 135;

              d := g_WMain2Images.Images[933];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
            end;
            d := g_WMain2Images.Images[pgidx];
              if d <> nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
          end else begin
            if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
            d := g_WMainImages.Images[320 + g_MySelf.m_btSex];
            end else
            d := g_WMainImages.Images[g_MySelf.m_btJob * 2 + 320 + g_MySelf.m_btSex];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx-2), SurfaceY(bby+64), d.ClientRect, d, TRUE);
          end;
            bbx := Left + 8{bbx + 18};
            bby := Top - 23{bby + 60};
            if g_UseItems[U_DRESS].S.Name <> '' then begin
               idx := g_UseItems[U_DRESS].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btSex = 1 then begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1219, ax, ay);
                     if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1229, ax, ay);
                     d := FrmMain.GetWStateComWomanImg(idx,ax,ay)
                   end else begin
                     if idx = 86 then
                       e := g_WMain2Images.GetCachedImage(1217, ax, ay);
                     if idx = 605 then
                       e := g_WMain2Images.GetCachedImage(1227, ax, ay);
                     d := FrmMain.GetWStateAssWoImg(idx,ax,ay);
                   end;
                 end else begin
                  if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1218, ax, ay);
                     if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                       e := g_WMain2Images.GetCachedImage(1228, ax, ay);
                     d := FrmMain.GetWStateComManImg(idx,ax,ay)
                   end else begin
                     if idx = 85 then
                       e := g_WMain2Images.GetCachedImage(1216, ax, ay);
                     if idx = 595 then
                       e := g_WMain2Images.GetCachedImage(1226, ax, ay);
                     d := FrmMain.GetWStateAssManImg(idx,ax,ay);
                   end;
                 end;
                 if g_MySelf.m_btMask in [20, 21] then begin
                   d := nil; e := nil;
                 end;
                 if d <> nil then
                 if g_MySelf.m_btSex = 0 then begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if e <> nil then begin
                       if idx = 85 then
                         dsurface.Draw (SurfaceX(bbx+ax-28), SurfaceY(bby+ay-12), e.ClientRect, e, TRUE);
                       if idx = 595 then
                         dsurface.Draw (SurfaceX(bbx+ax-75), SurfaceY(bby+ay-19), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);
                   end else begin
                     if e <> nil then begin
                       if idx = 85 then
                         dsurface.Draw (SurfaceX(bbx+ax-23), SurfaceY(bby+ay-10), e.ClientRect, e, TRUE);
                       if idx = 595 then
                         dsurface.Draw (SurfaceX(bbx+ax-50), SurfaceY(bby+ay-15), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);
                   end;
                 end else begin
                   if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     if e <> nil then begin
                       if idx = 86 then
                         dsurface.Draw (SurfaceX(bbx+ax-42), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                       if idx = 605 then
                         dsurface.Draw (SurfaceX(bbx+ax-67), SurfaceY(bby+ay- 23), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-24), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
                   end else begin
                     if e <> nil then begin
                       if idx = 86 then
                         dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay- 9), e.ClientRect, e, TRUE);
                       if idx = 605 then
                         dsurface.Draw (SurfaceX(bbx+ax-53), SurfaceY(bby+ay- 25), e.ClientRect, e, TRUE);
                     end;
                     dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
                   end;
                 end;
               end;
            end;
            //ºñ¿¬ÀÚ°´ »óÅÂÃ¢ Çì¾î
            idx := 460 + g_MySelf.m_btHair div 2;
            if g_MySelf.m_btSex = 1 then
            idx := 500 + g_MySelf.m_btHair div 2;
            if g_UseItems[U_HELMET].S.Name <> '' then begin
               idx := g_UseItems[U_HELMET].S.Looks;
               if idx >= 0 then begin
                 if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

                 end else begin
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComManImg(idx,ax,ay)
                 end else
                  d := FrmMain.GetWStateAssManImg(idx,ax,ay);
                 if g_MySelf.m_btSex = 1 then
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComWomanImg(idx,ax,ay)
                 end else
                  d := FrmMain.GetWStateAssWoImg(idx,ax,ay);
                 end;
                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin         //Åõ±¸
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax - 21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);
                  end else
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 24), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
               end;
               idx := 0;
            end;
            if idx > 0 then begin          //Çì¾î
             if (g_UseItems[U_DRESS].S.Shape = 20) and (g_UseItems[U_DRESS].S.Name <> '') then begin

             end else
               d := g_WMainImages.GetCachedImage (idx, ax, ay);

               if g_MySelf.m_btMask in [20, 21] then d := nil;

               if d <> nil then
                  if g_MySelf.m_btSex = 0 then begin
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax - 21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE)
                  end else
                    if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                     dsurface.Draw (SurfaceX(bbx+ax - 24), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 20), d.ClientRect, d, TRUE);
            end;
            if g_UseItems[U_WEAPON].S.Name <> '' then begin   //¹«±â    //»óÅÂÃ¢ÀÛ¾÷
               idx := g_UseItems[U_WEAPON].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComManImg(idx,ax,ay)
                 end else
                  d := FrmMain.GetWStateAssManImg(idx,ax,ay);
               if g_MySelf.m_btSex = 1 then
                 if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                  d := FrmMain.GetWStateComWomanImg(idx,ax,ay)
                 end else
                  d := FrmMain.GetWStateAssWoImg(idx,ax,ay);
                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if d <> nil then
                     if g_MySelf.m_btSex = 0 then begin
                       if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        dsurface.Draw (SurfaceX(bbx+ax - 23), SurfaceY(bby+ay + 23), d.ClientRect, d, TRUE);
                       end else
                        dsurface.Draw (SurfaceX(bbx+ax - 19), SurfaceY(bby+ay + 26), d.ClientRect, d, TRUE);
                     end else
                       if g_MySelf.m_btWeapon in [0,1,38,39,68..97,110..115] then begin
                        dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 19), d.ClientRect, d, TRUE);
                       end else
                        dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);

                if (g_UseItems[U_WEAPON].S.WEffect > 0) then begin
                  if (g_UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 23), SurfaceY(bby + ay + 23), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 22), SurfaceY(bby + ay + 19), d, 1);
                    end;
                  end else begin
                    img := 0 + (g_UseItems[U_WEAPON].S.WEffect - 85) * 10;
                    if g_MySelf.m_btSex = 0 then
                      d := g_WState_Eff_Assassin_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                    else d := g_WState_Eff_Assassin_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                    if d <> nil then begin
                      if g_MySelf.m_btSex = 0 then
                        DrawBlend(dsurface, SurfaceX(bbx + ax - 19), SurfaceY(bby + ay + 26), d, 1)
                      else DrawBlend(dsurface, SurfaceX(bbx + ax - 22), SurfaceY(bby + ay + 25), d, 1);
                    end;
                  end;
                end;

              end;
            end;



         end else begin      //±âº» Á÷¾÷ »óÅÂÃ¢

          if g_MySelf.m_btMask in [20, 21] then begin
            if g_MySelf.m_btMask = 20 then begin
              pgidx := 930;
              bbx := Left + 28;
              bby := Top + 120;

              d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
               DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

              d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
              if d <> nil then
               DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
            end else begin
              pgidx := 932;
              bbx := Left + 48;
              bby := Top + 135;

              d := g_WMain2Images.Images[933];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
            end;
            d := g_WMain2Images.Images[pgidx];
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby + 1), d.ClientRect, d, TRUE);
          end else begin
            pgidx := 340;
            if g_MySelf <> nil then
               if g_MySelf.m_btSex = 1 then pgidx := 341;
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WMainImages.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);

          end;

            d := g_WTitleImages.Images[500];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+8), SurfaceY(Top+70), d.ClientRect, d, TRUE);

            bbx := Left;
            bby := Top;
            if g_UseItems[U_DRESS].S.Name <> '' then begin
               idx := g_UseItems[U_DRESS].S.Looks;
               if idx >= 0 then begin
                 if g_MySelf.m_btSex = 1 then begin
                   if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                     e := g_WMain2Images.GetCachedImage(1203, ax, ay);
                   if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                     e := g_WMain2Images.GetCachedImage(1205, ax, ay);
                 end else begin
                   if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                     e := g_WMain2Images.GetCachedImage(1202, ax, ay);
                   if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                     e := g_WMain2Images.GetCachedImage(1204, ax, ay);
                 end;
                 d := FrmMain.GetWStateImg(idx,ax,ay);
                 if g_MySelf.m_btMask in [20, 21] then d := nil;
                 if d <> nil then begin
                   if g_MySelf.m_btSex = 1 then begin
                     if e <> nil then begin
                       if idx = 86 then
                         dsurface.Draw (SurfaceX(bbx+ax-30), SurfaceY(bby+ay - 31), e.ClientRect, e, TRUE);
                       if idx = 605 then
                         dsurface.Draw (SurfaceX(bbx+ax-38), SurfaceY(bby+ay - 34), e.ClientRect, e, TRUE);
                     end;
                   end else begin
                     if e <> nil then begin
                       if idx = 85 then
                         dsurface.Draw (SurfaceX(bbx+ax-26), SurfaceY(bby+ay - 40), e.ClientRect, e, TRUE);
                       if idx = 595 then
                         dsurface.Draw (SurfaceX(bbx+ax-35), SurfaceY(bby+ay - 40), e.ClientRect, e, TRUE);
                     end;
                   end;
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                   if (g_UseItems[U_DRESS].S.AniCount > 0) and (g_MySelf.m_btJob in [4, 9]) then begin
                     img := 0 + (g_UseItems[U_DRESS].S.AniCount - 1) * 20;
                     d := g_WState_Eff_BImages.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 100 mod 12), ax, ay ) ;
                     if d <> nil then
                      DrawBlend(dsurface, SurfaceX(bbx + ax + 127), SurfaceY(bby + ay + 222), d, 1);
                   end;
                 end;
               end;
            end;
            //Çì¾î
            idx := 440 + g_MySelf.m_btHair div 2;
            if g_MySelf.m_btSex = 1 then
            idx := 480 + g_MySelf.m_btHair div 2;

            if g_UseItems[U_HELMET].S.Name <> '' then begin
               idx := g_UseItems[U_HELMET].S.Looks;
               if idx >= 0 then begin
                 if (g_UseItems[U_DRESS].S.Shape in [30,111]) and (g_UseItems[U_DRESS].S.Name <> '') then begin

                 end else
                  d := FrmMain.GetWStateImg(idx,ax,ay);

                  if g_MySelf.m_btMask in [20, 21] then d := nil;
                  if g_MySelf.m_btJob = 5 then d := nil;
                  if d <> nil then
                    if g_MySelf.m_btSex = 0 then begin
                     dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay+2), d.ClientRect, d, TRUE);
                    end else
                     dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
               end;
               idx := 0;
            end;

            if idx > 0 then begin
              if (g_UseItems[U_DRESS].S.Shape in [30,111]) and (g_UseItems[U_DRESS].S.Name <> '') then begin

              end else
               d := g_WMainImages.GetCachedImage (idx, ax, ay);
               if g_MySelf.m_btMask in [20, 21] then d := nil;
               if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;

            if g_UseItems[U_WEAPON].S.Name <> '' then begin
               idx := g_UseItems[U_WEAPON].S.Looks;
               if idx >= 0 then begin
                 d := FrmMain.GetWStateImg(idx,ax,ay);
                 if g_MySelf.m_btMask in [20, 21] then d := nil;
                 if d <> nil then begin
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                   if idx = 923 then begin
                     d := FrmMain.GetWStateImg(idx-1,ax,ay);
                     if d <> nil then DrawBlend (dsurface,bbx + ax,bby + ay,d, 1);
                   end;
                   if (g_UseItems[U_WEAPON].S.WEffect > 0) then begin
                     if g_UseItems[U_WEAPON].S.WEffect in [93..98] then  //ÀÚ°´ º°µµ
                       img := 0 + (g_UseItems[U_WEAPON].S.WEffect + 11 ) * 10
                     else
                     img := 0 + (g_UseItems[U_WEAPON].S.WEffect ) * 10;
                     d := g_WState_Eff.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay ) ;
                     if d <> nil then
                      DrawBlend(dsurface, SurfaceX(bbx + ax  ), SurfaceY(bby + ay ), d, 1);
                   end;
                   if (g_UseItems[U_WEAPON].S.Shape in [11,12,14,15]) and (g_MySelf.m_btJob in [4, 9]) then begin
                     case g_UseItems[U_WEAPON].S.Shape of
                      11: img := 120;
                      12: img := 140;
                      14: img := 100;
                      15: img := 80;
                     end;
                     d := g_WState_Eff_BImages.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 100 mod 20), ax, ay ) ;
                     if d <> nil then
                      DrawBlend(dsurface, SurfaceX(bbx + ax + 127), SurfaceY(bby + ay + 222), d, 1);
                   end;
                 end;

              end;
            end;
         end;
         end;
         end;
         end;
         end;

         1: begin   // Ä³¸¯ÅÍ »óÅÂÃ¢ 1
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WTitleImages.Images[506];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[501];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left + 70), SurfaceY(Top + 70), d.ClientRect, d, TRUE);

            l := Left + 120;
            m := Top + 155;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(l+0), SurfaceY(m), IntToStr(LoWord(g_MySelf.m_Abil.AC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.AC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+27), IntToStr(LoWord(g_MySelf.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MAC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+54), IntToStr(LoWord(g_MySelf.m_Abil.DC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.DC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+81), IntToStr(LoWord(g_MySelf.m_Abil.MC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+108), IntToStr(LoWord(g_MySelf.m_Abil.SC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.SC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+135), IntToStr(g_MySelf.m_Abil.HP) + '/' + IntToStr(g_MySelf.m_Abil.MaxHP));
               TextOut (SurfaceX(l+0), SurfaceY(m+162), IntToStr(g_MySelf.m_Abil.MP) + '/' + IntToStr(g_MySelf.m_Abil.MaxMP));
               Release;
            end;
         end;

         2: begin   // Ä³¸¯ÅÍ »óÅÂÃ¢ 2
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WTitleImages.Images[507];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[502];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+132), SurfaceY(Top+70), d.ClientRect, d, TRUE);

            bbx := bbx + 42;
            bby := bby + 62;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               mmx := bbx + 95;
               Font.Color := clSilver;
               TextOut (bbx, bby, '¾­Ñé ');
               TextOut(mmx, bby, FormatFloat('0.00%',(g_Myself.m_Abil.Exp / g_Myself.m_Abil.MaxExp) * 100)); //Ripman exp fix

               TextOut (bbx, bby+16*1, '±³°ü¸ºÖØ ');
               if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
                  Font.Color := clRed;
               TextOut (mmx, bby+16*1, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight));

               Font.Color := clSilver;
               TextOut (bbx, bby+16*2, '´©´÷¸ºÖØ ');
               if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
                  Font.Color := clRed;
               TextOut (mmx, bby+16*2, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight));

               Font.Color := clSilver;
               TextOut (bbx, bby+16*3, 'ÍóÁ¦ ');
               if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
                  Font.Color := clRed;
               TextOut (mmx, bby+16*3, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight));

               Font.Color := clSilver;
               TextOut (bbx, bby+16*4, '×¼È· ');
               TextOut (mmx, bby+16*4, IntToStr(g_nMyHitPoint));

               TextOut (bbx, bby+16*5, 'Ãô½Ý ');
               TextOut (mmx, bby+16*5, IntToStr(g_nMySpeedPoint));

               TextOut (bbx, bby+16*6, 'Ä§·¨¶ã±Ü ');
               TextOut (mmx, bby+16*6, '+' + IntToStr(g_nMyAntiMagic));

               TextOut (bbx, bby+16*7, '¶¾Îï¶ã±Ü ');
               TextOut (mmx, bby+16*7, '+' + IntToStr(g_nMyAntiPoison));

               TextOut (bbx, bby+16*8, 'ÖÐ¶¾»Ö¸´ ');
               TextOut (mmx, bby+16*8, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');

               TextOut (bbx, bby+16*9, 'ÉúÃü»Ö¸´ ');
               TextOut (mmx, bby+16*9, '+' + IntToStr(g_nMyHealthRecover * 10) + '%');

               TextOut (bbx, bby+16*10, 'Ä§·¨»Ö¸´ ');
               TextOut (mmx, bby+16*10, '+' + IntToStr(g_nMySpellRecover * 10) + '%');

               TextOut (bbx, bby+16*11, 'ÐÒÔË ');
               if g_nMyLuckPoint > 200 then begin     //ÀúÁÖ Ç¥½Ã
                 if g_nMyLuckPoint < 247 then
                    TextOut (mmx, bby+16*11, '-' + IntToStr(9))
                 else
                    TextOut (mmx, bby+16*11, '-' + IntToStr(256 - g_nMyLuckPoint));
               end else begin
                    TextOut (mmx, bby+16*11, IntToStr(g_nMyLuckPoint));
               end;
               Release;
            end;
         end;

         3: begin       //¸¶¹ý ÆäÀÌÁö
            bbx := Left + 8;
            bby := Top + 90;
            d := g_WTitleImages.Images[508];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            d := g_WTitleImages.Images[503];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+194), SurfaceY(Top+70), d.ClientRect, d, TRUE);

            magtop := MagicPage * 6;
            magline := _MIN(MagicPage*6+6, g_MagicList.Count);
            for i:=magtop to magline-1 do begin
               pm := PTClientMagic (g_MagicList[i]);
               m := i - magtop;
               keyimg := 0;
                  d := g_WMainImages.Images[1656];
                  if d <> nil then
                     dsurface.Draw (bbx + 9, bby + 41 + m * 33, d.ClientRect, d, TRUE);
                  with dsurface.Canvas do begin
                  SetBkMode (Handle, TRANSPARENT);
                  Font.Size := 8;
                  Font.Color := clWhite;
                  Key1 := 'F1';
                  Key2 := 'F2';
                  Key3 := 'F3';
                  Key4 := 'F4';
                  Key5 := 'F5';
                  Key6 := 'F6';
                  Key7 := 'F7';
                  Key8 := 'F8';
                  Key9 := 'Ctrl';
                  Key10 := '+';

                  if byte(pm.Key) = byte('1') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby + 43 + m * 33), Key1);
                  end;
                  if byte(pm.Key) = byte('2') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby + 43 + m * 33), Key2);
                  end;
                  if byte(pm.Key) = byte('3') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby + 43 + m * 33), Key3);
                  end;
                  if byte(pm.Key) = byte('4') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby + 43 + m * 33), Key4);
                  end;
                  if byte(pm.Key) = byte('5') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key5);
                  end;
                  if byte(pm.Key) = byte('6') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key6);
                  end;
                  if byte(pm.Key) = byte('7') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key7);
                  end;
                  if byte(pm.Key) = byte('8') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key8);
                  end;


                  if byte(pm.Key) = byte('E') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key1);
                  end;
                  if byte(pm.Key) = byte('F') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key2);
                  end;
                  if byte(pm.Key) = byte('G') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key3);
                  end;
                  if byte(pm.Key) = byte('H') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key4);
                  end;
                  if byte(pm.Key) = byte('I') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key5);
                  end;
                  if byte(pm.Key) = byte('J') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key6);
                  end;
                  if byte(pm.Key) = byte('K') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key7);
                  end;
                  if byte(pm.Key) = byte('L') then begin
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 28), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 20), SurfaceY(bby +59 + m * 33), Key8);
                  end;

                  Font.Size := 9;
                  Release;
               end;
               d := g_WTitleImages.Images[516];
               if d <> nil then
                  dsurface.Draw (bbx + 78, bby+46+m*33, d.ClientRect, d, TRUE);
               d := g_WTitleImages.Images[517];
               if d <> nil then
                  dsurface.Draw (bbx + 78, bby+58+m*33, d.ClientRect, d, TRUE);
            end;


            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clSilver;            //¸¶¹ý ÆäÀÌÁö
               if (g_MagicList.Count > 0) then begin
               TextOut(bbx + 112, bby + 252, inttostr(MagicPage + 1)+'/'+inttostr((g_MagicList.Count+5) div 6));
               end;
               for i:=magtop to magline-1 do begin
                  pm := PTClientMagic (g_MagicList[i]);
                  m := i - magtop;
                  if not (pm.Level in [0..3]) then pm.Level := 0;

                  TextOut (bbx + 120, bby+45+m*33, pm.Def.sMagicName);   //¹«°ø ÀÌ¸§
                  if pm.Level in [0..3] then trainlv := pm.Level
                  else trainlv := 0;
                  TextOut (bbx+94, bby+45+m*33, IntToStr(pm.Level));  //¹«°ø ·¹º§
                  if pm.Def.MaxTrain[trainlv] > 0 then begin
                     if trainlv < 3 then
                        TextOut (bbx+120, bby+60+m*33, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))  //¹«°ø ¼ö·Ã

                     else TextOut (bbx+120, bby+60+m*33, '-');   //¹«°ø ¼ö·Ã ¿Ï·á
                  end;
               end;
               Release;
            end;
         end;
      end;

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);                //ÀÌ¸§
         Font.Color := g_MySelf.m_nNameColor;
         tx :=  135 - TextWidth(FrmMain.CharName) div 2;
         TextOut (SurfaceX(Left + tx),
                  SurfaceY(Top + 16), g_MySelf.m_sUserName);
         DHeartMyState.Left := tx-14;
         DHeartMyState.Top := 16;

         Case g_MySelf.m_btColumn of
           0:  ;
           1: begin
             Font.Color := clYellow;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), g_MySelf.ColumName);
           end;
           2: begin
             Font.Color := clYellow;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), g_MySelf.ColumName);
           end;
           3: begin
             Font.Color := clFuchsia;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), g_MySelf.ColumName);
           end;
           4: begin
             Font.Color := clFuchsia;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), g_MySelf.ColumName);
           end;
           5: begin
             Font.Color := clRed;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), g_MySelf.ColumName);
           end;
           6: begin
             Font.Color := clRed;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), g_MySelf.ColumName);
           end;
         end;

         fstr := Copy(g_MySelf.FameName, 1, pos(' ', g_MySelf.FameName)-1 );
         tx := 135 - TextWidth(g_MySelf.FameName) div 2;
         Font.Color := clWhite;
         TextOut (SurfaceX(Left + tx), SurfaceY(Top + 50), g_MySelf.FameName );
         Font.Color := clLime;
         TextOut (SurfaceX(Left + tx), SurfaceY(Top + 50), fstr );

         Font.Color := clSilver;
         if g_sGuildName <> '' then begin
         output:= g_sGuildName + '/' + g_sGuildRankName;
         TextOut (SurfaceX(Left + 135) - TextWidth(output) div 2, SurfaceY(Top + 33), output);
         end;
         Font.Color := ClWhite;
         Release;
      end;
   end;
end;


procedure TFrmDlg.DSWLightDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx, ax, ay, i: Integer;
  d: TDirectDrawSurface;
  nWhere: Integer;
begin
  nWhere := -1;
  if StatePage = 0 then begin
    if Sender = DSWWeapon then nWhere := U_WEAPON;
    if Sender = DSWDress then nWhere := U_DRESS;
    if Sender = DSWHelmet then nWhere := U_HELMET;
    if Sender = DSWNecklace then nWhere := U_NECKLACE;
    if Sender = DSWLight then nWhere := U_RIGHTHAND;
    if Sender = DSWArmRingR then nWhere := U_ARMRINGR;
    if Sender = DSWArmRingL then nWhere := U_ARMRINGL;
    if Sender = DSWRingR then nWhere := U_RINGR;
    if Sender = DSWRingL then nWhere := U_RINGL;
    if Sender = DSWBujuk then nWhere := U_BUJUK;
    if Sender = DSWBelt then nWhere := U_BELT;
    if Sender = DSWBoots then nWhere := U_BOOTS;
    if Sender = DSWCharm then nWhere := U_CHARM;
    if Sender = DSWTiger then nWhere := U_TIGER;


    if nWhere >= 0 then begin
      if g_UseItems[nWhere].s.Name <> '' then begin
        Idx := g_UseItems[nWhere].s.looks;
        if Idx >= 0 then begin
          d := g_WBagItemImages.Images[Idx];
          if d <> nil then
            with TDButton(Sender) do
              dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
                SurfaceY(Top + (Height - d.Height) div 2),
                d.ClientRect, d, True);


          if (g_UseItems[nWhere].S.btValue[19] > 2) and   //ºÀÀÎ
            (now < UnixToDateTime(DateTimeToUnix(g_UseItems[nWhere].S.MaxDate))) then begin
            d := g_WStateItemImages.Images[3590];
            if d <> nil then
              with TDButton(Sender) do
              dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2) + 12,
                                SurfaceY(Top + (Height - d.Height) div 2) + 8, d.ClientRect, d, True);
          end;

          if g_UseItems[nWhere].S.ItemGlow <> 0  then
          if (aiShineFrame[nWhere] <> -1) then begin
            d := g_WMainImages.GetCachedImage(ITEMSHINEOFFSET + aiShineFrame[nWhere], ax,ay);
            if d <> nil then begin
              with TDButton(Sender) do
              DrawBlend(dsurface, SurfaceX(Left + ax - 6), SurfaceY(Top + ay) + 41, d, 1);
            end;
          end;


          for i := 0 to 13 do begin
            if GetTickCount > aiShineTime[i] + 80 then begin
              aiShineTime[i] := GetTickCount;
              if aiShineFrame[i] < 9 then
                aiShineFrame[i] := aiShineFrame[i] + 1
              else begin
                aiShineFrame[i] := -1;
                aiShineTime[i] := GetTickCount + 2000 + Random(1500);
              end;
            end;
          end;

        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateWinClick(Sender: TObject; X, Y: Integer);
begin
   if StatePage = 3 then begin
      X := DStateWin.LocalX (X) - DStateWin.Left;
      Y := DStateWin.LocalY (Y) - DStateWin.Top;
      if (X >= 33) and (X <= 33+166) and (Y >= 55) and (Y <= 55+37*5) then begin
         magcur := (Y-55) div 37;
         if (magcur+magtop) >= g_MagicList.Count then
            magcur := (g_MagicList.Count-1) - magtop;
      end;
   end;
end;

procedure TFrmDlg.DCloseStateClick(Sender: TObject; X, Y: Integer);
begin
   DStateWin.Visible := FALSE;
end;

procedure TFrmDlg.DCharDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.PageChanged;
begin
   DScreen.ClearHint;
   case StatePage of
      3: begin
         DStMag1.Visible := TRUE;  DStMag2.Visible := TRUE;
         DStMag3.Visible := TRUE;  DStMag4.Visible := TRUE;
         DStMag5.Visible := TRUE;  DStMag6.Visible := TRUE;
         DSWBoots.Visible:= False;
         DSWCharm.Visible := False;
         DSWBelt.Visible := False;
         DStPageUp.Visible := TRUE;
         DStPageDown.Visible := TRUE;
         MagicPage := 0;
      end;
      else begin
         DStMag1.Visible := FALSE;  DStMag2.Visible := FALSE;
         DStMag3.Visible := FALSE;  DStMag4.Visible := FALSE;
         DStMag5.Visible := FALSE;  DStMag6.Visible := FALSE;
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
         DSWBoots.Visible:= True;
         DSWCharm.Visible := True;
         DSWBelt.Visible:=True;
      end;
   end;
end;


procedure TFrmDlg.HeroPageChanged;
begin
  DScreen.ClearHint;
  case HeroStatePage of
    0, 1: begin
        DHeroSWWeapon.Visible := True;
        DHeroSWDress.Visible := True;
        DHeroSWHelmet.Visible := True;
        DHeroSWArmRingR.Visible := True;
        DHeroSWRingR.Visible := True;
        DHeroSWNecklace.Visible := True;
        DHeroSWLight.Visible := True;
        DHeroSWArmRingL.Visible := True;
        DHeroSWRingL.Visible := True;
        DHeroSWCharm.Visible := True;
        DHeroSWBoots.Visible := True;
        DHeroSWBelt.Visible := True;
        DHeroSWBujuk.Visible := True;

        DHeroStPageUp.Visible := False;
        DHeroStPageDown.Visible := False;

        DHeroStMag1.Visible := False; DHeroStMag2.Visible := False;
        DHeroStMag3.Visible := False; DHeroStMag4.Visible := False;
        DHeroStMag5.Visible := False; DHeroStMag6.Visible := False;
      end;
    2: begin
        DHeroSWWeapon.Visible := False;
        DHeroSWDress.Visible := False;
        DHeroSWHelmet.Visible := False;
        DHeroSWArmRingR.Visible := False;
        DHeroSWRingR.Visible := False;
        DHeroSWNecklace.Visible := False;
        DHeroSWLight.Visible := False;
        DHeroSWArmRingL.Visible := False;
        DHeroSWRingL.Visible := False;
        DHeroSWCharm.Visible := False;
        DHeroSWBoots.Visible := False;
        DHeroSWBelt.Visible := False;
        DHeroSWBujuk.Visible := False;

        DHeroStPageUp.Visible := False;
        DHeroStPageDown.Visible := False;

        DHeroStMag1.Visible := False; DHeroStMag2.Visible := False;
        DHeroStMag3.Visible := False; DHeroStMag4.Visible := False;
        DHeroStMag5.Visible := False; DHeroStMag6.Visible := False;
      end;
    3: begin
        DHeroSWWeapon.Visible := False;
        DHeroSWDress.Visible := False;
        DHeroSWHelmet.Visible := False;
        DHeroSWArmRingR.Visible := False;
        DHeroSWRingR.Visible := False;
        DHeroSWNecklace.Visible := False;
        DHeroSWLight.Visible := False;
        DHeroSWArmRingL.Visible := False;
        DHeroSWRingL.Visible := False;
        DHeroSWCharm.Visible := False;
        DHeroSWBoots.Visible := False;
        DHeroSWBelt.Visible := False;
        DHeroSWBujuk.Visible := False;

        DHeroStMag1.Visible := True; DHeroStMag2.Visible := True;
        DHeroStMag3.Visible := True; DHeroStMag4.Visible := True;
        DHeroStMag5.Visible := True; DHeroStMag6.Visible := True;

        DHeroStPageUp.Visible := True;
        DHeroStPageDown.Visible := True;
        HeroMagicPage := 0;
      end;
  end;
end;

procedure TFrmDlg.RefCheckButtonXY;
var
  i: Integer;
begin
  //g_FScreenWidth
  i := g_QuestMsgList.Count * 32;
  if g_QuestMsgList.Count > 0 then
    Inc(i, 2 * (g_QuestMsgList.Count - 1));
  DBTCheck1.Left := (g_FScreenWidth - i) div 2 - DBottom.Left - 9;
  DBTCheck2.Left := DBTCheck1.Left + 32 + 2;
  DBTCheck3.Left := DBTCheck2.Left + 32 + 2;
  DBTCheck4.Left := DBTCheck3.Left + 32 + 2;
  DBTCheck5.Left := DBTCheck4.Left + 32 + 2;
  DBTCheck6.Left := DBTCheck5.Left + 32 + 2;
  DBTCheck7.Left := DBTCheck6.Left + 32 + 2;
  DBTCheck8.Left := DBTCheck7.Left + 32 + 2;
  DBTCheck9.Left := DBTCheck8.Left + 32 + 2;
  DBTCheck10.Left := DBTCheck9.Left + 32 + 2;
end;

procedure TFrmDlg.RentalPageChanged;    //´ë¿©Ã¢ ¸ðµå
begin
   case RentalPage of
      0: begin
        DReturn.Visible := True;
        DWithdraw.Visible := False;
        if g_RentalItem.StartTime = 0 then
        SendClientMessage(CM_GETRENTAL, g_MySelf.m_nRecogId, 0, 0, 0, '');
      end;
      1: begin
        DReturn.Visible := False;
        DWithdraw.Visible := True;
        SendClientMessage(CM_GETRENTAL2, g_MySelf.m_nRecogId, 0, 0, 0, '');
      end;
   end;
end;

procedure TFrmDlg.GrowPageChanged;    //¹®ÆÄ¼ºÀå ÆäÀÌÁö
begin
   DScreen.ClearHint;
   GrowIndex := 0;
   case GrowPage of
      0: begin
        DGGrow1.Visible := True;
        DGGrow2.Visible := True;
        DGGrow3.Visible := True;
        DGGrow4.Visible := True;
        DGGrow5.Visible := True;
        DGGrow6.Visible := True;
        DGGrow7.Visible := True;
        if GuildCommanderMode then begin
          DGGrowUp.Visible := True;
        end else begin
          DGGrowUp.Visible := False;
        end;
      end;
      1: begin
        DGGrow1.Visible := False;
        DGGrow2.Visible := False;
        DGGrow3.Visible := False;
        DGGrow4.Visible := False;
        DGGrow5.Visible := False;
        DGGrow6.Visible := False;
        DGGrow7.Visible := False;
        DGGrowUp.Visible := False;
      end;
   end;
end;

procedure TFrmDlg.ExChangePageChanged;    //È¯Àü
begin
   DScreen.ClearHint;
   case ExChangePage of
      0: begin
        DExGold.Visible := True;
        DExHwan.Visible := False;

        DDExGold.Visible := False;
        DDExHwan.Visible := True;
      end;
      1: begin
        DExGold.Visible := False;
        DExHwan.Visible := True;

        DDExGold.Visible := True;
        DDExHwan.Visible := False;
      end;
   end;
end;


procedure TFrmDlg.DCharClick(Sender: TObject; X, Y: Integer);
begin
   StatePage := 0;
   PageChanged;
end;

procedure TFrmDlg.DStatusClick(Sender: TObject; X, Y: Integer);
begin
   StatePage := 1;
   PageChanged;
end;

procedure TFrmDlg.DStateClick(Sender: TObject; X, Y: Integer);
begin
   StatePage := 2;
   PageChanged;
end;

procedure TFrmDlg.DSkillClick(Sender: TObject; X, Y: Integer);
begin
   StatePage := 3;
   PageChanged;
end;

procedure TFrmDlg.DSWWeaponClick(Sender: TObject; X, Y: Integer);
var
   where, n, sel: integer;
   flag, movcancel: Boolean;
   sData, sData1, sData2 :String;
   keyvalue: TKeyBoardState;
begin
 if g_FishingOk = FALSE then begin
   if g_MySelf = nil then exit;
   if StatePage <> 0 then exit;
   if g_boItemMoving then begin
      flag := FALSE;
      movcancel := FALSE;
      if (g_MovingItem.Owner = DDealDlg) or (g_MovingItem.Owner = DHeroStateWin) or (g_MovingItem.Owner = DItemStore) then Exit;
      if (g_MovingItem.Index >= 500) then exit;
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      where := GetTakeOnPosition (g_MovingItem.Item.S.StdMode);
      if g_MovingItem.Index >= 0 then begin
         case where of
            U_DRESS: begin
               if Sender = DSWDress then begin
                 { if g_Myself.m_btSex = 0 then //³²ÀÚ
                     if g_MovingItem.Item.S.StdMode <> 10 then //³²ÀÚ¿Ê
                        exit;
                  if g_Myself.m_btSex = 1 then //¿©ÀÚ
                     if g_MovingItem.Item.S.StdMode <> 11 then //¿©ÀÚ¿Ê
                        exit;              }
                  if not FrmMain.CheckItemDelay(g_MovingItem.Item.S.AniCount) then exit;
                  flag := TRUE;
                  if g_MovingItem.Item.S.HumRun then begin
                    g_nRunReadyCount:=1;
                    DScreen.AddChatBoardString ('ÁúÁÖ ´É·ÂÀÌ ¹ßÈÖµË´Ï´Ù.',ClGreen,ClWhite);
                  end;
               end;
            end;
            U_WEAPON: begin
               if Sender = DSWWEAPON then begin
                  flag := TRUE;
               end;
            end;
            U_NECKLACE: begin
               if Sender = DSWNecklace then
                  flag := TRUE;
            end;
            U_RIGHTHAND: begin
               if Sender = DSWLight then
                  flag := TRUE;
            end;
            U_HELMET: begin
               if Sender = DSWHelmet then
                  flag := TRUE;
            end;
            U_RINGR, U_RINGL: begin
               if Sender = DSWRingL then begin
                  where := U_RINGL;
                  flag := TRUE;
               end;
               if Sender = DSWRingR then begin
                  where := U_RINGR;
                  flag := TRUE;
               end;
            end;
            U_ARMRINGR: begin
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
               if Sender = DSWArmRingR then begin
                  where := U_ARMRINGR;
                  flag := TRUE;
               end;
            end;
            U_ARMRINGL: begin
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            U_BUJUK: begin
               if Sender = DSWBujuk then begin
                  where := U_BUJUK;
                  flag := TRUE;
               end;
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            U_BELT: begin
               if Sender = DSWBelt then begin
                  where := U_BELT;
                  flag := TRUE;
               end;
            end;
            U_BOOTS: begin
              if Sender = DSWBoots then begin
                 where := U_BOOTS;
                 flag := TRUE;
                 if g_MovingItem.Item.S.HumRun then begin
                    DScreen.AddChatBoardString ('ÃâÖúÅÜ¹¦ÄÜ¡£',ClGreen,ClWhite);
                 end;
              end;
            end;
            U_CHARM: begin
               if Sender = DSWCharm then begin
                  where := U_CHARM;
                  flag := TRUE;
               end;
            end;

            U_TIGER: begin       //È£¶ûÀÌ
              if Sender = DSWTiger then begin
                 where := U_TIGER;
                 flag := TRUE;
              end;
            end;

         end;
      end else begin
         n := -(g_MovingItem.Index+1);
         if n in [0..MAXUSEITEM] then begin           //¾ÆÀÌÅÛ °¹¼ö
           ItemClickSound (g_MovingItem.Item.S);
           g_UseItems[n] := g_MovingItem.Item;
           g_MovingItem.Item.S.Name := '';
           g_boItemMoving := FALSE;
           g_MovingItem.Owner := nil;
         end;
      end;
      if flag then begin
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DHeroItemBag) then begin
          if (g_MovingItem.Owner = DItemBag) then begin
            ItemClickSound (g_MovingItem.Item.S);
            g_WaitingUseItem := g_MovingItem;
            g_WaitingUseItem.Index := where;
            FrmMain.SendTakeOnItem (where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
            g_MovingItem.Item.S.Name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
          end else begin
            CancelHeroItemMoving;
            exit;
          end;
        end;
      end;
   end else begin
      flag := FALSE;
      if (g_MovingItem.Item.S.Name <> '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      sel := -1;
      if Sender = DSWDress then sel := U_DRESS;
      if Sender = DSWWeapon then sel := U_WEAPON;
      if Sender = DSWHelmet then sel := U_HELMET;
      if Sender = DSWNecklace then sel := U_NECKLACE;
      if Sender = DSWLight then sel := U_RIGHTHAND;
      if Sender = DSWRingL then sel := U_RINGL;
      if Sender = DSWRingR then sel := U_RINGR;
      if Sender = DSWArmRingL then sel := U_ARMRINGL;
      if Sender = DSWArmRingR then sel := U_ARMRINGR;

      if Sender = DSWBujuk then sel := U_BUJUK;
      if Sender = DSWBelt then sel := U_BELT;
      if Sender = DSWBoots then sel := U_BOOTS;
      if Sender = DSWCharm then sel := U_CHARM;
      if Sender = DSWTiger then sel := U_TIGER;  //È£¶ûÀÌ

      if sel >= 0 then begin
         if g_UseItems[sel].S.Name <> '' then begin
            FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
            GetKeyboardState(keyvalue);
            if keyvalue[VK_CONTROL] = $80 then begin //º¸¿Á(±¸ ½Ã½ºÅÛ)
              if not PlayScene.EdChat.Visible then begin
                  PlayScene.EdChat.Visible := True;
                  PlayScene.EdChat.SetFocus;
              end;
              if PlayScene.EdChat.SelStart = Length(PlayScene.EdChat.Text) then begin
                PlayScene.EdChat.Text := PlayScene.EdChat.Text +  '{' + '1' + '/' + IntToStr(g_UseItems[sel].MakeIndex) + '}';
                PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
              end else begin
                sData := Copy(PlayScene.EdChat.Text, 1, PlayScene.EdChat.SelStart);
                sData1 := Copy(PlayScene.EdChat.Text, PlayScene.EdChat.SelStart + 1, Length(PlayScene.EdChat.Text) - PlayScene.EdChat.SelStart);
                sData2 := '{' + '1' + '/' + IntToStr(g_UseItems[sel].MakeIndex) + '}';
                PlayScene.EdChat.Text := sData + sData2 + sData1;
                PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text) - Length(WideString(sData1));
              end;
              PlayScene.EdChat.SelLength := 0;
              SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
              exit;
            end;

            ItemClickSound (g_UseItems[sel].S);
            g_MovingItem.Index := -(sel+1);
            g_MovingItem.Item := g_UseItems[sel];
            g_UseItems[sel].S.Name := '';
            g_boItemMoving := TRUE;
            g_MovingItem.Owner := DStateWin;
         end;
      end;
      if g_MovingItem.Item.S.StdMode in [101,102] Then begin  //È£¶ûÀÌ ÅÛ »¬ °æ¿ì
         if Flag = False then
          DTigerDlg.Visible := FALSE;       //Ã¢ ´ÝÈû
         SendClientMessage(CM_TIGERSET, 0, 0, 0, 0);  //³»¸®±â
      end;
     if g_MovingItem.Item.S.HumRun then begin
     if Flag = False then
      g_nRunReadyCount:=0;
     end;
   end;
 end;
end;

procedure TFrmDlg.DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  sel: integer;
  Butt:TDButton;
begin
   if StatePage <> 0 then exit;
   sel := -1;
   Butt:=TDButton(Sender);
   if Sender = DSWDress then sel := U_DRESS
   else if Sender = DSWWeapon then sel := U_WEAPON
   else if Sender = DSWHelmet then sel := U_HELMET
   else if Sender = DSWNecklace then sel := U_NECKLACE
   else if Sender = DSWLight then sel := U_RIGHTHAND
   else if Sender = DSWRingL then sel := U_RINGL
   else if Sender = DSWRingR then sel := U_RINGR
   else if Sender = DSWArmRingL then sel := U_ARMRINGL
   else if Sender = DSWArmRingR then sel := U_ARMRINGR
   else if Sender = DSWBujuk then sel := U_BUJUK
   else if Sender = DSWBelt then sel := U_BELT
   else if Sender = DSWBoots then sel := U_BOOTS
   else if Sender = DSWCharm then sel := U_CHARM
   else if Sender = DSWTiger then sel := U_TIGER;    //È£¶ûÀÌ

   if sel >= 0 then begin
      g_MouseItem := g_UseItems[sel];
      GetMouseItemHint(g_MySelf, @g_MouseItem);
      if HintList.Count > 0 then begin
        nLocalX:=Butt.LocalX(X - Butt.Left);
        nLocalY:=Butt.LocalY(Y - Butt.Top);
        nHintX:=Butt.SurfaceX(Butt.Left) + DStateWin.SurfaceX(DStateWin.Left) + nLocalX;
        nHintY:=Butt.SurfaceY(Butt.Top) + DStateWin.SurfaceY(DStateWin.Top) + nLocalY;
        with Sender as TDButton do
          DScreen.ShowHintB(nHintX + 10, nHintY + 24, HintList, False);
      end;
      g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DStateWinMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  sMsg:String;
begin
   g_MouseStateItem.S.Name := '';
   DScreen.ClearHint;
   X := DStateWin.LocalX (X) - DStateWin.Left;
   Y := DStateWin.LocalY (Y) - DStateWin.Top;

  if StatePage = 1 then begin
      if (X > 90) and (X < 212) and (Y > 152) and (Y < 167) then begin
         DScreen.ShowHintA (DStateWin.Left + 175, DStateWin.Top+152,
                           '·ÀÓùÁ¦ ', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 179) and (Y < 194) then begin
         DScreen.ShowHintA (DStateWin.Left + 175, DStateWin.Top+179,
                           'Ä§·¨·ÀÓùÁ¦ ', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 205) and (Y < 220) then begin
         DScreen.ShowHintA (DStateWin.Left + 175, DStateWin.Top+205,
                           '¹¥»÷Á¦ ', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 233) and (Y < 248) then begin
         DScreen.ShowHintA (DStateWin.Left + 175, DStateWin.Top+233,
                           'Ä§·¨ ', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 260) and (Y < 274) then begin
         DScreen.ShowHintA (DStateWin.Left + 175, DStateWin.Top+260,
                           'µÀÊõ ', clYellow, FALSE);
         exit;
      end;
   end;

   if (X > 12) and (X < 45) and (Y > 30) and (Y < 62) then begin
      case g_MySelf.m_btJob of
         0: sMsg := 'Õ½Ê¿';
         1: sMsg := '·¨Ê¦';
         2: sMsg := 'µÀÊ¿';
         3: sMsg := '´Ì¿Í';
         4: sMsg := 'ºÍÉÐ';
         5: sMsg := '±ÌÑªÕ½Ê¿';
         6: sMsg := 'ºëÐþ·¨Ê¦';
         7: sMsg := 'ñ´ÏÉµÀÊ¿';
         8: sMsg := '·ÉÑà´Ì¿Í';
         9: sMsg := 'ÆÆ½äÉ®';
      end;

     DScreen.ShowHintA (DStateWin.Left + 15, DStateWin.Top + 15,
                           sMsg, clYellow, FALSE);
     exit;
   end;


end;

procedure TFrmDlg.DStMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   idx, icon: integer;
   d: TDirectDrawSurface;
   pm: PTClientMagic;
begin
   with Sender as TDButton do begin
      idx := _Max(Tag + MagicPage * 6, 0);             //¸¶¹ý Å×µÎ¸®
      if idx < g_MagicList.Count then begin
         pm := PTClientMagic (g_MagicList[idx]);
         icon := pm.Def.btIcon {* 2};          //btEffect
         if icon >= 0 then begin
            if not Downed then begin
               d := GetMagic2Images(pm.Def.wMagicID).Images[icon];
               if d <> nil then
                  dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
            end else begin
               d := GetMagic2Images(pm.Def.wMagicID).Images[icon+1];
               if d <> nil then
                  dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
            end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DStMag1Click(Sender: TObject; X, Y: Integer);
var
   i, idx: integer;
   selkey: word;
   keych: char;
   pm: PTClientMagic;
begin
   if StatePage = 3 then begin
      idx := TDButton(Sender).Tag + magtop;
      if (idx >= 0) and (idx < g_MagicList.Count) then begin

         pm := PTClientMagic (g_MagicList[idx]);
         selkey := word(pm.Key);
         SetMagicKeyDlg (PM.Def.wMagicID, pm.Def.btIcon {* 2}, pm.Def.sMagicName, selkey);
         keych := char(selkey);

         for i:=0 to g_MagicList.Count-1 do begin
            pm := PTClientMagic (g_MagicList[i]);
            if pm.Key = keych then begin
               pm.Key := #0;
               FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0);
            end;
         end;
         pm := PTClientMagic (g_MagicList[idx]);
         //if pm.Def.EffectType <> 0 then begin
         pm.Key := keych;
         FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych);
         //end;
      end;
   end;
end;

procedure TFrmDlg.DStPageUpClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DStPageUp then begin
      if MagicPage > 0 then begin
         Dec (MagicPage);
      end;
   end else begin
      if MagicPage < (g_MagicList.Count+5) div 6 - 1 then begin
         Inc (MagicPage);
      end;
   end;
end;

{------------------------------------------------------------------------}


{------------------------------------------------------------------------}

procedure TFrmDlg.DBottomDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d ,g ,e , h :TDirectDrawSurface;              //ÀÎÅÍÆäÀÌ½º BOTTOB ºÎºÐ
  rc:TRect;
  btop, sx, sy, i, fcolor, bcolor , strln, img, Idx: integer;
  r: Real;
  str, str1 , str2, fstr : string;
  c: TColor;

  Aucbuff : pTAucbuffItem; //°æ¸Å
  ax, ay, YSize: Integer;
  nTime  :String;
  boot : Boolean;
begin
  boot:= False;
  if g_Myself = nil then exit;

  if g_MyHero = nil then begin
    if g_FScreenWidth = 800 then begin
      d:=g_WMainImages.Images[BOTTOMBOARDHERO800];
    end else begin
      d:=g_WAresImages.Images[BOTTOMBOARDHERO1024];
    end;
  end else begin
    if g_FScreenWidth = 800 then begin
      d:=g_WMainImages.Images[BOTTOMBOARDHERO800];
    end else begin
      d:=g_WAresImages.Images[BOTTOMBOARDHERO1024];
    end;
  end;

  img := 0;
  btop := 0;
  if d <> nil then begin
    with d.ClientRect do
    rc := Rect (Left, Top, Right, Top+120);
    btop := g_FScreenHeight - d.height;
     dsurface.Draw (0, btop, rc, d, TRUE);
    with d.ClientRect do
      rc := Rect (Left, Top+120, Right, Bottom);
     dsurface.Draw (0,btop + 120, rc, d, FALSE);
  end;

   ax := 3;
   ay := 5;
   if AuctionView then begin              //°æ¸ÅÀ§Ä¡
     if DSkillBar.Visible then YSize := 25
     else YSize := 0;

    d := g_WAresImages.Images[126];
     if d <> nil then
       DrawBlendEx (dsurface, 5, 5 + YSize, d, 0, 0, d.Width, d.Height, 0);
    d := g_WAresImages.Images[126];
     if d <> nil then
       DrawBlendEx (dsurface, 50, 5 + YSize, d, 0, 0, d.Width, d.Height, 0);
    d := g_WAresImages.Images[126];
     if d <> nil then
       DrawBlendEx (dsurface, 95, 5 + YSize, d, 0, 0, d.Width, d.Height, 0);

      for I := 0 to g_AucList.Count - 1 do begin
        Aucbuff := g_AucList.items[I];
        if Aucbuff <> nil then begin
          if (Aucbuff.nTime - GetTickCount < 1000) then begin  //1ÃÊ ¹Ì¸¸ »èÁ¦ Ã³¸®ÇØÁÖÀÚ..
            if DOffAuction.Visible then CloseAuc;
            if (Aucbuff.Seller = g_MySelf.m_sUserName){ or (Aucbuff.Solder = g_MySelf.m_sUserName)} then  boot := True;
            if boot then SendClientMessage2 (CM_AUCGET, Aucbuff.Item.MakeIndex ,0, 0, 0, Aucbuff.Seller);
            g_AucList.Delete(I);
          end;
          
          if GetTickCount - g_dwTenSecTick[i] > 500 then begin
            g_TenSecTick[i] := Not g_TenSecTick[i];
            g_dwTenSecTick[i]:=GetTickCount();
          end;

          d := g_WBagItemImages.Images[Aucbuff.Item.S.Looks];
          if d <> nil then begin
            if (Aucbuff.nTime - GetTickCount < 10 * 1000) and g_TenSecTick[i] then   //10ÃÊºÎÅÍ
            else dsurface.Draw(ax + (44 - d.Width) div 2 + 2 + i*45,
                           ay + (43 - d.Height) div 2 + YSize, d.ClientRect , d , TRUE);
          end;
          with dsurface.Canvas do begin
            nTime := format('%d:%d', [(Aucbuff.nTime - GetTickCount) Div 60000, ((Aucbuff.nTime - GetTickCount) Div 1000) Mod 60]);
            SetBkMode(handle, TRANSPARENT);
            Font.Size := 9;
            Font.Style := [fsBold];
            BoldTextOut(dsurface, ax + 9 + i*45, ay + 26 + YSize, clWhite, clBlack, nTime);
            Font.Style := [];
            Release;
          end;
        end;
      end;
      
   end;
   if g_MyHero = nil then begin
   if g_MySelf.m_btSex = 0 then begin
    Case g_MySelf.m_btJob of
     0: h := g_WMainImages.Images[1400];
     1: h := g_WMainImages.Images[1401];
     2: h := g_WMainImages.Images[1402];
     3: h := g_WMainImages.Images[1403];
     4: h := g_WAresImages.Images[407];
     5: h := g_WMainImages.Images[1405];
     6: h := g_WMainImages.Images[1406];
     7: h := g_WMainImages.Images[1407];
     8: h := g_WMainImages.Images[1408];
     9: h := g_WAresImages.Images[407];
    end;
   end else
    Case g_MySelf.m_btJob of
     0: h := g_WMainImages.Images[1410];
     1: h := g_WMainImages.Images[1411];
     2: h := g_WMainImages.Images[1412];
     3: h := g_WMainImages.Images[1413];
     4: h := g_WAresImages.Images[407];
     5: h := g_WMainImages.Images[1415];
     6: h := g_WMainImages.Images[1416];
     7: h := g_WMainImages.Images[1417];
     8: h := g_WMainImages.Images[1418];
     9: h := g_WAresImages.Images[407];
    end;
   if h <> nil then
     dsurface.Draw (DBottom.Left + 110, DBottom.Top + 68, h.ClientRect, h, TRUE);


   e := g_WMainImages.Images[10];
    if e <> nil then
       dsurface.Draw (DBottom.Left + 122, DBottom.Top + 108, e.ClientRect, e, TRUE);

   g := g_WMainImages.Images[11];
    if g <> nil then
       dsurface.Draw (DBottom.Left + 154, DBottom.Top + 75, g.ClientRect, g, TRUE);

   end;

   if g_MySelf <> nil then begin
      with dsurface.Canvas do begin
       SetBkMode(dsurface.Canvas.handle, TRANSPARENT);
       Font.Color := clWhite;
       if g_MyHero = nil then begin
       Font.Size := 9;
    //   TextOut (158, (g_FScreenHeight - 86),  '¡ùÎÏÅ£´«Ææ¡ù');
       TextOut ((134 - TextWidth(intToStr(g_nGrade)) div 2 ),(g_FScreenHeight - 40),  intToStr(g_nGrade));
       Font.Size := 8;
       TextOut (174,(g_FScreenHeight - 70), IntToStr(g_Myself.m_Abil.KillPoint));
       TextOut (174,(g_FScreenHeight - 57), IntToStr(g_Myself.m_Abil.DeathPoint));
       if g_Myself.m_Abil.KillPoint > 0 then
       TextOut (174,(g_FScreenHeight - 44), FormatFloat('0.00%',(g_Myself.m_Abil.KillPoint / (g_Myself.m_Abil.KillPoint + g_Myself.m_Abil.DeathPoint)) * 100))
       else
       TextOut (174,(g_FScreenHeight - 44), '0%');
       Font.Size := 9;

       fstr := Copy(g_MySelf.FameName, 1, pos(' ', g_MySelf.FameName)-1 );
       Font.Color := clWhite;
       TextOut ((172) - dsurface.Canvas.TextWidth(g_MySelf.FameName) div 2 ,g_FScreenHeight - 25, g_MySelf.FameName);
       Font.Color := clLime;
       TextOut ((172) - dsurface.Canvas.TextWidth(g_MySelf.FameName) div 2 ,g_FScreenHeight - 25, fstr);
       Font.Color := clWhite;
       end;
       Font.Size := 9;
       TextOut ((14 - dsurface.Canvas.TextWidth(IntToStr(g_MySelf.m_Abil.Level)) div 2),(g_FScreenHeight - 40), IntToStr(g_MySelf.m_Abil.Level));
       TextOut (g_FScreenWidth - 100, g_FScreenHeight - 29, GetGoldStr(g_MySelf.m_nGold));
       TextOut (g_FScreenWidth - 29, g_FScreenHeight - 46, intToStr(GetBagItemCount) + '¸ñ');

       TextOut (52 - dsurface.Canvas.TextWidth(FrmMain.CharName) div 2, g_FScreenHeight - 25, g_MySelf.m_sUserName);
       dsurface.Canvas.Release;
     end;
      //Ã¼·Â ¸¶·Â °ÔÀÌÁö
      if (g_MySelf.m_Abil.MaxHP > 0) and (g_MySelf.m_Abil.MaxMP > 0) then begin
         if (g_MySelf.m_btJob = 0) and (g_MySelf.m_Abil.Level < 26 ) then begin //·¹º§ (Àü»ç)
            d := g_WMainImages.Images[5];
            if d <> nil then begin
               rc := d.ClientRect;
               rc.Right := d.ClientRect.Right - 2;
               dsurface.Draw (0, btop+30, rc, d, True);
            end;
            d := g_WMainImages.Images[6];
            if d <> nil then begin
               rc := d.ClientRect;
               rc.Right := d.ClientRect.Right - 2;
               rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
               dsurface.Draw (0, btop+30+rc.Top, rc, d, True);
            end;
         end else begin
            d := g_WMainImages.Images[4];
            if d <> nil then begin

               rc := d.ClientRect;
               rc.Right := d.ClientRect.Right div 2 - 2;       //Ã¼·Â Ç¥½Ã
               rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
               dsurface.Draw (0, btop+30+rc.Top, rc, d, True);

               rc := d.ClientRect;
               rc.Left := d.ClientRect.Right div 2 {- 2};
               rc.Right := d.ClientRect.Right - 1;
               rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxMP * (g_MySelf.m_Abil.MaxMP - g_MySelf.m_Abil.MP));
               dsurface.Draw (0 + rc.Left, btop+30+rc.Top, rc, d, True);
            end;
         end;
         {with DBottom do begin
           if (g_MySelf.m_Abil.MaxHP = g_MySelf.m_Abil.HP) then begin
             img := 1400 + Integer((GetTickCount - AppendTick) div 120 mod 10);
             d := g_WMagic_BonzeImages.Images[img];
             if d <> nil then
               DrawBlend(dsurface, 6, btop + 20, d, 1);
           end;
           if (g_MySelf.m_Abil.MaxMP = g_MySelf.m_Abil.MP) then begin
             img := 1410 + Integer((GetTickCount - AppendTick) div 120 mod 10);
             d := g_WMagic_BonzeImages.Images[img];
             if d <> nil then
               DrawBlend(dsurface, - 4, btop + 20, d, 1);
           end;
         end;   }
      end;
      // °æÇèÄ¡ °ÔÀÌÁö
      if (g_MySelf.m_Abil.MaxExp > 0) then begin
         if g_FScreenWidth = 800 then begin
           d := g_WMainImages.Images[7];
         end else begin
           d := g_WAresImages.Images[272];
         end;
         if d <> nil then begin
            rc := d.ClientRect;
            if g_MySelf.m_Abil.Exp > 0 then
            r := g_MySelf.m_Abil.MaxExp / g_MySelf.m_Abil.Exp
            else
            r := 0;
            if r > 0 then
            rc.Right := Round (rc.Right / r)
            else
            rc.Right := 0;
            dsurface.Draw (8, g_FScreenHeight - 7, rc, d, FALSE);
            with dsurface.Canvas do begin
              SetBkMode(dsurface.Canvas.handle, TRANSPARENT);
              Font.Size := 8;
              BoldTextOut (dsurface, (g_FScreenWidth - TextWidth(FormatFloat('0.00%',(g_Myself.m_Abil.Exp / g_Myself.m_Abil.MaxExp) * 100))) div 2,g_FScreenHeight - 9, clWhite, clBlack, FormatFloat('0.00%',(g_Myself.m_Abil.Exp / g_Myself.m_Abil.MaxExp) * 100));
              Font.Size := 9;
              dsurface.Canvas.Release;
            end;
          end;
      end;

      if (g_MySelf.m_Abil.MaxWeight > 0) then begin  //¹«°Ô °ÔÀÌÁö.
           d := g_WMainImages.Images[76];
           if d <> nil then begin

            rc := d.ClientRect;
            if g_MySelf.m_Abil.Weight > 0 then r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
            else r := 0;
            if r > 0 then rc.Right := Round (rc.Right / r)
            else rc.Right := 0;

            rc := d.ClientRect;
            if g_MySelf.m_Abil.Weight > 0 then r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
            else r := 0;
            if r > 0 then rc.Right := Round (rc.Right / r)
            else rc.Right := 0;
            dsurface.Draw (g_FScreenWidth - 105 , g_FScreenHeight - 47, rc, d, FALSE);
         end;
      end;

   end;

   if g_MyHero <> nil then begin
      g := g_WMainImages.Images[1392];
      if (g <> nil) and (g_MyHero.m_btHeroAutoDurg > 0) then
       dsurface.Draw( 184 ,g_FScreenHeight - 97, g.ClientRect, g, True);
      if (g <> nil) and (g_MyHero.m_btHeroAutoDurg > 1) then
       dsurface.Draw( 204 ,g_FScreenHeight - 97, g.ClientRect, g, True);

      if (g_AutoPotItems[0].s.Name <> '') and (g_MyHero.m_btHeroAutoDurg > 0) then begin
        d := g_WDnItemImages.Images[g_AutoPotItems[0].s.looks];
        if d <> nil then
          dsurface.Draw(196 - d.Width div 2, ((g_FScreenHeight - 88) - d.Height div 2), d.ClientRect, d, True);
        with dsurface.Canvas do begin
          SetBkMode(handle, TRANSPARENT);
          if (g_AutoPotItems[0].Amount > 0) and (g_AutoPotItems[0].S.StdMode in [0,3]) then begin      //¹°¾à
            Font.Size := 8;
            BoldTextOut(dsurface, (195 -(TextWidth(IntToStr(g_AutoPotItems[0].Amount)) div 2) ),
                      (g_FScreenHeight - 89), clYellow, clBlack, IntToStr(g_AutoPotItems[0].Amount));
            Font.Size := 9;
          end;
          Release;
        end;
      end;
      if (g_AutoPotItems[1].s.Name <> '') and (g_MyHero.m_btHeroAutoDurg > 1) then begin
        d := g_WDnItemImages.Images[g_AutoPotItems[1].s.looks];
        if d <> nil then
          dsurface.Draw(216 - d.Width div 2, ((g_FScreenHeight - 88) - d.Height div 2), d.ClientRect, d, True);
        with dsurface.Canvas do begin
          SetBkMode(handle, TRANSPARENT);
          if (g_AutoPotItems[1].Amount > 0) and (g_AutoPotItems[1].S.StdMode in [0,3]) then begin      //¹°¾à
            Font.Size := 8;
            BoldTextOut(dsurface,(215 -(TextWidth(IntToStr(g_AutoPotItems[1].Amount)) div 2) ),
                      (g_FScreenHeight - 89), clYellow, clBlack, IntToStr(g_AutoPotItems[1].Amount));
            Font.Size := 9;
          end;
          Release;
        end;
      end;

      Idx := 0;
      case g_MyHero.m_btSex of
        0:
          case g_MyHero.m_btJob of
            0: Idx := 1400;
            1: Idx := 1401;
            2: Idx := 1402;
            3: Idx := 1403;
            4: Idx := 1404;
          end;
        1:
          case g_MyHero.m_btJob of
            0: Idx := 1410;
            1: Idx := 1411;
            2: Idx := 1412;
            3: Idx := 1413;
            4: Idx := 1414;
          end;
      end;
      if Idx > 0 then begin
        if g_MyHero.m_btLimitLevel > 0 then begin
          d := g_WMainImages.Images[Idx + 350];
        end else
        d := g_WMainImages.Images[Idx];
        if d <> nil then begin
          if g_MyHero.m_boDeath then begin
            d := g_WMainImages.Images[1379];
          end;
          dsurface.Draw( 109 , g_FScreenHeight - 82, d.ClientRect, d, True);
        end;
      end;

      d := g_WMainImages.Images[10];
        if d <> nil then
          dsurface.Draw( 122 , g_FScreenHeight - 41, d.ClientRect, d, True);

      d := g_WMainImages.Images[11];
        if d <> nil then
          dsurface.Draw( 154 , g_FScreenHeight - 76, d.ClientRect, d, True);


      d := g_WMainImages.Images[1951]; //¿µ¿õHP
      if d <> nil then begin
        rc := d.ClientRect;
        if g_MyHero.m_Abil.MaxHP > 0 then
          rc.Right := Round(rc.Right / g_MyHero.m_Abil.MaxHP * g_MyHero.m_Abil.HP);
        dsurface.Draw( 172, g_FScreenHeight - 70, rc, d, True);
      end;

      d := g_WMainImages.Images[1952]; //¿µ¿õMP
      if d <> nil then begin
        rc := d.ClientRect;
        if g_MyHero.m_Abil.MaxMP > 0 then
          rc.Right := Round(rc.Right / g_MyHero.m_Abil.MaxMP * g_MyHero.m_Abil.MP);
        dsurface.Draw(172,g_FScreenHeight - 58, rc, d, True);
      end;

      if g_MyHero.m_btLimitLevel > 0 then begin
        h := g_WMainImages.Images[1358];
        if h <> nil then begin
          dsurface.Draw( 126 , g_FScreenHeight - 45, h.ClientRect, h, True);
        end;
      end else
       h := nil;
       
      if g_MyHero.m_btLimitLevel <= 0 then begin
        d := g_WMainImages.Images[1953]; //¿µ¿õEXP
        if d <> nil then begin
          rc := d.ClientRect;
          if g_MyHero.m_Abil.MaxExp > 0 then
            rc.Right := Round(rc.Right / g_MyHero.m_Abil.MaxExp * g_MyHero.m_Abil.Exp);
          dsurface.Draw(172, g_FScreenHeight - 44, rc, d, True);
        end;
      end;
      with dsurface.Canvas do begin
        SetBkMode(handle, TRANSPARENT);
        Font.Size := 9;
        BoldTextOut (dsurface, 171 - TextWidth(g_MyHero.m_sUserName) div 2, g_FScreenHeight - 24, clWhite, clBlack, g_MyHero.m_sUserName);
        Font.Size := 8;
        BoldTextOut (dsurface, 135 - TextWidth(IntToStr(g_MyHero.m_Abil.Level)) div 2, g_FScreenHeight - 39, clWhite, clBlack, IntToStr(g_MyHero.m_Abil.Level));

        BoldTextOut (dsurface, 170,g_FScreenHeight - 71, clWhite, clBlack, IntToStr(g_MyHero.m_Abil.HP) + '/' + IntToStr(g_MyHero.m_Abil.MaxHP));
        BoldTextOut (dsurface, 170,g_FScreenHeight - 58, clWhite, clBlack, IntToStr(g_MyHero.m_Abil.MP) + '/' + IntToStr(g_MyHero.m_Abil.MaxMP));
        if g_MyHero.m_btLimitLevel > 0 then begin
          str2 := 'ÏÞÖÆ' + IntToStr(g_MyHero.m_btLimitLevel) + '½×¶Î';
          BoldTextOut (dsurface, 170,g_FScreenHeight - 46, clWhite, clBlack, str2);
        end else begin
          if g_MyHero.m_Abil.MaxExp > 0 then
            BoldTextOut (dsurface, 170,g_FScreenHeight - 45, clWhite, clBlack, FormatFloat('0.00%', ( g_MyHero.m_Abil.Exp / g_MyHero.m_Abil.MaxExp) * 100 ));
        end;
        Font.Size := 9;
        Release;
      end;
   end;


   with DScreen do begin
        if g_boHPView then begin
          if (g_Myself.m_Abil.Level < 26) and (g_Myself.m_btJob = 0) then begin
           SetBKMode(Dsurface.Canvas.Handle, TRANSPARENT);
           BoldTextOut (dsurface,12,btop+65,clwhite, clblack, 'HP(' + IntToStr(g_Myself.m_Abil.HP) + '/' + IntToStr(g_Myself.m_Abil.MaxHP) + ')');
           Dsurface.Canvas.Release;
          end else begin
           SetBKMode(Dsurface.Canvas.Handle, TRANSPARENT);
           BoldTextOut (dsurface,12,btop+58,clwhite, clblack, 'HP(' + IntToStr(g_Myself.m_Abil.HP) + '/' + IntToStr(g_Myself.m_Abil.MaxHP) + ')');
           BoldTextOut (dsurface,12,btop+73,clwhite, clblack, 'MP(' + IntToStr(g_Myself.m_Abil.MP) + '/' + IntToStr(g_Myself.m_Abil.MaxMP) + ')');
           Dsurface.Canvas.Release;
          end;
        end else begin
          if (g_Myself.m_Abil.Level < 26) and (g_Myself.m_btJob = 0) then begin
           SetBKMode(Dsurface.Canvas.Handle, TRANSPARENT);
           BoldTextOut (dsurface,37,btop+52,clwhite, clblack, IntToStr(g_Myself.m_Abil.HP));
           BoldTextOut (dsurface,32,btop+62,clwhite, clblack, '-----');
           BoldTextOut (dsurface,37,btop+72,clwhite, clblack, IntToStr(g_Myself.m_Abil.MaxHP));
           Dsurface.Canvas.Release;
          end else begin
           SetBKMode(Dsurface.Canvas.Handle, TRANSPARENT);
           BoldTextOut (dsurface,20,btop+52,clwhite, clblack, IntToStr(g_Myself.m_Abil.HP));
           BoldTextOut (dsurface,17,btop+61,clwhite, clblack, '-----');
           BoldTextOut (dsurface,20,btop+71,clwhite, clblack, IntToStr(g_Myself.m_Abil.MaxHP));
           BoldTextOut (dsurface,58,btop+52,clwhite, clblack, IntToStr(g_Myself.m_Abil.MP));
           BoldTextOut (dsurface,51,btop+61,clwhite, clblack, '-----');
           BoldTextOut (dsurface,58,btop+71,clwhite, clblack, IntToStr(g_Myself.m_Abil.MaxMP));
           Dsurface.Canvas.Release;
          end;
        end;
     end;


   dsurface.Canvas.Release;
   if (GetTickCount - g_dwEatOpTime > 300) then begin    //¹°¾à
     if g_EatOp then g_EatOp := False;
   end;
   if (GetTickCount - g_dwEatHeroOpTime > 300) then begin    //¹°¾à
     if g_EatHeroOp then g_EatHeroOp := False;
   end;
  DBtCheck1.Visible := g_QuestMsgList.Count > 0;
  DBtCheck2.Visible := g_QuestMsgList.Count > 1;
  DBtCheck3.Visible := g_QuestMsgList.Count > 2;
  DBtCheck4.Visible := g_QuestMsgList.Count > 3;
  DBtCheck5.Visible := g_QuestMsgList.Count > 4;
  DBtCheck6.Visible := g_QuestMsgList.Count > 5;
  DBtCheck7.Visible := g_QuestMsgList.Count > 6;
  DBtCheck8.Visible := g_QuestMsgList.Count > 7;
  DBtCheck9.Visible := g_QuestMsgList.Count > 8;
  DBtCheck10.Visible := g_QuestMsgList.Count > 9;
end;

{--------------------------------------------------------------}

procedure TFrmDlg.DBottomInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var                                             //ÀÎÅÍÆäÀÌ½º DBottom ºÎºÐ
   d , g: TDirectDrawSurface;
begin
  if g_FScreenWidth = 800 then begin
    d := g_WMainImages.Images[BOTTOMBOARD800];
  end else begin
    d := g_WAresImages.Images[BOTTOMBOARD1024];
  end;
  if d <> nil then begin
    if d.Pixels[X, Y] > 0 then IsRealArea := TRUE
    else IsRealArea := FALSE;
  end;
end;

procedure TFrmDlg.DMyStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex + 2];
      end else
      if d.MouseMoveing then begin
         dd := d.WLib.Images[d.FaceIndex + 1];
      end else begin
         dd := d.WLib.Images[d.FaceIndex];
      end;
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);

   end;
end;

procedure TFrmDlg.DBotGroupDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         if not d.DontDrawUp then dd := d.WLib.Images[d.FaceIndex+1]
         else  dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end
      else if not d.DontDrawUp then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DBotPlusAbilDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex + 2];
      end else
      if d.MouseMoveing then begin
         dd := d.WLib.Images[d.FaceIndex + 1]
      end else begin
         dd := d.WLib.Images[d.FaceIndex];
      end;
      
      if dd <> nil then
         dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
   end;
end;

procedure TFrmDlg.DMyStateClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMyState then begin
      StatePage := 0;
      OpenMyStatus;
   end;
   if Sender = DMyBag then OpenItemBag;
   if Sender = DMyMagic then begin
      StatePage := 3;
      OpenMyStatus;
   end;
   if Sender = DOption then DOptionClick;
end;
     //¿É¼ÇÃ¢
procedure TFrmDlg.DOptionClick();
begin
  if DOptions.Visible = false then begin
    // ½ºÅ³º¯°æ                                //¸Þ½ÃÁö Ã¢
    if g_boSkillSetting then begin
      DOptionsSkillMode1.SetImgIndex (g_WMain2Images, 452);
      DOptionsSkillMode2.SetImgIndex (g_WMain2Images, 453);
    end else begin
      DOptionsSkillMode1.SetImgIndex (g_WMain2Images, 450);
      DOptionsSkillMode2.SetImgIndex (g_WMain2Images, 455);
    end;
    // ½ºÅ³¹Ù
    if DSkillBar.Visible then begin
      DOptionsSkillBarOn.SetImgIndex (g_WMain2Images, 458);
      DOptionsSkillBarOff.SetImgIndex (g_WMain2Images, 469);
    end else begin
      DOptionsSkillBarOn.SetImgIndex (g_WMain2Images, 456);
      DOptionsSkillBarOff.SetImgIndex (g_WMain2Images, 461);
    end;
    //È¿°úÅ°
    if g_boEffect then begin
      DOptionsEffectOn.SetImgIndex (g_WMain2Images, 458);
      DOptionsEffectOff.SetImgIndex (g_WMain2Images, 459);
    end else begin
      DOptionsEffectOn.SetImgIndex (g_WMain2Images, 456);
      DOptionsEffectOff.SetImgIndex (g_WMain2Images, 461);
    end;
    //À½Çâ È¿°ú Å°
    if g_boSound then begin
      DOptionsSoundOn.SetImgIndex (g_WMain2Images, 468);
    end else begin
      DOptionsSoundOn.SetImgIndex (g_WMain2Images, 468);
    end;

    if g_boBGSound then begin
      DOptionsMp3On.SetImgIndex (g_WMain2Images, 468);
    end else begin
      DOptionsMp3On.SetImgIndex (g_WMain2Images, 468);
    end;

    // ¾ÆÀÌÅÛ ÁÝ±â Å°
    if g_boShowAllItem then begin
      DOptionsDropViewOn.SetImgIndex (g_WMain2Images, 458);
      DOptionsDropViewOff.SetImgIndex (g_WMain2Images, 459);
    end else begin
      DOptionsDropViewOn.SetImgIndex (g_WMain2Images, 456);
      DOptionsDropViewOff.SetImgIndex (g_WMain2Images, 461);
    end;
    // Ä³¸¯ÅÍ ÀÌ¸§
    if g_boNameAllView then begin
      DOptionsNameAllViewOn.SetImgIndex (g_WMain2Images, 458);
      DOptionsNameAllViewOff.SetImgIndex (g_WMain2Images, 459);
      if g_boNameChNpView then DNameChNP.SetImgIndex (g_WMain2Images, 458)
      else DNameChNP.SetImgIndex (g_WMain2Images, 459);
      if g_boNameMonView then  DNameMon.SetImgIndex (g_WMain2Images, 458)
      else DNameMon.SetImgIndex (g_WMain2Images, 459);
    end else begin
      DOptionsNameAllViewOn.SetImgIndex (g_WMain2Images, 456);
      DOptionsNameAllViewOff.SetImgIndex (g_WMain2Images, 461);
      DNameChNP.SetImgIndex (g_WMain2Images, 459);
      DNameMon.SetImgIndex (g_WMain2Images, 459);
    end;
    if g_boHPView then begin
      DOptionsHPView1.SetImgIndex (g_WMain2Images, 464);
      DOptionsHPView2.SetImgIndex (g_WMain2Images, 465);
    end else begin
      DOptionsHPView1.SetImgIndex (g_WMain2Images, 462);
      DOptionsHPView2.SetImgIndex (g_WMain2Images, 467);
    end;
    if g_boNameChNpView then begin
      DNameChNP.SetImgIndex (g_WMain2Images, 458);
    end else begin
      DNameChNP.SetImgIndex (g_WMain2Images, 459);
    end;
    if g_boNameMonView then begin
      DNameMon.SetImgIndex (g_WMain2Images, 458);
    end else begin
      DNameMon.SetImgIndex (g_WMain2Images, 459);
    end;

    if g_boFullScreen2 then begin
      DOptionsFull.SetImgIndex (g_WMain2Images, 458);
      DOptionsWin.SetImgIndex (g_WMain2Images, 459);
    end else begin
      DOptionsFull.SetImgIndex (g_WMain2Images, 456);
      DOptionsWin.SetImgIndex (g_WMain2Images, 461);
    end;
    if g_bobuttHint then begin
      DOptionsHintOn.SetImgIndex (g_WMain2Images, 458);
      DOptionsHintOff.SetImgIndex (g_WMain2Images, 459);
    end else begin
      DOptionsHintOn.SetImgIndex (g_WMain2Images, 456);
      DOptionsHintOff.SetImgIndex (g_WMain2Images, 461);
    end;
    if g_FScreenMode2 = 0 then begin
      DOptionsScreen1.SetImgIndex (g_WMain2Images, 464);
      DOptionsScreen2.SetImgIndex (g_WMain2Images, 465);
    end else begin
      DOptionsScreen1.SetImgIndex (g_WMain2Images, 462);
      DOptionsScreen2.SetImgIndex (g_WMain2Images, 467);
    end;
    // centre the window and move it above the bottom bar
    DOptions.Left := (g_FScreenWidth div 2) - ((DOptions.Width) div 2);
    DOptions.Top := (g_FScreenHeight div 2) - ((DOptions.Height) div 2) - 65;
  end;
  DOptions.Visible := not DOptions.Visible;
end;

{------------------------------------------------------------------------}


{------------------------------------------------------------------------}

procedure TFrmDlg.DBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   idx, nInt: integer;
   d: TDirectDrawSurface;
   e: TDirectDrawSurface;
   showstr: String;
begin
   with Sender as TDButton do begin
      idx := Tag;
      if idx in [0..5] then begin

         if g_ItemArr[idx].S.Name <> '' then begin
            d := g_WBagItemImages.Images[g_ItemArr[idx].S.Looks];
            if d <> nil then begin
              dsurface.Draw (SurfaceX(Left+(Width-d.Width) div 2), SurfaceY(Top+(Height-d.Height) div 2), d.ClientRect, d, TRUE);
              if (g_ItemArr[idx].Amount > 0) and (g_ItemArr[idx].S.StdMode in [0,1,3,45,46]) then begin      //¹°¾à
                nInt := (g_ItemArr[idx].Amount);
                with dsurface.Canvas do begin
                  SetBKMode(Handle, TRANSPARENT);
                  showstr := IntToStr(nInt);
                  TextOutA (dsurface, SurfaceX(Left -(TextWidth(showstr) div 2) + 18), SurfaceY(Top + 18), clYellow, showstr);
                  Release;
                end;
              end;
              if ((g_ItemArr[idx].Dura div 10) > 0) and (g_ItemArr[idx].S.StdMode in [25]) then begin      //¹°¾à
                nInt := (g_ItemArr[idx].Dura div 10);
                with dsurface.Canvas do begin
                  SetBKMode(Handle, TRANSPARENT);
                  showstr := IntToStr(nInt);
                  TextOutA (dsurface, SurfaceX(Left - (TextWidth(showstr) div 2) + 18), SurfaceY(Top + 18), clYellow, showstr);
                  Release;
                end;
              end;
            end;
         end;

      end;
      with Sender do begin
       with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Size := 8;
         Font.Color := clWhite;
          if g_boVerticalBelt then begin
            TextOut (SurfaceX(Left + 1), SurfaceY(Top + 1), IntToStr(idx+1));
          end else
            TextOut (SurfaceX(Left + 1), SurfaceY(Top + 1), IntToStr(idx+1));
         Font.Size := 9;
         Release;
        end;
      end;
   end;
end;

procedure TFrmDlg.DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   idx: integer;
   nLocalX,nLocalY:Integer;
   nHintX,nHintY:Integer;                       //º§Æ® ÀÌ¸§ Å×µÎ¸® »ö
   Butt:TDButton;
begin
   idx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   if idx in [0..5] then begin
     if g_ItemArr[idx].S.Name <> '' then begin
       g_MouseItem := g_ItemArr[idx];
       GetMouseItemHint(g_MySelf, @g_MouseItem);
       if HintList.Count > 0 then begin
         nLocalX:=Butt.LocalX(X - Butt.Left);
         nLocalY:=Butt.LocalY(Y - Butt.Top);
         nHintX:=Butt.SurfaceX(Butt.Left) + DBeltWindow.SurfaceX(DBeltWindow.Left) + nLocalX;
         nHintY:=Butt.SurfaceY(Butt.Top) + DBeltWindow.SurfaceY(DBeltWindow.Top) + nLocalY;
         with Sender as TDButton do
          DScreen.ShowHintB(nHintX, nHintY, HintList, True);
       end;
      end;
     g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DBelt1Click(Sender: TObject; X, Y: Integer);
var
   idx,mi: integer;
   temp: TClientItem;
begin
   idx := TDButton(Sender).Tag;
   if idx in [0..5] then begin
      if not g_boItemMoving then begin
         if (g_ItemArr[idx].S.Name <> '') and ((GetTickCount - LastBeltDoubleClick) > 500) then begin
            ItemClickSound (g_ItemArr[idx].S);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := idx;
            MoveingItemIndex := idx;
            g_MovingItem.Item := g_ItemArr[idx];
            g_ItemArr[idx].S.Name := '';
            g_MovingItem.Owner := DItemBag;
         end;
      end else begin
         MoveingItemIndex := -1;
         if (g_MovingItem.Owner = DHeroStateWin) then Exit;
         if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
            (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;

          if g_MovingItem.Index >= 500 then   //¿©°ü¿¡¼­ º§Æ®·Î
            CancelItemMoving;
          if (g_MovingItem.Index <= -26) and (g_MovingItem.Index > -36) then  //±³È¯Ã¢¿¡¼­ º§Æ®·Î
            DealItemReturnBag2 (g_MovingItem.Item);          //°Å·¡
          if (g_MovingItem.Index = -36) then     //´ë¿©Ã¢¿¡¼­ º§Æ®·Î
             RentalItemReturnBag (g_MovingItem.Item);
          if g_MovingItem.Index = -52 then
             n_ActionPrice := 0;
             
         if (g_MovingItem.Owner <> DHeroItemBag) then begin
            if g_ItemArr[idx].S.Name <> '' then begin
               if CheckItemMode(g_MovingItem.Item,g_ItemArr[idx]) then begin    //¹°¾à
                 FrmMain.BundleItem(g_MovingItem.Item.S.StdMode,g_ItemArr[idx].S.MaxAmount,inttostr(g_MovingItem.Item.MakeIndex)+'/'+inttostr(g_ItemArr[idx].MakeIndex));
                 if ((g_MovingItem.Item.S.StdMode in [0,1,3,45,46]) and ((g_MovingItem.Item.Amount + g_ItemArr[idx].Amount) <= g_ItemArr[idx].S.MaxAmount)) then begin
                   g_MovingItem.Item.S.Name := '';
                 end else begin
                   AddItemBag (g_MovingItem.Item);
                   g_MovingItem.Item.S.Name := '';
                 end;
                 g_boItemMoving := FALSE;
               end else begin
                 temp := g_ItemArr[idx];
                 g_ItemArr[idx] := g_MovingItem.Item;
                 g_MovingItem.Index := idx;
                 g_MovingItem.Item := temp;
                 g_MovingItem.Owner := DItemBag;
               end;
            end else begin
              mi := g_MovingItem.Index;
              if (mi < 0) and (mi >= -25 {-9}) then begin
              //»óÅÂÃ¢¿¡¼­ º§Æ®·Î
                g_WaitingUseItem := g_MovingItem;
                FrmMain.SendTakeOffItem (-(g_MovingItem.Index+1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
                g_MovingItem.Item.S.name := '';
                g_MovingItem.Owner := nil;
                g_boItemMoving := FALSE;
              end else begin
                g_ItemArr[idx] := g_MovingItem.Item;
                g_MovingItem.Item.S.name := '';
                g_MovingItem.Owner := nil;
                g_boItemMoving := FALSE;
              end;
            end;
         end;
         if (g_MovingItem.Owner = DHeroItemBag) then begin //¿µ¿õ > ÁÖÀÎ º§Æ®·Î
           frmMain.SendItemToMasterBag((g_MovingItem.Index), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.s.Name);     //¿µ¿õ > ÁÖÀÎ º§Æ®·Î
           g_WaitingUseItem := g_MovingItem;
           g_MovingItem.Item.s.Name := '';
           g_boItemMoving := False;
           g_MovingItem.Owner := nil;
         end;
      end;
   end;
end;

procedure TFrmDlg.DBelt1DblClick(Sender: TObject);
var
   idx, where: integer;
   TempSender: TObject;
begin
   LastBeltDoubleClick := GetTickCount;
   idx := TDButton(Sender).Tag;
   if idx in [0..5] then begin
      if g_ItemArr[idx].S.Name <> '' then begin
         if (g_ItemArr[idx].S.StdMode <= 4) or (g_ItemArr[idx].S.StdMode = 31) or (g_ItemArr[idx].S.StdMode in [8,9,14,18]) then begin
            if (GetTickCount - BeltchekClick) > 400 then begin  //¹°¾à
                FrmMain.EatItem (idx);
            end;                              //¹°¾à
         end;
      end else begin
         if g_boItemMoving and (g_MovingItem.Index = idx) and
           (g_MovingItem.Item.S.StdMode <= 4) or (g_MovingItem.Item.S.StdMode = 31) or
            (g_ItemArr[idx].S.StdMode in [8,9,14,18]) or (g_MovingItem.Item.S.StdMode = 25)
         then begin
            if g_MovingItem.Item.S.StdMode = 25 then begin
                  where := GetTakeOnPosition (g_MovingItem.Item.S.StdMode);
                  if g_MovingItem.Index >= 0 then begin
                     case where of
                        U_ARMRINGR, U_BUJUK: begin
                           TempSender := DSWBujuk;
                        end;
                     end;
                  end;
                  DSWWeaponClick(TempSender, 1, 1);
                  Exit;
            end;
            FrmMain.EatItem (-1);
         end;
      end;
   end;
end;



procedure TFrmDlg.SwapBujuk(idx: integer);    //ºÎÀû
var
   where: integer;
   TempSender: TObject;
   i : Integer;
begin
   if g_ItemArr[idx].S.StdMode <> 25 then Exit;

   g_WaitingUseItem.Item := g_ItemArr[idx];
   g_WaitingUseItem.Index := U_BUJUK;
   FrmMain.SendTakeOnItem (U_BUJUK, g_ItemArr[idx].MakeIndex, g_ItemArr[idx].S.Name);
   g_ItemArr[idx].S.Name := '';
end;


procedure TFrmDlg.GetMouseItemHint(Actor: TActor; MouseItem: pTClientItem);

  procedure AddBoardString (str, NameColor: string);
  var
   i, len, aline, n: integer;
   temp: string;
   loop: Boolean;
  const
    MAXWIDTH = 319;
  begin
    n := 0;
    loop := TRUE;
    while loop do begin
      temp := '';
      i := 1;
      len := Length (str);
      while TRUE do begin
         if i > len then begin
            loop := FALSE;
            break;
         end;
         if byte (str[i]) >= 128 then begin
            temp := temp + str[i];
            Inc (i);
            if i <= len then temp := temp + str[i]
            else begin
               loop := FALSE;
               break;
            end;
         end else
            temp := temp + str[i];

         aline := FrmMain.Canvas.TextWidth (temp);
         if aline > MAXWIDTH then begin
            HintList.AddObject('<CO' + NameColor + '>' + temp + '<CE>', TObject(GetRGB(248)));
            Inc (n);
            str := Copy (str, i+1, Len-i);
            temp := '';
            break;
         end;
         Inc (i);
      end;
      if temp <> '' then begin
         if n < MAXWIDTH then begin
            HintList.AddObject('<CO' + NameColor + '>' + temp + '<CE>', TObject(GetRGB(248)));
         end;
      end;
    end;
  end;
  function GetJPBtStr(Mode,Minus: Byte): string;
  begin
    Result := '';
    if MouseItem.S.btValue[Mode] > 0 then begin
      if Minus > 1 then begin
        if Minus = 3 then
          Result := '     <CO$FF>[-' + IntToStr(MouseItem.S.btValue[Mode]) + ']<CE>'
        else
        Result := '     <CO$FF00>[+' + IntToStr(MouseItem.S.btValue[Mode] - 10) + ']<CE>';
      end else begin
        if Minus > 0 then
          Result := '     <CO$FF>[+' + IntToStr(MouseItem.S.btValue[Mode]) + ']<CE>'
        else
        Result := '     <CO$FF00>[+' + IntToStr(MouseItem.S.btValue[Mode]) + ']<CE>';
      end;
    end;
  end;
  function GetJPBtStr2(Mode,Minus: Byte): string;
  begin
    Result := '';
    if MouseItem.S.btValue[Mode] > 0 then begin
      if Minus > 0 then
        Result := '     <CO$FF>[+' + IntToStr(MouseItem.S.btValue[Mode]) + '0%]<CE>'
      else
      Result := '     <CO$FF00>[+' + IntToStr(MouseItem.S.btValue[Mode]) + '0%]<CE>';
    end;
  end;
  function GetDuraStr(Dura, maxdura: Integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(Dura / 1000)) + '/' + IntToStr(Round(maxdura / 1000))
    else
      Result := IntToStr(Round(Dura / 1000));
  end;
  function GetDura100Str(Dura, maxdura: Integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(Dura / 100)) + '/' + IntToStr(Round(maxdura / 100))
    else
      Result := IntToStr(Round(Dura / 100));
  end;
  function GetDura10Str (dura, maxdura: integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(dura/10)) + '/' + IntToStr(Round(maxdura/10))
    else
      Result := IntToStr(Round(dura/10));
  end;
  function GetDura1Str (dura, maxdura: integer): string;
  begin
    if not BoNoDisplayMaxDura then
      Result := IntToStr(Round(dura)) + '/' + IntToStr(Round(maxdura))
    else
      Result := IntToStr(Round(dura));
  end;
var
  sTemp, sTemp1, sDescr, sTemp2: string;
  I,k,j,g,h,z, nSUM: Integer;
  dwExp, dwMaxExp: LongWord;
  sItemDesc: string;
  useable, UseLevel, Jobuseable :Boolean;
  sItemName, sUPC, sUP, sComName: string;
  ItemColor :TColor;
  sNameColor: string;
  line2: string;
  SetItem: pTSetItems;
  boOK: Boolean;
  MySex: Byte;
  ShowString: string;
begin
  HintList.Clear;
  line2 := ''; nSUM := 0;
  useable := True;
  Jobuseable := True;
  UseLevel := True;
  sComName := '';
  ShowString := '';
  z := 0;
  if (Actor = nil) or (MouseItem.s.Name = '') then Exit;
  MySex := Actor.m_btSex;

  sItemName := FilterShowName(MouseItem.S, MouseItem.s.Name);

  if MouseItem.s.Name <> '' then begin
    if (MouseItem.S.StdMode in [5,6,7,90,99,10,11,12,15,19,20,21,22,23,24,26,46,62,63,64,101,102]) then begin
      if (MouseItem.Amount > 0) and (MouseItem.S.boCompound) then begin
        case MouseItem.Amount of
          2 : sComName := '<CO$' + string(IntToHex(GetRGB(g_CompoundSet.Color[1]), 6)) + '>+' + IntToStr(MouseItem.Amount - 1) + '<CE> ';    //DE7B00
          3 : sComName := '<CO$' + string(IntToHex(GetRGB(g_CompoundSet.Color[2]), 6)) + '>+' + IntToStr(MouseItem.Amount - 1) + '<CE> ';
          4 : sComName := '<CO$' + string(IntToHex(GetRGB(g_CompoundSet.Color[3]), 6)) + '>+' + IntToStr(MouseItem.Amount - 1) + '<CE> ';
          5 : sComName := '<CO$' + string(IntToHex(GetRGB(g_CompoundSet.Color[4]), 6)) + '>+' + IntToStr(MouseItem.Amount - 1) + '<CE> ';
        end;
        sItemName := sComName + sItemName;
      end;
      if MouseItem.S.Grade in [0,1] then begin
        if MouseItem.s.btValue[19] > 2 then        //ºÀÀÎ
          HintList.AddObject(sItemName + '<CO$FF> - ºÀÀÎ<CE>' , TObject(clYellow))
        else
        HintList.AddObject(sItemName, TObject(clYellow));
        HintList.AddObject('Ò»°ã', TObject(clWhite));
        ItemColor := clWhite;
      end;
      if MouseItem.S.Grade = 2 then begin
        if MouseItem.s.btValue[19] > 2 then        //ºÀÀÎ
          HintList.AddObject(sItemName + '<CO$FF> - ºÀÀÎ<CE>' , TObject(TColor($00FFDF42)))
        else
        HintList.AddObject(sItemName, TObject(TColor($00FFDF42)));
        HintList.AddObject('±¦Îï', TObject(TColor($00FFDF42)));
        ItemColor := TColor($00FFDF42);
      end;
      if MouseItem.S.Grade = 3 then begin
        if MouseItem.s.btValue[19] > 2 then        //ºÀÀÎ
          HintList.AddObject(sItemName + '<CO$FF> - ºÀÀÎ<CE>' , TObject(TColor($000075FF)))
        else
        HintList.AddObject(sItemName, TObject(TColor($000075FF)));
        HintList.AddObject('Ê¥Îï', TObject(TColor($000075FF)));
        ItemColor := TColor($000075FF);
      end;
      if MouseItem.S.Grade = 4 then begin
        if MouseItem.s.btValue[19] > 2 then        //ºÀÀÎ
          HintList.AddObject(sItemName + '<CO$FF> - ·âÓ¡<CE>' , TObject(TColor($00FFAADE)))
        else
        HintList.AddObject(sItemName, TObject(TColor($00FFAADE)));
        HintList.AddObject('ÉñÎï', TObject(TColor($00FFAADE)));
        ItemColor := TColor($00FFAADE);
      end;
    end else begin
      if MouseItem.s.btValue[19] > 2 then        //ºÀÀÎ
        HintList.AddObject(sItemName + '<CO$FF> - ºÀÀÎ<CE>' , TObject(clYellow))
      else
      HintList.AddObject(sItemName, TObject(clYellow));
    end;

    if MouseItem.s.btValue[19] = 1 then begin        //´ë¿©
      if HintList.Count > 0 then HintList.Delete(0);
        HintList.InsertObject(0, '<CO$2D401>' + sItemName + '<CE> - ×âÁÞ' , TObject(clWhite));
    end;

    case MouseItem.s.StdMode of
      14: begin  //ºÀÀÎÁÖ
        if HintList.Count > 0 then HintList.Delete(0);
        HintList.InsertObject(0, 'Ó¢ÐÛÐÅÏ¢' , TObject(clYellow));
        HintList.AddObject('¡¡',TObject(GetRGB(248)));
        HintList.AddObject('Ãû×Ö: ' + MouseItem.S.Name + '    ÐÔ±ð: ' + GetSexName(MouseItem.S.btValue[0]) + 'ÀÚ', TObject(clWhite));
        HintList.AddObject('µÈ¼¶: ' + IntToStr(MouseItem.S.btValue[1]) + '       Ö°Òµ: ' + GetJobName(MouseItem.S.btValue[2]), TObject(clWhite));
        HintList.AddObject('×ÊÖÊ: ' + GetHeroGradeName(MouseItem.S.btValue[4]), TObject(clWhite));

        if MouseItem.S.btValue[5] > 0 then begin
          HintList.AddObject('µÈ¼¶ÏÞÖÆ×´Ì¬: ' + IntTOsTR(MouseItem.S.btValue[5]) + '½×¶Î', TObject(clWhite));
        end else
          HintList.AddObject('µÈ¼¶ÏÞÖÆ×´Ì¬: ' + '½âËø', TObject(clWhite));
        HintList.AddObject('¡¡',TObject(GetRGB(248)));
        HintList.AddObject('Ñ§Ï°¼¼ÄÜ: [' + IntToStr(MouseItem.S.btValue[3]) + ']', TObject(clWhite));
        if MouseItem.S.btValue[2] = 0 then begin
          if MouseItem.S.btValue[6] > 0 then
          HintList.AddObject('»ù±¾½£Êõ(Lv' + IntToStr(MouseItem.S.btValue[6]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[7] > 0 then
          HintList.AddObject('¹¥É±½£Êõ(Lv' + IntToStr(MouseItem.S.btValue[7]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[8] > 0 then
          HintList.AddObject('´ÌÉ±½£Êõ(Lv' + IntToStr(MouseItem.S.btValue[8]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[9] > 0 then
          HintList.AddObject('°ëÔÂÍäµ¶(Lv' + IntToStr(MouseItem.S.btValue[9]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[10] > 0 then
          HintList.AddObject('ÁÒ»ð½£·¨(Lv' + IntToStr(MouseItem.S.btValue[10]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[12] > 0 then
          HintList.AddObject('Ë«ÁúÕ¶(Lv' + IntToStr(MouseItem.S.btValue[12]-1) + ')', TObject(clWhite));
        end;
        if MouseItem.S.btValue[2] = 1 then begin
          if MouseItem.S.btValue[6] > 0 then
          HintList.AddObject('»ðÇòÊõ(Lv' + IntToStr(MouseItem.S.btValue[6]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[7] > 0 then
          HintList.AddObject('´ó»ðÇò(Lv' + IntToStr(MouseItem.S.btValue[7]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[8] > 0 then
          HintList.AddObject('µØÓü»ð(Lv' + IntToStr(MouseItem.S.btValue[8]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[9] > 0 then
          HintList.AddObject('¼²¹âµçÓ°(Lv' + IntToStr(MouseItem.S.btValue[9]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[10] > 0 then
          HintList.AddObject('À×µçÊõ(Lv' + IntToStr(MouseItem.S.btValue[10]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[12] > 0 then
          HintList.AddObject('»ðÇ½(Lv' + IntToStr(MouseItem.S.btValue[12]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[13] > 0 then
          HintList.AddObject('±¬ÁÑ»ðÑæ(Lv' + IntToStr(MouseItem.S.btValue[13]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[14] > 0 then
          HintList.AddObject('µØÓüÀ×¹â(Lv' + IntToStr(MouseItem.S.btValue[14]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[15] > 0 then
          HintList.AddObject('Ä§·¨¶Ü(Lv' + IntToStr(MouseItem.S.btValue[15]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[16] > 0 then
          HintList.AddObject('Ê¥ÑÔÊõ(Lv' + IntToStr(MouseItem.S.btValue[16]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[17] > 0 then
          HintList.AddObject('±ùÅØÏø(Lv' + IntToStr(MouseItem.S.btValue[17]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[18] > 0 then
          HintList.AddObject('ÊÉÑªÊõ(Lv' + IntToStr(MouseItem.S.btValue[18]-1) + ')', TObject(clWhite));
        end;
        if MouseItem.S.btValue[2] = 2 then begin
          if MouseItem.S.btValue[6] > 0 then
          HintList.AddObject('ÖÎÓúÊõ(Lv' + IntToStr(MouseItem.S.btValue[6]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[7] > 0 then
          HintList.AddObject('¾«ÉñÁ¦Õ½·¨(Lv' + IntToStr(MouseItem.S.btValue[7]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[8] > 0 then
          HintList.AddObject('Ê©¶¾Êõ(Lv' + IntToStr(MouseItem.S.btValue[8]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[9] > 0 then
          HintList.AddObject('Áé»ê»ð·û(Lv' + IntToStr(MouseItem.S.btValue[9]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[10] > 0 then
          HintList.AddObject('ÓÄÁé¶Ü(Lv' + IntToStr(MouseItem.S.btValue[10]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[12] > 0 then
          HintList.AddObject('ÉñÊ¥Õ½¼×Êõ(Lv' + IntToStr(MouseItem.S.btValue[12]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[13] > 0 then
          HintList.AddObject('ÐÄÁéÆôÊ¾(Lv' + IntToStr(MouseItem.S.btValue[13]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[14] > 0 then
          HintList.AddObject('ÈºÌåÖÎÁÆÊõ(Lv' + IntToStr(MouseItem.S.btValue[14]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[15] > 0 then
          HintList.AddObject('ÎÞ¼«ÕæÆø(Lv' + IntToStr(MouseItem.S.btValue[15]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[16] > 0 then
          HintList.AddObject('¾»»¯Êõ(Lv' + IntToStr(MouseItem.S.btValue[16]-1) + ')', TObject(clWhite));
        end;
        if MouseItem.S.btValue[2] = 3 then begin
          if MouseItem.S.btValue[6] > 0 then
          HintList.AddObject('¾øÃü½£·¨(Lv' + IntToStr(MouseItem.S.btValue[6]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[7] > 0 then
          HintList.AddObject('·ç½£Êõ(Lv' + IntToStr(MouseItem.S.btValue[7]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[8] > 0 then
          HintList.AddObject('ÌåÑ¸·ç(Lv' + IntToStr(MouseItem.S.btValue[8]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[9] > 0 then
          HintList.AddObject('Ç¨ÒÆ½£(Lv' + IntToStr(MouseItem.S.btValue[9]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[10] > 0 then
          HintList.AddObject('·çÉíÊõ(Lv' + IntToStr(MouseItem.S.btValue[10]-1) + ')', TObject(clWhite));
          if MouseItem.S.btValue[12] > 0 then
          HintList.AddObject('ÃÍ¶¾½£Æø(Lv' + IntToStr(MouseItem.S.btValue[12]-1) + ')', TObject(clWhite));
        end;
      end;

      0: begin //¹°¾à
          case MouseItem.S.Shape of
            0: HintList.AddObject('³ÖÐø»Ö¸´', TObject(clWhite));
            1, 3, 4: HintList.AddObject('Ë²Ê±»Ö¸´', TObject(clWhite));
            6: HintList.AddObject('³ÖÐø»Ö¸´-¸öÈË', TObject(clWhite));
            7: HintList.AddObject('³ÖÐø»Ö¸´-×é¶Ó', TObject(clWhite));
            2: HintList.AddObject('ÌØÊâ', TObject(clWhite));
            10, 11: HintList.AddObject('Ç¿»¯', TObject(clWhite));
          end;
          if MouseItem.S.Shape = 2 then  HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite))
          else  HintList.AddObject(Format('ÖØÁ¿ %s ÊýÁ¿ %s',[IntToStr(MouseItem.s.Weight * MouseItem.Amount),IntToStr(MouseItem.Amount)]), TObject(clWhite));

          if not (MouseItem.S.Shape in [2,10,11]) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          case MouseItem.S.Shape of
            0: begin
              if (MouseItem.s.AC > 0) then begin
                HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + ' ³ÖÐø»Ö¸´', TObject(clWhite));
              end;
              if (MouseItem.s.MAC > 0) then begin
                HintList.AddObject('MP + ' + IntToStr(MouseItem.s.MAC) + ' ³ÖÐø»Ö¸´', TObject(clWhite));
              end;
            end;
            1: begin
              if (MouseItem.s.AC > 0) and (MouseItem.s.MAC = 0) then begin
                HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + ' Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
              if (MouseItem.s.MAC > 0) and (MouseItem.s.AC = 0) then begin
                HintList.AddObject('MP + ' + IntToStr(MouseItem.s.MAC) + ' Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
              if (MouseItem.s.MAC > 0) and (MouseItem.s.AC > 0) then begin
                HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + ' Ë²Ê±»Ö¸´', TObject(clWhite));
                HintList.AddObject('MP + ' + IntToStr(MouseItem.s.MAC) + ' Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
            end;
            3: begin
              if (MouseItem.s.AC > 0) and (MouseItem.s.MAC = 0) then begin
                HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + '% Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
              if (MouseItem.s.MAC > 0) and (MouseItem.s.AC = 0) then begin
                HintList.AddObject('MP + ' + IntToStr(MouseItem.s.MAC) + '% Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
              if (MouseItem.s.MAC > 0) and (MouseItem.s.AC > 0) then begin
                HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + '% Ë²Ê±»Ö¸´', TObject(clWhite));
                HintList.AddObject('MP + ' + IntToStr(MouseItem.s.MAC) + '% Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
            end;
            4: begin
              if (MouseItem.s.AC > 0) and (MouseItem.s.MAC > 0) then begin
                HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + ' ~ ' + IntToStr(MouseItem.s.MAC) + ' Ë²Ê±»Ö¸´', TObject(clWhite));
              end;
            end;

            6, 7: begin //Áö¼Ó¹°¾à
              if (MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) then begin
                if (MouseItem.s.AC > 0) then begin
                  HintList.AddObject('HP + ' + IntToStr(MouseItem.s.AC) + ' »Ö¸´', TObject(clWhite));
                end;
                if (MouseItem.s.MAC > 0) then begin
                  HintList.AddObject('MP + ' + IntToStr(MouseItem.s.AC) + ' »Ö¸´', TObject(clWhite));
                end;
                HintList.AddObject('¡¡',TObject(GetRGB(248)));
                HintList.AddObject(IntToStr(MouseItem.s.DuraMax) + '·Ö (' + IntToStr(MouseItem.s.AniCount) + 'Ãë)', TObject(clWhite));
              end;
            end;
          end;
          if not (MouseItem.S.Shape in [2,4]) then begin
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            HintList.AddObject('ÐèÒªÖ°Òµ: È«Ö°Òµ', TObject(clWhite));
          end;

          if MouseItem.S.Shape = 4 then begin
            useable := False;
            line2 := GetJobName(MouseItem.s.Need);
            if (Actor.m_btJob in [MouseItem.s.Need]) then
              useable := True;
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            if useable then
              HintList.AddObject('ÐèÒªÖ°Òµ: ' + line2, TObject(clWhite))
            else HintList.AddObject('ÐèÒªÖ°Òµ: ' + line2, TObject(clRed));
          end;
      end;
      2: begin   //È¯ÅÛ stdmode 2¹ø ºÐ·ù    °ãÄ¡±â ºÒ°¡

        case MouseItem.S.Shape of
           7: HintList.AddObject('´«ËÍ¾íÖá', TObject(clWhite));
           1, 13, 16, 22..24, 27, 32, 45: HintList.AddObject('Ç¿»¯', TObject(clWhite));
           4, 9, 10: HintList.AddObject('×°±¸Ç¿»¯', TObject(clWhite));
           12: HintList.AddObject('×°±¸ÐÞÀí', TObject(clWhite));
           11, 14, 15, 17, 19, 25, 26, 30: HintList.AddObject('ÌØÊâÓÃÍ¾', TObject(clWhite));
           18, 31: HintList.AddObject('Ãæ¾ß', TObject(clWhite));
           44: HintList.AddObject('ÁéÎï', TObject(clWhite));
           else  HintList.AddObject('ÌØÊâÓÃÍ¾', TObject(clWhite));
        end;
        HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.S.Weight), TObject(clWhite));
        if MouseItem.S.Shape = 7 then begin     //ÃÊ´ëÀå
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if MouseItem.Dura > 0 then begin
            HintList.AddObject(IntToStr(MouseItem.S.btValue[0]) + '×¯Ô°ÎïÆ·', TObject(clWhite));
            HintList.AddObject('ÓÐÐ§ÆÚÏÞÎª24Ð¡Ê±¡£', TObject(clWhite));
          end;
        end;
        if MouseItem.S.Shape = 13 then begin
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if MouseItem.DuraMax > 0 then begin
            HintList.AddObject(IntToStr(MouseItem.DuraMax) + ' »ñµÃ', TObject(clWhite));
          end;
        end;
        if MouseItem.S.Shape in [16, 32] then begin
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('¾­ÑéÖµ + ' + IntToStr(LoWord(MouseItem.S.AC - 100)) + '%', TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('³ÖÐøÊ±¼ä ' + inttostr(MouseItem.S.DuraMax) +'Ð¡Ê±', TObject(clWhite));
        end;
        if (MouseItem.S.Shape = 17) and (MouseItem.S.StdMode = 2) then begin
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('¼õÉÙ ' + IntToStr(LoWord(MouseItem.S.AC)) + ' µãPNÖµ', TObject(GetRGB(116)));
        end;
        if (MouseItem.S.Shape in [18, 31]) then begin     //º¯½ÅÅ»
          if (MouseItem.S.DC > 0) or (MouseItem.S.MC > 0) or (MouseItem.S.SC > 0)
            or (MouseItem.S.AC > 0) or (MouseItem.S.MAC > 0) or (MouseItem.S.AniCount > 100) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.S.DC > 0) then
            HintList.AddObject('¹¥»÷ + 0~' + IntToStr(LoWord(MouseItem.S.DC)) + ' ', TObject(clWhite));
          if (MouseItem.S.MC > 0) then
            HintList.AddObject('Ä§·¨ + 0~' + IntToStr(LoWord(MouseItem.S.MC)) + ' ', TObject(clWhite));
          if (MouseItem.S.SC > 0) then
            HintList.AddObject('µÀÊõ + 0~' + IntToStr(LoWord(MouseItem.S.SC)) + ' ', TObject(clWhite));

          if ((MouseItem.S.DC > 0) or (MouseItem.S.MC > 0) or (MouseItem.S.SC > 0))
            and ((MouseItem.S.AC > 0) or (MouseItem.S.MAC > 0)) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.S.AC > 0) then
            HintList.AddObject('·ÀÓù + 0~' + IntToStr(LoWord(MouseItem.S.AC)) + ' ', TObject(clWhite));
          if (MouseItem.S.MAC > 0) then
            HintList.AddObject('Ä§·¨·ÀÓù + 0~' + IntToStr(LoWord(MouseItem.S.MAC)) + ' ', TObject(clWhite));
            
          if ((MouseItem.S.AC > 0) or (MouseItem.S.MAC > 0)) and (MouseItem.S.AniCount > 100) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.S.AniCount > 100) then
            HintList.AddObject('¾­ÑéÖµ + ' +  IntToStr(LoWord(MouseItem.S.AniCount - 100)) + '%', TObject(clWhite));

          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('ÃâÖúÅÜ¹¦ÄÜ', TObject(clWhite));
          if MouseItem.S.Shape = 31 then begin
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            HintList.AddObject('Ê¹ÓÃÊ±¼ä ' +  IntToStr(LoWord(MouseItem.S.DuraMax)) + 'Ð¡Ê±', TObject(clWhite));
          end;
        end;
        if (MouseItem.S.Shape = 19) then begin
          HintList.AddObject('±¬ÂÊ + ' + IntToStr(LoWord(MouseItem.S.AC - 100)) + '% ', TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('³ÖÐøÊ±¼ä ' + IntToStr(MouseItem.S.DuraMax) + 'Ð¡Ê±', TObject(clWhite));
        end;

        if (g_MouseItem.S.Shape in [20,21]) then begin     //È£À§º´
         // HintList.AddObject('Àû¿ë½Ã°£: ' + DateTimeToStr(UnixToDateTime(MakeLong(g_MouseItem.DuraMax,g_MouseItem.dura)))
         //            + ' (ÃÑ ' + IntToStr(LoWord(g_MouseItem.S.DuraMax)) + 'ÀÏ)', TObject(clWhite));
        end;

        if (MouseItem.S.Shape = 22) then begin     //°ø·Â¼ö
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('¹¥»÷Á¦ + ' + IntToStr(LoWord(MouseItem.S.AC - 100)) + '%', TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('³ÖÐøÊ±¼ä ' + inttostr(MouseItem.S.DuraMax) +'Ð¡Ê±', TObject(clWhite));
        end;

        if (MouseItem.S.Shape = 23)  then begin     //Ãµ·É¼ö
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if LoWord(MouseItem.S.AC) > 0 then
            HintList.AddObject('ÐÒÔË ' + IntToStr(LoWord(MouseItem.S.AC)), TObject(clWhite));
          if LoWord(MouseItem.S.DC) > 0 then
            HintList.AddObject('¹¥»÷ ' + IntToStr(LoWord(MouseItem.S.DC - 100)), TObject(clWhite));
          if LoWord(MouseItem.S.MC) > 0 then
            HintList.AddObject('Ãô½Ý ' + IntToStr(LoWord(MouseItem.S.MC)), TObject(clWhite));
          if LoWord(MouseItem.S.SC) > 0 then
            HintList.AddObject('×¼È· ' + IntToStr(LoWord(MouseItem.S.SC)), TObject(clWhite));
          if LoWord(MouseItem.S.MAC) > 0 then
            HintList.AddObject('HP +' + IntToStr(LoWord(MouseItem.S.MAC)), TObject(clWhite));

          if (LoWord(MouseItem.S.AC) > 0) or (LoWord(MouseItem.S.MAC) > 0) or (LoWord(MouseItem.S.DC) > 0) or (LoWord(MouseItem.S.MC) > 0) or (LoWord(MouseItem.S.SC) > 0) then
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('Ê¹ÓÃÊ±¼ä ' + inttostr(MouseItem.S.DuraMax) +'Ð¡Ê±', TObject(clWhite));
        end;

        if (MouseItem.S.Shape = 24) then begin     //Á¤È®ÀÇ¹°¾à
           HintList.AddObject('¡¡',TObject(GetRGB(248)));
           HintList.AddObject('×¼È· + ' + IntToStr(LoWord(MouseItem.S.AC)) + '', TObject(clWhite));
           HintList.AddObject('¡¡',TObject(GetRGB(248)));
           HintList.AddObject('³ÖÐøÊ±¼ä ' + inttostr(MouseItem.S.DuraMax) +'Ð¡Ê±', TObject(clWhite));
        end;

        if (MouseItem.S.Shape = 27) then begin     //¿ÁÃ»¼ö
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if LoWord(MouseItem.S.AC) > 0 then
            HintList.AddObject('ÐÒÔË ' + IntToStr(LoWord(MouseItem.S.AC)), TObject(clWhite));
          if LoWord(MouseItem.S.MAC) > 0 then
            HintList.AddObject('·ÀÓù ' + IntToStr(LoWord(MouseItem.S.MAC)), TObject(clWhite));
          if LoWord(MouseItem.S.DC) > 0 then
            HintList.AddObject('¹¥»÷ ' + IntToStr(LoWord(MouseItem.S.DC)), TObject(clWhite));
          if LoWord(MouseItem.S.MC) > 0 then
            HintList.AddObject('Ä§·¨ ' + IntToStr(LoWord(MouseItem.S.MC)), TObject(clWhite));
          if LoWord(MouseItem.S.SC) > 0 then
            HintList.AddObject('µÀÊõ ' + IntToStr(LoWord(MouseItem.S.SC)), TObject(clWhite));

          if (LoWord(MouseItem.S.AC) > 0) or (LoWord(MouseItem.S.MAC) > 0) or (LoWord(MouseItem.S.DC) > 0) or (LoWord(MouseItem.S.MC) > 0) or (LoWord(MouseItem.S.SC) > 0) then
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('Ê¹ÓÃÊ±¼ä ' + inttostr(MouseItem.S.DuraMax) +'Ð¡Ê±', TObject(clWhite));
        end;
        if (MouseItem.S.Shape = 30) then begin     //¼ö·ÃÀÇ¹°¾à
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('Ê¹ÓÃÊ±¼ä ' + inttostr(MouseItem.S.DuraMax) +'Ð¡Ê±', TObject(clWhite));
        end;

        if (MouseItem.S.Shape = 43) then begin  //°í±â
           if MouseItem.S.DuraMax > 0 then
             HintList.AddObject('ÖÒ³Ï¶È»Ö¸´ ' + inttostr(MouseItem.S.DuraMax div 1000) +'', TObject(clWhite));
        end;
        if (MouseItem.S.Shape = 44) then begin  //°í±Þ Âý»ì¶±
           if MouseItem.S.DuraMax > 0 then
             HintList.AddObject('ÖÒ³Ï¶È»Ö¸´ ' + inttostr(MouseItem.S.DuraMax div 1000) +'', TObject(clWhite));
        end;

        if (MouseItem.S.Shape = 45) and (MouseItem.S.StdMode = 2) then begin     //µå··Çã¸®
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if LoWord(MouseItem.S.AC) > 0 then
            HintList.AddObject('ÐÒÔË ' + IntToStr(LoWord(MouseItem.S.AC)), TObject(clWhite));
          if LoWord(MouseItem.S.MAC) > 0 then
            HintList.AddObject('·ÀÓù ' + IntToStr(LoWord(MouseItem.S.MAC)), TObject(clWhite));
          if LoWord(MouseItem.S.DC) > 0 then
            HintList.AddObject('¹¥»÷ ' + IntToStr(LoWord(MouseItem.S.DC)), TObject(clWhite));
          if LoWord(MouseItem.S.MC) > 0 then
            HintList.AddObject('Ä§·¨ ' + IntToStr(LoWord(MouseItem.S.MC)), TObject(clWhite));
          if LoWord(MouseItem.S.SC) > 0 then
            HintList.AddObject('µÀÊõ ' + IntToStr(LoWord(MouseItem.S.SC)), TObject(clWhite));
          if (LoWord(MouseItem.S.AC) > 0) or (LoWord(MouseItem.S.MAC) > 0) or (LoWord(MouseItem.S.DC) > 0) or (LoWord(MouseItem.S.MC) > 0) or (LoWord(MouseItem.S.SC) > 0) then
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('³ÖÐøÊ±¼ä : ' + IntToStr(MouseItem.S.DuraMax) + 'Ð¡Ê±(Í¬ÖÖÐ§¹û²»µþ¼Ó)', TObject(clYellow));
        end;


        end;
      3:   //¹°¾à È¯ÅÛ °ãÄ¡±â °¡´É
            begin
        case MouseItem.S.Shape of
           1..5: HintList.AddObject('´«ËÍ¾íÖá', TObject(clWhite));
           8, 50..60: HintList.AddObject('ÌØÊâÓÃÍ¾', TObject(clWhite));
           12, 13, 14: HintList.AddObject('Ç¿»¯', TObject(clWhite));
           else HintList.AddObject('ÌØÊâÓÃÍ¾', TObject(clWhite));
        end;
        HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.S.Weight), TObject(clWhite));
        if (MouseItem.S.Shape in [12,13]) and (MouseItem.S.StdMode = 3) then begin
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if LoWord(MouseItem.S.AC) > 0 then
           HintList.AddObject('MAXHP + ' + IntToStr(LoWord(MouseItem.S.AC)), TObject(clWhite));
         if HiWord(MouseItem.S.AC) > 0 then
           HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(HiWord(MouseItem.S.AC)), TObject(clWhite));
         if LoWord(MouseItem.S.MAC) > 0 then
           HintList.AddObject('MAXMP + ' + IntToStr(LoWord(MouseItem.S.MAC)), TObject(clWhite));
         if LoWord(MouseItem.S.DC) > 0 then
           HintList.AddObject('¹¥»÷ + ' + IntToStr(LoWord(MouseItem.S.DC)), TObject(clWhite));
         if LoWord(MouseItem.S.MC) > 0 then
           HintList.AddObject('Ä§·¨ + ' + IntToStr(LoWord(MouseItem.S.MC)), TObject(clWhite));
         if LoWord(MouseItem.S.SC) > 0 then
           HintList.AddObject('µÀÊõ + ' + IntToStr(LoWord(MouseItem.S.SC)), TObject(clWhite));
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if HiWord(MouseItem.S.MAC) >= 3600 then
           HintList.AddObject('³ÖÐøÊ±¼ä: ' + IntToStr(HiWord(MouseItem.S.MAC div 3600)) + 'Ð¡Ê±', TObject(clWhite))
         else
           HintList.AddObject('³ÖÐøÊ±¼ä: ' + IntToStr(HiWord(MouseItem.S.MAC div 60)) + '·Ö', TObject(clWhite));
        end;

        if (MouseItem.S.Shape in [14]) and (MouseItem.S.StdMode = 3) then begin
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if (LoWord(MouseItem.S.AC) > 0) then
           HintList.AddObject('·ÀÓù + ' + IntToStr(LoWord(MouseItem.S.AC)), TObject(clWhite));
         if (LoWord(MouseItem.S.MAC) > 0) then
           HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(LoWord(MouseItem.S.MAC)), TObject(clWhite));
         if (MouseItem.S.AtkSpd > 0) then
           HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.S.AtkSpd), TObject(clWhite));
         if (LoWord(MouseItem.S.DC) > 0) then
           HintList.AddObject('¹¥»÷ + ' + IntToStr(LoWord(MouseItem.S.DC)), TObject(clWhite));
         if (LoWord(MouseItem.S.MC) > 0) then
           HintList.AddObject('Ä§·¨ + ' + IntToStr(LoWord(MouseItem.S.MC)), TObject(clWhite));
         if (LoWord(MouseItem.S.SC) > 0) then
           HintList.AddObject('µÀÊõ + ' + IntToStr(LoWord(MouseItem.S.SC)), TObject(clWhite));
         if ((LoWord(MouseItem.S.AC) > 0) or (LoWord(MouseItem.S.MAC) > 0) or (MouseItem.S.AtkSpd > 0) or (LoWord(MouseItem.S.DC) > 0) or
          (LoWord(MouseItem.S.MC) > 0) or (LoWord(MouseItem.S.SC) > 0))
          and ((MouseItem.S.Accurate > 0) or (MouseItem.S.Agility > 0) or (MouseItem.S.HpAdd > 0) or (MouseItem.S.MpAdd > 0)) then
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if (MouseItem.S.Accurate > 0) then
           HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate), TObject(clWhite));
         if (MouseItem.S.Agility > 0) then
           HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.S.Agility), TObject(clWhite));
         if (MouseItem.S.HpAdd > 0) then
           HintList.AddObject('MAXHP + ' + IntToStr(MouseItem.S.HpAdd), TObject(clWhite));
         if (MouseItem.S.MpAdd > 0) then
           HintList.AddObject('MAXMP + ' + IntToStr(MouseItem.S.MpAdd), TObject(clWhite));
         if ((MouseItem.S.Accurate > 0) or (MouseItem.S.Agility > 0) or (MouseItem.S.HpAdd > 0) or (MouseItem.S.MpAdd > 0))
           and ((MouseItem.S.MagAvoid > 0) or (MouseItem.S.ToxAvoid > 0)) then
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if (MouseItem.S.MagAvoid > 0) then
           HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.S.MagAvoid), TObject(clWhite));
         if (MouseItem.S.ToxAvoid > 0) then
           HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.S.ToxAvoid), TObject(clWhite));

         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if HiWord(MouseItem.S.MAC) >= 3600 then
           HintList.AddObject('³ÖÐøÊ±¼ä: ' + IntToStr(HiWord(MouseItem.S.MAC div 3600)) + 'Ð¡Ê±', TObject(clWhite))
         else
           HintList.AddObject('³ÖÐøÊ±¼ä: ' + IntToStr(HiWord(MouseItem.S.MAC div 60)) + '·Ö', TObject(clWhite));
        end;

        if (MouseItem.S.Shape in [50..60]) and (MouseItem.S.StdMode = 3) then begin
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('ÐèÒªÖ°Òµ: È«Ö°Òµ', TObject(clWhite));
        end;
        end;
      4: begin      //¹«°øÃ¥
          case MouseItem.s.Shape of
            0: HintList.AddObject('Õ½Ê¿¡¢±ÌÑªÕ½Ê¿ ¼¼ÄÜÊé', TObject(clWhite));
            1: HintList.AddObject('·¨Ê¦, ºëÐþ·¨Ê¦ ¼¼ÄÜÊé', TObject(clWhite));
            2: HintList.AddObject('µÀÊ¿, ñ´ÏÉµÀÊ¿ ¼¼ÄÜÊé', TObject(clWhite));
            3: HintList.AddObject('´Ì¿Í, ·ÉÑà´Ì¿Í ¼¼ÄÜÊé', TObject(clWhite));
            4: HintList.AddObject('ºÍÉÐ, ÆÆ½äÉ® ¼¼ÄÜÊé', TObject(clWhite));
            5: HintList.AddObject('±ÌÑªÕ½Ê¿ ¼¼ÄÜÊé', TObject(clWhite));
            6: HintList.AddObject('ºëÐþ·¨Ê¦ ¼¼ÄÜÊé', TObject(clWhite));
            7: HintList.AddObject('ñ´ÏÉµÀÊ¿ ¼¼ÄÜÊé', TObject(clWhite));
            8: HintList.AddObject('·ÉÑà´Ì¿Í ¼¼ÄÜÊé', TObject(clWhite));
            9: HintList.AddObject('ÆÆ½äÉ® ¼¼ÄÜÊé', TObject(clWhite));
         //   5: HintList.AddObject('½Â·Á, ÆÄ°è½Â·Á ¹«°øÃ¥', TObject(clWhite));
          end;
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));

          useable := False;
          UseLevel := False;
          case MouseItem.s.Shape of
            0: begin
                line2 := 'Õ½Ê¿/±ÌÑªÕ½Ê¿';
                if (Actor.m_btJob in [0,5]) then
                  useable := True;
              end;
            1: begin
                line2 := '·¨Ê¦/ºëÐþ·¨Ê¦';
                if (Actor.m_btJob in [1,6]) then
                  useable := True;
              end;
            2: begin
                line2 := 'µÀÊ¿/ñ´ÏÉµÀÊ¿';
                if (Actor.m_btJob in [2,7]) then
                  useable := True;
              end;
            3: begin
                line2 := '´Ì¿Í/·ÉÑà´Ì¿Í';
                if (Actor.m_btJob in [3,8]) then
                  useable := True;
              end;
            4: begin
                line2 := 'ºÍÉÐ/ÆÆ½äÉ®';
                if (Actor.m_btJob in [4,9]) then
                  useable := True;
              end;
            5: begin
                line2 := '±ÌÑªÕ½Ê¿';
                if (Actor.m_btJob in [5]) then
                  useable := True;
              end;
            6: begin
                line2 := 'ºëÐþ·¨Ê¦';
                if (Actor.m_btJob in [6]) then
                  useable := True;
              end;
            7: begin
                line2 := 'ñ´ÏÉµÀÊ¿';
                if (Actor.m_btJob in [7]) then
                  useable := True;
              end;
            8: begin
                line2 := '·ÉÑà´Ì¿Í';
                if (Actor.m_btJob in [8]) then
                  useable := True;
              end;
            9: begin
                line2 := 'ÆÆ½äÉ®';
                if (Actor.m_btJob in [9]) then
                  useable := True;
              end;
          end;
          if (Actor.m_Abil.Level >= MouseItem.s.DuraMax) then
             UseLevel := True;

          if UseLevel then begin
            HintList.AddObject('ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.DuraMax), TObject(clWhite));
          end else begin
            HintList.AddObject('ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.DuraMax), TObject(clRed));
          end;
          if useable then begin
            HintList.AddObject('ÐèÒªÖ°Òµ: ' + line2, TObject(clWhite));
          end else begin
            HintList.AddObject('ÐèÒªÖ°Òµ: ' + line2, TObject(clRed));
          end;


        end;

      8: begin    //Ç÷·æÀÇ»óÀÚ, °æ¸Å±Ç
          HintList.AddObject('ÌØÊâÓÃÍ¾', TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite));
        end;
      9: begin //¿µ¹°
          HintList.AddObject('ÁéÎï', TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite));

          if (MouseItem.s.DC > 0) or (MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) then
           HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.s.DC > 0) then begin
            HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)), TObject(clWhite));
          end;
          if (MouseItem.s.MC > 0) then begin
            HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)), TObject(clWhite));
          end;
          if (MouseItem.s.SC > 0) then begin
            HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)), TObject(clWhite));
          end;

          if (MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) then
           HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.s.AC > 0) then begin
            HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
          end;
          if (MouseItem.s.MAC > 0) then begin
            HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
          end;
        end;
      5, 6, 99, 90:  begin  //¹«±â
          useable := False;
          if MouseItem.s.Reserved and $01 <> 0 then begin
            if HintList.Count > 0 then HintList.Delete(0);
            case MouseItem.S.Grade of
              0, 1: HintList.InsertObject(0, sComName + '<CO$FFFF>' + MouseItem.s.Name + '<CE> - ÐèÒªÒ±Á¶È·ÈÏ' , TObject(clWhite));
              2: HintList.InsertObject(0, sComName + '<CO$00FFDF42>' + MouseItem.s.Name + '<CE> - ÐèÒªÒ±Á¶È·ÈÏ' , TObject(clWhite));
              3: HintList.InsertObject(0, sComName + '<CO$000075FF>' + MouseItem.s.Name + '<CE> - ÐèÒªÒ±Á¶È·ÈÏ' , TObject(clWhite));
              4: HintList.InsertObject(0, sComName + '<CO$00FFAADE>' + MouseItem.s.Name + '<CE> - ÐèÒªÒ±Á¶È·ÈÏ' , TObject(clWhite));
            end;
          end;

          HintList.AddObject('ÎäÆ÷', TObject(clWhite));

          if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
          else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));

          if (MouseItem.s.Source in [1..10]) or (MouseItem.s.btValue[7] >= 1) then begin
            if MouseItem.s.btValue[7] >= 1 then
              HintList.AddObject('Ç¿»¯ + ' + IntToStr(MouseItem.s.Source) + GetJPBtStr(7,0), TObject($00EFB539))
            else
              HintList.AddObject('Ç¿»¯ + ' + IntToStr(MouseItem.s.Source), TObject(clWhite));
          end;


          HintList.AddObject('¡¡',TObject(GetRGB(248)));


          if (MouseItem.s.DC > 0) then begin
            if MouseItem.s.btValue[0] >= 1 then
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)) + GetJPBtStr(0,0), TObject($00EFB539))
            else
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)), TObject(clWhite));
          end;

          if (MouseItem.s.MC > 0) then begin
            if MouseItem.s.btValue[1] >= 1 then
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)) + GetJPBtStr(1,0), TObject($00EFB539))
            else
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)), TObject(clWhite));
          end;

          if (MouseItem.s.SC > 0) then begin
            if MouseItem.s.btValue[2] >= 1 then
              HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)) + GetJPBtStr(2,0), TObject($00EFB539))
            else
              HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)), TObject(clWhite));
          end;

          if (Loword(MouseItem.s.AC) > 0) then begin
            if MouseItem.s.btValue[3] >= 1 then
              HintList.AddObject('ÐÒÔË + ' + IntToStr(Loword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
            else
              HintList.AddObject('ÐÒÔË + ' + IntToStr(Loword(MouseItem.s.AC)), TObject(clWhite));
          end;
          if (Loword(MouseItem.s.MAC) > 0) then begin
            if MouseItem.s.btValue[4] >= 1 then
              HintList.AddObject('×çÖä + ' + IntToStr(Loword(MouseItem.s.MAC)) + GetJPBtStr(4,1), TObject(clRed))
            else
              HintList.AddObject('×çÖä + ' + IntToStr(Loword(MouseItem.s.MAC)), TObject(clWhite));
          end;

          if MouseItem.s.Accurate > 0 then begin
            if MouseItem.s.btValue[5] >= 1 then
              HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(5,0), TObject($00EFB539))
            else
              HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate), TObject(clWhite));
          end;

          if (MouseItem.s.Source <= -1) and (MouseItem.s.Source >= -50) then begin
             HintList.AddObject('ÉñÊ¥ + ' + IntToStr(-MouseItem.s.Source), TObject(clWhite));
          end;
          if (MouseItem.s.Source <= -51) and (MouseItem.s.Source >= -100) then begin
             HintList.AddObject('ÉñÊ¥ - ' + IntToStr(-MouseItem.s.Source - 50), TObject(clWhite));
          end;

          if MouseItem.s.AtkSpd > 0 then begin
            if MouseItem.s.AtkSpd > 10 then begin
              if MouseItem.s.btValue[6] >= 1 then
                HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd - 10) + GetJPBtStr(6,2), TObject($00EFB539))
              else
                HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd - 10), TObject(clWhite));
            end else begin
              if MouseItem.s.btValue[6] >= 1 then
                HintList.AddObject('¹¥»÷ËÙ¶È - ' + IntToStr(MouseItem.s.AtkSpd) + GetJPBtStr(6,3), TObject($00EFB539))
              else
                HintList.AddObject('¹¥»÷ËÙ¶È - ' + IntToStr(MouseItem.s.AtkSpd), TObject(clWhite));
            end;
          end;

          if MouseItem.S.Slowdown > 0 then begin
            if MouseItem.s.btValue[8] >= 1 then
              HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown) + GetJPBtStr(8,0), TObject($00EFB539))
            else
              HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown), TObject(clWhite));
          end;
          if MouseItem.S.Tox > 0 then begin
            if MouseItem.s.btValue[9] >= 1 then
              HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox) + GetJPBtStr(9,0), TObject($00EFB539))
            else
              HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox), TObject(clWhite));
          end;

          if ((MouseItem.s.HpAdd > 0) or (MouseItem.s.MpAdd > 0)) then
            HintList.AddObject('¡¡',TObject(GetRGB(248)));

          if (MouseItem.s.HpAdd > 0) then begin
            HintList.AddObject('MAXHP + ' + IntToStr(MouseItem.s.HpAdd), TObject(clWhite));
          end;
          if (MouseItem.s.MpAdd > 0) then begin
            HintList.AddObject('MAXMP + ' + IntToStr(MouseItem.s.MpAdd), TObject(clWhite));
          end;

          case MouseItem.S.btValue[12] of
            1 : begin  sUP := 'ÓÂÃÍ'; sUPC := '¹¥»÷'; end;
            2 : begin  sUP := 'Ä§Ê¥'; sUPC := 'Ä§·¨'; end;
            3 : begin  sUP := 'ÏÉ½ç'; sUPC := 'µÀÊõ'; end;
            4 : begin  sUP := 'ÊØ»¤'; sUPC := '·ÀÓù'; end;
            5 : begin  sUP := '³ýÄ§'; sUPC := 'Ä§·¨·ÀÓù'; end;
            6 : begin  sUP := '¿áº®'; sUPC := 'MAX HP,MP'; end;
          end;
          if MouseItem.S.btValue[12] > 0 then begin
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            if MouseItem.S.btValue[18] > 0 then begin
              HintList.AddObject( sUP + '¾õÐÑ (' + IntToStr(MouseItem.S.btValue[18]) + ')', TObject(ItemColor));
              nSUM := MouseItem.S.btValue[13] + MouseItem.S.btValue[14] + MouseItem.S.btValue[15] + MouseItem.S.btValue[16] + MouseItem.S.btValue[17];
              if nSUM > 0 then begin
                if MouseItem.S.btValue[12] = 6 then
                  HintList.AddObject( sUPC + ' + ' + IntToStr(nSUM), TObject(clWhite))
                  else HintList.AddObject( sUPC + ' + ' + IntToStr(nSUM) + '~' + IntToStr(nSUM), TObject(clWhite));
              end;
            end;
            if g_boItemHint or g_bobuttHint then begin
            if MouseItem.S.btValue[13] > 0 then
              HintList.AddObject('1½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[13]) + '~' + IntToStr(MouseItem.S.btValue[13]), TObject(clWhite));
            if MouseItem.S.btValue[14] > 0 then
              HintList.AddObject('2½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[14]) + '~' + IntToStr(MouseItem.S.btValue[14]), TObject(clWhite));
            if MouseItem.S.btValue[15] > 0 then
              HintList.AddObject('3½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[15]) + '~' + IntToStr(MouseItem.S.btValue[15]), TObject(clWhite));
            if MouseItem.S.btValue[16] > 0 then
              HintList.AddObject('4½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[16]) + '~' + IntToStr(MouseItem.S.btValue[16]), TObject(clWhite));
            if MouseItem.S.btValue[17] > 0 then
              HintList.AddObject('5½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[17]) + '~' + IntToStr(MouseItem.S.btValue[17]), TObject(clWhite));
            end;
          end;

          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          case MouseItem.s.Need of
            0: begin
                if Actor.m_Abil.Level >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            1: begin
                if Hiword(Actor.m_Abil.DC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            2: begin
                if Hiword(Actor.m_Abil.MC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªÄ§·¨: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            3: begin
                if Hiword(Actor.m_Abil.SC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªµÀÊõ: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            6: begin
                useable := True;
                sTemp := 'ÐÐ»á³ÉÔ±×¨ÓÃ';
              end;
            60: begin
                useable := True;
                sTemp := 'ÐÐ»áÕÆÃÅ×¨ÓÃ';
              end;
            7: begin
                useable := True;
                sTemp := 'É³°Í¿Ë³ÉÔ±×¨ÓÃ';
              end;
            70: begin
                useable := True;
                sTemp := 'É³°Í¿Ë³ÇÖ÷×¨ÓÃ';
              end;
            9: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÉÔ±×¨ÓÃ';
              end;
            80: begin
                useable := True;
                sTemp := '³ÇÖ÷×¨ÓÃ';
              end;
            90: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÇÖ÷×¨ÓÃ';
              end;
            20: begin
                useable := True;
                sTemp := '»áÔ±×¨ÓÃ';
              end;
            21: begin
                useable := True;
                sTemp := 'Ðû´«ÍÅ³¤×¨ÓÃ';
              end;
            22: begin
                useable := True;
                sTemp := 'Ðû´«³ÉÔ±×¨ÓÃ';
              end;
            23: begin
                useable := True;
                sTemp := '¼ÇÕßÍÅ³¤×¨ÓÃ';
              end;
            24: begin
                useable := True;
                sTemp := '¼ÇÕß³ÉÔ±×¨ÓÃ';
              end;
            25: begin
                useable := True;
                sTemp := 'ºìÆìÍÅ³¤×¨ÓÃ';
              end;
            26: begin
                useable := True;
                sTemp := 'ºìÆì³ÉÔ±×¨ÓÃ';
              end;
          end;
          if useable then begin
            HintList.AddObject(sTemp, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp, TObject(clRed));
          end;
          if MouseItem.S.StdMode = 90 then begin
            if Actor.m_btJob in [4,9] then
               Jobuseable := True
            else Jobuseable := False;
              sTemp2 := 'ÐèÒªÖ°Òµ: ºÍÉÐ/ÆÆ½äÉ®';
          end else begin
            case MouseItem.s.Shape of
              19: begin
                 Jobuseable := True;
                 sTemp2 := 'ÐèÒªÖ°Òµ: È«Ö°Òµ';
              end;
              34,35,36,37,39..48,55,56,57: begin
                 Jobuseable := True;
                 sTemp2 := 'ÐèÒªÖ°Òµ: È«Ö°Òµ(ºÍÉÐ³ýÍâ)';
              end;
              49: begin
                 if Actor.m_btJob in [0,5] then
                   Jobuseable := True
                 else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: Õ½Ê¿/±ÌÑªÕ½Ê¿';
              end;
              50: begin
                 if Actor.m_btJob in [1,6] then
                   Jobuseable := True
                 else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: ·¨Ê¦/ºëÐþ·¨Ê¦';
              end;
              51: begin
                 if Actor.m_btJob in [2,7] then
                   Jobuseable := True
                 else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: µÀÊõ/ñ´ÏÉµÀÊ¿';
              end;
              90..95,96,97,99,103 : begin
                if Actor.m_btJob in [3] then
                 Jobuseable := True
                else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: ´Ì¿Í';
              end;
              98,100..102,104 : begin
                if Actor.m_btJob in [3,8] then
                 Jobuseable := True
                else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: ´Ì¿Í/·ÉÑà´Ì¿Í';
              end;
              else begin
                 if Actor.m_btJob in [0..3] then
                 Jobuseable := True
                else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: Õ½Ê¿/·¨Ê¦/µÀÊ¿/´Ì¿Í';
              end;
            end;

            if MouseItem.S.HumUp = 1 then begin
              if Actor.m_btJob = 5 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ±ÌÑªÕ½Ê¿';
            end;
            if MouseItem.S.HumUp = 2 then begin
              if Actor.m_btJob = 6 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ºëÐþ·¨Ê¦';
            end;
            if MouseItem.S.HumUp = 3 then begin
              if Actor.m_btJob = 7 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ñ´ÏÉµÀÊ¿';
            end;
            if MouseItem.S.HumUp = 4 then begin
              if Actor.m_btJob = 8 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ·ÉÑà´Ì¿Í';
            end;
            if MouseItem.S.HumUp = 5 then begin
              if Actor.m_btJob = 9 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ÆÆ½äÉ®';
            end;   
          end;
          if Jobuseable then begin
            HintList.AddObject(sTemp2, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp2, TObject(clRed));
          end;
        end;

      7: begin  //³¬½Ã´ë
         HintList.AddObject('µö¾ß', TObject(clWhite));
         if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
           else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));

         HintList.AddObject('¡¡',TObject(GetRGB(248)));

         if MouseItem.S.Accurate > 0 then
           HintList.AddObject('µöÓã³É¹¦ÂÊ ' + IntToStr(MouseItem.S.Accurate * 2) + '%', TObject(clWhite));
         if MouseItem.S.DC > 0 then
           HintList.AddObject('µ¯ÐÔ ' + IntToStr(LoWord(MouseItem.S.DC) + HiWord(MouseItem.S.DC)), TObject(clWhite));

         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         HintList.AddObject('×°±¸: È«Ö°Òµ¿ÉÓÃ', TObject(clWhite));

         case MouseItem.S.Need of
           0: begin
             if Actor.m_Abil.Level < MouseItem.S.NeedLevel then
               useable := True;
               sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
             end;
           1: begin
             if HiWord (Actor.m_Abil.DC) < MouseItem.S.NeedLevel then
               useable := True;
               sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
             end;
           2: begin
             if Hiword(Actor.m_Abil.MC) >= MouseItem.s.NeedLevel then
               useable := True;
               sTemp := 'ÐèÒªÄ§·¨: ' + IntToStr(MouseItem.s.NeedLevel);
             end;
           3: begin
             if Hiword(Actor.m_Abil.SC) >= MouseItem.s.NeedLevel then
               useable := True;
               sTemp := 'ÐèÒªµÀÊõ: ' + IntToStr(MouseItem.s.NeedLevel);
             end;
           6: begin
               useable := True;
               sTemp := 'ÐÐ»á³ÉÔ±×¨ÓÃ';
             end;
           60: begin
               useable := True;
               sTemp := 'ÐÐ»áÕÆÃÅ×¨ÓÃ';
             end;
           7: begin
               useable := True;
               sTemp := 'É³°Í¿Ë³ÉÔ±×¨ÓÃ';
             end;
           70: begin
               useable := True;
               sTemp := 'É³°Í¿Ë³ÇÖ÷×¨ÓÃ';
             end;
           80: begin
                useable := True;
                sTemp := '³ÇÖ÷×¨ÓÃ';
             end;
           9: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÉÔ±×¨ÓÃ';
             end;
           90: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÇÖ÷×¨ÓÃ';
             end;
           20: begin
               useable := True;
               sTemp := '»áÔ±×¨ÓÃ';
             end;
           21: begin
               useable := True;
               sTemp := 'Ðû´«ÍÅ³¤×¨ÓÃ';
             end;
           22: begin
               useable := True;
               sTemp := 'Ðû´«³ÉÔ±×¨ÓÃ';
             end;
           23: begin
               useable := True;
               sTemp := '¼ÇÕßÍÅ³¤×¨ÓÃ';
             end;
           24: begin
               useable := True;
               sTemp := '¼ÇÕß³ÉÔ±×¨ÓÃ';
             end;
           25: begin
               useable := True;
               sTemp := 'ºìÆìÍÅ³¤×¨ÓÃ';
             end;
           26: begin
               useable := True;
               sTemp := 'ºìÆì³ÉÔ±×¨ÓÃ';
             end;
         end;
         if useable then begin
           HintList.AddObject(sTemp, TObject(clWhite));
         end else begin
           HintList.AddObject(sTemp, TObject(clRed));
         end;


        end;
      10, 11, 12:  begin   //¿Ê
          useable := False;

          HintList.AddObject('ÒÂ·þ', TObject(clWhite));

          if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
          else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));

          HintList.AddObject('¡¡',TObject(GetRGB(248)));

          if MouseItem.s.DC > 0 then begin
            if MouseItem.s.btValue[0] >= 1 then
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)) + GetJPBtStr(0,0), TObject($00EFB539))
            else
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)), TObject(clWhite));
          end;
          if MouseItem.s.MC > 0 then begin
            if MouseItem.s.btValue[1] >= 1 then
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)) + GetJPBtStr(1,0), TObject($00EFB539))
            else
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)), TObject(clWhite));
          end;
          if MouseItem.s.SC > 0 then begin
            if MouseItem.s.btValue[2] >= 1 then
              HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)) + GetJPBtStr(2,0), TObject($00EFB539))
            else
              HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)), TObject(clWhite));
          end;
          if MouseItem.s.Accurate > 0 then begin
            if MouseItem.s.btValue[9] >= 1 then
              HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(9,0), TObject($00EFB539))
            else
              HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate), TObject(clWhite));
          end;
          if MouseItem.s.Source > 0 then begin
            HintList.AddObject('ÐÒÔË + ' + IntToStr(MouseItem.s.Source), TObject(clWhite));
          end;
          if (MouseItem.s.DC > 0) or (MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.Source > 0) or (MouseItem.s.Accurate > 0) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));

          if MouseItem.s.AC > 0 then begin
            if MouseItem.s.btValue[3] >= 1 then
              HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
            else
              HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
          end;
          if MouseItem.s.MAC > 0 then begin
            if MouseItem.s.btValue[4] >= 1 then
              HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
            else
              HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
          end;

          if MouseItem.s.HpAdd > 0 then
            HintList.AddObject('MAXHP + ' + IntToStr(MouseItem.s.HpAdd), TObject(clWhite));
          if MouseItem.s.MpAdd > 0 then
            HintList.AddObject('MAXMP + ' + IntToStr(MouseItem.s.MpAdd), TObject(clWhite));

          if MouseItem.s.RecHp > 0 then
            HintList.AddObject('ÉúÃü»Ö¸´ + ' + IntToStr(MouseItem.s.RecHp * 10) + '%', TObject(clWhite));
          if MouseItem.s.RecMp > 0 then
            HintList.AddObject('Ä§·¨»Ö¸´ + ' + IntToStr(MouseItem.s.RecMp * 10) + '%', TObject(clWhite));

          if MouseItem.s.Agility > 0 then begin
            if MouseItem.s.btValue[6] >= 1 then
              HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility) + GetJPBtStr(6,0), TObject($00EFB539))
            else
              HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility), TObject(clWhite));
          end;
          if MouseItem.s.ToxAvoid > 0 then begin
            if MouseItem.s.btValue[7] >= 1 then
              HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid) + GetJPBtStr(7,0), TObject($00EFB539))
            else
              HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid), TObject(clWhite));
          end;
          if MouseItem.s.MagAvoid > 0 then begin
            if MouseItem.s.btValue[8] >= 1 then
              HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid) + GetJPBtStr(8,0), TObject($00EFB539))
            else
              HintList.AddObject('¸¶Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid), TObject(clWhite));
          end;

          case MouseItem.S.btValue[12] of
            1 : begin  sUP := 'ÓÂÃÍ'; sUPC := 'ÆÄ±«'; end;
            2 : begin  sUP := 'Ä§Ê¥'; sUPC := 'Ä§·¨'; end;
            3 : begin  sUP := 'ÏÉ½ç'; sUPC := 'µÀÊõ'; end;
            4 : begin  sUP := 'ÊØ»¤'; sUPC := '·ÀÓù'; end;
            5 : begin  sUP := '³ýÄ§'; sUPC := 'Ä§·¨·ÀÓù'; end;
            6 : begin  sUP := '¿áº®'; sUPC := 'MAX HP,MP'; end;
          end;
          if MouseItem.S.btValue[12] > 0 then begin
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            if MouseItem.S.btValue[18] > 0 then begin
              HintList.AddObject( sUP + 'µÄ¾õÐÑ (' + IntToStr(MouseItem.S.btValue[18]) + ')', TObject(ItemColor));
              nSUM := MouseItem.S.btValue[13] + MouseItem.S.btValue[14] + MouseItem.S.btValue[15] + MouseItem.S.btValue[16] + MouseItem.S.btValue[17];
              if nSUM > 0 then begin
                if MouseItem.S.btValue[12] = 6 then
                  HintList.AddObject( sUPC + ' + ' + IntToStr(nSUM), TObject(clWhite))
                  else HintList.AddObject( sUPC + ' + ' + IntToStr(nSUM) + '~' + IntToStr(nSUM), TObject(clWhite));
              end;
            end;
            if g_boItemHint or g_bobuttHint then begin
            if MouseItem.S.btValue[13] > 0 then
              HintList.AddObject('1½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[13]) + '~' + IntToStr(MouseItem.S.btValue[13]), TObject(clWhite));
            if MouseItem.S.btValue[14] > 0 then
              HintList.AddObject('2½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[14]) + '~' + IntToStr(MouseItem.S.btValue[14]), TObject(clWhite));
            if MouseItem.S.btValue[15] > 0 then
              HintList.AddObject('3½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[15]) + '~' + IntToStr(MouseItem.S.btValue[15]), TObject(clWhite));
            if MouseItem.S.btValue[16] > 0 then
              HintList.AddObject('4½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[16]) + '~' + IntToStr(MouseItem.S.btValue[16]), TObject(clWhite));
            if MouseItem.S.btValue[17] > 0 then
              HintList.AddObject('5½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[17]) + '~' + IntToStr(MouseItem.S.btValue[17]), TObject(clWhite));
            end;
          end;

          if (MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or (MouseItem.s.Agility > 0) or (MouseItem.s.ToxAvoid > 0)
            or (MouseItem.s.MagAvoid > 0) or (MouseItem.s.HpAdd > 0) or (MouseItem.s.HpAdd > 0)
             or (MouseItem.s.RecHp > 0) or (MouseItem.s.RecMp > 0) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));

          case MouseItem.s.Need of
            0: begin
                if Actor.m_Abil.Level >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            1: begin
                if Hiword(Actor.m_Abil.DC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            2: begin
                if Hiword(Actor.m_Abil.MC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªÄ§·¨: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            3: begin
                if Hiword(Actor.m_Abil.SC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªµÀÊõ: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            6: begin
                useable := True;
                sTemp := 'ÐÐ»á³ÉÔ±×¨ÓÃ';
              end;
            60: begin
                useable := True;
                sTemp := 'ÐÐ»áÕÆÃÅ×¨ÓÃ';
              end;
            7: begin
                useable := True;
                sTemp := 'É³°Í¿Ë³ÉÔ±×¨ÓÃ';
              end;
            70: begin
                useable := True;
                sTemp := 'É³°Í¿Ë³ÇÖ÷×¨ÓÃ';
              end;
            9: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÉÔ±×¨ÓÃ';
              end;
            80: begin
                useable := True;
                sTemp := '³ÇÖ÷×¨ÓÃ';
              end;
            90: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÇÖ÷×¨ÓÃ';
              end;
            20: begin
                useable := True;
                sTemp := '»áÔ±×¨ÓÃ';
              end;
            21: begin
                useable := True;
                sTemp := 'Ðû´«ÍÅ³¤×¨ÓÃ';
              end;
            22: begin
                useable := True;
                sTemp := 'Ðû´«³ÉÔ±×¨ÓÃ';
              end;
            23: begin
                useable := True;
                sTemp := '¼ÇÕßÍÅ³¤×¨ÓÃ';
              end;
            24: begin
                useable := True;
                sTemp := '¼ÇÕß³ÉÔ±×¨ÓÃ';
              end;
            25: begin
                useable := True;
                sTemp := 'ºìÆìÍÅ³¤×¨ÓÃ';
              end;
            26: begin
                useable := True;
                sTemp := 'ºìÆì³ÉÔ±×¨ÓÃ';
              end;
          end;
          if useable then begin
            HintList.AddObject(sTemp, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp, TObject(clRed));
          end;
          if MouseItem.S.StdMode = 12 then begin
            case MouseItem.s.Shape of
              5,12,13 : begin         //°¨½ÃÀÚ,¿µÁ¤,Ç÷·æ°©ÁÖ
                if Actor.m_btJob in [0..4] then
                  Jobuseable := True
                else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: Õ½Ê¿/·¨Ê¦/µÀÊ¿/´Ì¿Í/ºÍÉÐ';
              end;
              4,6,8,15 : begin    //¹«ºÀ,Ãµ·æ,ÆÄÈ²,Èæ·æ½Å°©
                Jobuseable := True;
                sTemp2 := 'ÐèÒªÖ°Òµ: È«Ö°Òµ';
              end;
              else begin
                if Actor.m_btJob in [4, 9] then
                 Jobuseable := True
                else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ºÍÉÐ/ÆÆ½äÉ®';
              end;
            end;
          end else begin
            case MouseItem.s.Shape of
              3..8,13..18,25..27,31..33 : begin       //Àü»ç ¼ú»ç µµ»ç¿Ê¸¸
                if Actor.m_btJob in [0..2] then
                 Jobuseable := True
                else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: Õ½Ê¿/·¨Ê¦/µÀÊ¿';
              end;
              1,2,12,19,29 : begin  //Æòº¹,°æ°©,¿µÁ¤,°¨½ÃÀÚ ,Ç÷·æ
                if MouseItem.S.StdMode in [10,11] then begin
                  if Actor.m_btJob in [0..4] then
                   Jobuseable := True
                  else Jobuseable := False;
                  sTemp2 := 'ÐèÒªÖ°Òµ: Õ½Ê¿/·¨Ê¦/µÀÊ¿/´Ì¿Í/ºÍÉÐ';
                end;
              end;
              9,10,11,30,110,111 : begin     //¹«ºÀ,Ãµ·æ,ÆÄÈ²,Èæ·æ½Å°©
                Jobuseable := True;
                sTemp2 := 'ÐèÒªÖ°Òµ: È«Ö°Òµ';
              end;
              101..109,112..115 : begin
                if Actor.m_btJob in [3] then
                 Jobuseable := True
                else Jobuseable := False;
                 sTemp2 := 'ÐèÒªÖ°Òµ: ´Ì¿Í';
              end;
            end;

            if MouseItem.S.CheckNoAss then begin
               sTemp2 := 'ÐèÒªÖ°Òµ: Õ½Ê¿/·¨Ê¦/µÀÊ¿';
               if Actor.m_btJob in [0..2] then
                 Jobuseable := True
               else Jobuseable := False;
            end;

            if MouseItem.S.CheckAss then begin
               sTemp2 := 'ÐèÒªÖ°Òµ: ´Ì¿Í';
               if Actor.m_btJob in [3] then
                 Jobuseable := True
               else Jobuseable := False;
            end;

            if MouseItem.S.CheckBonze then begin
               sTemp2 := 'ÐèÒªÖ°Òµ: ºÍÉÐ/ÆÆ½äÉ®';
               if Actor.m_btJob in [4, 9] then
                 Jobuseable := True
               else Jobuseable := False;
            end;
            
            if MouseItem.S.HumUp = 1 then begin
              if Actor.m_btJob = 5 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ±ÌÑªÕ½Ê¿';
            end;
            if MouseItem.S.HumUp = 2 then begin
              if Actor.m_btJob = 6 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ºëÐþ·¨Ê¦';
            end;
            if MouseItem.S.HumUp = 3 then begin
              if Actor.m_btJob = 7 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ñ´ÏÉµÀÊ¿';
            end;
            if MouseItem.S.HumUp = 4 then begin
              if Actor.m_btJob = 8 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ·ÉÑà´Ì¿Í';
            end;
            if MouseItem.S.HumUp = 5 then begin
              if Actor.m_btJob = 9 then
                Jobuseable := True
              else Jobuseable := False;
                sTemp2 := 'ÐèÒªÖ°Òµ: ÆÆ½äÉ®';
            end;
          end;
          if Jobuseable then begin
            HintList.AddObject(sTemp2, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp2, TObject(clRed));
          end;


        end;
        15, //Åõ±¸
        19, 20, 21,  //¸ñ°ÉÀÌ
        22, 23, //¹ÝÁö
        24, 26, //ÆÈÂî
        62, 63, 64   //½Å¹ß
        : begin
          useable := False;

          if MouseItem.s.StdMode = 15 then
          HintList.AddObject('Í·¿ø', TObject(clWhite));
          if MouseItem.s.StdMode in [19..21] then
          HintList.AddObject('ÏîÁ´', TObject(clWhite));
          if MouseItem.s.StdMode in [22,23] then
          HintList.AddObject('½äÖ¸', TObject(clWhite));
          if MouseItem.s.StdMode in [24,26] then
          HintList.AddObject('ÊÖïí', TObject(clWhite));
          if MouseItem.s.StdMode in [63] then
          HintList.AddObject('ÊØ»¤Ê¯', TObject(clWhite));
          if MouseItem.s.StdMode in [62] then
          HintList.AddObject('Ñ¥×Ó', TObject(clWhite));
          if MouseItem.s.StdMode in [64] then
          HintList.AddObject('Ñü´ø', TObject(clWhite));

          if MouseItem.s.StdMode <> 63 then begin
            if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
            else  HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
          end else HintList.AddObject(Format('ÖØÁ¿ %s',[IntToStr(MouseItem.s.Weight)]), TObject(clWhite));

          if (MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.Accurate > 0) or (MouseItem.s.Agility > 0) or
             (MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or (MouseItem.s.MagAvoid > 0) or (MouseItem.s.ToxAvoid > 0) or
             (Hiword(MouseItem.S.MAC) > 0) or (Hiword(MouseItem.S.AC) > 0) or (g_MouseItem.S.AtkSpd > 0) or (MouseItem.s.Source > 0) or (MouseItem.s.WearWeight > 0) or
             (MouseItem.S.Slowdown > 0) or (MouseItem.S.Tox > 0) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));

          if MouseItem.S.StdMode in [19,20, 21] then begin   //¸ñ°ÉÀÌ ±âº»
            if MouseItem.s.AC > 0 then begin
              if MouseItem.s.btValue[3] >= 1 then
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
              else
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
            end;
            if MouseItem.s.MAC > 0 then begin
              if MouseItem.s.btValue[4] >= 1 then
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
            end;
            if (MouseItem.s.MAC > 0) or (MouseItem.s.AC > 0) then
              HintList.AddObject('¡¡',TObject(GetRGB(248)));
          end;

          if MouseItem.s.DC > 0 then begin
            if MouseItem.s.btValue[0] >= 1 then
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)) + GetJPBtStr(0,0), TObject($00EFB539))
            else
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)), TObject(clWhite));
          end;

          if MouseItem.s.MC > 0 then begin
            if MouseItem.s.btValue[1] >= 1 then
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)) + GetJPBtStr(1,0), TObject($00EFB539))
            else
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)), TObject(clWhite));
          end;

          if MouseItem.s.SC > 0 then begin
            if MouseItem.s.btValue[2] >= 1 then
              HintList.AddObject('µÀÊ¿ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)) + GetJPBtStr(2,0), TObject($00EFB539))
            else
              HintList.AddObject('µÀÊ¿ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)), TObject(clWhite));
          end;

          if MouseItem.S.StdMode = 15 then begin   //Åõ±¸
             if (MouseItem.S.Accurate > 0) then begin
               if MouseItem.s.btValue[8] >= 1 then
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(8,0), TObject($00EFB539))
               else
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate), TObject(clWhite));
             end;

             if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.Accurate > 0) or (MouseItem.s.Agility > 0)) and
             ((MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or (MouseItem.s.MagAvoid > 0) or (MouseItem.s.ToxAvoid > 0)) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));

             if MouseItem.s.AC > 0 then begin
               if MouseItem.s.btValue[3] >= 1 then
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
               else
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
             end;
             if MouseItem.s.MAC > 0 then begin
               if MouseItem.s.btValue[4] >= 1 then
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
             end;

             if MouseItem.s.Agility > 0 then begin
               HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility), TObject(clWhite));
             end;

             if MouseItem.S.MagAvoid > 0 then  begin
               if MouseItem.s.btValue[10] >= 1 then
                 HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid) + GetJPBtStr(10,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid), TObject(clWhite));
             end;
             if MouseItem.S.ToxAvoid > 0 then begin
               if MouseItem.s.btValue[9] >= 1 then
                 HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid) + GetJPBtStr(9,0), TObject($00EFB539))
               else
                 HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid), TObject(clWhite));
             end;
          end;

          if MouseItem.S.StdMode = 19 then begin   //¸ñ°ÉÀÌ Çà¿î
            {if LoWord(MouseItem.S.MAC) > 0 then begin
              if MouseItem.s.btValue[3] >= 1 then
                 HintList.AddObject('ÀúÁÖ + ' + IntToStr(Hiword(MouseItem.S.AC)) + GetJPBtStr(3,1), TObject(clRed))
              else
                 HintList.AddObject('ÀúÁÖ + ' + IntToStr(Hiword(MouseItem.S.AC)), TObject(clWhite));
            end;  }
            if MouseItem.S.Source > 0 then begin
              if MouseItem.s.btValue[10] >= 1 then
                 HintList.AddObject('ÐÒÔË + ' + IntToStr(MouseItem.S.Source) + GetJPBtStr(10,0), TObject($00EFB539))
              else
                 HintList.AddObject('ÐÒÔË + ' + IntToStr(MouseItem.S.Source), TObject(clWhite));
            end;
            if (g_MouseItem.S.AtkSpd > 0) then begin
               if MouseItem.s.btValue[17] >= 1 then
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(g_MouseItem.S.AtkSpd) + GetJPBtStr(17,0), TObject($00EFB539))
               else
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(g_MouseItem.S.AtkSpd), TObject(clWhite));
            end;
            if (MouseItem.S.Accurate > 0) then begin
              if MouseItem.s.btValue[15] >= 1 then
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(15,0), TObject($00EFB539))
              else
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate), TObject(clWhite));
            end;
            if (MouseItem.S.Slowdown > 0) then begin
               if MouseItem.s.btValue[14] >= 1 then
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown) + GetJPBtStr(14,0), TObject($00EFB539))
               else
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown), TObject(clWhite));
            end;
            if (MouseItem.S.Tox > 0) then begin
               if MouseItem.s.btValue[9] >= 1 then
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox) + GetJPBtStr(9,0), TObject($00EFB539))
               else
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox), TObject(clWhite));
            end;

            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.S.Accurate > 0) or
              (MouseItem.S.Source > 0) or (g_MouseItem.S.AtkSpd > 0) or
              (MouseItem.S.Slowdown > 0) or (MouseItem.S.Tox > 0)) and (MouseItem.s.MagAvoid > 0) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if MouseItem.S.MagAvoid > 0 then begin
             if MouseItem.s.btValue[12] >= 1 then
               HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.S.MagAvoid) + GetJPBtStr(12,0), TObject($00EFB539))
             else
               HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.S.MagAvoid), TObject(clWhite));
            end;
          end;


          if MouseItem.S.StdMode = 20 then begin   //¸ñ°ÉÀÌ ±âº»
           if (MouseItem.s.AtkSpd > 0) then begin
               if MouseItem.s.btValue[17] >= 1 then
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd) + GetJPBtStr(17,0), TObject($00EFB539))
               else
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd), TObject(clWhite));
            end;
            if (MouseItem.S.Accurate > 0) then begin
              if MouseItem.s.btValue[15] >= 1 then
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate) + GetJPBtStr(15,0), TObject($00EFB539))
              else
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate), TObject(clWhite));
            end;
            if (MouseItem.S.Slowdown > 0) then begin
               if MouseItem.s.btValue[14] >= 1 then
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown) + GetJPBtStr(14,0), TObject($00EFB539))
               else
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown), TObject(clWhite));
            end;
            if (MouseItem.S.Tox > 0) then begin
               if MouseItem.s.btValue[9] >= 1 then
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox) + GetJPBtStr(9,0), TObject($00EFB539))
               else
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox), TObject(clWhite));
            end;

            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or
              (MouseItem.s.AtkSpd > 0) or (MouseItem.S.Accurate > 0) or (MouseItem.S.Slowdown > 0) or (MouseItem.S.Tox > 0)) and
              ((MouseItem.s.Agility > 0) or (MouseItem.S.MagAvoid > 0)) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if (MouseItem.S.Agility > 0) then begin
              if MouseItem.s.btValue[16] >= 1 then
                HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.S.Agility) + GetJPBtStr(16,0), TObject($00EFB539))
              else
                HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.S.Agility), TObject(clWhite));
            end;
            if MouseItem.S.MagAvoid > 0 then  begin
              if MouseItem.s.btValue[12] >= 1 then
                HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid) + GetJPBtStr(12,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid), TObject(clWhite));
            end;
          end;

          if MouseItem.S.StdMode = 21 then begin   //¸ñ°ÉÀÌ °ø¼Ó
            if (MouseItem.s.AtkSpd > 0) then begin
               if MouseItem.s.btValue[17] >= 1 then
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd) + GetJPBtStr(17,0), TObject($00EFB539))
               else
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd), TObject(clWhite));
            end;
            if (MouseItem.S.Accurate > 0) then begin
              if MouseItem.s.btValue[15] >= 1 then
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate) + GetJPBtStr(15,0), TObject($00EFB539))
              else
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.S.Accurate), TObject(clWhite));
            end;
            if (MouseItem.S.Slowdown > 0) then begin
               if MouseItem.s.btValue[14] >= 1 then
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown) + GetJPBtStr(14,0), TObject($00EFB539))
               else
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown), TObject(clWhite));
            end;
            if (MouseItem.S.Tox > 0) then begin
               if MouseItem.s.btValue[9] >= 1 then
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox) + GetJPBtStr(9,0), TObject($00EFB539))
               else
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox), TObject(clWhite));
            end;

            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.AtkSpd > 0) or
            (MouseItem.S.Accurate > 0) or (MouseItem.S.Slowdown > 0) or (MouseItem.S.Tox > 0)) and
            ((MouseItem.s.RecHp > 0) or (HiWord(MouseItem.s.MAC) > 0)  or (MouseItem.s.MagAvoid > 0)) then
            HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if MouseItem.s.RecHp > 0 then begin
              if MouseItem.s.btValue[7] >= 1 then
                HintList.AddObject('ÉúÃü»Ö¸´ + ' + IntToStr(MouseItem.s.RecHp) + '0%' + GetJPBtStr2(7,0), TObject($00EFB539))
              else
                HintList.AddObject('ÉúÃü»Ö¸´ + ' + IntToStr(MouseItem.s.RecHp) + '0%', TObject(clWhite));
            end;
            if MouseItem.s.RecMp > 0 then begin
              if MouseItem.s.btValue[8] >= 1 then
                HintList.AddObject('Ä§·¨»Ö¸´ + ' + IntToStr(MouseItem.s.RecMp) + '0%' + GetJPBtStr2(8,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨»Ö¸´ + ' + IntToStr(MouseItem.s.RecMp) + '0%', TObject(clWhite));
            end;
            if MouseItem.S.MagAvoid > 0 then  begin
              if MouseItem.s.btValue[12] >= 1 then
                HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid) + GetJPBtStr(12,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid), TObject(clWhite));
            end;
          end;

          if MouseItem.s.StdMode = 22 then begin  //¹ÝÁö
             if MouseItem.s.AtkSpd > 0 then begin
                if MouseItem.s.btValue[16] >= 1 then
                  HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd) + GetJPBtStr(16,0), TObject($00EFB539))
                else
                  HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd), TObject(clWhite));
             end;

             if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.AtkSpd > 0)) and
             ((MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or (MouseItem.s.Slowdown > 0) or (MouseItem.s.Tox > 0)) then
              HintList.AddObject('¡¡',TObject(GetRGB(248)));


             if MouseItem.s.AC > 0 then begin
               if MouseItem.s.btValue[3] >= 1 then
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
               else
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
             end;
             if MouseItem.s.MAC > 0 then begin
               if MouseItem.s.btValue[4] >= 1 then
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
             end;

             if MouseItem.S.Slowdown > 0 then begin
               if MouseItem.s.btValue[14] >= 1 then
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown) + GetJPBtStr(14,0), TObject($00EFB539))
               else
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown), TObject(clWhite));
             end;

             if MouseItem.S.Tox > 0 then begin
               if MouseItem.s.btValue[9] >= 1 then
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox) + GetJPBtStr(9,0), TObject($00EFB539))
               else
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox), TObject(clWhite));
             end;
          end;

          if MouseItem.s.StdMode = 23 then begin  //¹ÝÁö °ø¼Ó
            if MouseItem.s.AC > 0 then begin
               if MouseItem.s.btValue[3] >= 1 then
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
               else
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
             end;
            if MouseItem.s.MAC > 0 then begin
               if MouseItem.s.btValue[4] >= 1 then
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
            end;

            if ((MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0)) and
             ((MouseItem.s.AtkSpd > 0) or (MouseItem.s.Slowdown > 0) or (MouseItem.s.Tox > 0)) then
              HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if MouseItem.s.AtkSpd > 0 then begin
              if MouseItem.s.btValue[16] >= 1 then
                HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd) + GetJPBtStr(16,0), TObject($00EFB539))
              else
                HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd), TObject(clWhite));
            end;

            if MouseItem.S.Slowdown > 0 then begin
              if MouseItem.s.btValue[14] >= 1 then
                HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown) + GetJPBtStr(14,0), TObject($00EFB539))
              else
                HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.S.Slowdown), TObject(clWhite));
            end;

            if MouseItem.S.Tox > 0 then begin
              if MouseItem.s.btValue[9] >= 1 then
                HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox) + GetJPBtStr(9,0), TObject($00EFB539))
              else
                HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.S.Tox), TObject(clWhite));
            end;

            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.AtkSpd > 0) or
              (MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or
             (MouseItem.S.Slowdown > 0) or (MouseItem.S.Tox > 0)) and ((MouseItem.s.ToxAvoid> 0) or (MouseItem.s.Source > 0)) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));


            if MouseItem.s.ToxAvoid > 0 then begin
               if MouseItem.s.btValue[13] >= 1 then
                 HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid) + GetJPBtStr(13,0), TObject($00EFB539))
               else
                 HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid), TObject(clWhite));
            end;
            if MouseItem.s.Source > 0 then begin
               if MouseItem.s.btValue[12] >= 1 then
                 HintList.AddObject('ÖÐ¶¾»Ö¸´ + ' + IntToStr(MouseItem.s.Source) + GetJPBtStr(12,0), TObject($00EFB539))
               else
                 HintList.AddObject('ÖÐ¶¾»Ö¸´ + ' + IntToStr(MouseItem.s.Source), TObject(clWhite));
            end;
          end;


          if MouseItem.s.StdMode in [24, 26] then begin  //ÆÈÂî24 26
            if (MouseItem.s.Source <= -1) and (MouseItem.s.Source >= -50) then begin
               HintList.AddObject('ÉñÊ¥ + ' + IntToStr(-MouseItem.s.Source), TObject(clWhite));
            end;
            if (MouseItem.s.Source <= -51) and (MouseItem.s.Source >= -100) then begin
              HintList.AddObject('ÉñÊ¥ - ' + IntToStr(-MouseItem.s.Source - 50), TObject(clWhite));
            end;
            if MouseItem.s.Accurate > 0 then begin
               if MouseItem.s.btValue[15] >= 1 then
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(15,0), TObject($00EFB539))
               else
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate), TObject(clWhite));
            end;

            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.Accurate > 0) or (MouseItem.s.Source <= -1)) and
            ((MouseItem.s.AC > 0) or ( MouseItem.s.MAC > 0) or (MouseItem.s.Agility > 0)) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if MouseItem.s.AC > 0 then begin
              if MouseItem.s.btValue[3] >= 1 then
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
              else
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
            end;
            if MouseItem.s.MAC > 0 then begin
              if MouseItem.s.btValue[4] >= 1 then
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
            end;
            if MouseItem.s.Agility > 0 then begin
               if MouseItem.s.btValue[16] >= 1 then
                 HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility) + GetJPBtStr(16,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility), TObject(clWhite));
            end;

          end;

          if MouseItem.s.StdMode = 62 then begin //½Å¹ß
            if MouseItem.s.AtkSpd > 0 then begin
              HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(Loword(MouseItem.s.AtkSpd)), TObject(clWhite));
            end;

            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.AtkSpd > 0)) and ((MouseItem.s.AC > 0) or
             (MouseItem.s.MAC > 0) or (MouseItem.s.Agility > 0)) and
            ((MouseItem.s.Source > 0) or (MouseItem.s.WearWeight > 0) or (MouseItem.s.Agility > 0) or (MouseItem.s.Accurate > 0)) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if MouseItem.s.AC > 0 then begin
              if MouseItem.s.btValue[3] >= 1 then
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
              else
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
            end;
            if MouseItem.s.MAC > 0 then begin
              if MouseItem.s.btValue[4] >= 1 then
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
            end;
            if MouseItem.s.Agility > 0 then begin
               if MouseItem.s.btValue[16] >= 1 then
                 HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility) + GetJPBtStr(16,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility), TObject(clWhite));
            end;
            if ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.AC > 0) or
             (MouseItem.s.MAC > 0) or (MouseItem.s.Agility > 0)) and
            ((MouseItem.s.Source > 0) or (MouseItem.s.WearWeight > 0) or (MouseItem.s.Agility > 0) or (MouseItem.s.Accurate > 0)) then
             HintList.AddObject('¡¡',TObject(GetRGB(248)));
            if MouseItem.s.Accurate > 0 then begin
               if MouseItem.s.btValue[15] >= 1 then
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(15,0), TObject($00EFB539))
               else
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate), TObject(clWhite));
            end;
            if MouseItem.s.Source > 0 then begin
              HintList.AddObject('ÍóÁ¦ + ' + IntToStr(MouseItem.s.Source), TObject(clWhite));
            end;
            if (MouseItem.s.WearWeight > 0) then begin
              HintList.AddObject('¸ºÖØ + ' + IntToStr(MouseItem.s.WearWeight), TObject(clWhite));
            end;
          end;


          if MouseItem.s.StdMode = 63 then begin  //¼öÈ£¼®
             if MouseItem.S.Source > 0 then begin
               HintList.AddObject('ÐÒÔË + ' + IntToStr(MouseItem.s.Source), TObject(clWhite));
             end;

             if MouseItem.s.AC > 0 then begin
               if MouseItem.s.btValue[3] >= 1 then
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
               else
                 HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
             end;
             if MouseItem.s.MAC > 0 then begin
               if MouseItem.s.btValue[4] >= 1 then
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
               else
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
             end;
          end;

          if MouseItem.s.StdMode = 64 then begin      //º§Æ®
            if MouseItem.s.Accurate > 0 then begin
              if MouseItem.s.btValue[15] >= 1 then
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate) + GetJPBtStr(15,0), TObject($00EFB539))
              else
                HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate), TObject(clWhite));
            end;

            if  ((MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) or (MouseItem.s.DC > 0) or (MouseItem.s.Accurate > 0)) and
             ((MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or (MouseItem.s.Agility > 0) or (MouseItem.s.ToxAvoid > 0)) then
              HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if MouseItem.s.AC > 0 then begin
              if MouseItem.s.btValue[3] >= 1 then
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
              else
                HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)), TObject(clWhite));
            end;
            if MouseItem.s.MAC > 0 then begin
              if MouseItem.s.btValue[4] >= 1 then
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
              else
                HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
            end;
            if MouseItem.s.Agility > 0 then begin
              if MouseItem.s.btValue[16] >= 1 then
                HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility) + GetJPBtStr(16,0), TObject($00EFB539))
              else
                HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility), TObject(clWhite));
            end;
            if MouseItem.s.ToxAvoid > 0 then begin
              if MouseItem.s.btValue[8] >= 1 then
                HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid) + GetJPBtStr(8,0), TObject($00EFB539))
              else
                HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid), TObject(clWhite));
            end;

            if (MouseItem.s.Source > 0) and ((MouseItem.s.AC > 0) or (MouseItem.s.MAC > 0) or (MouseItem.s.ToxAvoid > 0)
              or (MouseItem.s.Agility > 0)) then
              HintList.AddObject('¡¡',TObject(GetRGB(248)));

            if (MouseItem.s.Source > 0) then begin
              HintList.AddObject('±³°ü¸ºÖØ + ' + IntToStr(MouseItem.s.Source), TObject(clWhite));
            end;
          end;

          if (MouseItem.S.HpAdd > 0) or (MouseItem.S.MpAdd > 0) then
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.s.HpAdd > 0) then begin
            HintList.AddObject('MAXHP + ' + IntToStr(MouseItem.s.HpAdd), TObject(clWhite));
          end;
          if MouseItem.s.MpAdd > 0 then begin
            HintList.AddObject('MAXMP + ' + IntToStr(MouseItem.s.MpAdd), TObject(clWhite));
          end;

          if MouseItem.S.StdMode = 15 then begin   //Åõ±¸
            case MouseItem.S.btValue[12] of
              1 : begin  sUP := 'ÓÂÃÍ'; sUPC := '¹¥»÷'; end;
              2 : begin  sUP := 'Ä§Ê¥'; sUPC := 'Ä§·¨'; end;
              3 : begin  sUP := 'ÏÉ½ç'; sUPC := 'µÀÊõ'; end;
              4 : begin  sUP := 'ÊØ»¤'; sUPC := '·ÀÓù'; end;
              5 : begin  sUP := '³ýÄ§'; sUPC := 'Ä§·¨·ÀÓù'; end;
              6 : begin  sUP := '¿áº®'; sUPC := 'MAX HP,MP'; end;
            end;
            if MouseItem.S.btValue[12] > 0 then begin
              HintList.AddObject('¡¡',TObject(GetRGB(248)));
              if MouseItem.S.btValue[18] > 0 then begin
                HintList.AddObject( sUP + 'µÄ¾õÐÑ (' + IntToStr(MouseItem.S.btValue[18]) + ')', TObject(ItemColor));
                nSUM := MouseItem.S.btValue[13] + MouseItem.S.btValue[14] + MouseItem.S.btValue[15] + MouseItem.S.btValue[16] + MouseItem.S.btValue[17];
                if nSUM > 0 then begin
                  if MouseItem.S.btValue[12] = 6 then
                    HintList.AddObject( sUPC + ' + ' + IntToStr(nSUM), TObject(clWhite))
                  else HintList.AddObject( sUPC + ' + ' + IntToStr(nSUM) + '~' + IntToStr(nSUM), TObject(clWhite));
                end;
              end;
              if g_boItemHint or g_bobuttHint then begin
              if MouseItem.S.btValue[13] > 0 then
                HintList.AddObject('1½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[13]) + '~' + IntToStr(MouseItem.S.btValue[13]), TObject(clWhite));
              if MouseItem.S.btValue[14] > 0 then
                HintList.AddObject('2½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[14]) + '~' + IntToStr(MouseItem.S.btValue[14]), TObject(clWhite));
              if MouseItem.S.btValue[15] > 0 then
                HintList.AddObject('3½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[15]) + '~' + IntToStr(MouseItem.S.btValue[15]), TObject(clWhite));
              if MouseItem.S.btValue[16] > 0 then
                HintList.AddObject('4½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[16]) + '~' + IntToStr(MouseItem.S.btValue[16]), TObject(clWhite));
              if MouseItem.S.btValue[17] > 0 then
                HintList.AddObject('5½×¶Î: ' + sUPC + ' + ' + IntToStr(MouseItem.S.btValue[17]) + '~' + IntToStr(MouseItem.S.btValue[17]), TObject(clWhite));
              end;
            end;
          end;
          HintList.AddObject('¡¡',TObject(GetRGB(248)));

           case MouseItem.s.Need of
            0: begin
                if Actor.m_Abil.Level >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp1 := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
          end;
          if useable then begin
            HintList.AddObject(sTemp1, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp1, TObject(clRed));
          end;

          if MouseItem.S.CheckBonze then begin
            if Actor.m_btJob in [4, 9] then
              Jobuseable := True
            else Jobuseable := False;
            sTemp2 := 'ÐèÒªÖ°Òµ: ºÍÉÐ/ÆÆ½äÉ®';
          end else begin
            Jobuseable := True;
            sTemp2 := 'ÐèÒªÖ°Òµ: È«Ö°Òµ';
          end;
          if Jobuseable then begin
            HintList.AddObject(sTemp2, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp2, TObject(clRed));
          end;


          case MouseItem.s.Need of
            1: begin
                if Hiword(Actor.m_Abil.DC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            2: begin
                if Hiword(Actor.m_Abil.MC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªÄ§·¨: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            3: begin
                if Hiword(Actor.m_Abil.SC) >= MouseItem.s.NeedLevel then
                  useable := True;
                sTemp := 'ÐèÒªµÀÊõ: ' + IntToStr(MouseItem.s.NeedLevel);
              end;
            6: begin
                useable := True;
                sTemp := 'ÐÐ»á³ÉÔ±×¨ÓÃ';
              end;
            60: begin
                useable := True;
                sTemp := 'ÐÐ»áÕÆÃÅ×¨ÓÃ';
              end;
            7: begin
                useable := True;
                sTemp := 'É³°Í¿Ë³ÉÔ±×¨ÓÃ';
              end;
            70: begin
                useable := True;
                sTemp := 'É³°Í¿Ë³ÇÖ÷×¨ÓÃ';
              end;
            9: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÉÔ±×¨ÓÃ';
              end;
            80: begin
                useable := True;
                sTemp := '³ÇÖ÷×¨ÓÃ';
              end;
            90: begin
                useable := True;
                sTemp := 'ÄÏÂú³ÇÖ÷×¨ÓÃ';
              end;
            20: begin
                useable := True;
                sTemp := '»áÔ±×¨ÓÃ';
              end;
            21: begin
                useable := True;
                sTemp := 'Ðû´«ÍÅ³¤×¨ÓÃ';
              end;
            22: begin
                useable := True;
                sTemp := 'Ðû´«³ÉÔ±×¨ÓÃ';
              end;
            23: begin
                useable := True;
                sTemp := '¼ÇÕßÍÅ³¤×¨ÓÃ';
              end;
            24: begin
                useable := True;
                sTemp := '¼ÇÕß³ÉÔ±×¨ÓÃ';
              end;
            25: begin
                useable := True;
                sTemp := 'ºìÆìÍÅ³¤×¨ÓÃ';
              end;
            26: begin
                useable := True;
                sTemp := 'ºìÆì³ÉÔ±×¨ÓÃ';
              end;
            8: begin
                if (Hiword(Actor.m_Abil.DC) >= MouseItem.s.NeedLevel) then begin
                  sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
                  HintList.AddObject(sTemp, TObject(clWhite));
                end else begin
                  sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
                  HintList.AddObject(sTemp, TObject(clRed));
                end;
                if (Hiword(Actor.m_Abil.SC) >= MouseItem.s.NeedOption) then
                  useable := True;
                sTemp := 'ÐèÒªµÀÊõ: ' + IntToStr(MouseItem.s.NeedOption);
              end;
          end;
          if useable then begin
            HintList.AddObject(sTemp, TObject(clWhite));
          end else begin
            HintList.AddObject(sTemp, TObject(clRed));
          end;

        end;

        80: begin //³¬½ËÁÙ°ú ¹Ù´Ã
           useable := FALSE;
           HintList.AddObject('µöÓãÅä¼þ', TObject(clWhite));
           if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
            else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));

           HintList.AddObject('¡¡',TObject(GetRGB(248)));
           if MouseItem.S.AC > 0 then
             HintList.AddObject('Ôö¼Óµ¯ÐÔ ' + IntToStr(LoWord(MouseItem.S.AC)), TObject(clWhite));

           HintList.AddObject('¡¡',TObject(GetRGB(248)));
           if Actor.m_Abil.Level >= MouseItem.S.NeedLevel then
             useable := TRUE;
           sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
           if useable then begin
             HintList.AddObject(sTemp, TObject(clWhite));
           end else begin
             HintList.AddObject(sTemp, TObject(clRed));
           end;
         end;

         81: begin //Âî
             useable := FALSE;
             HintList.AddObject('µöÓãÅä¼þ', TObject(clWhite));
             if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
              else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));
             HintList.AddObject('¡¡',TObject(GetRGB(248)));
             if MouseItem.S.AC > 0 then
              HintList.AddObject('Ò§¹³³É¹¦ÂÊ +' + IntToStr(LoWord(MouseItem.S.AC)) + '% ~ ' + IntToStr(HiWord(MouseItem.S.AC)) + '%', TObject(clWhite));

             HintList.AddObject('¡¡',TObject(GetRGB(248)));
             if Actor.m_Abil.Level >= MouseItem.S.NeedLevel then
               useable := TRUE;
             sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
             if useable then begin
               HintList.AddObject(sTemp, TObject(clWhite));
             end else begin
               HintList.AddObject(sTemp, TObject(clRed));
             end;
         end;

         82: begin //¹Ì³¢
               useable := FALSE;
               HintList.AddObject('µöÓãÅä¼þ', TObject(clWhite));
               HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.S.Weight) + ' ÊýÁ¿ '+ IntToStr(MouseItem.Dura), TObject(clWhite));
               HintList.AddObject('¡¡',TObject(GetRGB(248)));
               if MouseItem.S.AC > 0 then
                 HintList.AddObject('µöÓã³É¹¦ÂÊ + ' + IntToStr(HiWord(MouseItem.S.AC)) + '%', TObject(clWhite));

               HintList.AddObject('¡¡',TObject(GetRGB(248)));
               if Actor.m_Abil.Level >= MouseItem.S.NeedLevel then
                 useable := TRUE;
                 sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
               if useable then begin
                 HintList.AddObject(sTemp, TObject(clWhite));
               end else begin
                 HintList.AddObject(sTemp, TObject(clRed));
               end;
         end;

         83: begin //¾î±ºÅ½Áö±â
             useable := FALSE;
             HintList.AddObject('µöÓãÅä¼þ', TObject(clWhite));
             HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.S.Weight) + ' ³Ö¾Ã '+ IntToStr(MouseItem.Dura) + '/' + IntToStr(MouseItem.DuraMax), TObject(clWhite));
             HintList.AddObject('¡¡',TObject(GetRGB(248)));
             if MouseItem.S.AC > 0 then
               HintList.AddObject('Ê§°ÜÊ±µöÓã³É¹¦ÂÊ + ' + IntToStr(LoWord(MouseItem.S.AC)) + '% ~ ' + IntToStr(HiWord(MouseItem.S.AC)) + '%', TObject(clWhite));
             HintList.AddObject('¡¡',TObject(GetRGB(248)));
             if Actor.m_Abil.Level >= MouseItem.S.NeedLevel then
               useable := TRUE;
               sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
             if useable then begin
               HintList.AddObject(sTemp, TObject(clWhite));
             end else begin
               HintList.AddObject(sTemp, TObject(clRed));
             end;
         end;

         84: begin //¸±
               useable := FALSE;
               HintList.AddObject('µöÓãÅä¼þ', TObject(clWhite));
               if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
                else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));
               HintList.AddObject('¡¡',TObject(GetRGB(248)));

               if MouseItem.S.AC > 0 then
                 HintList.AddObject('µöÓã³É¹¦ÂÊ + ' + IntToStr(HiWord(MouseItem.S.AC)) + '%', TObject(clWhite));

               if MouseItem.S.MAC > 0 then
                 HintList.AddObject('×Ô¶¯µöÓã³É¹¦ÂÊ + ' + IntToStr(HiWord(MouseItem.S.AC)) + '%', TObject(clWhite));

               HintList.AddObject('×Ô¶¯µöÓãÅä¼þÎïÆ·', TObject(clWhite));

               HintList.AddObject('¡¡',TObject(GetRGB(248)));
               if Actor.m_Abil.Level >= MouseItem.S.NeedLevel then
                 useable := TRUE;
                 sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
               if useable then begin
                 HintList.AddObject(sTemp, TObject(clWhite));
               end else begin
                 HintList.AddObject(sTemp, TObject(clRed));
               end;
         end;


      101,102, 70,71,72,73,74: //È£¶ûÀÌ  Å»°Í
             begin
               useable := FALSE;
               if MouseItem.S.StdMode in [101, 102] then
                 HintList.AddObject('×øÆï', TObject(clWhite));
               if MouseItem.S.StdMode in [70] then
                 HintList.AddObject('çÖÉþ', TObject(clWhite));
               if MouseItem.S.StdMode in [71] then
                 HintList.AddObject('Áåîõ', TObject(clWhite));
               if MouseItem.S.StdMode in [72] then
                 HintList.AddObject('°°¾ß', TObject(clWhite));
               if MouseItem.S.StdMode in [73] then
                 HintList.AddObject('ºûµû½á', TObject(clWhite));
               if MouseItem.S.StdMode in [74] then
                 HintList.AddObject('Ãæ¾ß', TObject(clWhite));

               if MouseItem.S.StdMode in [70..74] then
                 if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
                  else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDura1Str(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
               else
               if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>ÖÒ³Ï¶È %s<CE>',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
                  else HintList.AddObject(Format('ÖØÁ¿ %s ÖÒ³Ï¶È %s',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));
               HintList.AddObject('¡¡',TObject(GetRGB(248)));

               if MouseItem.S.DC > 0 then begin
                 if MouseItem.s.btValue[0] >= 1 then
                   HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)) + GetJPBtStr(0,0), TObject($00EFB539))
                 else
                   HintList.AddObject('¹¥»÷ + ' + IntToStr(LoWord(MouseItem.S.DC)) + '~' + IntToStr(HiWord(MouseItem.S.DC)), TObject(clWhite));
               end;
               if MouseItem.S.MC > 0 then begin
                 if MouseItem.s.btValue[1] >= 1 then
                   HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)) + GetJPBtStr(1,0), TObject($00EFB539))
                 else
                   HintList.AddObject('Ä§·¨ + ' + IntToStr(LoWord(MouseItem.S.MC)) + '~' + IntToStr(HiWord(MouseItem.S.MC)), TObject(clWhite));
               end;
               if MouseItem.S.SC > 0 then begin
                 if MouseItem.s.btValue[1] >= 1 then
                   HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)) + GetJPBtStr(2,0), TObject($00EFB539))
                 else
                   HintList.AddObject('µÀÊõ + ' + IntToStr(LoWord(MouseItem.S.SC)) + '~' + IntToStr(HiWord(MouseItem.S.SC)), TObject(clWhite));
               end;
               if (MouseItem.S.AC > 0) or (MouseItem.S.MAC > 0) and (MouseItem.S.DC > 0) or (MouseItem.S.MC > 0) or (MouseItem.S.SC > 0) then
               HintList.AddObject('¡¡',TObject(GetRGB(248)));

               if MouseItem.S.AC > 0 then begin
                 if MouseItem.s.btValue[3] >= 1 then
                   HintList.AddObject('·ÀÓù + ' + IntToStr(Loword(MouseItem.s.AC)) + '~' + IntToStr(Hiword(MouseItem.s.AC)) + GetJPBtStr(3,0), TObject($00EFB539))
                 else
                   HintList.AddObject('·ÀÓù + ' + IntToStr(LoWord(MouseItem.S.AC)) + '~' + IntToStr(HiWord(MouseItem.S.AC)), TObject(clWhite));
               end;
               if MouseItem.S.MAC > 0 then begin
                 if MouseItem.s.btValue[4] >= 1 then
                   HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(Loword(MouseItem.s.MAC)) + '~' + IntToStr(Hiword(MouseItem.s.MAC)) + GetJPBtStr(4,0), TObject($00EFB539))
                 else
                   HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(LoWord(MouseItem.S.MAC)) + '~' + IntToStr(HiWord(MouseItem.S.MAC)), TObject(clWhite));
               end;
               if (MouseItem.S.AC > 0) or (MouseItem.S.MAC > 0) then
               HintList.AddObject('¡¡',TObject(GetRGB(248)));
               case MouseItem.S.Need of
                  0: begin
                     if Actor.m_Abil.Level >= MouseItem.s.NeedLevel then
                       useable := True;
                       sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  1: begin
                     if Hiword(Actor.m_Abil.DC) >= MouseItem.s.NeedLevel then
                       useable := True;
                       sTemp := 'ÐèÒª¹¥»÷: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  2: begin
                    if Hiword(Actor.m_Abil.MC) >= MouseItem.s.NeedLevel then
                      useable := True;
                      sTemp := 'ÐèÒªÄ§·¨: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  3: begin
                    if Hiword(Actor.m_Abil.SC) >= MouseItem.s.NeedLevel then
                      useable := True;
                      sTemp := 'ÐèÒªµÀÊõ: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  4: begin
                    useable := True;
                    sTemp := 'Requires Rebirth Level: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  40: begin
                    useable := True;
                    sTemp := 'Requires Rebirth & Player Level: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  41: begin
                    useable := True;
                    sTemp := 'Requires Rebirth & DC: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  42: begin
                    useable := True;
                    sTemp := 'Requires Rebirth & MC: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  43: begin
                    useable := True;
                    sTemp := 'Requires Rebirth & SC: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  44: begin
                    useable := True;
                    sTemp := 'Requires Rebirth & Reputation points: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  5: begin
                    useable := True;
                    sTemp := 'Requires Reputation points: ' + IntToStr(MouseItem.s.NeedLevel);
                  end;
                  6: begin
                        useable := TRUE;
                        sTemp := ' ÐÐ»á³ÉÔ±×¨ÓÃ';
                     end;
                  60: begin
                        useable := TRUE;
                        sTemp := ' ÐÐ»áÕÆÃÅ×¨ÓÃ';
                     end;
                  7: begin
                        useable := TRUE;
                        sTemp := ' É³°Í¿Ë³ÉÔ±×¨ÓÃ';
                     end;
                  70: begin
                        useable := TRUE;
                        sTemp := ' É³°Í¿Ë³ÇÖ÷×¨ÓÃ';
                     end;
                  80: begin
                        useable := True;
                        sTemp := '³ÇÖ÷×¨ÓÃ';
                     end;
                  9: begin
                        useable := True;
                        sTemp := 'ÄÏÂú³ÉÔ±×¨ÓÃ';
                     end;
                  90: begin
                        useable := True;
                        sTemp := 'ÄÏÂú³ÇÖ÷×¨ÓÃ';
                     end;
                  20: begin
                        useable := TRUE;
                        sTemp := '»áÔ±×¨ÓÃ';
                     end;
                  21: begin
                        useable := TRUE;
                        sTemp := 'Ðû´«ÍÅ³¤×¨ÓÃ';
                     end;
                  22: begin
                        useable := TRUE;
                        sTemp := 'Ðû´«³ÉÔ±×¨ÓÃ';
                     end;
                  23: begin
                        useable := TRUE;
                        sTemp := '¼ÇÕßÍÅ³¤×¨ÓÃ';
                     end;
                  24: begin
                        useable := TRUE;
                        sTemp := '¼ÇÕß³ÉÔ±×¨ÓÃ';
                     end;
                  25: begin
                        useable := TRUE;
                        sTemp := 'ºìÆìÍÅ³¤×¨ÓÃ';
                     end;
                  26: begin
                        useable := TRUE;
                        sTemp := 'ºìÆì³ÉÔ±×¨ÓÃ';
                     end;
               end;

               if useable then begin
                 HintList.AddObject(sTemp, TObject(clWhite));
               end else begin
                 HintList.AddObject(sTemp, TObject(clRed));
               end;


             end;

      37: //º¸¿Á ½ÅÁÖ
            begin
               HintList.AddObject('±¦Óñ', TObject(clWhite));
               if LoWord(MouseItem.s.MAC) > 0 then
                 HintList.AddObject('±¦Öé', TObject(clWhite));

               HintList.AddObject(Format('ÖØÁ¿ %s',[IntToStr(MouseItem.s.Weight)]), TObject(clWhite));

               HintList.AddObject('¡¡',TObject(GetRGB(248)));

               if Loword(MouseItem.S.AC) = 0 then
                 HintList.AddObject('¹¥»÷ + ' + IntToStr(0) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 1 then
                 HintList.AddObject('Ä§·¨ + ' + IntToStr(0) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 2 then
                 HintList.AddObject('µÀÊõ + ' + IntToStr(0) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 3 then
                 HintList.AddObject('·ÀÓù + ' + IntToStr(0) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 4 then
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(0) + '~' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 5 then
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 6 then
                 HintList.AddObject('Ãô½Ý + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 15 then
                 HintList.AddObject('×¼È· + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 9 then
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 14 then
                 HintList.AddObject('¼õËÙ + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 12 then
                 HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 8 then
                 HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) = 7 then
                 HintList.AddObject('³Ö¾Ã + ' + IntToStr(Hiword(MouseItem.s.MAC)), TObject(clWhite));

               if  (Loword(MouseItem.S.AC) > 0) or (Hiword(MouseItem.S.MAC) > 0)  then
               HintList.AddObject('¡¡',TObject(GetRGB(248)));


               HintList.AddObject('°´×¡ Ctrl ¼ü²¢Ñ¡ÔñÐèÒªÇ¿»¯µÄÎïÆ·', TObject(clWhite));


               case Loword(MouseItem.S.AC) of
                  0..2: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÎäÆ÷¡¢ÏîÁ´¡¢½äÖ¸¡¢ÊÖïí', TObject(clWhite));
                     end;
                  3, 4: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ½äÖ¸¡¢ÊÖïí¡¢ÒÂ·þ¡¢Í·¿ø¡¢Ñü´ø¡¢Ñ¥×Ó', TObject(clWhite));
                     end;
                  7: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ËùÓÐ×°±¸', TObject(clWhite));
                     end;
                  5: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÎäÆ÷¡¢ÏîÁ´¡¢½äÖ¸', TObject(clWhite));
                     end;
                  6: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÊÖïí¡¢ÒÂ·þ¡¢Ñü´ø¡¢Ñ¥×Ó', TObject(clWhite));
                     end;
                  15: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÏîÁ´¡¢ÊÖïí¡¢Í·¿ø¡¢Ñü´ø', TObject(clWhite));
                     end;
                  9,14: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÎäÆ÷¡¢ÏîÁ´¡¢½äÖ¸', TObject(clWhite));
                     end;
                  12: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÏîÁ´¡¢ÒÂ·þ¡¢Í·¿ø', TObject(clWhite));
                     end;
                  8: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÒÂ·þ¡¢Í·¿ø¡¢Ñü´ø', TObject(clWhite));
                     end;
               end;
            end;

      59, 60, 61: //º¸¿Á ½ÅÁÖ
            begin

               if MouseItem.s.StdMode in [59] then
                 HintList.AddObject('ÐÞÀí', TObject(clWhite));
               if MouseItem.s.StdMode in [60] then
                 HintList.AddObject('±¦Óñ', TObject(clWhite));
               if MouseItem.s.StdMode in [61] then
                 HintList.AddObject('±¦Öé', TObject(clWhite));

               HintList.AddObject(Format('ÖØÁ¿ %s',[IntToStr(MouseItem.s.Weight)]), TObject(clWhite));

               HintList.AddObject('¡¡',TObject(GetRGB(248)));

               if Loword(MouseItem.S.DC) > 0 then
                 HintList.AddObject('¹¥»÷ + ' + IntToStr(0) + '~' + IntToStr(Loword(MouseItem.s.DC)), TObject(clWhite));
               if Loword(MouseItem.S.MC) > 0 then
                 HintList.AddObject('Ä§·¨ + ' + IntToStr(0) + '~' + IntToStr(Loword(MouseItem.s.MC)), TObject(clWhite));
               if Loword(MouseItem.S.SC) > 0 then
                 HintList.AddObject('µÀÊõ + ' + IntToStr(0) + '~' + IntToStr(Loword(MouseItem.s.SC)), TObject(clWhite));
               if Loword(MouseItem.S.AC) > 0 then
                 HintList.AddObject('·ÀÓù + ' + IntToStr(0) + '~' + IntToStr(Loword(MouseItem.s.AC)), TObject(clWhite));
               if Loword(MouseItem.S.MAC) > 0 then
                 HintList.AddObject('Ä§·¨·ÀÓù + ' + IntToStr(0) + '~' + IntToStr(Loword(MouseItem.s.MAC)), TObject(clWhite));
               if MouseItem.S.AtkSpd > 0 then
                 HintList.AddObject('¹¥»÷ËÙ¶È + ' + IntToStr(MouseItem.s.AtkSpd), TObject(clWhite));
               if MouseItem.S.Agility > 0 then
                 HintList.AddObject('Ãô½Ý + ' + IntToStr(MouseItem.s.Agility), TObject(clWhite));
               if MouseItem.S.Accurate > 0 then
                 HintList.AddObject('×¼È· + ' + IntToStr(MouseItem.s.Accurate), TObject(clWhite));
               if MouseItem.S.Tox > 0 then
                 HintList.AddObject('ÖÐ¶¾ + ' + IntToStr(MouseItem.s.Tox), TObject(clWhite));
               if MouseItem.S.SlowDown > 0 then
                 HintList.AddObject('¼õËÙ + ' + IntToStr(MouseItem.s.SlowDown), TObject(clWhite));
               if MouseItem.S.MagAvoid > 0 then
                 HintList.AddObject('Ä§·¨¶ã±Ü + ' + IntToStr(MouseItem.s.MagAvoid), TObject(clWhite));
               if MouseItem.S.ToxAvoid > 0 then
                 HintList.AddObject('¶¾Îï¶ã±Ü + ' + IntToStr(MouseItem.s.ToxAvoid), TObject(clWhite));
               if MouseItem.DuraMax > 0 then
                 HintList.AddObject('³Ö¾Ã + ' + IntToStr(MouseItem.DuraMax div 1000), TObject(clWhite));

               if (Loword(MouseItem.S.DC) > 0) or (Loword(MouseItem.S.MC) > 0) or (Loword(MouseItem.S.SC) > 0) or (Loword(MouseItem.S.AC) > 0) or
                 (Loword(MouseItem.S.MAC) > 0) or (MouseItem.S.AtkSpd > 0) or (MouseItem.S.Agility > 0) or (MouseItem.S.Accurate > 0) or (MouseItem.S.Tox > 0) or (MouseItem.S.SlowDown > 0) or
                  (MouseItem.S.MagAvoid > 0) or (MouseItem.S.ToxAvoid > 0) or (MouseItem.DuraMax > 0) then
               HintList.AddObject('¡¡',TObject(GetRGB(248)));

               if MouseItem.S.Shape in [20,21] then begin
                 HintList.AddObject('°´×¡ Ctrl ¼ü²¢Ñ¡ÔñÐèÒªÐÞÀíµÄÎïÆ·', TObject(clWhite));
               end else
               if MouseItem.S.Shape in [22,23] then begin
                 HintList.AddObject('°´×¡ Ctrl ¼ü²¢Ñ¡ÔñÐèÒªÌØÊâÐÞÀíµÄÎïÆ·', TObject(clWhite));
               end else
                 HintList.AddObject('°´×¡ Ctrl ¼ü²¢Ñ¡ÔñÐèÒªÇ¿»¯µÄÎïÆ·', TObject(clWhite));


               case MouseItem.S.Shape of
                  1..3: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÎäÆ÷¡¢ÏîÁ´¡¢½äÖ¸¡¢ÊÖïí', TObject(clWhite));
                     end;
                  4, 5: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ½äÖ¸¡¢ÊÖïí¡¢Í·¿ø¡¢ÒÂ·þ¡¢Ñü´ø¡¢Ñ¥×Ó', TObject(clWhite));
                     end;
                  6: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ËùÓÐ×°±¸', TObject(clWhite));
                     end;
                  7: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÎäÆ÷¡¢ÏîÁ´¡¢½äÖ¸', TObject(clWhite));
                     end;
                  8: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÊÖïí¡¢ÒÂ·þ¡¢Ñü´ø¡¢Ñ¥×Ó', TObject(clWhite));
                     end;
                  9: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÏîÁ´¡¢ÊÖïí¡¢Í·¿ø¡¢Ñü´ø', TObject(clWhite));
                     end;
                  10,11: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÎäÆ÷¡¢ÏîÁ´¡¢½äÖ¸', TObject(clWhite));
                     end;
                  12: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÏîÁ´¡¢ÒÂ·þ¡¢Í·¿ø', TObject(clWhite));
                     end;
                  13: begin
                      HintList.AddObject('Ç¿»¯ÀàÐÍ: ÒÂ·þ¡¢Í·¿ø¡¢Ñü´ø', TObject(clWhite));
                     end;
                  20,22: begin
                      HintList.AddObject('ÐÞÀíÀàÐÍ: ÒÂ·þ¡¢Í·¿ø¡¢Ñü´ø¡¢Ñ¥×Ó', TObject(clWhite));
                     end;
                  21,23: begin
                      HintList.AddObject('ÐÞÀíÀàÐÍ: ÏîÁ´¡¢½äÖ¸¡¢ÊÖïí', TObject(clWhite));
                     end;
               end;
            end;





      25: begin   //ºÎÀû, µ¶°¡·ç
          case MouseItem.s.Shape of
             1, 2: HintList.AddObject('¶¾·Û', TObject(clWhite));
             5, 6: HintList.AddObject('»¤Éí·û', TObject(clWhite));
             7, 8: HintList.AddObject('»¤Éí·û & ¶¾·Û', TObject(clWhite));
             10: HintList.AddObject('½ðÉíÉáÀû', TObject(clWhite));
          end;

          HintList.AddObject('ÖØÁ¿ ' + IntToStr(g_MouseItem.S.Weight) + ' Ê¹ÓÃ ' + GetDura10Str(MouseItem.Dura, MouseItem.DuraMax), TObject(clWhite));
          if (MouseItem.s.DC > 0) or (MouseItem.s.MC > 0) or (MouseItem.s.SC > 0) then begin
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            if MouseItem.s.DC > 0 then
              HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)), TObject(clWhite));
            if MouseItem.s.MC > 0 then
              HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)), TObject(clWhite));
            if MouseItem.s.SC > 0 then
              HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)), TObject(clWhite));
          end;

          if MouseItem.s.Shape = 10 then begin       //Áø½Å»ç¸®
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            case MouseItem.S.Need of
             0: begin
                if Actor.m_Abil.Level >= MouseItem.s.NeedLevel then
                  useable := True
                else useable := False;
                  sTemp := 'ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel);
               end;

            end;
            if useable then begin
              HintList.AddObject(sTemp, TObject(clWhite));
            end else begin
              HintList.AddObject(sTemp, TObject(clRed));
            end;

            if MouseItem.S.CheckBonze then begin
              if Actor.m_btJob in [4, 9] then
                Jobuseable := True
              else Jobuseable := False;
              sTemp2 := 'ÐèÒªÖ°Òµ: ºÍÉÐ/ÆÆ½äÉ®';
            end else begin
              Jobuseable := True;
              sTemp2 := 'ÐèÒªÖ°Òµ: È«Ö°Òµ';
            end;

            if Jobuseable then begin
              HintList.AddObject(sTemp2, TObject(clWhite));
            end else begin
              HintList.AddObject(sTemp2, TObject(clRed));
            end;
          end;
        end;

      30: begin  //È¶ºÒ

        HintList.AddObject('»ð¾æ', TObject(clWhite));
        if MouseItem.Dura <= 0 then HintList.AddObject(Format('ÖØÁ¿ %s <CO$FF>³Ö¾Ã %s<CE>',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite))
         else HintList.AddObject(Format('ÖØÁ¿ %s ³Ö¾Ã %s',[IntToStr(MouseItem.s.Weight),GetDuraStr(MouseItem.Dura, MouseItem.DuraMax)]), TObject(clWhite));

        if (MouseItem.S.DC > 0) or (MouseItem.S.MC > 0) or (MouseItem.S.SC > 0) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));

          if MouseItem.s.DC > 0 then begin
            line2 := '¹¥»÷' + IntToStr(Loword(MouseItem.s.DC)) + '-' + IntToStr(Hiword(MouseItem.s.DC)) + ' ';
            HintList.AddObject('¹¥»÷ + ' + IntToStr(Loword(MouseItem.s.DC)) + '~' + IntToStr(Hiword(MouseItem.s.DC)), TObject(clWhite));
          end;

          if MouseItem.s.MC > 0 then begin
            line2 := line2 + 'Ä§·¨' + IntToStr(Loword(MouseItem.s.MC)) + '-' + IntToStr(Hiword(MouseItem.s.MC)) + ' ';
            HintList.AddObject('Ä§·¨ + ' + IntToStr(Loword(MouseItem.s.MC)) + '~' + IntToStr(Hiword(MouseItem.s.MC)), TObject(clWhite));
          end;

          if MouseItem.s.SC > 0 then begin
            line2 := line2 + 'µÀÊõ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)) + ' ';
            HintList.AddObject('µÀÊõ + ' + IntToStr(Loword(MouseItem.s.SC)) + '~' + IntToStr(Hiword(MouseItem.s.SC)), TObject(clWhite));
          end;
        if (MouseItem.S.HpAdd > 0) or (MouseItem.S.MpAdd > 0) then
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if (MouseItem.s.HpAdd > 0) then begin
            HintList.AddObject('MAXHP + ' + IntToStr(MouseItem.s.HpAdd), TObject(clWhite));
          end;
          if MouseItem.s.MpAdd > 0 then begin
            HintList.AddObject('MAXMP + ' + IntToStr(MouseItem.s.MpAdd), TObject(clWhite));
          end;
      end;
      36: begin    //Àç·áÅÛ
          HintList.AddObject('ÈÎÎñ' , TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' +  IntToStr(MouseItem.S.Weight) , TObject(clWhite));
        end;
      40:  begin   //°í±âµ¢¾î¸®
          HintList.AddObject('²ÄÁÏ', TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight) + ' Æ·ÖÊ ' + GetDuraStr(MouseItem.Dura, MouseItem.DuraMax), TObject(clWhite));
        end;
      42:  begin  //¾àÀç·á
          HintList.AddObject('²ÄÁÏ' , TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('¶¾Ò©³É·Ö', TObject(116));
        end;
      43: begin   //±¤¼®
          HintList.AddObject('Àç·á', TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight) + ' ´¿¶È ' + IntToStr(Round(MouseItem.Dura / 1000)), TObject(clWhite));
        end;
      45: begin    //Àç·áÅÛ
          UseLevel := False;
          case MouseItem.s.Shape of
             1: HintList.AddObject('´«ËÍ¾í', TObject(clWhite));
             2, 3: HintList.AddObject('ÌØÊâÓÃÍ¾', TObject(clWhite));
             else
              HintList.AddObject('²ÄÁÏ' , TObject(clWhite));
          end;
          HintList.AddObject('ÖØÁ¿ ' +  IntToStr((MouseItem.S.Weight * MouseItem.Amount) div 2) + ' ÊýÁ¿ ' + IntToStr(MouseItem.Amount) , TObject(clWhite));

          if (MouseItem.S.Shape in [2, 3]) then begin   //°í¼º
            HintList.AddObject('¡¡',TObject(GetRGB(248)));
            if (Actor.m_Abil.Level >= MouseItem.s.NeedLevel) then
              UseLevel := True;
            if UseLevel then begin
              HintList.AddObject('ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel), TObject(clWhite));
            end else begin
              HintList.AddObject('ÐèÒªµÈ¼¶: ' + IntToStr(MouseItem.s.NeedLevel), TObject(clRed));
            end;
            HintList.AddObject('ÐèÒªÖ°Òµ: È«Ö°Òµ', TObject(clWhite));
          end;

        end;
      46: begin    //°¢¼º
          HintList.AddObject('ÌØÊâÓÃÍ¾' , TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' +  IntToStr((MouseItem.S.Weight * MouseItem.Amount) div 2) + ' ÊýÁ¿ ' + IntToStr(MouseItem.Amount) , TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('ÐèÒªÖ°Òµ: È«Ö°Òµ', TObject(clWhite));
        end;
      47: begin    //Àç·áÅÛ
          HintList.AddObject('ÌØÊâ²ÄÁÏ' , TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' +  IntToStr(MouseItem.S.Weight) , TObject(clWhite));
        end;
      48: begin
          HintList.AddObject('×°ÊÎÎïÆ·' , TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          if FindDecoration(g_MouseITem.Dura) <> nil then begin
            HintList.AddObject('Íâ¹Û ' + FindDecoration(g_MouseItem.Dura).Name, TObject(clWhite));
            case FindDecoration(g_MouseItem.Dura).Location of
                0: HintList.AddObject('Ö»ÄÜÉèÖÃÔÚÍâ²¿', TObject(clWhite));
                1: HintList.AddObject('Ö»ÄÜÉèÖÃÔÚÄÚ²¿', TObject(clWhite));
                2: HintList.AddObject('ÄÚ²¿¡¢Íâ²¿¶¼ÄÜÉèÖÃ', TObject(clWhite));
            end;
          end;

        end;
      49: begin
          HintList.AddObject('ÒøÆ±' , TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' + IntToStr((MouseItem.S.Weight * MouseItem.Amount) div 2) + ' ÊýÁ¿ ' + IntToStr(MouseItem.Amount) , TObject(clWhite));
        end; //
      31: begin  //Æ¯¼ö¾ÆÀÌÅÛ
          HintList.AddObject('´òÀ¦', TObject(clWhite));
          HintList.AddObject('ÖØÁ¿ ' +  IntToStr(MouseItem.S.Weight), TObject(clWhite));
          HintList.AddObject('¡¡',TObject(GetRGB(248)));
          HintList.AddObject('ÐèÒªÖ°Òµ: È«Ö°Òµ', TObject(clWhite));
        end;
    else begin
        HintList.AddObject('ÖØÁ¿ ' + IntToStr(MouseItem.s.Weight), TObject(clWhite));
      end;
    end;

    end;

    if MouseItem.s.btValue[19] > 0 then begin
      HintList.AddObject('¡¡',TObject(GetRGB(248)));
      if MouseItem.S.btValue[19] = 2 then begin   //¹ÝÂ¦
        if now > UnixToDateTime(MouseItem.S.MaxDate) then
          HintList.AddObject('Ê¹ÓÃÊ±¼ä ' + FormatDateTime('yyyyÄê mmÔÂ ddÈÕ hhÊ± nn·Ö', UnixToDateTime(MouseItem.S.MaxDate)), TObject(clRed))
        else
          HintList.AddObject('Ê¹ÓÃÊ±¼ä ' + FormatDateTime('yyyyÄê mmÔÂ ddÈÕ hhÊ± nn·Ö', UnixToDateTime(MouseItem.S.MaxDate)), TObject(clYellow));
      end;
      if MouseItem.S.btValue[19] = 1 then begin   //´ë¿©
        if MouseItem.S.Owner <> '' then
          HintList.AddObject('ÓµÓÐÕß '+ MouseItem.S.Owner + ' ×âÁÞÊ±¼ä ' + FormatDateTime('mmÔÂddÈÕ hhÊ±nn·Ö' , UnixToDateTime(MouseItem.S.MaxDate)), TObject(clYellow))
        else HintList.AddObject('×âÁÞÊ±¼ä ' + FormatDateTime('mmÔÂddÈÕ hhÊ±nn·Ö' , UnixToDateTime(MouseItem.S.MaxDate)), TObject(clYellow))
      end;
      if (MouseItem.s.btValue[19] > 2) and (now < UnixToDateTime(DateTimeToUnix(MouseItem.S.MaxDate))) then begin    //ºÀÀÎ
        HintList.AddObject('·âÓ¡Ê±¼ä ' + FormatDateTime('yyyyÄê mmÔÂ ddÈÕ hhÊ± nn·Ö', UnixToDateTime(MouseItem.S.MaxDate)), TObject(clRed))
      end;
    end;

    if ((not MouseItem.S.boCanTrade) or (not MouseItem.S.boCanRepair) or (not MouseItem.S.boCanSell) or (not MouseItem.S.boCanHeroBag)
      or (MouseItem.S.boOnlyHero) or (MouseItem.S.boCompound)
      or (not MouseItem.S.DisassembleItem) or MouseItem.S.NonStuff or MouseItem.S.Unique) and (g_boItemHint or g_bobuttHint) then begin
      HintList.AddObject('¡¡',TObject(GetRGB(248)));

      if MouseItem.S.Unique then
       HintList.AddObject('½ûÖ¹Ç¿»¯', TObject(clYellow));
      if not MouseItem.S.boCanRepair then
       HintList.AddObject('½ûÖ¹ÐÞÀí', TObject(clYellow));
      if not MouseItem.S.boCanTrade then
       HintList.AddObject('½ûÖ¹½»Ò×', TObject(clYellow));
      if not MouseItem.S.boCanSell then
       HintList.AddObject('½ûÖ¹³öÊÛ', TObject(clYellow));
      if MouseItem.S.boOnlyHero then
       HintList.AddObject('Ó¢ÐÛ×¨ÓÃ', TObject(clYellow));
      if not MouseItem.S.DisassembleItem then
       HintList.AddObject('½ûÖ¹·Ö½â', TObject(clYellow));
      if MouseItem.S.NonStuff then
       HintList.AddObject('½ûÖ¹ºÏ³É', TObject(clYellow));
      if not MouseItem.S.boCanHeroBag then
       HintList.AddObject('½ûÖ¹Ó¢ÐÛÊ¹ÓÃ', TObject(clYellow));
      if MouseItem.S.boCompound then
       HintList.AddObject('ºÏ³É²ÄÁÏ', TObject(clLime));
    end;

    if (MouseItem.S.StdMode in [0,1,3,45,46,49]) and (MouseItem.s.MaxAmount > 0) then begin
      HintList.AddObject('¡¡',TObject(GetRGB(248)));
      HintList.AddObject('ÔÊÐíµþ¼ÓµÄ×î´óÊýÁ¿: ' + IntToStr(MouseItem.s.MaxAmount), TObject(clWhite));
      HintList.AddObject('Shift + µã»÷Êó±ê×ó¼ü·ÖÀëÎïÆ·', TObject(clWhite));
    end;

    g_ExtractStringList.Clear;
    sItemDesc := GetItemDesc(MouseItem.S.Name);
    if (sItemDesc <> '') and (not g_boSetHint) then begin
      HintList.AddObject('¡¡',TObject(GetRGB(248)));
      if Pos('\', sItemDesc) > 0 then begin
        ExtractStrings(['\'], [' '], PChar(sItemDesc), g_ExtractStringList);
        if g_ExtractStringList.Count > 0 then begin
          HintList.AddObject(g_ExtractStringList.Strings[0], TObject(GetRGB(116)));
        end;
        for I := 1 to g_ExtractStringList.Count - 1 do begin
          HintList.AddObject(g_ExtractStringList.Strings[I], TObject(GetRGB(116)));
        end;
      end else begin
        g_ExtractStringList.Add(sItemDesc);
        HintList.AddObject(sItemDesc, TObject(GetRGB(116)));
      end;
    end;

    if g_SetItemsList.Count > 0 then begin
      for g := 0 to g_SetItemsList.Count - 1 do begin
        SetItem := pTSetItems(g_SetItemsList[g]);
        for j := Low(SetItem.Items) to High(SetItem.Items) do begin
          if (SetItem.Items[j] <> '') and (CompareText(SetItem.Items[j], MouseItem.S.Name) = 0) and (not SetItem.HideValue) then begin
            if g_boSetHint then begin
              HintList.AddObject('¡¡',TObject(GetRGB(248)));
              HintList.AddObject('ÎïÆ·ÐÅÏ¢',TObject(clWhite));
              boOK := True;
              if actor = g_MySelf then begin
                if MySex = 1 then begin
                  if (SetItem.Items[U_BUJUK] <> '') or (SetItem.Items[U_WEAPON] <> '') then begin
                    if (SetItem.Items[U_BUJUK] <> '') and (g_UseItems[U_DRESS].s.Name = SetItem.Items[U_BUJUK]) then begin  //¿Ê¼Â ¿Ê Âø¿ëÁß
                      if (SetItem.Items[U_WEAPON] <> '') then begin //¹«±â¼Âµµ ÀÖ´Ù.
                        if (g_UseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±âÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin  //¹«±â ¹ÌÂø¿ë
                          HintList.AddObject('<CO$6BBD4A>[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '<CE>  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin //¹«±â¼Â ¾ø°í ¿Ê¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÒÂ·þ]   ' + SetItem.Items[U_BUJUK], TObject(GetRGB(204)));
                      end;
                    end else
                    if (SetItem.Items[U_WEAPON] <> '') and (g_UseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±â¼Â ¹«±â Âø¿ëÁß
                      if (SetItem.Items[U_BUJUK] <> '') then begin //¿Ê¼Âµµ ÀÖ´Ù.
                        if (g_UseItems[U_DRESS].s.Name = SetItem.Items[U_BUJUK]) then begin //¿Ê Âø¿ëÁß
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin //¿Ê ¹ÌÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  <CO$6BBD4A>[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON] + '<CE>', TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin  //¿Ê¼Â ¾ø°í ¹«±â¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                      end;
                    end else begin
                      if (SetItem.Items[U_BUJUK] <> '') and (SetItem.Items[U_WEAPON] = '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_BUJUK] = '') then begin
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_BUJUK] <> '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end else begin
                  if (SetItem.Items[U_DRESS] <> '') or (SetItem.Items[U_WEAPON] <> '') then begin
                    if (SetItem.Items[U_DRESS] <> '') and (g_UseItems[U_DRESS].s.Name = SetItem.Items[U_DRESS]) then begin  //¿Ê¼Â ¿Ê Âø¿ëÁß
                      if (SetItem.Items[U_WEAPON] <> '') then begin //¹«±â¼Âµµ ÀÖ´Ù.
                        if (g_UseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±âÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin  //¹«±â ¹ÌÂø¿ë
                          HintList.AddObject('<CO$6BBD4A>[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '<CE>  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin //¹«±â¼Â ¾ø°í ¿Ê¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS], TObject(GetRGB(204)));
                      end;
                    end else
                    if (SetItem.Items[U_WEAPON] <> '') and (g_UseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±â¼Â ¹«±â Âø¿ëÁß
                      if (SetItem.Items[U_DRESS] <> '') then begin //¿Ê¼Âµµ ÀÖ´Ù.
                        if (g_UseItems[U_DRESS].s.Name = SetItem.Items[U_DRESS]) then begin //¿Ê Âø¿ëÁß
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin //¿Ê ¹ÌÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  <CO$6BBD4A>[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON] + '<CE>', TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin  //¿Ê¼Â ¾ø°í ¹«±â¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                      end;
                    end else begin
                      if (SetItem.Items[U_DRESS] <> '') and (SetItem.Items[U_WEAPON] = '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_DRESS] = '') then begin
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_DRESS] <> '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end;

                if (SetItem.Items[U_HELMET] <> '') or (SetItem.Items[U_NECKLACE] <> '') then begin
                  if (SetItem.Items[U_HELMET] <> '') and (g_UseItems[U_HELMET].s.Name = SetItem.Items[U_HELMET]) then begin  //Çï¸ä¼Â Çï¸ä Âø¿ëÁß
                    if (SetItem.Items[U_NECKLACE] <> '') then begin //¸ñ°ÉÀÌ¼Âµµ ÀÖ´Ù.
                      if (g_UseItems[U_NECKLACE].s.Name = SetItem.Items[U_NECKLACE]) then begin //¸ñ°ÉÀÌÂø¿ë
                        HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(204)));
                      end else begin  //¸ñ°ÉÀÌ ¹ÌÂø¿ë
                        HintList.AddObject('<CO$6BBD4A>[Í·¿ø]    ' + SetItem.Items[U_HELMET] + '<CE>  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin //¸ñ°ÉÀÌ¼Â ¾ø°í Çï¸ä¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_NECKLACE] <> '') and (g_UseItems[U_NECKLACE].s.Name = SetItem.Items[U_NECKLACE]) then begin //¸ñ°ÉÀÌ¼Â ¸ñ°ÉÀÌ Âø¿ëÁß
                    if (SetItem.Items[U_HELMET] <> '') then begin //Çï¸ä¼Âµµ ÀÖ´Ù.
                      if (g_UseItems[U_HELMET].s.Name = SetItem.Items[U_HELMET]) then begin //Çï¸ä Âø¿ëÁß
                        HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(204)));
                      end else begin //Çï¸ä ¹ÌÂø¿ë
                        HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  <CO$6BBD4A>[ÏîÁ´] ' + SetItem.Items[U_NECKLACE] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin  //Çï¸ä¼Â ¾ø°í ¸ñ°ÉÀÌ¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_HELMET] <> '') and (SetItem.Items[U_NECKLACE] = '') then begin
                      HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_NECKLACE] <> '') and (SetItem.Items[U_HELMET] = '') then begin
                      HintList.AddObject('[ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_NECKLACE] <> '') and (SetItem.Items[U_HELMET] <> '') then begin
                      HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                  end;
                end;

                if (SetItem.Items[U_ARMRINGL] <> '') or (SetItem.Items[U_ARMRINGR] <> '') then begin
                  if (SetItem.Items[U_ARMRINGL] <> '') and (g_UseItems[U_ARMRINGL].s.Name = SetItem.Items[U_ARMRINGL]) then begin
                    if (SetItem.Items[U_ARMRINGR] <> '') then begin
                      if (g_UseItems[U_ARMRINGR].s.Name = SetItem.Items[U_ARMRINGR]) then begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  <CO$6BBD4A>[ÊÖïí]  ' + SetItem.Items[U_ARMRINGR] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_ARMRINGL] <> '') and (g_UseItems[U_ARMRINGR].s.Name = SetItem.Items[U_ARMRINGL]) then begin
                    if (SetItem.Items[U_ARMRINGR] <> '') then begin
                      if (g_UseItems[U_ARMRINGL].s.Name = SetItem.Items[U_ARMRINGR]) then begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('<CO$6BBD4A>[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '<CE>  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_ARMRINGL] <> '') and (SetItem.Items[U_ARMRINGR] = '') then begin
                      HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_ARMRINGR] <> '') then begin
                      if (g_UseItems[U_ARMRINGL].s.Name = SetItem.Items[U_ARMRINGR]) or (g_UseItems[U_ARMRINGR].s.Name = SetItem.Items[U_ARMRINGR]) then begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end;
                if (SetItem.Items[U_RINGL] <> '') or (SetItem.Items[U_RINGR] <> '') then begin
                  if (SetItem.Items[U_RINGL] <> '') and (g_UseItems[U_RINGL].s.Name = SetItem.Items[U_RINGL]) then begin
                    if (SetItem.Items[U_RINGR] <> '') then begin
                      if (g_UseItems[U_RINGR].s.Name = SetItem.Items[U_RINGR]) then begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  <CO$6BBD4A>[½äÖ¸]  ' + SetItem.Items[U_RINGR] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_RINGL] <> '') and (g_UseItems[U_RINGR].s.Name = SetItem.Items[U_RINGL]) then begin
                    if (SetItem.Items[U_RINGR] <> '') then begin
                      if (g_UseItems[U_RINGL].s.Name = SetItem.Items[U_RINGR]) then begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('<CO$6BBD4A>[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '<CE>  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_RINGL] <> '')  and (SetItem.Items[U_RINGR] = '') then begin
                      HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_RINGR] <> '') then begin
                      if (g_UseItems[U_RINGL].s.Name = SetItem.Items[U_RINGR]) or (g_UseItems[U_RINGR].s.Name = SetItem.Items[U_RINGR]) then begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end;

                if (SetItem.Items[U_BELT] <> '') or (SetItem.Items[U_BOOTS] <> '') then begin
                  if (SetItem.Items[U_BELT] <> '') and (g_UseItems[U_BELT].s.Name = SetItem.Items[U_BELT]) then begin  //º§Æ®¼Â º§Æ® Âø¿ëÁß
                    if (SetItem.Items[U_BOOTS] <> '') then begin //½Å¹ß¼Âµµ ÀÖ´Ù.
                      if (g_UseItems[U_BOOTS].s.Name = SetItem.Items[U_BOOTS]) then begin //½Å¹ßÂø¿ë
                        HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(204)));
                      end else begin  //½Å¹ß ¹ÌÂø¿ë
                        HintList.AddObject('<CO$6BBD4A>[Ñü´ø]  ' + SetItem.Items[U_BELT] + '<CE>  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin //½Å¹ß¼Â ¾ø°í º§Æ®¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_BOOTS] <> '') and (g_UseItems[U_BOOTS].s.Name = SetItem.Items[U_BOOTS]) then begin //½Å¹ß¼Â ½Å¹ß Âø¿ëÁß
                    if (SetItem.Items[U_BELT] <> '') then begin //º§Æ®¼Âµµ ÀÖ´Ù.
                      if (g_UseItems[U_BELT].s.Name = SetItem.Items[U_BELT]) then begin //º§Æ® Âø¿ëÁß
                        HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  [½Å¹ß]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(204)));
                      end else begin //º§Æ® ¹ÌÂø¿ë
                        HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  <CO$6BBD4A>[½Å¹ß]  ' + SetItem.Items[U_BOOTS] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin  //º§Æ®¼Â ¾ø°í ½Å¹ß¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_BELT] <> '') and (SetItem.Items[U_BOOTS] = '') then begin
                      HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_BOOTS] <> '') and (SetItem.Items[U_BELT] = '') then begin
                      HintList.AddObject('[Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_BOOTS] <> '') and (SetItem.Items[U_BELT] <> '') then begin
                      HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                  end;
                end;

                if (SetItem.Items[U_CHARM] <> '') then begin
                  if (g_UseItems[U_CHARM].s.Name = SetItem.Items[U_CHARM]) then begin
                    HintList.AddObject('[ÊØ»¤Ê¯]  ' + SetItem.Items[U_CHARM], TObject(GetRGB(204)));
                  end else begin
                    HintList.AddObject('[ÊØ»¤Ê¯]  ' + SetItem.Items[U_CHARM], TObject(GetRGB(248)));
                    boOK := False;
                  end;
                end;

              end else begin
                if MySex = 1 then begin
                  if (SetItem.Items[U_BUJUK] <> '') or (SetItem.Items[U_WEAPON] <> '') then begin
                    if (SetItem.Items[U_BUJUK] <> '') and (g_HeroUseItems[U_DRESS].s.Name = SetItem.Items[U_BUJUK]) then begin  //¿Ê¼Â ¿Ê Âø¿ëÁß
                      if (SetItem.Items[U_WEAPON] <> '') then begin //¹«±â¼Âµµ ÀÖ´Ù.
                        if (g_HeroUseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±âÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin  //¹«±â ¹ÌÂø¿ë
                          HintList.AddObject('<CO$6BBD4A>[¿Ê]  ' + SetItem.Items[U_BUJUK] + '<CE>  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin //¹«±â¼Â ¾ø°í ¿Ê¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÒÂ·þ]   ' + SetItem.Items[U_BUJUK], TObject(GetRGB(204)));
                      end;
                    end else
                    if (SetItem.Items[U_WEAPON] <> '') and (g_HeroUseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±â¼Â ¹«±â Âø¿ëÁß
                      if (SetItem.Items[U_BUJUK] <> '') then begin //¿Ê¼Âµµ ÀÖ´Ù.
                        if (g_HeroUseItems[U_DRESS].s.Name = SetItem.Items[U_BUJUK]) then begin //¿Ê Âø¿ëÁß
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin //¿Ê ¹ÌÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  <CO$6BBD4A>[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON] + '<CE>', TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin  //¿Ê¼Â ¾ø°í ¹«±â¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                      end;
                    end else begin
                      if (SetItem.Items[U_BUJUK] <> '') and (SetItem.Items[U_WEAPON] = '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_BUJUK] = '') then begin
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_BUJUK] <> '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_BUJUK] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end else begin
                  if (SetItem.Items[U_DRESS] <> '') or (SetItem.Items[U_WEAPON] <> '') then begin
                    if (SetItem.Items[U_DRESS] <> '') and (g_HeroUseItems[U_DRESS].s.Name = SetItem.Items[U_DRESS]) then begin  //¿Ê¼Â ¿Ê Âø¿ëÁß
                      if (SetItem.Items[U_WEAPON] <> '') then begin //¹«±â¼Âµµ ÀÖ´Ù.
                        if (g_HeroUseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±âÂø¿ë
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin  //¹«±â ¹ÌÂø¿ë
                          HintList.AddObject('<CO$6BBD4A>[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '<CE>  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin //¹«±â¼Â ¾ø°í ¿Ê¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS], TObject(GetRGB(204)));
                      end;
                    end else
                    if (SetItem.Items[U_WEAPON] <> '') and (g_HeroUseItems[U_WEAPON].s.Name = SetItem.Items[U_WEAPON]) then begin //¹«±â¼Â ¹«±â Âø¿ëÁß
                      if (SetItem.Items[U_DRESS] <> '') then begin //¿Ê¼Âµµ ÀÖ´Ù.
                        if (g_HeroUseItems[U_DRESS].s.Name = SetItem.Items[U_DRESS]) then begin //¿Ê Âø¿ëÁß
                          HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                        end else begin //¿Ê ¹ÌÂø¿ë
                          HintList.AddObject('[¿Ê]  ' + SetItem.Items[U_DRESS] + '  -  <CO$6BBD4A>[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON] + '<CE>', TObject(GetRGB(248)));
                          boOK := False;
                        end;
                      end else begin  //¿Ê¼Â ¾ø°í ¹«±â¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(204)));
                      end;
                    end else begin
                      if (SetItem.Items[U_DRESS] <> '') and (SetItem.Items[U_WEAPON] = '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_DRESS] = '') then begin
                        HintList.AddObject('[ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                      if (SetItem.Items[U_WEAPON] <> '') and (SetItem.Items[U_DRESS] <> '') then begin
                        HintList.AddObject('[ÒÂ·þ]  ' + SetItem.Items[U_DRESS] + '  -  [ÎäÆ÷]  ' + SetItem.Items[U_WEAPON], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end;

                if (SetItem.Items[U_HELMET] <> '') or (SetItem.Items[U_NECKLACE] <> '') then begin
                  if (SetItem.Items[U_HELMET] <> '') and (g_HeroUseItems[U_HELMET].s.Name = SetItem.Items[U_HELMET]) then begin  //Çï¸ä¼Â Çï¸ä Âø¿ëÁß
                    if (SetItem.Items[U_NECKLACE] <> '') then begin //¸ñ°ÉÀÌ¼Âµµ ÀÖ´Ù.
                      if (g_HeroUseItems[U_NECKLACE].s.Name = SetItem.Items[U_NECKLACE]) then begin //¸ñ°ÉÀÌÂø¿ë
                        HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(204)));
                      end else begin  //¸ñ°ÉÀÌ ¹ÌÂø¿ë
                        HintList.AddObject('<CO$6BBD4A>[Í·¿ø]    ' + SetItem.Items[U_HELMET] + '<CE>  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin //¸ñ°ÉÀÌ¼Â ¾ø°í Çï¸ä¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_NECKLACE] <> '') and (g_HeroUseItems[U_NECKLACE].s.Name = SetItem.Items[U_NECKLACE]) then begin //¸ñ°ÉÀÌ¼Â ¸ñ°ÉÀÌ Âø¿ëÁß
                    if (SetItem.Items[U_HELMET] <> '') then begin //Çï¸ä¼Âµµ ÀÖ´Ù.
                      if (g_HeroUseItems[U_HELMET].s.Name = SetItem.Items[U_HELMET]) then begin //Çï¸ä Âø¿ëÁß
                        HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(204)));
                      end else begin //Çï¸ä ¹ÌÂø¿ë
                        HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  <CO$6BBD4A>[ÏîÁ´] ' + SetItem.Items[U_NECKLACE] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin  //Çï¸ä¼Â ¾ø°í ¸ñ°ÉÀÌ¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_HELMET] <> '') and (SetItem.Items[U_NECKLACE] = '') then begin
                      HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_NECKLACE] <> '') and (SetItem.Items[U_HELMET] = '') then begin
                      HintList.AddObject('[ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_NECKLACE] <> '') and (SetItem.Items[U_HELMET] <> '') then begin
                      HintList.AddObject('[Í·¿ø]  ' + SetItem.Items[U_HELMET] + '  -  [ÏîÁ´] ' + SetItem.Items[U_NECKLACE], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                  end;
                end;

                if (SetItem.Items[U_ARMRINGL] <> '') or (SetItem.Items[U_ARMRINGR] <> '') then begin
                  if (SetItem.Items[U_ARMRINGL] <> '') and (g_HeroUseItems[U_ARMRINGL].s.Name = SetItem.Items[U_ARMRINGL]) then begin
                    if (SetItem.Items[U_ARMRINGR] <> '') then begin
                      if (g_HeroUseItems[U_ARMRINGR].s.Name = SetItem.Items[U_ARMRINGR]) then begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  <CO$6BBD4A>[ÊÖïí]  ' + SetItem.Items[U_ARMRINGR] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_ARMRINGL] <> '') and (g_HeroUseItems[U_ARMRINGR].s.Name = SetItem.Items[U_ARMRINGL]) then begin
                    if (SetItem.Items[U_ARMRINGR] <> '') then begin
                      if (g_HeroUseItems[U_ARMRINGL].s.Name = SetItem.Items[U_ARMRINGR]) then begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('<CO$6BBD4A>[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '<CE>  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_ARMRINGL] <> '') and (SetItem.Items[U_ARMRINGR] = '') then begin
                      HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_ARMRINGR] <> '') then begin
                      if (g_HeroUseItems[U_ARMRINGL].s.Name = SetItem.Items[U_ARMRINGR]) or (g_HeroUseItems[U_ARMRINGR].s.Name = SetItem.Items[U_ARMRINGR]) then begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[ÊÖïí]  ' + SetItem.Items[U_ARMRINGL] + '  -  [ÊÖïí]  ' + SetItem.Items[U_ARMRINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end;
                if (SetItem.Items[U_RINGL] <> '') or (SetItem.Items[U_RINGR] <> '') then begin
                  if (SetItem.Items[U_RINGL] <> '') and (g_HeroUseItems[U_RINGL].s.Name = SetItem.Items[U_RINGL]) then begin
                    if (SetItem.Items[U_RINGR] <> '') then begin
                      if (g_HeroUseItems[U_RINGR].s.Name = SetItem.Items[U_RINGR]) then begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  <CO$6BBD4A>[½äÖ¸]  ' + SetItem.Items[U_RINGR] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_RINGL] <> '') and (g_HeroUseItems[U_RINGR].s.Name = SetItem.Items[U_RINGL]) then begin
                    if (SetItem.Items[U_RINGR] <> '') then begin
                      if (g_HeroUseItems[U_RINGL].s.Name = SetItem.Items[U_RINGR]) then begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('<CO$6BBD4A>[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '<CE>  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin
                      HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_RINGL] <> '')  and (SetItem.Items[U_RINGR] = '') then begin
                      HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_RINGR] <> '') then begin
                      if (g_HeroUseItems[U_RINGL].s.Name = SetItem.Items[U_RINGR]) or (g_HeroUseItems[U_RINGR].s.Name = SetItem.Items[U_RINGR]) then begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(204)));
                      end else begin
                        HintList.AddObject('[½äÖ¸]  ' + SetItem.Items[U_RINGL] + '  -  [½äÖ¸]  ' + SetItem.Items[U_RINGR], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end;
                  end;
                end;

                if (SetItem.Items[U_BELT] <> '') or (SetItem.Items[U_BOOTS] <> '') then begin
                  if (SetItem.Items[U_BELT] <> '') and (g_HeroUseItems[U_BELT].s.Name = SetItem.Items[U_BELT]) then begin  //º§Æ®¼Â º§Æ® Âø¿ëÁß
                    if (SetItem.Items[U_BOOTS] <> '') then begin //½Å¹ß¼Âµµ ÀÖ´Ù.
                      if (g_HeroUseItems[U_BOOTS].s.Name = SetItem.Items[U_BOOTS]) then begin //½Å¹ßÂø¿ë
                        HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(204)));
                      end else begin  //½Å¹ß ¹ÌÂø¿ë
                        HintList.AddObject('<CO$6BBD4A>[Ñü´ø]  ' + SetItem.Items[U_BELT] + '<CE>  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin //½Å¹ß¼Â ¾ø°í º§Æ®¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT], TObject(GetRGB(204)));
                    end;
                  end else
                  if (SetItem.Items[U_BOOTS] <> '') and (g_HeroUseItems[U_BOOTS].s.Name = SetItem.Items[U_BOOTS]) then begin //½Å¹ß¼Â ½Å¹ß Âø¿ëÁß
                    if (SetItem.Items[U_BELT] <> '') then begin //º§Æ®¼Âµµ ÀÖ´Ù.
                      if (g_HeroUseItems[U_BELT].s.Name = SetItem.Items[U_BELT]) then begin //º§Æ® Âø¿ëÁß
                        HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(204)));
                      end else begin //º§Æ® ¹ÌÂø¿ë
                        HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  <CO$6BBD4A>[Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS] + '<CE>', TObject(GetRGB(248)));
                        boOK := False;
                      end;
                    end else begin  //º§Æ®¼Â ¾ø°í ½Å¹ß¼Â¸¸ ÀÖÀ¸¸ç Âø¿ëÁß
                      HintList.AddObject('[Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(204)));
                    end;
                  end else begin
                    if (SetItem.Items[U_BELT] <> '') and (SetItem.Items[U_BOOTS] = '') then begin
                      HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_BOOTS] <> '') and (SetItem.Items[U_BELT] = '') then begin
                      HintList.AddObject('[Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                    if (SetItem.Items[U_BOOTS] <> '') and (SetItem.Items[U_BELT] <> '') then begin
                      HintList.AddObject('[Ñü´ø]  ' + SetItem.Items[U_BELT] + '  -  [Ñ¥×Ó]  ' + SetItem.Items[U_BOOTS], TObject(GetRGB(248)));
                      boOK := False;
                    end;
                  end;
                end;

                if (SetItem.Items[U_CHARM] <> '') then begin
                  if (g_HeroUseItems[U_CHARM].s.Name = SetItem.Items[U_CHARM]) then begin
                    HintList.AddObject('[ÊØ»¤Ê¯]  ' + SetItem.Items[U_CHARM], TObject(GetRGB(204)));
                  end else begin
                    HintList.AddObject('[ÊØ»¤Ê¯]  ' + SetItem.Items[U_CHARM], TObject(GetRGB(248)));
                    boOK := False;
                  end;
                end;
              end;
              ShowString := '';
              if boOK then sNameColor := '$21ADEF'
              else sNameColor := '$808080';

              if (SetItem.Value[1] > 0) and (SetItem.Value[4] <= 0) then
               ShowString := ShowString + '¹¥»÷ + ' + IntToStr(SetItem.Value[1]) + '~' + IntToStr(SetItem.Value[4]) + ' ';
              if (SetItem.Value[2] > 0) and (SetItem.Value[5] <= 0) then
               ShowString := ShowString + 'Ä§·¨ + ' + IntToStr(SetItem.Value[2]) + '~' + IntToStr(SetItem.Value[5]) + ' ';
              if (SetItem.Value[3] > 0) and (SetItem.Value[6] <= 0) then
               ShowString := ShowString + 'µÀÊõ + ' + IntToStr(SetItem.Value[3]) + '~' + IntToStr(SetItem.Value[6]) + ' ';
              if (SetItem.Value[7] > 0) and (SetItem.Value[9] <= 0) then
               ShowString := ShowString + '·ÀÓù + ' + IntToStr(SetItem.Value[7]) + '~' + IntToStr(SetItem.Value[9]) + ' ';
              if (SetItem.Value[8] > 0) and (SetItem.Value[10] <= 0) then
               ShowString := ShowString + 'Ä§·¨·ÀÓù + ' + IntToStr(SetItem.Value[8]) + '~' + IntToStr(SetItem.Value[10]) + ' ';
              for k := Low(SetItem.Value) to High(SetItem.Value) do begin
                if (SetItem.Value[k] > 0) then begin
                  case k of
                    4: ShowString := ShowString + '¹¥»÷ + ' + IntToStr(SetItem.Value[1]) + '~' + IntToStr(SetItem.Value[4]) + ' ';
                    5: ShowString := ShowString + 'Ä§·¨ + ' + IntToStr(SetItem.Value[2]) + '~' + IntToStr(SetItem.Value[5]) + ' ';
                    6: ShowString := ShowString + 'µÀÊõ + ' + IntToStr(SetItem.Value[3]) + '~' + IntToStr(SetItem.Value[6]) + ' ';
                    9: ShowString := ShowString + '·ÀÓù + ' + IntToStr(SetItem.Value[7]) + '~' + IntToStr(SetItem.Value[9]) + ' ';
                    10: ShowString := ShowString + 'Ä§·¨·ÀÓù + ' + IntToStr(SetItem.Value[8]) + '~' + IntToStr(SetItem.Value[10]) + ' ';
                    11: ShowString := ShowString + '×¼È· + ' + IntToStr(SetItem.Value[k]) + ' ';
                    12: ShowString := ShowString + 'Ãô½Ý + ' + IntToStr(SetItem.Value[k]) + ' ';
                    13: ShowString := ShowString + 'MaxHP + ' + IntToStr(SetItem.Value[k]) + ' ';
                    14: ShowString := ShowString + 'MaxMP + ' + IntToStr(SetItem.Value[k]) + ' ';
                    15: ShowString := ShowString + 'ÉúÃü»Ö¸´ + ' + IntToStr(SetItem.Value[k]) + '0%' + ' ';
                    16: ShowString := ShowString + 'Ä§·¨»Ö¸´ + ' + IntToStr(SetItem.Value[k]) + '0%' + ' ';
                    17: ShowString := ShowString + 'ÖÐ¶¾»Ö¸´ + ' + IntToStr(SetItem.Value[k]) + '0%' + ' ';
                    18: ShowString := ShowString + 'Ä§·¨¶ã±Ü + ' + IntToStr(SetItem.Value[k]) + ' ';
                    19: ShowString := ShowString + '¶¾Îï¶ã±Ü + ' + IntToStr(SetItem.Value[k]) + ' ';
                    20: ShowString := ShowString + 'ÐÒÔË + ' + IntToStr(SetItem.Value[k]) + ' ';
                    21: ShowString := ShowString + '¸ºÖØ + ' + IntToStr(SetItem.Value[k]) + ' ';
                    22: ShowString := ShowString + '±³°ü¸ºÖØ + ' + IntToStr(SetItem.Value[k]) + ' ';
                    23: ShowString := ShowString + 'ÍóÁ¦ + ' + IntToStr(SetItem.Value[k]) + ' ';
                    25: ShowString := ShowString + 'MP -> HP + ' + IntToStr(SetItem.Value[k]) + ' ';
                    24: ShowString := ShowString + '¹¥»÷ËÙ¶È + ' + IntToStr(SetItem.Value[k]) + ' ';
                    26: ShowString := ShowString + 'ÃâÖúÅÜ' + ' ';
                    27: ShowString := ShowString + 'ÉúÃüÎüÊÕ + ' + IntToStr(SetItem.Value[k]) + '%' + ' ';
                    28: ShowString := ShowString + 'Ä§·¨ÎüÊÕ + ' + IntToStr(SetItem.Value[k]) + '%' + ' ';
                    29: ShowString := ShowString + 'ÉñÊ¥ + ' + IntToStr(SetItem.Value[k]) + ' ';
                    30: ShowString := ShowString + 'HP + ' + IntToStr(SetItem.Value[k]) + '%' + ' ';
                    31: ShowString := ShowString + '´«ËÍ¹¦ÄÜ ';
                    32: ShowString := ShowString + 'Âé±Ô¹¦ÄÜ ';
                    33: ShowString := ShowString + '»¤Éí¹¦ÄÜ ';
                    34: ShowString := ShowString + '¹¥»÷Á¦ + ' + IntToStr(SetItem.Value[k]) + '%' + ' ';
                    35: ShowString := ShowString + '¾­ÑéÖµ + ' + IntToStr(SetItem.Value[k]) + '%' + ' ';
                    else begin
                      ShowString := ShowString + '';
                    end;
                  end;
                end;
              end;
              if (ShowString <> '') then begin
                HintList.AddObject('¡¡',TObject(GetRGB(248)));
                HintList.AddObject('Ì××°Ð§¹û',TObject(clWhite));
                AddBoardString(ShowString, sNameColor);
              end;
              if (CompareText(SetItem.Items[j], Mouseitem.S.Name) = 0) then break;
            end else begin
              if z > 0 then continue;
              HintList.AddObject('¡¡',TObject(GetRGB(248)));
              HintList.AddObject('²é¿´Ì××°Ð§¹û: Alt¼ü',TObject(clYellow));
              inc(z);
              break;
            end;
          end;
        end;
      end;
    end;
end;


procedure TFrmDlg.GetGrowInfo (var iname: sItemMome;idx: integer);    //¹®ÆÄ¼ºÀå
var
  i: integer;
begin
   if g_MySelf = nil then exit;
   for i:=0 to 50 do begin
    iname.sItemopes[i]:='';
    iname.nColor[i] := -1;
   end;
   if idx = 1 then begin
     case GuildGrow1.GrowHP of
      0: begin
        iname.sItemopes[0] := 'ÉúÃü';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎÉú´æÕ½¶·£¬Ôö¼Ó×î´óµÄÉúÃü';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÖµÊýÁ¿¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'ÏÂÒ»µÈ¼¶';
        iname.nColor[4] := clWhite;
        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;
        iname.sItemopes[6] := 'Ð§¹û: ×î´óHP +20';
        iname.nColor[6] := clWhite;
      end;
      1..4: begin
        iname.sItemopes[0] := 'ÉúÃü';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎÉú´æÕ½¶·£¬Ôö¼Ó×î´óµÄÉúÃü';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÖµÊýÁ¿¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'ÏÂÒ»µÈ¼¶';
        iname.nColor[4] := clWhite;
        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;
        iname.sItemopes[6] := 'Ð§¹û: ×î´óHP +' + inttoStr(20 *  GuildGrow1.GrowHP);
        iname.nColor[6] := clWhite;
      end;
      5:begin
        iname.sItemopes[0] := 'ÉúÃü';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎÉú´æÕ½¶·£¬Ôö¼Ó×î´óµÄÉúÃü';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÖµÊýÁ¿¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'Ð§¹û: ×î´óHP +' + inttoStr(20 *  GuildGrow1.GrowHP);
        iname.nColor[4] := clWhite;
      end;
     end;
   end;

   if idx = 2 then begin
     case GuildGrow1.GrowMP of
      0: begin
        iname.sItemopes[0] := 'Ä§Á¦';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := '¼ÓÉî¶ÔÄ§Á¦µÄÀí½â£¬Ôö¼ÓÄ§Á¦×î´óÖµ¡£';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := ' ';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := 'ÏÂÒ»µÈ¼¶';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;
        iname.sItemopes[5] := 'Ð§¹û: ×î´óMP +20';
        iname.nColor[5] := clWhite;
      end;
      1..4:begin
        iname.sItemopes[0] := 'Ä§Á¦';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := '¼ÓÉî¶ÔÄ§Á¦µÄÀí½â£¬Ôö¼ÓÄ§Á¦×î´óÖµ¡£';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := ' ';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := 'ÏÂÒ»µÈ¼¶';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;
        iname.sItemopes[5] := 'Ð§¹û: ×î´óMP +' + inttoStr(20 *  GuildGrow1.GrowMP);
        iname.nColor[5] := clWhite;
      end;
      5:begin
        iname.sItemopes[0] := 'Ä§Á¦';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := '¼ÓÉî¶ÔÄ§Á¦µÄÀí½â£¬Ôö¼ÓÄ§Á¦×î´óÖµ¡£';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := ' ';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := 'Ð§¹û: ×î´óMP +' + inttoStr(20 *  GuildGrow1.GrowMP);
        iname.nColor[3] := clWhite;
      end;
     end;
   end;

   if idx = 3 then begin
     case GuildGrow1.GrowEXP of
      0:begin
        iname.sItemopes[0] := 'ÀÏÁ·';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := 'ÐÐ»á³ÉÔ±µÄ»ý¼«ÐÔÔö¼Ó£¬»ñµÃµÄPC¾­Ñé';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÖµÔö¼Ó¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ10¼¶';
        if GuildGrow1.GuildLevel < 10 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: PC EXP +4%';
        iname.nColor[6] := clWhite;
      end;
      1..4:begin
        iname.sItemopes[0] := 'ÀÏÁ·';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'ÐÐ»á³ÉÔ±µÄ»ý¼«ÐÔÔö¼Ó£¬»ñµÃµÄPC¾­Ñé';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÖµÔö¼Ó¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ10¼¶';
        if GuildGrow1.GuildLevel < 10 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: PC EXP +' + inttoStr(4 *  GuildGrow1.GrowEXP) + '%';
        iname.nColor[6] := clWhite;
      end;
      5: begin
        iname.sItemopes[0] := 'ÀÏÁ·';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'ÐÐ»á³ÉÔ±µÄ»ý¼«ÐÔÔö¼Ó£¬»ñµÃµÄPC¾­Ñé';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÖµÔö¼Ó¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'Ð§¹û: PC EXP +' + inttoStr(4 *  GuildGrow1.GrowEXP) + '%';
        iname.nColor[4] := clWhite;
      end;
     end;
   end;

   if idx = 4 then begin
     case GuildGrow1.GrowAC of
      0:begin
        iname.sItemopes[0] := 'ÈÌÄÍ';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎ³ÐÊÜÎïÀí¹¥»÷£¬Ê¹×ÔÉíµÄ·ÀÓùÁ¦';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'µÃµ½ÌáÉý¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ5¼¶';
        if GuildGrow1.GuildLevel < 5 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: AC +2';
        iname.nColor[6] := clWhite;
      end;
      1..4: begin
        iname.sItemopes[0] := 'ÈÌÄÍ';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎ³ÐÊÜÎïÀí¹¥»÷£¬Ê¹×ÔÉíµÄ·ÀÓùÁ¦';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'µÃµ½ÌáÉý¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ5¼¶';
        if GuildGrow1.GuildLevel < 5 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: AC +' + inttoStr(2 *  GuildGrow1.GrowAC);
        iname.nColor[6] := clWhite;
      end;
      5: begin
        iname.sItemopes[0] := 'ÈÌÄÍ';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎ³ÐÊÜÎïÀí¹¥»÷£¬Ê¹×ÔÉíµÄ·ÀÓùÁ¦';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'µÃµ½ÌáÉý¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'Ð§¹û: AC +' + inttoStr(2 *  GuildGrow1.GrowAC);
        iname.nColor[4] := clWhite;
      end;
     end;
   end;

   if idx = 5 then begin
     case GuildGrow1.GrowMAC of
      0:begin
        iname.sItemopes[0] := 'Ú¤Ïë';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎ³ÐÊÜÄ§·¨¹¥»÷£¬Ê¹×ÔÉíµÄÄ§·¨·À';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÓùÁ¦µÃµ½ÌáÉý¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ5¼¶';
        if GuildGrow1.GuildLevel < 5 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: MAC +2';
        iname.nColor[6] := clWhite;
      end;
      1..4:begin
        iname.sItemopes[0] := 'Ú¤Ïë';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎ³ÐÊÜÄ§·¨¹¥»÷£¬Ê¹×ÔÉíµÄÄ§·¨·À';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÓùÁ¦µÃµ½ÌáÉý¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ5¼¶';
        if GuildGrow1.GuildLevel < 5 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: MAC +' + inttoStr(2 *  GuildGrow1.GrowMAC);
        iname.nColor[6] := clWhite;
      end;
      5:begin
        iname.sItemopes[0] := 'Ú¤Ïë';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Ñ§»áÈçºÎ³ÐÊÜÄ§·¨¹¥»÷£¬Ê¹×ÔÉíµÄÄ§·¨·À';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÓùÁ¦µÃµ½ÌáÉý¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'Ð§¹û: MAC +' + inttoStr(2 *  GuildGrow1.GrowMAC);
        iname.nColor[4] := clWhite;
      end;
     end;
   end;

   if idx = 6 then begin
     case GuildGrow1.GrowPower of
      0:begin
        iname.sItemopes[0] := 'ÓÂÃÍ';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := 'Æ¾½èÓÂÃÍµÄ¾«ÉñÔö¼Ó×Ô¼ºµÄ¹¥»÷Á¦¡£';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := ' ';
        iname.nColor[2] := clWhite;

        iname.sItemopes[3] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ10¼¶';
        if GuildGrow1.GuildLevel < 10 then iname.nColor[3] := $000000DF
        else iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'Ð§¹û: ¹¥»÷ +6';
        iname.nColor[5] := clWhite;
      end;
      1..4:begin
        iname.sItemopes[0] := 'ÓÂÃÍ';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Æ¾½èÓÂÃÍµÄ¾«ÉñÔö¼Ó×Ô¼ºµÄ¹¥»÷Á¦¡£';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := ' ';
        iname.nColor[2] := clWhite;

        iname.sItemopes[3] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ10¼¶';
        if GuildGrow1.GuildLevel < 10 then iname.nColor[3] := $000000DF
        else iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'Ð§¹û: ¹¥»÷ +' + inttoStr(5 + GuildGrow1.GrowPower);
        iname.nColor[5] := clWhite;
      end;
      5:begin
        iname.sItemopes[0] := 'ÓÂÃÍ';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'Æ¾½èÓÂÃÍµÄ¾«ÉñÔö¼Ó×Ô¼ºµÄ¹¥»÷Á¦¡£';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := ' ';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := 'Ð§¹û: ¹¥»÷ +' + inttoStr(5 + GuildGrow1.GrowPower);
        iname.nColor[3] := clWhite;
      end;
     end;
   end;

   if idx = 7 then begin
     case GuildGrow1.GrowLuck of
      0: begin
        iname.sItemopes[0] := 'ÐÒÔË';
        iname.nColor[0] := $000000DF;
        iname.sItemopes[1] := 'ÐÐ»á³ÉÔ±µÃµ½ÔËÆø£¬»ñµÃ¶îÍâµÄÐÒÔË£¬Ö»';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÓÐµÈ¼¶´ïµ½5¼¶ÒÔÉÏ²ÅÄÜµÃµ½ÐÒÔË¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ15¼¶';
        if GuildGrow1.GuildLevel < 15 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: ÐÒÔË +1';
        iname.nColor[6] := clWhite;
      end;
      1..4: begin
        iname.sItemopes[0] := 'ÐÒÔË';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'ÐÐ»á³ÉÔ±µÃµ½ÔËÆø£¬»ñµÃ¶îÍâµÄÐÒÔË£¬Ö»';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÓÐµÈ¼¶´ïµ½5¼¶ÒÔÉÏ²ÅÄÜµÃµ½ÐÒÔË¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;

        iname.sItemopes[4] := 'ÐèÒªµÈ¼¶: ÐÐ»áµÈ¼¶´óÓÚ15¼¶';
        if GuildGrow1.GuildLevel < 15 then iname.nColor[4] := $000000DF
        else iname.nColor[4] := clWhite;

        iname.sItemopes[5] := 'ÐèÒªÐÐ»á¼¼ÄÜµã: 1';
        if GuildGrow1.GuildPoint < 1 then iname.nColor[5] := $000000DF
        else iname.nColor[5] := clWhite;

        iname.sItemopes[6] := 'Ð§¹û: ÐÒÔË +1';
        iname.nColor[6] := clWhite;
      end;
      5: begin
        iname.sItemopes[0] := 'ÐÒÔË';
        iname.nColor[0] := $00B58431;
        iname.sItemopes[1] := 'ÐÐ»á³ÉÔ±µÃµ½ÔËÆø£¬»ñµÃ¶îÍâµÄÐÒÔË£¬Ö»';
        iname.nColor[1] := clWhite;
        iname.sItemopes[2] := 'ÓÐµÈ¼¶´ïµ½5¼¶ÒÔÉÏ²ÅÄÜµÃµ½ÐÒÔË¡£';
        iname.nColor[2] := clWhite;
        iname.sItemopes[3] := ' ';
        iname.nColor[3] := clWhite;
        iname.sItemopes[4] := 'Ð§¹û: ÐÒÔË +1';
        iname.nColor[4] := clWhite;
      end;
     end;
   end;
end;


{----------------------------------------------------------}
procedure TFrmDlg.GetMouseMagicInfo(var Magim:nMagicType);   //¹«°øÁ¤º¸
var
  i: integer;
  sItemDesc : String;
begin
  if g_MySelf = nil then exit;
    for i:=0 to 12 do begin
     Magim.MagicStr[i] := '';
     Magim.StrColor[i] := -1;
    end;

  if g_MagicItem.Def.sMagicName <> '' then begin

     Magim.MagicStr[0] := '[<CO$FFFFFF>'+g_MagicItem.Def.sMagicName+'<CE>]' +
     '                            '+ 'Lv. ' + inttostr(g_MagicItem.Level);;
     Magim.StrColor[0] := clYellow;

     g_ExtractStringList.Clear;
     sItemDesc := GetMagicDesc(g_MagicItem.Def.sMagicName);
     if (sItemDesc <> '')  then begin
      if Pos('\', sItemDesc) > 0 then begin
        ExtractStrings(['\'], [' '], PChar(sItemDesc), g_ExtractStringList);
        for I := 0 to g_ExtractStringList.Count - 1 do begin
          Magim.MagicStr[i + 1] := g_ExtractStringList.Strings[i];
          Magim.StrColor[i + 1] := clYellow;
        end;
       end else begin
         g_ExtractStringList.Add(sItemDesc);
       end;
     end;
     if g_MagicItem.Def.wMimicID in [13,14,15,16,17,18,19,30,41,46,49,75,79,87,95,96,101,105] then begin
       if ((g_UseItems[U_BUJUK].S.StdMode = 25) and (g_UseItems[U_BUJUK].S.Shape = 5))
         or ((g_UseItems[U_ARMRINGL].S.StdMode = 25) and (g_UseItems[U_ARMRINGL].S.Shape = 5)) then
        Magim.StrColor[2] := clYellow
       else Magim.StrColor[2] := clRed;
     end;

     if g_MagicItem.Def.wMimicID in [54] then begin
       if ((g_UseItems[U_BUJUK].S.StdMode = 25) and (g_UseItems[U_BUJUK].S.Shape = 6))
         or ((g_UseItems[U_ARMRINGL].S.StdMode = 25) and (g_UseItems[U_ARMRINGL].S.Shape = 6)) then
        Magim.StrColor[2] := clYellow
       else Magim.StrColor[2] := clRed;
     end;

     if g_MagicItem.Def.wMimicID in [60,62,63,70,71,72,76,88,102,106,110] then begin
       if g_UseItems[U_WEAPON].S.StdMode = 99 then
        Magim.StrColor[2] := clYellow
       else Magim.StrColor[2] := clRed;
     end;

     if g_MagicItem.Def.wMimicID in [113,115,116,118,127,129] then begin    //Áø½Å»ç¸® ¹ý·û¿¬°ø ³ªÇÑ±â°ø È£½Å°­±â ºñ°ÝÀå °­È£¼ú
       if ((g_UseItems[U_BUJUK].S.StdMode = 25) and (g_UseItems[U_BUJUK].S.Shape = 10))
         or ((g_UseItems[U_ARMRINGL].S.StdMode = 25) and (g_UseItems[U_ARMRINGL].S.Shape = 10)) then
        Magim.StrColor[2] := clYellow
       else Magim.StrColor[2] := clRed;
     end;

     if g_MagicItem.Level < 3 then begin
       Magim.MagicStr[11] := '[¿ÉÐÞÁ¶µÈ¼¶: '+'Lv'+inttostr(g_MagicItem.Def.TrainLevel[g_MagicItem.Level+1])+']';
       Magim.StrColor[11] := clLime;
       if g_MagicItem.Def.MaxTrain[g_MagicItem.Level] > 0 then begin
         Magim.MagicStr[12] := 'ÐÞÁ¶Öµ ' + inttostr(g_MagicItem.CurTrain) +'/' + IntToStr(g_MagicItem.Def.MaxTrain[g_MagicItem.Level]) ;
         Magim.StrColor[12] := clSkyBlue;
       end;
     end;
     if g_MagicItem.Level = 3 then begin
     if g_MagicItem.Def.btJob = 0 then
      Magim.MagicStr[11] := 'Õ½Ê¿¡¢±ÌÑªÕ½Ê¿ ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 1 then
      Magim.MagicStr[11] := '·¨Ê¦¡¢ºëÐþ·¨Ê¦ ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 2 then
      Magim.MagicStr[11] := 'µÀÊ¿¡¢ñ´ÏÉµÀÊ¿ ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 3 then
      Magim.MagicStr[11] := '´Ì¿Í¡¢·ÉÑà´Ì¿Í ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 4 then
      Magim.MagicStr[11] := 'ºÍÉÐ¡¢ÆÆ½äÉ® ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 5 then
      Magim.MagicStr[11] := '±ÌÑªÕ½Ê¿ ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 6 then
      Magim.MagicStr[11] := 'ºëÐþ·¨Ê¦ ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 7 then
      Magim.MagicStr[11] := 'ñ´ÏÉµÀÊ¿ ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 8 then
      Magim.MagicStr[11] := '·ÉÑà´Ì¿Í ¼¼ÄÜÊé';
     if g_MagicItem.Def.btJob = 9 then
      Magim.MagicStr[11] := 'ÆÆ½äÉ® ¼¼ÄÜÊé';


     if g_MagicItem.Def.btJob = 99 then
      Magim.MagicStr[11] := 'È«Ö°ÒµÍ¨ÓÃ ¼¼ÄÜÊé';
      Magim.StrColor[11] := clSkyBlue;
     end;


  end;
end;

{----------------------------------------------------------}


procedure TFrmDlg.DItemBagDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d, f: TDirectDrawSurface;
   rc:TRect;
   r: Real;
   btop :integer;
begin
   if g_MySelf = nil then exit;
   with DItemBag do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      if BagPage = 0 then begin
       with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         TextOut (SurfaceX(Left+54), SurfaceY(Top+214), GetGoldStr(g_MySelf.m_nGold));
         TextOut (SurfaceX(Left+268), SurfaceY(Top+215), intToStr(GetBagItemCount) + '¸ñ');
         Release;
       end;
      end;
   end;
   d:=nil;
   if g_MySelf <> nil then begin
        if (g_MySelf.m_Abil.MaxWeight > 0) then begin  //¹«°Ô °ÔÀÌÁö.
          d := g_WMainImages.Images[24];
          if d <> nil then begin
            rc := d.ClientRect;
            if g_MySelf.m_Abil.Weight > 0 then r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
            else r := 0;
            if r > 0 then rc.Right := Round (rc.Right / r)
            else rc.Right := 0;

            rc := d.ClientRect;
            if g_MySelf.m_Abil.Weight > 0 then r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
            else r := 0;
            if r > 0 then rc.Right := Round (rc.Right / r)
            else rc.Right := 0;
            dsurface.Draw (DItemBag.Left+182 , DItemBag.Top+217, rc, d, FALSE);
          end;
        end;
      end;
end;

procedure TFrmDlg.DCloseBagClick(Sender: TObject; X, Y: Integer);
begin
   DItemBag.Visible := FALSE;
end;

procedure TFrmDlg.DItemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
  nIdx: Integer;
  nWhere: Integer;
  List: TStringList;
begin
  DScreen.ClearHint;
  nIdx := ACol + ARow * DItemGrid.ColCount + 6;
  if nIdx in [6..MAXBAGITEM - 1] then begin
    g_MouseItem := g_ItemArr[nIdx];
    if (g_MouseItem.s.Name <> '') then begin
      nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
      if (nWhere >= 0) then begin
        List := TStringList.Create;
        try
          GetMouseItemHint(g_MySelf, @g_MouseItem);
          List.AddStrings(HintList);

          GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
          if HintList.Count > 0 then begin
            HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];     //°¡¹æ
          end;
          with DItemGrid do
            DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
          HintList.Clear;
        finally
          FreeAndNil(List);
        end;
        g_MouseItem.s.Name := '';
      end else begin
        GetMouseItemHint(g_MySelf, @g_MouseItem);
        with DItemGrid do
          DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
      end;
    end;
  end else begin
    g_MouseItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DItemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
  Shift: TShiftState);
var
   idx, mi: integer;
   temp: TClientItem;
   bCheck: Boolean;
   msg:TDefaultMessage;
   sData, sData1, sData2 :String;
begin
  bCheck := False;
  if BagPage = 0 then begin
   idx := ACol + ARow * DItemGrid.ColCount + 6;
   if (not g_boItemMoving) and (g_ItemArr[idx].S.Name <> '') then begin
     if ssRight in Shift then begin
       if (g_dwEatTime + 300 < GetTickCount) and (g_ItemArr[idx].S.StdMode < 4) then begin
          FrmMain.EatItem (idx);
          Exit;
       end;
     end;
   end;

   if idx in [6..MAXBAGITEM-1] then begin
      if not g_boItemMoving then begin
         if g_ItemArr[idx].S.Name <> '' then begin
           if FrmDlg2.DWndCompound.Visible then begin
             FrmDlg2.CompoundItemAdd(idx);
             exit;
           end;
           if ssCtrl in Shift then begin  //º¸¿Á(±¸ ½Ã½ºÅÛ)
                if not PlayScene.EdChat.Visible then begin
                  PlayScene.EdChat.Visible := True;
                  PlayScene.EdChat.SetFocus;
                end;
                if PlayScene.EdChat.SelStart = Length(PlayScene.EdChat.Text) then begin
                    PlayScene.EdChat.Text := PlayScene.EdChat.Text +  '{' + '0' + '/' + IntToStr(g_ItemArr[Idx].MakeIndex) + '}';
                    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                end else begin
                  sData := Copy(PlayScene.EdChat.Text, 1, PlayScene.EdChat.SelStart);
                  sData1 := Copy(PlayScene.EdChat.Text, PlayScene.EdChat.SelStart + 1, Length(PlayScene.EdChat.Text) - PlayScene.EdChat.SelStart);
                  sData2 := '{' + '0' + '/' + IntToStr(g_ItemArr[Idx].MakeIndex) + '}';
                  PlayScene.EdChat.Text := sData + sData2 + sData1;
                  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text) - Length(WideString(sData1));
                end;
                PlayScene.EdChat.SelLength := 0;
                SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
                exit;
           end;
           if (ssShift in Shift) then begin      //¹°¾à  ½ÃÀcÆ®
             if (g_ItemArr[idx].S.StdMode in [0,1,3,45,46]) and (g_ItemArr[idx].Amount > 1) then begin     //¹°¾à
               QItemAmount := g_ItemArr[idx].Amount;
               QItemmsIdex := g_ItemArr[idx].MakeIndex;
               HItemmsIdex := -1;
               DWItemSepa.Visible := True;
               Exit;
             end;
           end;
           if not g_EatOp then begin     //¹°¾à
             g_boItemMoving := TRUE;
             g_MovingItem.Index := idx;
             MoveingItemIndex := idx;
             g_MovingItem.Item := g_ItemArr[idx];
             g_ItemArr[idx].S.Name := '';
             g_MovingItem.Owner := DItemBag;
             ItemClickSound (g_ItemArr[idx].S);
             g_boBagToStore := TRUE;
           end;
         end;
      end else begin
       MoveingItemIndex := -1;
       if (g_MovingItem.Index >= 500) and (g_MovingItem.index < 600) then begin
         if (g_MovingItem.Owner = DItemStore) and (SpotDlgMode = dmStorage) and g_boStoreToBag and (m_nStorageMode = 0) then begin
          FrmMain.SendTakeBackStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 0);
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
          g_boStoreToBag := FALSE;
          exit;
         end else begin
           if (g_MovingItem.Owner = DItemStore) and (SpotDlgMode = dmStorage) and g_boStoreToBag and (m_nStorageMode = 1) then begin
             FrmMain.SendTakeBackStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 1);
             g_MovingItem.Item.S.name := '';
             g_boItemMoving := FALSE;
             g_boStoreToBag := FALSE;
             exit;
           end;
         end;
       end;
       if (g_MovingItem.Index >= 600) then begin
         if (g_MovingItem.Owner = DItemStore) and (SpotDlgMode = dmStorage) and g_boStoreToBag and (m_nStorageMode = 0) then begin
          FrmMain.SendTakeBackHeroStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 0);
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
          g_boStoreToBag := FALSE;
          exit;
         end else begin
           if (g_MovingItem.Owner = DItemStore) and (SpotDlgMode = dmStorage) and g_boStoreToBag and (m_nStorageMode = 1) then begin
             FrmMain.SendTakeBackHeroStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 1);
             g_MovingItem.Item.S.name := '';
             g_boItemMoving := FALSE;
             g_boStoreToBag := FALSE;
             exit;
           end;
         end;
       end;

         mi := g_MovingItem.Index;

         if (DMakeItemDlg.Visible) or (DDealDlg.Visible) then begin  // 2004/02/23 ¾ÆÀÌÅÛ ±³È¯,Á¦Á¶½Ã º§Æ®Ã¢¿¡¼­ °¡¹æÃ¢À¸·Î ¾ÆÀÌÅÛÀ» ÀÌµ¿ ÇÒ ¼ö ¾øµµ·Ï ¼öÁ¤..
            if (mi >= 0) and (mi < 6) then begin
               CancelItemMoving;
               if DMakeItemDlg.Visible then DMessageDlg ('ÖÆÔìÎïÆ·Ê±£¬ÎïÆ·²»ÄÜ´ÓÖÆÔì´°¿ÚÈ¡»Øµ½±³°ü¡£', [mbOk])
               else if DDealDlg.Visible then DMessageDlg ('½»Ò×ÎïÆ·Ê±£¬ÎïÆ·²»ÄÜ´Ó½»Ò×´°¿ÚÈ¡»Øµ½±³°ü¡£', [mbOk]);
               Exit;
            end;
         end;
         if (g_MovingItem.Owner = DHeroStateWin) then exit;
         if (mi = -94) or (mi = -95) or (mi = -96) or (mi = -97) or (mi = -98) then exit;
         if (g_MovingItem.Owner <> DHeroItemBag) then begin
           if (g_MovingItem.Owner = DStateWin) then begin  //-99: Sell
            //»óÅÂÃ¢¿¡¼­ °¡¹æÀ¸·Î
            g_WaitingUseItem := g_MovingItem;
            FrmMain.SendTakeOffItem (-(g_MovingItem.Index+1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
            g_MovingItem.Owner := nil;
           end else begin
            if (mi <= -26) and (mi > -36) then   //±³È¯Ã¢¿¡¼­ °¡¹æÃ¢À¸·Î
               DealItemReturnBag (g_MovingItem.Item);     //°Å·¡
            if (g_MovingItem.Index = -36) then    //´ë¿©Ã¢¿¡¼­ °¡¹æÃ¢À¸·Î
               RentalItemReturnBag (g_MovingItem.Item);
            if g_MovingItem.Index = -52 then
              n_ActionPrice := 0;

            if g_ItemArr[idx].S.Name <> '' then begin

             if ssCtrl in Shift then begin  //º¸¿Á(±¸ ½Ã½ºÅÛ)
               if (g_MovingItem.item.S.Name <> '') and (g_MovingItem.item.S.StdMode = 37) then begin //º¸¿Á
                 if mrYes = FrmDlg.DMessageDlg ('ÄãÏëÊ¹ÓÃ ' + g_ItemArr[idx].S.Name+ ' Éý¼¶ ' + g_MovingItem.item.S.Name +' Âð£¿', [mbYes, mbNo]) then begin //bChack := True
                   //DScreen.AddSysMsg('1', 40, 60, clRed);
                   msg := MakeDefaultMsg (CM_GEMITEM, g_MovingItem.Item.makeindex, LoWord(g_ItemArr[idx].MakeIndex), HiWord(g_ItemArr[idx].MakeIndex),0);
                   frmmain.SendSocket (EncodeMessage (msg));
                   UpItemItem := g_ItemArr[idx];
                   UpgradeItemEffect2;

                   if AddItemBag(g_MovingItem.Item) then begin
                     g_MovingItem.Item.S.name := '';
                     g_boItemMoving := FALSE;
                   end;
                //   g_boItemMoving := FALSE;
                //   g_MovingItem.Item.S.Name := '';
                //   exit;
                 end else begin
                  //  DScreen.AddSysMsg('2', 40, 60, clYellow);
                    CancelItemMoving;
                    Exit;
                 end;
               end;

               if (g_MovingItem.Item.S.StdMode in [59,60,61]) and (Not ((g_MovingItem.Item.S.StdMode = 59) and (g_MovingItem.Item.S.Shape in [20,21,22,23])) ) then begin          //½ºÃÄ
                 if mrOk = DMessageDlg ('ÄãÏëÊ¹ÓÃ ' + g_ItemArr[idx].S.Name+' Éý¼¶ '+g_MovingItem.Item.S.Name+' Âð£¿', [mbOk, mbCancel]) then bCheck := True
                 else begin
                     CancelItemMoving;
                      Exit;
                 end;
               end else bCheck := True;
             end;
              if bCheck then begin
                UpItemItem := g_ItemArr[idx];
                FrmMain.UpGradeItem(g_ItemArr[idx].MakeIndex, g_MovingItem.Item.MakeIndex,   //½ºÃÄ
                                      g_ItemArr[idx].S.Name , g_MovingItem.Item.S.Name );
                if AddItemBag(g_MovingItem.Item) then begin
                   g_MovingItem.Item.S.name := '';
                   g_boItemMoving := FALSE;
                end;
              end else begin
                if CheckItemMode(g_MovingItem.Item,g_ItemArr[idx]) then begin     //¹°¾à
                  FrmMain.BundleItem(g_MovingItem.Item.S.StdMode,g_ItemArr[idx].S.MaxAmount,inttostr(g_MovingItem.Item.MakeIndex)+'/'+inttostr(g_ItemArr[idx].MakeIndex));      //¹°¾à
                 if ((g_MovingItem.Item.S.StdMode in [0,1,3,45,46]) and ((g_MovingItem.Item.Amount + g_ItemArr[idx].Amount) <= g_ItemArr[idx].S.MaxAmount)) then begin
                  g_MovingItem.Item.S.Name := '';
                 end else begin
                   AddItemBag (g_MovingItem.Item);
                   g_MovingItem.Item.S.Name := '';
                 end;
                 g_boItemMoving := FALSE;
                end else begin
                 temp := g_ItemArr[idx];
                 g_ItemArr[idx] := g_MovingItem.Item;
                 g_MovingItem.Index := idx;
                 g_MovingItem.Item := temp;
                 g_MovingItem.Owner := DItemBag;
                end;
              end;
            end else begin
               g_ItemArr[idx] := g_MovingItem.Item;
               g_MovingItem.Item.S.name := '';
               g_boItemMoving := FALSE;
               g_MovingItem.Owner := nil;
            end;
           end;
         end;
         if (g_MovingItem.Owner = DHeroItemBag) then begin
           frmMain.SendItemToMasterBag((g_MovingItem.Index), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.s.Name);     //¿µ¿õ > ÁÖÀÎ °¡¹æÀ¸·Î
           g_WaitingUseItem := g_MovingItem;
           g_MovingItem.Item.s.Name := '';
           g_boItemMoving := False;
           g_MovingItem.Owner := nil;
         end;
      end;
   end;
   ArrangeItemBag;
  end;
end;

procedure TFrmDlg.DItemGridDblClick(Sender: TObject);
var
   where, idx, i: integer;
   keyvalue: TKeyBoardState;
   cu: TClientItem;
   TempSender: TObject;
begin
 if g_FishingOk = FALSE then begin
 if BagPage = 0 then begin
   idx := DItemGrid.Col + DItemGrid.Row * DItemGrid.ColCount + 6;
   if idx in [6..MAXBAGITEM-1] then begin
      if g_ItemArr[idx].S.Name <> '' then begin

      end else begin
         if g_boItemMoving and (g_MovingItem.Item.S.Name <> '') then begin
            FillChar(keyvalue, sizeof(TKeyboardState), #0);
            GetKeyboardState (keyvalue);
            if keyvalue[VK_CONTROL] = $80 then begin
               cu := g_MovingItem.Item;
               g_MovingItem.Item.S.Name := '';
               g_boItemMoving := FALSE;
               AddItemBag (cu);
            end else
            if (g_MovingItem.Index = idx) and (g_ItemArr[idx].S.StdMode = 45) and (g_ItemArr[idx].S.Shape = 2) then begin
               PlayScene.EdChat.Visible :=TRUE;
               PlayScene.EdChat.SetFocus;
               SetImeMode (PlayScene.EdChat.Handle, imSHanguel);   //ÇÑ±Û
               PlayScene.EdChat.Text := '@°í(³ì) ';
               PlayScene.EdChat.SelStart:= Length(PlayScene.EdChat.Text);
               PlayScene.EdChat.SelLength :=0;
            end else
            if (g_MovingItem.Index = idx) and (g_ItemArr[idx].S.StdMode = 45) and (g_ItemArr[idx].S.Shape = 3) then begin
               PlayScene.EdChat.Visible :=TRUE;
               PlayScene.EdChat.SetFocus;
               SetImeMode (PlayScene.EdChat.Handle, imSHanguel);   //ÇÑ±Û
               PlayScene.EdChat.Text := '@°í(º¸) ';
               PlayScene.EdChat.SelStart:= Length(PlayScene.EdChat.Text);
               PlayScene.EdChat.SelLength :=0;
            end else
            if (g_MovingItem.Index = idx) and
                  (g_MovingItem.Item.S.StdMode <= 4) or (g_ItemArr[idx].S.StdMode = 31)or (g_ItemArr[idx].S.StdMode in [8,9,14,18]) then begin
                  g_EatOp :=  True;        //¹°¾à
                  FrmMain.EatItem (-1);        //¹°¾à
            end else begin
              //Equip item from dbl click ^_~
              where := GetTakeOnPosition(g_MovingItem.Item.S.StdMode);

              if g_MovingItem.Index >= 0 then begin
                case where of
                  U_DRESS: TempSender := DSWDress;
                  U_WEAPON: TempSender := DSWWEAPON;
                  U_NECKLACE: TempSender := DSWNecklace;
                  U_RIGHTHAND: TempSender := DSWLight;
                  U_HELMET: TempSender := DSWHelmet;
                  U_RINGL: begin
                    if g_UseItems[U_RINGR].S.Name = '' then TempSender := DSWRingR
                      else TempSender := DSWRingL;
                  end;
                  U_ARMRINGR: begin
                    if g_UseItems[U_ARMRINGR].S.Name = '' then TempSender := DSWArmRingR
                      else TempSender := DSWArmRingL;
                  end;
                  U_BUJUK: begin
                    if g_MovingItem.Item.S.Shape = 5 then TempSender := DSWBujuk
                      else TempSender := DSWArmRingL
                  end;
                  U_BELT: TempSender := DSWBelt;
                  U_BOOTS: TempSender := DSWBoots;
                  U_CHARM: TempSender := DSWCharm;
                  U_TIGER: TempSender := DSWTiger;
                end;
              end;
              DSWWeaponClick(TempSender, 1, 1);
            end;
         end;
      end;
   end;
 end;
 end;
end;

procedure  TFrmDlg.UpgradeItemEffect(wResult : word);    //º¸¿Á
begin
   UpItemOffset := UPITEMSUCCESSOFFSET;
   UpItemMaxFrame := 8;

   BoUpItemEffect := TRUE;
   CurUpItemEffect := 0;
end;

procedure  TFrmDlg.UpgradeItemEffect2;    //º¸¿Á
begin
   UpItemOffset := UPITEMSUCCESSOFFSET;
   UpItemMaxFrame := 8;

   BoUpItemEffect := False;
   CurUpItemEffect := 0;
end;

procedure TFrmDlg.DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
var
   idx,i, ii, ax, ay, nInt: integer;
   d,e: TDirectDrawSurface;
   tempsize:integer;
   showstr : String;
begin
 if BagPage = 0 then begin
   idx := ACol + ARow * DItemGrid.ColCount + 6;
   if idx in [6..MAXBAGITEM-1] then begin
      if g_ItemArr[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_ItemArr[idx].S.Looks];
         if d <> nil then
          with DItemGrid do begin
            dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2) + 1,
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ ARow,
                              d.ClientRect, d, TRUE);
            if (g_ItemArr[idx].S.btValue[19] > 2) and (now < UnixToDateTime(DateTimeToUnix(g_ItemArr[idx].S.MaxDate))) then begin  //ºÀÀÎ
              d := g_WStateItemImages.Images[3590];
              if d <> nil then
               dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2) + 12,
                                SurfaceY(Rect.BottomRight.y + 18), d.ClientRect, d, True);
            end;

            if (g_ItemArr[idx].Amount > 0) and (g_ItemArr[idx].S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
              nInt := g_ItemArr[idx].Amount;
              with dsurface.Canvas do begin
                SetBKMode(Handle, TRANSPARENT);
                showstr := IntToStr(nInt);
                TextOutA(dsurface, SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - (TextWidth(showstr)div 2) + 20),
                       SurfaceY(Rect.BottomRight.y + 21), clYellow, showstr);
                Release;
              end;
            end;
            if ((g_ItemArr[idx].Dura div 10) > 0) and (g_ItemArr[idx].S.StdMode in [25]) then begin     //¹°¾à
              nInt := (g_ItemArr[idx].Dura div 10);
              with dsurface.Canvas do begin
                SetBKMode(Handle, TRANSPARENT);
                showstr := IntToStr(nInt);
                TextOutA(dsurface, SurfaceX(Rect.Left - (TextWidth(showstr)div 2) + 20),
                       SurfaceY(Rect.BottomRight.y + 21), clYellow, showstr);
                Release;
              end;
            end;

          end;
      end;

   end;

   if BoUpItemEffect then begin  // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå È¿°ú       //º¸¿Á
      if GetTickCount - upeffecttime > 120 then begin
         upeffecttime := GetTickCount;
         Inc (CurUpItemEffect);
         if CurUpItemEffect >= UpItemMaxFrame then begin
            FrmMain.DelitemProg2;
            BoUpItemEffect := FALSE;
            UpItemItem.S.Name := '';
         end;
      end;
   end;

   if BoUpItemEffect then begin       //º¸¿Á

      d := g_WMagic2Images.GetCachedImage (UpItemOffset + CurUpItemEffect, ax, ay);

      if d <> nil then
         if idx in [6..MAXBAGITEM-1] then
            if (UpItemItem.MakeIndex = g_ItemArr[idx].MakeIndex) and
               (Trim(UpItemItem.S.Name) = Trim(g_ItemArr[idx].S.Name))  then
               DrawBlend (dsurface,
                           DItemGrid.SurfaceX(Rect.Left) -9 + ax,
                           DItemGrid.SurfaceY(Rect.Top) +41 + ay,
                           d, 1);
   end;


 end;
end;

procedure TFrmDlg.DGoldClick(Sender: TObject; X, Y: Integer);
begin
   if g_MySelf = nil then exit;
   if not g_boItemMoving then begin
      if g_MySelf.m_nGold > 0 then begin
         PlaySound (s_money);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -98;
         g_MovingItem.Item.S.Name := g_sGoldName;
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name := '';
         if g_MovingItem.Index = -97 then begin
            DealZeroGold;       //°Å·¡
         end;
      end;
   end;
end;

{------------------------------------------------------------------------}
//NPC¶Ô»°¿ò
{------------------------------------------------------------------------}

procedure TFrmDlg.ShowMDlg (face: integer; mname, msgstr: string);
var
   i: integer;
begin
   NewstrmD := '';
   DMerchantDlg.Left := 0;
   DMerchantDlg.Top := 0;
   MerchantFace := face;
   MerchantName := mname;
   MDlgStr := msgstr;
   Npcoutindex := 0;
   DMovenpcbot.listcont := StrCountToInteger(MDlgStr,'\')-7;
   stringtolists(MDlgStr,'\',Npcoutindex,8,NewstrmD);
   DMovenpcbot.Left := 416;
   DMovenpcbot.Top := 50;
   DMerchantDlg.Visible := TRUE;
   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;

   ChackMsgstrMond; //»óÀÎ
   RequireAddPoints := TRUE;
   LastestClickTime := GetTickCount;
end;


procedure TFrmDlg.ResetMenuDlg;
var
   i: integer;
begin
   CloseDSellDlg;
   for i:=0 to g_MenuItemList.Count-1 do
      Dispose(PTClientItem(g_MenuItemList[i]));
   g_MenuItemList.Clear;

   for i:=0 to MenuList.Count-1 do
      Dispose (PTClientGoods(MenuList[i]));
   MenuList.Clear;

   //CurDetailItem := '';
   MenuIndex := -1;
   MenuTopLine := 0;

   BoMakeItemMenu := FALSE;         //Á¦Á¶½ºÃÄ
   NameMakeItem := '';               //Á¦Á¶½ºÃÄ
   BoPCItemMenu := FALSE;
   DGTList.visible :=FALSE;
   DDecoListDlg.visible:=FALSE;
   DSellDlg.Visible := FALSE;
   DShopMenuDlg.Visible := FALSE;
   DMakeItemDlg.Visible := FALSE;
end;


procedure TFrmDlg.ShowNewShopMenuDlg;
begin
   Menboots := -1;
   Mensellidx := 0;

   DShopMenuMove.listcont := MenuList.Count-5;
   DShopMenuMove.Left := DShopMenuMove.rLeft;
   DShopMenuMove.Top := DShopMenuMove.RTop;

   MenuIndex := -1;

   DMerchantDlg.Left := 0;
   DMerchantDlg.Top := 0;
   DMerchantDlg.Visible := TRUE;

   //DSellDlg.Visible := FALSE;
   DMakeItemDlg.Visible := FALSE;
   DGTList.visible :=FALSE;
   DDecoListDlg.visible:=FALSE;

   if not BoMakeItemMenu then begin
   DSellDlg.Left := 266;
   DSellDlg.Top := 224;
   DSellDlg.Visible := TRUE;
   end;

   DShopMenuDlg.Left := 0;
   DShopMenuDlg.Top  := 223;
   DShopMenuDlg.Visible := TRUE;
   MenuTop := 0;

   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;
   DItemBag.Visible := TRUE;

   LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowStoreDlg;  //¿©°ü ¿­±â
begin
   DMerchantDlg.visible:=FALSE;
   g_Npcbookinx := -1;
   DItemStore.Left := 0;
   DItemStore.Top := 0;
   DItemStore.Visible := TRUE;
   m_Storemode := 0;
   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;
   DItemBag.Visible := TRUE;


   CloseDealDlg;          //°Å·¡
   CloseRentalDlg; //´ë¿©

   DUpWapondow.Visible := False;
   DUpWeapon.Visible := False;
   CloseDUpWapon;
   DUpCheck.Visible := False;
   CloseDUpWapon2;
end;

procedure TFrmDlg.ShowScStoragePW;
begin
   DItemStore.Visible := FALSE;
   DItemBag.Visible := FALSE;
   DChangeStPw.Visible := TRUE;
   with EStoragePW1 do begin
      Text  := '';
      Width := 259;
      Left  := DChangeStPw.Left + 21;
      Top   := DChangeStPw.Top + 80;
   end;
   with EStoragePW2 do begin
      Text  := '';
      Width := 259;
      Left  := DChangeStPw.Left + 21;
      Top   := DChangeStPw.Top + 133;
   end;
   with EStoragePW3 do begin
      Text  := '';
      Width := 259;
      Left  := DChangeStPw.Left + 21;
      Top   := DChangeStPw.Top + 186;
   end;

   EStoragePW1.Visible := True;
   EStoragePW1.SetFocus;
   EStoragePW2.Visible := True;
   EStoragePW3.Visible := True;
end;

procedure TFrmDlg.ShowSetStoragePW;  //¿©°ü ¿­±â
begin
   DSetPassWd.Visible := TRUE;
   with EStoragePW1 do begin
      Text  := '';
      Width := 231;
      Left  := DSetPassWd.Left + 36;
      Top   := DSetPassWd.Top + 105;
   end;
   with EStoragePW2 do begin
      Text  := '';
      Width := 231;
      Left  := DSetPassWd.Left + 36;
      Top   := DSetPassWd.Top + 159;
   end;

   EStoragePW1.Visible := True;
   EStoragePW1.SetFocus;
   EStoragePW2.Visible := True;
end;

procedure TFrmDlg.ShowInputStoragePW;
begin
   DInputStPwd.Visible := TRUE;
   with EStoragePW1 do begin
      Text  := '';
      Width := 179;
      Left  := DInputStPwd.Left + 19;
      Top   := DInputStPwd.Top + 38;
   end;
   EStoragePW1.Visible := True;
   EStoragePW1.SetFocus;
   CloseMDlg;
end;

procedure TFrmDlg.ShowShopSellDlg;
begin
   if Not BoMakeItemMenu then begin
   DSellDlg.Left := 265;
   DSellDlg.Top := 224;
   DSellDlg.Visible := TRUE;
   end;

   DShopMenuDlg.Visible := FALSE;
   DMakeItemDlg.Visible := FALSE;
   DGTList.visible :=FALSE;
   DDecoListDlg.visible:=FALSE;

   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;
   DItemBag.Visible := TRUE;

   LastestClickTime := GetTickCount;
   g_sSellPriceStr := '';
   g_boQuickSell:=FALSE;
end;

procedure TFrmDlg.ShowHeroControl;
begin
  if g_MyHero <> nil then begin
    DBeltHero.Visible := True;
    DBotAi1.Visible := True;
    DBotAi2.Visible := True;
    DBotAi3.Visible := True;
    DBotAi4.Visible := True;
    DHeroControl.Visible := True;
    FrmDlg2.DHeroBuffDlg.Visible := True;
    DStore2.Enabled := True;
    m_Storemode := 0;
    DStoreGrid.Visible := True;
    DHeroStoreGrid.Visible := True;
  end else begin
    DBeltHero.Visible := False;
    DBotAi1.Visible := False;
    DBotAi2.Visible := False;
    DBotAi3.Visible := False;
    DBotAi4.Visible := False;
    DHeroControl.Visible := False;
    DHeroSkillBar.Visible := False;
    FrmDlg2.DHeroBuffDlg.Visible := False;
    g_boHeroAiMode := 0;
    DStore2.Enabled := False;
    m_Storemode := 0;
    DStoreGrid.Visible := True;
    DHeroStoreGrid.Visible := False;
  end;
end;

procedure TFrmDlg.CloseMDlg;
var
   i: integer;
begin
   MDlgStr := '';
   NewstrmD := '';
   DMerchantDlg.Visible := FALSE;
   if DSales.Visible then CloseItemMarketDlg;
   if DComStorage.Visible = TRUE then  //°ø¿ëÃ¢°í
     ToggleComStorageWindow;
   if DGuildStorage.Visible = TRUE then  //¹®ÆÄÃ¢°í
     ToggleGuildStorageWindow;
   if DItemWakeUpDlg.Visible then CloseItemWakeUpDlg;
   ChackMsgstrMond;
   DItemBag.Left := 0;
   DItemBag.Top := 0;
   DShopMenuDlg.Visible := FALSE;
   CloseDSellDlg;
   DGTList.visible :=FALSE;
   DDecoListDlg.visible:=FALSE;

   DUpWapondow.Visible := False;
   DUpWeapon.Visible := False;
   CloseDUpWapon;
   DUpCheck.Visible := False;
   CloseDUpWapon2;
end;

procedure TFrmDlg.SafeCloseDlg;    //Á¦Á¶½ºÃÄ
begin
   if DMakeItemDlg.Visible then DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);
end;

procedure TFrmDlg.CloseItemMarketDlg;   //À§Å¹ Á¾·á
begin
    DSalesExitClick(DSalesExit, 0, 0);
end;

procedure TFrmDlg.ShowDUpWapon(anpc: integer); //Àç·Ã
begin
  if g_nCurMerchant <> anpc then
  g_nCurMerchant := anpc;

  DUpWeapon.Left := 265;
  DUpWeapon.Top := 224;
  DUpWeapon.Visible := TRUE;

  DUpWapondow.Left := 0;
  DUpWapondow.Top  := 224;
  DUpWapondow.Visible := true;

  DItemBag.Left := g_FScreenWidth - 315;
  DItemBag.Top := 0;
  DItemBag.Visible := TRUE;
end;


procedure TFrmDlg.ShowCheckWapon(anpc: integer); //Á¦·Ã È®ÀÎ
begin
  if g_nCurMerchant <> anpc then
  g_nCurMerchant := anpc;


  DUpCheck.Left := 5;
  DUpCheck.Top  := 224;
  DUpCheck.Visible := true;    

  DItemBag.Left := g_FScreenWidth - 315;
  DItemBag.Top := 0;
  DItemBag.Visible := TRUE;
end;

procedure TFrmDlg.CloseDUpWapon;    //Àç·Ã
var
i:integer;
begin
  for i:=0 to 15 do begin
   if G_UpWaponItem[i].S.Name <> '' then begin
      AddItemBagst(G_UpWaponItem[i]);
   end;
  end;
  FillChar (G_UpWaponItem, sizeof(TClientItem)*16, #0);

  if g_UpWapon.S.Name <> '' then
     AddItemBag (g_UpWapon);
   g_UpWapon.S.Name := '';
end;

procedure TFrmDlg.CloseDUpWapon2;    //Á¦·Ã È®ÀÎ
begin
  if g_UpWapon.S.Name <> '' then
     AddItemBag (g_UpWapon);
   g_UpWapon.S.Name := '';
end;

procedure TFrmDlg.CloseDSellDlg;
begin
   DSellDlg.Visible := FALSE;
   if g_SellDlgItem.S.Name <> '' then
     AddItemBag (g_SellDlgItem);
   g_SellDlgItem.S.Name := '';
end;

procedure TFrmDlg.ShowDisassembleDlg;
begin
   DDisassembleDlg.Visible := TRUE;
   DItemBag.Visible := True;
   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;           

   LastestClickTime := GetTickCount;
   g_sDisassemblePriceStr := '';
   DShopMenuDlg.Visible := FALSE;
   DMakeItemDlg.Visible := FALSE;
   DGTList.visible :=FALSE;
   DDecoListDlg.visible:=FALSE;
end;

procedure TFrmDlg.CloseDisassembleDlg;
begin
   DDisassembleDlg.Visible := FALSE;
   if g_DisassembleDlgItem.S.Name <> '' then
     AddItemBag (g_DisassembleDlgItem);
   g_DisassembleDlgItem.S.Name := '';
end;

procedure TFrmDlg.ShowDismantleDlg;
begin
   DDismantleDlg.Visible := TRUE;
   DItemBag.Visible := True;
   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;

   LastestClickTime := GetTickCount;
   g_sDismantlePriceStr := '';
   DShopMenuDlg.Visible := FALSE;
   DMakeItemDlg.Visible := FALSE;
   DGTList.visible :=FALSE;
   DDecoListDlg.visible:=FALSE;
end;

procedure TFrmDlg.CloseDismantleDlg;
begin
   DDismantleDlg.Visible := FALSE;
   if g_DismantleDlgItem.S.Name <> '' then
     AddItemBag (g_DismantleDlgItem);
   g_DismantleDlgItem.S.Name := '';
end;

procedure TFrmDlg.ShowWakeUp;
begin
   DItemWakeUpDlg.Visible := True;
   g_ItemWakeUp := 0;
   DItemBag.Left := g_FScreenWidth - 315;
   DItemBag.Top := 0;
   DItemBag.Visible := TRUE;
   ClearWakeDlg;
   DelWakeUpItem;
end;

procedure TFrmDlg.CloseItemWakeUpDlg;
begin
   DItemWakeUpDlg.Visible := FALSE;
   if g_ItemWakeUpDlgItem.S.Name <> '' then
     AddItemBag (g_ItemWakeUpDlgItem);
   g_ItemWakeUpDlgItem.S.Name := '';
   g_ItemWakeUpList.Clear;
   MoveWakeUpItemToBag;
   g_ItemWakeUp := 0;
   DWakeUpList.Visible := False;
end;

procedure TFrmDlg.DMerchantDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  function GetColor(btColor: byte): TColor;
  begin
     case btColor of
       0: Result := $FFE098;
       1: Result := $E7F7;
       2: Result := $7179F2;
       3: Result := $5A94D6;
       4: Result := $FF8000;
       5: Result := $80FF;
       6: Result := $B1F0B7;
       7: Result := $FF80FF;
       8: Result := clSilver;
       9: Result := clRed;
      10: Result := clLime;
      11: Result := clYellow;
      12: Result := clBlue;
      13: Result := clFuchsia;
      14: Result := clAqua;
      15: Result := $299410;
     else begin
       Result := clRed;
     end;
  end;
end;
var
  d: TDirectDrawSurface;
  str, data, fdata, cmdstr, cmdmsg, cmdparam: string;
  lx, ly, sx: Integer;
  drawcenter: Boolean;
  pcp: pTClickPoint;
  nLength: Integer;
  btColor: byte;
  UseColor: TColor;
  sColor: string;
begin
   DMerchantDlg.Left := 0;
   DMerchantDlg.Top := 0;
   UseColor := clRed;
   with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    with dsurface.Canvas do begin
       SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
       Font.Size := 11;
       Font.Color := $00ADD6EF;
       Font.Style := [fsBold];
       if (MerchantName = 'QFunction') or (MerchantName = 'QManage') then
        TextOut(SurfaceX(Left + 36),SurfaceY(Top + 8), '¹ÜÀíÔ±')
       else
        TextOut(SurfaceX(Left + 36),SurfaceY(Top + 8), MerchantName);
       Font.Color := clWhite;
       Font.Style := [];
       Font.Size := 9;
       dsurface.Canvas.Release;
    end;

    SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
    lx := 15;
    ly := 38;
    if (g_Npcbookinx < 0) then begin
      str := NewstrmD;
      DBnpcup.Visible := True;
      DBnpcex.Visible := True;
      DMovenpcbot.Visible := True;
    end else begin
      str := MDlgStr;
      DBnpcup.Visible := False;
      DBnpcex.Visible := False;
      DMovenpcbot.Visible := False;
    end;
    drawcenter := FALSE;
    while True do begin
     if str = '' then break;
       str := GetValidStr3(str, data, ['\']);
     if data <> '' then begin
       sx := 0;
       fdata := '';
       while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin
         if data[1] <> '<' then begin
           data := '<' + GetValidStr3(data, fdata, ['<']);
         end;
         data := ArrestStringEx(data, '<', '>', cmdstr);
         if cmdstr <> '' then begin
           if Uppercase(cmdstr) = 'C' then begin
             drawcenter := True;
             continue;
           end;
           if Uppercase(cmdstr) = '/C' then begin
             drawcenter := FALSE;
             continue;
           end;
           cmdparam := GetValidStr3(cmdstr, cmdstr, ['/']);
         end else begin
           DSellDlg.Visible := FALSE;
           DShopMenuDlg.Visible := FALSE;
         end;
         if fdata <> '' then begin
           SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
           BoldTextOut(dsurface, SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clWhite, clBlack, fdata);
           sx := sx + dsurface.Canvas.TextWidth(fdata);
           dsurface.Canvas.Release;
         end;
         if (Length(cmdparam) > 0) and (cmdparam[1] <> '@') then begin
           nLength := CompareText(cmdparam, 'FCOLOR=');
           if (nLength > 0) and (Length(cmdparam) > Length('FCOLOR=')) then begin
             sColor := Copy(cmdparam, Length('FCOLOR=') + 1, nLength);
             btColor := Str_ToInt(sColor, 100);
             UseColor := GetColor(btColor);
             cmdparam := '';
           end;
         end;
         if cmdstr <> '' then begin
           if RequireAddPoints and (cmdparam <> '') then begin
             new(pcp);
             pcp.rc := Rect(lx + sx, ly, lx + sx + dsurface.Canvas.TextWidth(cmdstr), ly + 14);
             pcp.rstr := cmdparam;
             MDlgPoints.Add(pcp);
           end;
           if SelectMenuStr = cmdparam then begin
              if (Length(cmdparam) > 0) and (cmdparam[1] = '@') then begin
                SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
                dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style + [fsUnderline];
                BoldTextOut(dsurface, SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clLime, clBlack, cmdstr);
                 sx := sx + dsurface.Canvas.TextWidth(cmdstr);
                dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style - [fsUnderline];
                dsurface.Canvas.Release;
              end else begin
                SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
                BoldTextOut(dsurface, SurfaceX(Left + lx + sx), SurfaceY(Top + ly), UseColor {clRed}, clBlack, cmdstr);
                  sx := sx + dsurface.Canvas.TextWidth(cmdstr);
                dsurface.Canvas.Release;
              end;
           end else begin
             if (Length(cmdparam) > 0) and (cmdparam[1] = '@') then begin
               SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
               dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style + [fsUnderline];
               BoldTextOut(dsurface, SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clYellow, clBlack, cmdstr);
               sx := sx + dsurface.Canvas.TextWidth(cmdstr);
               dsurface.Canvas.Font.Style := dsurface.Canvas.Font.Style - [fsUnderline];
               dsurface.Canvas.Release;
             end else begin
               SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
               BoldTextOut(dsurface, SurfaceX(Left + lx + sx), SurfaceY(Top + ly), UseColor, clBlack, cmdstr);
               sx := sx + dsurface.Canvas.TextWidth(cmdstr);
               dsurface.Canvas.Release;
             end;
           end;
         end;
       end;
       if data <> '' then begin
         SetBkMode(dsurface.Canvas.Handle, TRANSPARENT);
         BoldTextOut(dsurface, SurfaceX(Left + lx + sx), SurfaceY(Top + ly), clWhite, clBlack, data);
         dsurface.Canvas.Release;
       end;
     end;
     ly := ly + 16;
    end;
    dsurface.Canvas.Release;
    RequireAddPoints := FALSE;
   end;
end;




procedure TFrmDlg.DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseMDlg;
end;

procedure TFrmDlg.SoldOutGoods (itemserverindex: integer);
var
   i: integer;
   pg: PTClientGoods;
begin
   for i:=0 to MenuList.Count-1 do begin
      pg := PTClientGoods (MenuList[i]);
      if (pg.Grade >= 0) and (pg.Stock = itemserverindex) then begin
         Dispose (pg);
         MenuList.Delete (i);
         if i < g_MenuItemList.Count then g_MenuItemList.Delete (i);
         if MenuIndex > MenuList.Count-1 then MenuIndex := MenuList.Count-1;
         break;
      end;
   end;
end;

procedure TFrmDlg.DelStorageItem (itemserverindex: integer);
var
   i: integer;
   pg: PTClientGoods;
begin
   for i:=0 to MenuList.Count-1 do begin
      pg := PTClientGoods (MenuList[i]);
      if (pg.Price = itemserverindex) then begin
         Dispose (pg);
         MenuList.Delete (i);
         //if i < g_SaveItemList.Count then g_SaveItemList.Delete (i);
         if MenuIndex > MenuList.Count-1 then MenuIndex := MenuList.Count-1;
         break;
      end;
   end;
end;




procedure TFrmDlg.DMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
   i, L, T: integer;
   ia, La, Ta: integer;
   p: PTClickPoint;
begin
   if GetTickCount < LastestClickTime then exit;
   L := DMerchantDlg.Left;
   T := DMerchantDlg.Top;
   La := DMerchantDlg.Left;
   Ta := DMerchantDlg.Top;
   with DMerchantDlg do begin
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            PlaySound (s_glass_button_click);
            if DMakeItemDlg.Visible then DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);  //Á¦Á¶½ºÃÄ
            SafeCloseDlg;       //Á¦Á¶½ºÃÄ
            FrmMain.SendMerchantDlgSelect (g_nCurMerchant, p.RStr);
            LastestClickTime := GetTickCount + 5000;
            break;
         end;
      end;
      for ia:=0 to MDlgsier.Count-1 do begin
         p := PTClickPoint (MDlgsier[ia]);
         if (X >= SurfaceX(La + p.rc.Left)) and (X <= SurfaceX(La + p.rc.Right)) and
            (Y >= SurfaceY(Ta + p.rc.Top)) and (Y <= SurfaceY(Ta + p.rc.Bottom)) then begin
            break;
         end;
      end;
   end;
end;

procedure TFrmDlg.DMerchantDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   if GetTickCount < LastestClickTime then exit;
   SelectMenuStr := '';
   L := DMerchantDlg.Left;
   T := DMerchantDlg.Top;
   with DMerchantDlg do
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
end;

procedure TFrmDlg.DMerchantDlgMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   SelectMenuStr := '';
end;

procedure TFrmDlg.DSellDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e: TDirectDrawSurface;
   actionname: string;
begin
   with DSellDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      e := WLib.Images[403];
      if (e <> nil) and (g_boQuickSell) then
        dsurface.Draw (SurfaceX(Left) + 91, SurfaceY(Top) + 39, e.ClientRect, e, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         actionname := '';
         case SpotDlgMode of                         //À§Å¹
            dmSell:   actionname := '³öÊÛ: ';
            dmRepair: actionname := 'ÐÞÀí: ';
            dmStorage: actionname := '¼ÄÊÛ: ';
            dmLock: actionname := '·âÓ¡: 5,000';
            dmComStorage: actionname := '¡¡¡¡¹«¹²²Ö¿â';
            dmGuildStorage: actionname := '¡¡¡¡ÐÐ»á²Ö¿â';
            dmWakeCancel: actionname := 'ÊÖÐø·Ñ: ';
            dmReStore: actionname := 'ÊÖÐø·Ñ: ';
         end;
         TextOut (SurfaceX(Left+26), SurfaceY(Top+13), actionname + g_sSellPriceStr);
         Release;
      end;
   end;
end;

procedure TFrmDlg.DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseDSellDlg;
end;

procedure TFrmDlg.DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
   valstr:String;
begin
   g_sSellPriceStr := '';
   if not g_boItemMoving then begin
      if g_SellDlgItem.S.Name <> '' then begin
         ItemClickSound (g_SellDlgItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -99;
         g_MovingItem.Item := g_SellDlgItem;
         g_MovingItem.Owner := DSellDlg;
         g_SellDlgItem.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;

      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DSellDlg) then begin
         ItemClickSound (g_MovingItem.Item.S);
         if (Not CheckCanSell(g_MovingItem.Item) and (SpotDlgMode = dmSell)) then begin
           CancelItemMoving;
           DMessageDlg ('´ËÎïÆ·ÎÞ·¨³öÊÛ¡£',[mbOk]);
           exit;
         end;
         if g_SellDlgItem.S.Name <> '' then begin
           temp := g_SellDlgItem;
           g_SellDlgItem := g_MovingItem.Item;
           g_MovingItem.Index := -99;
           g_MovingItem.Item := temp;
           g_MovingItem.Owner := DSellDlg;
         end else begin
           g_SellDlgItem := g_MovingItem.Item;
           g_MovingItem.Item.S.name := '';
           g_MovingItem.Owner := nil;
           g_boItemMoving := FALSE;
         end;
         if not g_boQuickSell then begin
           g_boQueryPrice := TRUE;
           g_dwQueryPriceTime := GetTickCount;
         end else begin
           DSellOk();
         end;
      end;
   end;

end;

procedure TFrmDlg.DSellDlgSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_SellDlgItem.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_SellDlgItem.S.Looks];
      if d <> nil then
         with DSellDlgSpot do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
            if (g_SellDlgItem.Amount > 0) and (g_SellDlgItem.S.StdMode in [0,1,3,45,46]) then begin      //¹°¾à
              SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
              dsurface.Canvas.Font.Color := clYellow;
              dsurface.Canvas.TextOut(SurfaceX(Left + 30),SurfaceY(Top + 28), IntToStr(g_SellDlgItem.Amount) );
              dsurface.Canvas.Font.Color := clWhite;
              dsurface.Canvas.Release;
            end;
      end;
   end;
end;

procedure TFrmDlg.DSellDlgSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nHintX, nHintY: integer;
begin
   DScreen.ClearHint;
   g_MouseItem := g_SellDlgItem;
   with DSellDlgSpot do begin
    if g_MouseItem.s.Name <> '' then begin
      GetMouseItemHint(g_MySelf, @g_MouseItem);
      nHintX:= DSellDlg.Left + X + 6;
      nHintY:= DSellDlg.Top + Y + 6;

      DScreen.ShowHintB(nHintX, nHintY, HintList, False);
    end;
  end;
end;

procedure TFrmDlg.DSellOk();
var
  dlgmessage: string;
  amount: integer;
  i: integer;
begin
   if (g_SellDlgItem.S.Name = '') and (g_SellDlgItemSellWait.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit;
   case SpotDlgMode of
      dmSell: begin
        FrmMain.SendSellItem (g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name{, g_sellDlgItem.Amount});
        LastestClickTime := GetTickCount + 5000;
      end;
      dmRepair: begin
        FrmMain.SendRepairItem (g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);
        LastestClickTime := GetTickCount + 5000;
      end;
      dmStorage: begin
        LastestClickTime := GetTickCount + 5000;
      end;
      dmLock: begin
        frmMain.SendItemLock (g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name); //ºÀÀÎ
        LastestClickTime := GetTickCount + 5000;
      end;

      dmWakeCancel: begin
        frmMain.SendItemWake(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name);
        LastestClickTime := GetTickCount + 5000;
      end;
      dmReStore: begin
        frmMain.SendItemReStore(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.s.Name);
        LastestClickTime := GetTickCount + 5000;
      end;

      dmComStorage:          //°ø¿ëÃ¢°í
        begin

          if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨Òª´¢´æ ' + g_SellDlgItem.S.Name +' Âð£¿', [mbYes, mbNo]) then
            FrmMain.SendComStorageItem (g_nCurMerchant, g_SellDlgItem.MakeIndex{, g_SellDlgItem.Amount})
          else
            AddItemBag (g_SellDlgItem);

        end;
      dmGuildStorage:          //¹®ÆÄÃ¢°í
        begin

          if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨Òª´¢´æ ' + g_SellDlgItem.S.Name +' Âð£¿', [mbYes, mbNo]) then
            FrmMain.SendGuildStorageItem (g_nCurMerchant, g_SellDlgItem.MakeIndex{, g_SellDlgItem.Amount})
          else
            AddItemBag (g_SellDlgItem);

        end;

   end;
   g_SellDlgItemSellWait := g_SellDlgItem;
   g_SellDlgItem.S.Name := '';
   g_sSellPriceStr := '';
end;


{------------------------------------------------------------------------}

//Ä§·¨

{------------------------------------------------------------------------}


procedure TFrmDlg.SetMagicKeyDlg (magid,icon: integer; magname: string; var curkey: word);
begin
   MagKeyID := magid;
   MagKeyIcon := icon;
   MagKeyMagName := magname;
   MagKeyCurKey := curkey;


   DKeySelDlg.Left := (g_FScreenWidth - DKeySelDlg.Width) div 2;
   DKeySelDlg.Top  := (g_FScreenHeight - DKeySelDlg.Height) div 2;
   HideAllControls;
   DKeySelDlg.ShowModal;

   while TRUE do begin
      if not DKeySelDlg.Visible then break;
      //FrmMain.DXTimerTimer (self, 0);
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then exit;
   end;

   RestoreHideControls;
   curkey := MagKeyCurKey;
end;


procedure TFrmDlg.SetHeroMagicKeyDlg(magid, icon: Integer; magname: string; var curkey: Word);
begin
  MagHKeyID := magid;
  MagHKeyIcon := icon;
  MagHKeyMagName := magname;
  MagHKeyCurKey := curkey;


  DHeroKeylDlg.Left := (g_FScreenWidth - DHeroKeylDlg.Width) div 2;
  DHeroKeylDlg.Top := (g_FScreenHeight - DHeroKeylDlg.Height) div 2;
  HideAllControls;
  DHeroKeylDlg.ShowModal;

  while True do begin
    if not DHeroKeylDlg.Visible then Break;
    frmMain.ProcOnIdle;
    Application.ProcessMessages;
    if Application.Terminated then Exit;
  end;

  RestoreHideControls;
  curkey := MagHKeyCurKey;
end;

procedure TFrmDlg.DKeySelDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
begin
   DScreen.ClearHint;
   with DKeySelDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clSilver;
         TextOut (SurfaceX(Left + 60), SurfaceY(Top + 26), MagKeyMagName + ' ¼ü ÉèÖÃ');
         Release;
         with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Size := 8;
         Font.Color := clWhite;
         Key1 := 'F1';
         Key2 := 'F2';
         Key3 := 'F3';
         Key4 := 'F4';
         Key5 := 'F5';
         Key6 := 'F6';
         Key7 := 'F7';
         Key8 := 'F8';
         Key9 := 'Ctrl';
         Key10 := '+';
         TextOut (SurfaceX(Left + 19), SurfaceY(Top+60), Key1);
         TextOut (SurfaceX(Left + 51), SurfaceY(Top+60), Key2);
         TextOut (SurfaceX(Left + 83), SurfaceY(Top+60), Key3);
         TextOut (SurfaceX(Left + 115), SurfaceY(Top+60), Key4);

         TextOut (SurfaceX(Left + 152), SurfaceY(Top+60), Key5);
         TextOut (SurfaceX(Left + 184), SurfaceY(Top+60), Key6);
         TextOut (SurfaceX(Left + 216), SurfaceY(Top+60), Key7);
         TextOut (SurfaceX(Left + 248), SurfaceY(Top+60), Key8);

         TextOut (SurfaceX(Left + 19), SurfaceY(Top+97), Key9);
         TextOut (SurfaceX(Left + 51), SurfaceY(Top+97), Key9);
         TextOut (SurfaceX(Left + 83), SurfaceY(Top+97), Key9);
         TextOut (SurfaceX(Left + 115), SurfaceY(Top+97), Key9);

         TextOut (SurfaceX(Left + 152), SurfaceY(Top+97), Key9);
         TextOut (SurfaceX(Left + 184), SurfaceY(Top+97), Key9);
         TextOut (SurfaceX(Left + 216), SurfaceY(Top+97), Key9);
         TextOut (SurfaceX(Left + 248), SurfaceY(Top+97), Key9);

         TextOut (SurfaceX(Left + 27), SurfaceY(Top+105), Key10);
         TextOut (SurfaceX(Left + 59), SurfaceY(Top+105), Key10);
         TextOut (SurfaceX(Left + 91), SurfaceY(Top+105), Key10);
         TextOut (SurfaceX(Left + 123), surfaceY(Top+105), Key10);

         TextOut (SurfaceX(Left + 160), SurfaceY(Top+105), Key10);
         TextOut (SurfaceX(Left + 192), SurfaceY(Top+105), Key10);
         TextOut (SurfaceX(Left + 224), SurfaceY(Top+105), Key10);
         TextOut (SurfaceX(Left + 256), SurfaceY(Top+105), Key10);

         TextOut (SurfaceX(Left + 19), SurfaceY(Top+113), Key1);
         TextOut (SurfaceX(Left + 51), SurfaceY(Top+113), Key2);
         TextOut (SurfaceX(Left + 83), SurfaceY(Top+113), Key3);
         TextOut (SurfaceX(Left + 115), SurfaceY(Top+113), Key4);

         TextOut (SurfaceX(Left + 152), SurfaceY(Top+113), Key5);
         TextOut (SurfaceX(Left + 184), SurfaceY(Top+113), Key6);
         TextOut (SurfaceX(Left + 216), SurfaceY(Top+113), Key7);
         TextOut (SurfaceX(Left + 248), SurfaceY(Top+113), Key8);
         Font.Size := 9;
         Release;
      end;
      end;
   end;
end;

procedure TFrmDlg.DKsIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DksIcon do begin                                //¸¶¹ý Å×µÎ¸®
      d := GetMagic2Images(MagKeyID).Images[MagKeyIcon];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DKsF1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   b: TDButton;
   d: TDirectDrawSurface;
   Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
begin
   b := nil;
   case MagKeyCurKey of
      word('1'): b := DKsF1;
      word('2'): b := DKsF2;
      word('3'): b := DKsF3;
      word('4'): b := DKsF4;
      word('5'): b := DKsF5;
      word('6'): b := DKsF6;
      word('7'): b := DKsF7;
      word('8'): b := DKsF8;
      word('E'): b := DKsConF1;
      word('F'): b := DKsConF2;
      word('G'): b := DKsConF3;
      word('H'): b := DKsConF4;
      word('I'): b := DKsConF5;
      word('J'): b := DKsConF6;
      word('K'): b := DKsConF7;
      word('L'): b := DKsConF8;
      else b := DKsNone;
   end;
   if b = Sender then begin
      with b do begin
         d := WLib.Images[FaceIndex+1];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Size := 8;
         Font.Color := clWhite;
         Key1 := 'F1';
         Key2 := 'F2';
         Key3 := 'F3';
         Key4 := 'F4';
         Key5 := 'F5';
         Key6 := 'F6';
         Key7 := 'F7';
         Key8 := 'F8';
         Key9 := 'Ctrl';
         Key10 := '+';
         if b = DKsF1 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key1);
         end;
         if b = DKsF2 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key2);
         end;
         if b = DKsF3 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key3);
         end;
         if b = DKsF4 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key4);
         end;
         if b = DKsF5 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key5);
         end;
         if b = DKsF6 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key6);
         end;
         if b = DKsF7 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key7);
         end;
         if b = DKsF8 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key8);
         end;


         if b = DKsConF1 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key1);
         end;
         if b = DKsConF2 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key2);
         end;
         if b = DKsConF3 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key3);
         end;
         if b = DKsConF4 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key4);
         end;
         if b = DKsConF5 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key5);
         end;
         if b = DKsConF6 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key6);
         end;
         if b = DKsConF7 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key7);
         end;
         if b = DKsConF8 then begin
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+2), Key9);
         TextOut (SurfaceX(Left + 10), SurfaceY(Top+10), Key10);
         TextOut (SurfaceX(Left + 2), SurfaceY(Top+18), Key8);
         end;
         Font.Size := 9;
         Release;
      end;

      end;
   end;
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Size := 8;
         Font.Color := clWhite;
         Key1 := 'F1';
         Key2 := 'F2';
         Key3 := 'F3';
         Key4 := 'F4';
         Key5 := 'F5';
         Key6 := 'F6';
         Key7 := 'F7';
         Key8 := 'F8';
         Key9 := 'Ctrl';
         Key10 := '+';
         if Sender = DKsF1 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key1);
         end;
         if Sender = DKsF2 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key2);
         end;
         if Sender = DKsF3 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key3);
         end;
         if Sender = DKsF4 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key4);
         end;
         if Sender = DKsF5 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key5);
         end;
         if Sender = DKsF6 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key6);
         end;
         if Sender = DKsF7 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key7);
         end;
         if Sender = DKsF8 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key8);
         end;


         if Sender = DKsConF1 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key1);
         end;
         if Sender = DKsConF2 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key2);
         end;
         if Sender = DKsConF3 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key3);
         end;
         if Sender = DKsConF4 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key4);
         end;
         if Sender = DKsConF5 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key5);
         end;
         if Sender = DKsConF6 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key6);
         end;
         if Sender = DKsConF7 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key7);
         end;
         if Sender = DKsConF8 then begin
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 11), SurfaceY(Top+11), Key10);
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+19), Key8);
         end;
         Font.Size := 9;
         Release;
      end;
      end;
   end;
end;

procedure TFrmDlg.DKsOkClick(Sender: TObject; X, Y: Integer);
begin
   DKeySelDlg.Visible := FALSE;
end;

procedure TFrmDlg.DKsF1Click(Sender: TObject; X, Y: Integer);
begin
   if Sender = DKsF1 then MagKeyCurKey := integer('1');
   if Sender = DKsF2 then MagKeyCurKey := integer('2');
   if Sender = DKsF3 then MagKeyCurKey := integer('3');
   if Sender = DKsF4 then MagKeyCurKey := integer('4');
   if Sender = DKsF5 then MagKeyCurKey := integer('5');
   if Sender = DKsF6 then MagKeyCurKey := integer('6');
   if Sender = DKsF7 then MagKeyCurKey := integer('7');
   if Sender = DKsF8 then MagKeyCurKey := integer('8');
   if Sender = DKsConF1 then MagKeyCurKey := integer('E');
   if Sender = DKsConF2 then MagKeyCurKey := integer('F');
   if Sender = DKsConF3 then MagKeyCurKey := integer('G');
   if Sender = DKsConF4 then MagKeyCurKey := integer('H');
   if Sender = DKsConF5 then MagKeyCurKey := integer('I');
   if Sender = DKsConF6 then MagKeyCurKey := integer('J');
   if Sender = DKsConF7 then MagKeyCurKey := integer('K');
   if Sender = DKsConF8 then MagKeyCurKey := integer('L');
   if Sender = DKsNone then MagKeyCurKey := 0;
end;

{------------------------------------------------------------------------}
//Ãæ°æ°´Å¥
{------------------------------------------------------------------------}

procedure TFrmDlg.DBotMiniMapClick(Sender: TObject; X, Y: Integer);
begin

  if (g_nMiniMapIndex < 0) then
    DScreen.AddChatBoardString('Ã»ÓÐ¿ÉÓÃµÄµØÍ¼ÏÔÊ¾¡£', clWhite, clRed)
  else begin
    if (not DMiniMap.Visible) and (not g_boViewMiniMap) then begin
      g_nViewMinMapLv := 1;
      g_boViewMiniMap := TRUE;
      DMiniMap.Visible := TRUE;
    end else begin
      if g_nViewMinMapLv >= 2 then begin
        g_nViewMinMapLv := 0;
        g_boViewMiniMap := FALSE;
        DMiniMap.Visible := False;
      end else Inc(g_nViewMinMapLv);
    end;
  end;
end;

procedure TFrmDlg.DBotTradeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendDealTry;
   end;
end;

procedure TFrmDlg.DBotGuildClick(Sender: TObject; X, Y: Integer);
begin
   if DGuildDlg.Visible then begin
      DGuildDlg.Visible := FALSE;
   end else
      if GetTickCount > g_dwQueryMsgTick then begin
         g_dwQueryMsgTick := GetTickCount + 3000;
         FrmMain.SendGuildDlg;
      end;
end;

procedure TFrmDlg.DBotGroupClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowGroupDlg;
end;

{------------------------------------------------------------------------}
//×é¶Ó´°¿Ú
{------------------------------------------------------------------------}

procedure TFrmDlg.ToggleRentalDlg;    //´ë¿©
begin
   RentalPage := 0;
   RentalPageChanged;
end;

procedure TFrmDlg.ToggleRentalDlg2;    //´ë¿©
begin
   RentalPage := 1;
   RentalPageChanged;
end;

procedure TFrmDlg.ToggleShowRentalDlg;    //´ë¿©
begin
  if DRentalDlg.Visible = fALSE then begin
   RentalPage := 0;
   RentalPageChanged;
  end;
   DRentalDlg.Visible := not DRentalDlg.Visible;
end;

procedure TFrmDlg.ToggleShowGroupDlg;
begin
   DGroupDlg.Visible := not DGroupDlg.Visible;
   GroupListIndex := -1;
   UserListIndex := -1;
   UserListMoveIndex := -1;
   GroupListMoveIndex := -1;
   GroupIndex := 0;
end;

procedure TFrmDlg.ToggleShowMailListDlg;     //ÂÊÁö
begin
   DMailListDlg.Visible := not DMailListDlg.Visible;
end;

procedure TFrmDlg.ToggleShowBlockListDlg;     //°ÅºÎÀÚ
begin
   if Not WantBlockList then begin
     FrmMain.SendRejectLIst;
     WantBlockList := True;
   end;
   DBlockListDlg.Visible := not DBlockListDlg.Visible;
end;

procedure TFrmDlg.ShowEditMail;   //¸ÞÀÏ
var
   d: TDirectDrawSurface;
   i: integer;
   data: string;
begin
   with DMemo do begin
      // ¸Þ¸ð º¯°æÀÎ °æ¿ì ±âÁ¸ ¸Þ¸ð¸¦ ´ëÀÔ
      if ViewWindowNo = VIEW_MEMO then begin
         BackupMemoMail := memoMail.Text;
      end;
      memomail.MaxLength := 255;
      if not memoMail.visible then memoMail.Visible := TRUE;
      if (ViewWindowNo in [VIEW_MEMO,VIEW_MAILSEND]) then
        memoMail.SetFocus;

      SetImeMode (MemoMail.Handle, imSHanguel);
      DMemo.Show;


      while TRUE do begin
         if not DMemo.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DMemo.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
         //°á°ú... ¹®ÆÄ°øÁö»çÇ×À» ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
         data := '';
         for i:=0 to Memo.Lines.Count-1 do begin
            if Memo.Lines[i] = '' then
               data := data + Memo.Lines[i] + ' '#13
            else data := data + Memo.Lines[i] + #13;
         end;
         data := ConvertEscChar(data);
         if Length(data) > 70 then begin
            data := Copy (data, 1, 70);
            DMessageDlg ('ÄãÊäÈëµÄÎÄ×Ö¹ý³¤£¬³¬³öµÄÎÄ×Ö½«±»×Ô¶¯ÆÁ±Î¡£', [mbOk]);
         end;

      end;
   end;
end;

procedure TFrmDlg.ToggleShowLoverDlg;   //¿¬ÀÎ ½ºÃÄ
begin
  DLoverWindow.Visible := not DLoverWindow.Visible;
  // È­¸éÀ» ¿­¶§¸¶´Ù µð½ºÇÃ·¹ÀÌ Á¤º¸¸¦ °»½ÅÇØÁØ´Ù.
  if DLoverWindow.Visible then
    flover.MakeDisplay;
end;

procedure TFrmDlg.ToggleShowMasterDlg;    //»çÁ¦ ½ºÃÄ
begin
  DMasterDlg.Visible := not DMasterDlg.Visible;
  // È­¸éÀ» ¿­¶§¸¶´Ù µð½ºÇÃ·¹ÀÌ Á¤º¸¸¦ °»½ÅÇØÁØ´Ù.
  if DMasterDlg.Visible then
    fMentor.MakeDisplay;
end;

procedure TFrmDlg.ToggleShowPetDlg;   //¿µ¹°
var
 i : integer;
begin
  DWinPet.Visible := not DWinPet.Visible;

  DPetOptionDlg.Visible := False;
  ToggleOptionPetDlg;

  // È­¸éÀ» ¿­¶§¸¶´Ù µð½ºÇÃ·¹ÀÌ Á¤º¸¸¦ °»½ÅÇØÁØ´Ù.
  PetInfoBoots := -1;
  if DWinPet.Visible and g_CheckPetDB then begin
     SendClientMessage(CM_GETPETINFO, g_MySelf.m_nRecogId, 0, 0, 0, '');
  end;
  if DWinPet.Visible then
   DPet1Click(DPet1,1,1);
end;
procedure TFrmDlg.ToggleOptionPetDlg;   //¿µ¹°¿É¼Ç
begin
  if g_boItemAll = 1 then DAllItem.Visible := True else DAllItem.Visible := False;
  if g_boItemGold = 1 then DGoldItem.Visible := True else DGoldItem.Visible := False;
  if g_boItemWeapon = 1 then DWeaponItem.Visible := True else DWeaponItem.Visible := False;
  if g_boItemDress = 1 then DDressItem.Visible := True else DDressItem.Visible := False;
  if g_boItemHelmet = 1 then DHelmatItem.Visible := True else DHelmatItem.Visible := False;
  if g_boItemBoots = 1 then DBootsItem.Visible := True else DBootsItem.Visible := False;
  if g_boItemBelt = 1 then DBeltItem.Visible := True else DBeltItem.Visible := False;
  if g_boItemAccessory = 1 then DAccessoryItem.Visible := True else DAccessoryItem.Visible := False;
  if g_boItemEtc = 1 then DEtcItem.Visible := True else DEtcItem.Visible := False;
end;

procedure TFrmDlg.DGroupDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d, e: TDirectDrawSurface;
   lx, ly, n: integer;
   GroupMember: pTGroupMember;
begin
   with DGroupDlg do begin
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     DGrpAllowGroup.Checked := g_boAllowGroup;
     DGrpCheckGroup.Checked := g_boCheckGroup;
     DCBGroupItemRam.Checked := g_GroupItemMode;
     DCBGroupItemDef.Checked := not g_GroupItemMode;
     DGrpCheckHero.Checked := g_boCheckHero;
   end;
end;

procedure TFrmDlg.DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   DGroupDlg.Visible := FALSE;
   GroupListIndex := -1;
   UserListIndex := -1;
   UserListMoveIndex := -1;
   GroupListMoveIndex := -1;
   GroupIndex := 0;
end;

procedure TFrmDlg.DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChangeGroupModeTick then begin
      g_boAllowGroup := not g_boAllowGroup;
      g_dwChangeGroupModeTick := GetTickCount + 1000; //timeout 5Ãë
      FrmMain.SendGroupMode ();
      PlaySound(s_norm_button_click);
   end;
end;

procedure TFrmDlg.DGrpDelegateClick(Sender: TObject; X, Y: Integer);
var
  who: string;
  GroupMember: pTGroupMember;
begin
  if (GetTickCount > g_dwChangeGroupModeTick) and (g_MemberGroup.Count > 0) then begin
    GroupMember := g_MemberGroup[0];
    who := GroupMember.ClientGroup.UserName;
    if (who = g_MySelf.m_sUserName) then begin
      if mrYes = FrmDlg.DMessageDlg ('ÄãÏë½âÉ¢ÄãµÄÐ¡×éÂð£¿', [mbYes, mbNo]) then begin
        g_dwChangeGroupModeTick := GetTickCount + 2000; //timeout 5ÃÊ
        frmMain.SendDelGroupMember(who);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGrpAddMemClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
  if (GetTickCount > g_dwChangeGroupModeTick) and (g_MemberGroup.Count = 0) then begin
     if (UserListIndex < RefGroupList.count) and (UserListIndex >= 0) then begin
      who := RefGroupList[UserListIndex];
      if who <> '' then begin
        if mrYes = FrmDlg.DMessageDlg ('[ÄãÏëÑûÇë ' + who + ' ]¼ÓÈëÄãµÄ¶ÓÎéÂð£¿', [mbYes, mbNo]) then begin
          g_dwChangeGroupModeTick := GetTickCount + 2000; //timeout 5ÃÊ
          FrmMain.SendCreateGroup(Integer(g_GroupItemMode), Integer(g_boCheckHero), who);
        end;
      end;
    end
    else begin
      DialogSize := 1;
      DMessageDlg ('ÇëÊäÈëÄãÒª¼ÓÈë¶ÓÎéµÄ³ÉÔ±µÄÃû×Ö...', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 1000; //timeout 5Ãë
         FrmMain.SendCreateGroup (Integer(g_GroupItemMode), Integer(g_boCheckHero), Trim (DlgEditText));
      end;
    end;
  end else
  if (GetTickCount > g_dwChangeGroupModeTick) and (g_MemberGroup.Count > 0) then begin
     if (UserListIndex < RefGroupList.count) and (UserListIndex >= 0) then begin
      who := RefGroupList[UserListIndex];
      if who <> '' then begin
        if mrYes = FrmDlg.DMessageDlg ('ÄãÏëÑûÇë [ ' + who+' ]¼ÓÈëÄãµÄ¶ÓÎéÂð£¿', [mbYes, mbNo]) then begin
          g_dwChangeGroupModeTick := GetTickCount + 2000; //timeout 5ÃÊ
          FrmMain.SendAddGroupMember(who);
        end;
      end;
    end
    else begin
      DialogSize := 1;
      DMessageDlg ('ÇëÊäÈëÄãÒª¼ÓÈë¶ÓÎéµÄ³ÉÔ±µÄÃû×Ö...', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 1000; //timeout 5Ãë
         FrmMain.SendAddGroupMember (Trim (DlgEditText));
      end;
    end;
  end;
end;

procedure TFrmDlg.DGrpDelMemClick(Sender: TObject; X, Y: Integer);
var
   who: string;
   GroupMember: pTGroupMember;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_MemberGroup.Count > 0) then begin
     if (GroupListIndex < g_MemberGroup.count) and (GroupListIndex >= 0) then begin
      GroupMember := g_MemberGroup[GroupListIndex];
      who := GroupMember.ClientGroup.UserName;
      if who <> '' then begin
        if mrYes = FrmDlg.DMessageDlg ('ÄãÒª½« [ ' + who+' ]´Ó¶ÓÎéÖÐÉ¾³ýÂð£¿', [mbYes, mbNo]) then begin
          g_dwChangeGroupModeTick := GetTickCount + 2000; //timeout 5ÃÊ
          frmMain.SendDelGroupMember(who);
        end;
      end;
    end else begin
      DialogSize := 1;
      DMessageDlg ('ÇëÊäÈëÒª´Ó¶ÓÎéÖÐÉ¾³ýµÄ³ÉÔ±µÄÃû×Ö...', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 1000; //timeout 5Ãë
         FrmMain.SendDelGroupMember (Trim (DlgEditText));
      end;
    end;
   end;
end;

procedure TFrmDlg.DBotLogoutClick(Sender: TObject; X, Y: Integer);
begin
   LocalLanguage := imSAlpha;
   SendClientMessage (CM_CANCLOSE, 0, 0, 0, 0);    //ÀüÅõÁß Á¢¼Ó Á¾·á
end;

procedure TFrmDlg.DBotExitClick(Sender: TObject; X, Y: Integer);
begin
   if (GetTickCount - g_dwLatestStruckTick > 10000) and
      (GetTickCount - g_dwLatestMagicTick > 10000) and
      (GetTickCount - g_dwLatestHitTick > 10000) or
      (g_MySelf.m_boDeath) then begin
      FrmMain.AppExit;
   end else
      DScreen.AddChatBoardString ('ÔÚÕ½¶·ÖÐÎÞ·¨ÍË³öÓÎÏ·¡£', clYellow, clRed);
end;

procedure TFrmDlg.DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  if g_FishingOk = FALSE then begin              //ÒÆ¶¯²Ö¿â
    if GetTickCount > g_dwQueryMsgTick then begin
      if (FrmDlg.DDealDlg.Visible = False) and (FrmDlg.DDRentalDlg.Visible = False) then begin
        Msg:='ÄãÏëÊ¹ÓÃ²Ö¿â¹¦ÄÜÂð£¿';
        if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
           g_dwQueryMsgTick := GetTickCount + 1000;
           SendClientMessage(CM_GETSTORAGE, g_MySelf.m_nRecogId , 0, 0, 0, '');
        end;
      end;
    end;
  end;
end;


{------------------------------------------------------------------------}

//´ë¿©
procedure TFrmDlg.OpenRentalDlg(mode:integer);         //´ë¿©
begin

   RentalMode := mode;
   
   DRentalRemoteDlg.Left := g_FScreenWidth-236-100;
   DRentalRemoteDlg.Top := 90;
   DDRentalDlg.Left := g_FScreenWidth-236-100;
   DDRentalDlg.Top  := 280;
   DItemBag.Left := 0;
   DItemBag.Top := 0;
   DItemBag.Visible := TRUE;
   DDRentalDlg.Visible := TRUE;
   DRentalRemoteDlg.Visible := TRUE;

   DRentalDlg.Visible := False;

   FillCHar (g_RentalItems, sizeof(TClientItem), #0);         //´ë¿©
   FillCHar (g_RentalRemoteItems, sizeof(TClientItem), #0);      //´ë¿©
   g_nRentalGold := 0;             //´ë¿©
   g_nRentalDay := 0;
   g_nRentalRemoteGold := 0;       //´ë¿©
   g_boRentalEnd := FALSE;         //´ë¿©

   ArrangeItembag;

   DRentalMsgDlg.Left := g_FScreenWidth-236-215;  //´ë¿©°Å·¡
   DRentalMsgDlg.Top  := 50;
   DRentalMsgDlg.Visible := TRUE;
end;

procedure TFrmDlg.CloseRentalDlg;          //´ë¿©
begin
   DDRentalDlg.Visible := FALSE;
   DRentalRemoteDlg.Visible := FALSE;
   ArrangeItembag;
   DRentalMsgDlg.Visible := FALSE; //±³È¯ °Å·¡
   FrmMain.SendCancelRental;
end;


{------------------------------------------------------------------------}


procedure TFrmDlg.OpenDealDlg;         //°Å·¡
var
   d: TDirectDrawSurface;
begin
   DDealRemoteDlg.Left := g_FScreenWidth-236-100;
   DDealRemoteDlg.Top := 90;
   DDealDlg.Left := g_FScreenWidth-236-100;
   DDealDlg.Top  := 280;
   DItemBag.Left := 0;
   DItemBag.Top := 0;
   DItemBag.Visible := TRUE;
   DDealDlg.Visible := TRUE;
   DDealRemoteDlg.Visible := TRUE;

   FillCHar (g_DealItems, sizeof(TClientItem)*10, #0);            //°Å·¡
   FillCHar (g_DealRemoteItems, sizeof(TClientItem)*20, #0);      //°Å·¡
   FillChar(HeroArr, SizeOf(TSelHero) * 4, #0);
   g_nDealGold := 0;             //°Å·¡
   g_nDealRemoteGold := 0;       //°Å·¡
   g_boDealEnd := FALSE;          //°Å·¡

   ArrangeItembag;

   DDealMsgDlg.Left := g_FScreenWidth-236-215;  //±³È¯°Å·¡
   DDealMsgDlg.Top  := 50;
   DDealMsgDlg.Visible := TRUE;
end;

procedure TFrmDlg.CloseDealDlg;          //°Å·¡
begin
   DDealDlg.Visible := FALSE;
   DDealRemoteDlg.Visible := FALSE;
   ArrangeItembag;
   DDealMsgDlg.Visible := FALSE; //±³È¯ °Å·¡
   FrmMain.SendCancelDeal;
end;

procedure TFrmDlg.SetGroupWnd;
var
  boGroup: Boolean;
  GroupMember: pTGroupMember;
begin
  if g_MySelf = nil then exit;
  DGrpAllowGroup.Checked := g_boAllowGroup;
  DCBGroupItemRam.Checked := g_GroupItemMode;
  DCBGroupItemDef.Checked := not g_GroupItemMode;
  DGrpCheckHero.Checked := g_boCheckHero;
  DGrpCheckGroup.Checked := g_boCheckGroup;
  DGpMove.Left := DGpMove.RLeft;
  DGpMove.Top := DGpMove.RTop;
  if g_MemberGroup.Count <= 0 then begin
    DCBGroupItemRam.Enabled := True;
    DCBGroupItemDef.Enabled := True;
    DGrpCheckHero.Enabled := True;
    DGrpCheckGroup.Enabled := True;
    DGrpDelMem.Visible := False;
    DGrpDelegate.Visible := False;
    DGrpAddMem.Visible := True;
    DWndGroup.Visible := False;
  end
  else begin
    DCBGroupItemRam.Enabled := False;
    DCBGroupItemDef.Enabled := False;
    DGrpCheckHero.Enabled := False;
    DGrpCheckGroup.Enabled := False;
    GroupMember := g_MemberGroup.Items[0];
    boGroup := (GroupMember.ClientGroup.UserID = g_MySelf.m_nRecogId);
    DGrpDelMem.Visible := boGroup;
    DGrpDelegate.Visible := boGroup;
    DGrpAddMem.Visible := boGroup;
    DWndGroup.Visible := True;
    DWndGroupMember.Visible := True;
    DGroupMember1.Visible := g_MemberGroup.Count > 1;
    DGroupMember2.Visible := g_MemberGroup.Count > 2;
    DGroupMember3.Visible := g_MemberGroup.Count > 3;
    DGroupMember4.Visible := g_MemberGroup.Count > 4;
    DGroupMember5.Visible := g_MemberGroup.Count > 5;
    DGroupMember6.Visible := g_MemberGroup.Count > 6;
    DGroupMember7.Visible := g_MemberGroup.Count > 7;
    DGroupMember8.Visible := g_MemberGroup.Count > 8;
    DGroupMember9.Visible := g_MemberGroup.Count > 9;
    DGroupMember10.Visible := g_MemberGroup.Count > 10;
    DGroupMember11.Visible := g_MemberGroup.Count > 11;
    DGroupMember12.Visible := g_MemberGroup.Count > 12;
  end;
end;

procedure TFrmDlg.DDealOkClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
   if GetTickCount > g_dwDealActionTick then begin
      FrmMain.SendDealEnd;          //°Å·¡
      g_dwDealActionTick := GetTickCount + 4000;
      g_boDealEnd := TRUE;

      if g_boItemMoving then begin
         mi := g_MovingItem.Index;
         if (mi <= -26) and (mi > -36) then begin     //°Å·¡
            AddDealItem (g_MovingItem.Item);
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DDealCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwDealActionTick then begin
      CloseDealDlg;
      FrmMain.SendCancelDeal;
   end;
end;

procedure TFrmDlg.DDealRemoteDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DDealRemoteDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         TextOut (SurfaceX(Left+42), SurfaceY(Top+127), GetGoldStr(g_nDealRemoteGold));
         TextOut (SurfaceX(Left + 100 - (TextWidth(g_sDealWho)) div 2), SurfaceY(Top+11), g_sDealWho);
         Release;
      end;
   end;
end;

procedure TFrmDlg.DDealDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DDealDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         TextOut (SurfaceX(Left+42), SurfaceY(Top+127), GetGoldStr(g_nDealGold));
         TextOut (SurfaceX(Left + 100 - (TextWidth(FrmMain.CharName)) div 2), SurfaceY(Top+11), FrmMain.CharName);
         Release;
      end;
   end;
end;

procedure TFrmDlg.DealItemReturnBag (mitem: TClientItem);    //°Å·¡
begin
   if not g_boDealEnd then begin
      g_DealDlgItem := mitem;
      FrmMain.SendDelDealItem (g_DealDlgItem);
      g_dwDealActionTick := GetTickCount + 4000;
   end;
end;

procedure TFrmDlg.DealItemReturnBag2 (mitem: TClientItem);         //°Å·¡
begin
   if not g_boDealEnd then begin
      g_DealDlgItem := mitem;
      FrmMain.SendDelDealItem2 (g_DealDlgItem);
      g_dwDealActionTick := GetTickCount + 4000;
   end;
end;

procedure TFrmDlg.DDGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
  Shift: TShiftState);
var
   temp: TClientItem;
   mi, idx: Integer;
   temp2: TClientItem;
   Amount: Integer;
   valstr:String;
begin
   if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
      if not g_boItemMoving then begin
         idx := ACol + ARow * DDGrid.ColCount;
         if idx in [0..9] then
            if g_DealItems[idx].S.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 26;
               g_MovingItem.Item := g_DealItems[idx];
               g_DealItems[idx].S.Name := '';
               g_MovingItem.Owner := DDealDlg;
               ItemClickSound (g_MovingItem.Item.S);
            end;
      end else begin
        if (g_MovingItem.Owner = DHeroItemBag) or (g_MovingItem.Owner = DStateWin) or (g_MovingItem.Owner = DHeroStateWin) then Exit;
        mi := g_MovingItem.Index;
        if CheckCanDeal(g_MovingItem.Item) then begin
          if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DDealDlg) then begin   //°Å·¡
            ItemClickSound (g_MovingItem.Item.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
              g_DealDlgItem := g_MovingItem.Item;
              FrmMain.SendAddDealItem (g_DealDlgItem);
              g_dwDealActionTick := GetTickCount + 4000;
            end else
              AddDealItem (g_MovingItem.Item);
            g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
          end;
        end else begin
          CancelItemMoving;
          DMessageDlg ('´ËÎïÆ·½ûÖ¹½»Ò×¡£',[mbOk]);
        end;
         if mi = -98 then DDGoldClick (self, 0, 0);
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
   idx := ACol + ARow * DDGrid.ColCount;
   if idx in [0..9] then begin
      if g_DealItems[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_DealItems[idx].S.Looks];
         if d <> nil then
            with DDGrid do begin
               dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 2)+ACol,
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ ARow,
                              d.ClientRect,
                              d, TRUE);
            if (g_DealItems[idx].Amount > 0) and (g_DealItems[idx].S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
             SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
             dsurface.Canvas.Font.Color := clYellow;
             dsurface.Canvas.TextOut(SurfaceX(Rect.BottomRight.x - (Length(IntToStr(g_DealItems[idx].Amount))div 2) + 20),
                           SurfaceY(Rect.BottomRight.y + 20), IntToStr(g_DealItems[idx].Amount));
             dsurface.Canvas.Font.Color := clWhite;
             dsurface.Canvas.Release;
            end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DDGridGridMouseMove(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
  Shift: TShiftState);
var
  nIdx: Integer;
  nWhere: Integer;
  List: TStringList;
begin
  DScreen.ClearHint;
  nIdx := ACol + ARow * DDGrid.ColCount;
  if nIdx in [0..9] then begin
    g_MouseItem := g_DealItems[nIdx];

    if g_MouseItem.s.Name <> '' then begin
      nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
      if (nWhere >= 0) then begin
        List := TStringList.Create;
        try
          GetMouseItemHint(g_MySelf, @g_MouseItem);
          List.AddStrings(HintList);

          GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
          if HintList.Count > 0 then begin
            HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];      //°Å·¡
          end;
          with DDGrid do
            DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
          HintList.Clear;
        finally
          FreeAndNil(List);
        end;
        g_MouseItem.s.Name := '';
      end else begin
        GetMouseItemHint(g_MySelf, @g_MouseItem);
        with DDGrid do
          DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
      end;

    end;
  end else begin
    g_MouseItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
   idx := ACol + ARow * DDRGrid.ColCount;
   if idx in [0..19] then begin
      if g_DealRemoteItems[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_DealRemoteItems[idx].S.Looks];
         if d <> nil then
            with DDRGrid do begin
                dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 2)+ACol,
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ ARow,
                              d.ClientRect,
                              d, TRUE);
            if (g_DealRemoteItems[idx].Amount > 0)  and (g_DealRemoteItems[idx].S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
               SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
               dsurface.Canvas.Font.Color := clYellow;
               dsurface.Canvas.TextOut(SurfaceX(Rect.BottomRight.x - (Length(IntToStr(g_DealRemoteItems[idx].Amount))div 2) + 20),
                         SurfaceY(Rect.BottomRight.y + 20), IntToStr(g_DealRemoteItems[idx].Amount));
               dsurface.Canvas.Font.Color := clWhite;
               dsurface.Canvas.Release;
            end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DDRGridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
  nIdx: Integer;
  nWhere: Integer;
  List: TStringList;
begin
  DScreen.ClearHint;
  nIdx := ACol + ARow * DDRGrid.ColCount;
  if nIdx in [0..19] then begin
    g_MouseItem := g_DealRemoteItems[nIdx];
    if g_MouseItem.s.Name <> '' then begin
      nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
      if (nWhere >= 0) then begin

        List := TStringList.Create;
        try
          GetMouseItemHint(g_MySelf, @g_MouseItem);
          List.AddStrings(HintList);

          GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
          if HintList.Count > 0 then begin
            HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];     //°Å·¡
          end;
          with DDRGrid do
            DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
          HintList.Clear;
        finally
          FreeAndNil(List);
        end;
        g_MouseItem.s.Name := '';
      end else begin
        GetMouseItemHint(g_MySelf, @g_MouseItem);
        with DDRGrid do
          DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
      end;

    end;
  end else begin
    g_MouseItem.s.Name := '';
  end;
end;


procedure TFrmDlg.DealZeroGold;             //°Å·¡
begin
   if not g_boDealEnd and (g_nDealGold > 0) then begin
      g_dwDealActionTick := GetTickCount + 4000;
      FrmMain.SendChangeDealGold (0);
   end;
end;

procedure TFrmDlg.DDGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then exit;
   if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
      if not g_boItemMoving then begin
         if g_nDealGold > 0 then begin
            PlaySound (s_money);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := -97;
            g_MovingItem.Item.S.Name := g_sGoldName;
         end;
      end else begin
         if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
            if (g_MovingItem.Index = -98) then begin
               if g_MovingItem.Item.S.Name = g_sGoldName then begin

                  DialogSize := 1;
                  g_boItemMoving := FALSE;
                  g_MovingItem.Item.S.Name := '';
                  DMessageDlg ('ÄãÈ·¶¨ÒªÈ¡³ö ' +g_sGoldName+ ' ½ð±ÒÂð£¿', [mbOk, mbAbort]);
                  GetValidStrVal (DlgEditText, valstr, [' ']);
                  dgold := Str_ToInt (valstr, 0);
                  if (dgold <= (g_nDealGold+g_MySelf.m_nGold)) and (dgold > 0) then begin
                     FrmMain.SendChangeDealGold (dgold);          //°Å·¡
                     g_dwDealActionTick := GetTickCount + 4000;
                  end else
                     dgold := 0;
               end;
            end;
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.Name := '';
         end;
      end;
   end;
end;



{--------------------------------------------------------------}


procedure TFrmDlg.DUserState1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);    //»ó´ë¹æ ¾ÆÀÌÅÛ »óÅÂÃ¢
var
   i, l, m, pgidx, bbx, bby, idx, ax, ay, sex, hair, Job, tx, img: integer;
   d, e: TDirectDrawSurface;
   hcolor, keyimg: integer;
   iname, d1, d2, d3: string;
   useable: Boolean;
   output,fstr : string;
begin
   with DUserState1 do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      if UserState1.bHero then begin
        DUSFriend.Visible := False;
        DUSGroup.Visible := False;
        DUSMail.Visible := False;
        DUser2.Visible := False;
      end else begin
        DUSFriend.Visible := True;
        DUSGroup.Visible := True;
        DUSMail.Visible := True;
        DUser2.Visible := True;
      end;
      d := g_WGuildImages.Images[UserState1.GuildMark];
      if d <> nil then
        DrawBlendEx (dsurface, SurfaceX(Left + 17) , SurfaceY(Top + 12), d, 0, 0, d.Width, d.Height,0);
      case UserState1.Job of
        0,5: d := g_WMainImages.Images[100];
        1,6: d := g_WMainImages.Images[101];
        2,7: d := g_WMainImages.Images[102];
        3,8: d := g_WMainImages.Images[103];
        4,9: d := g_WAresImages.Images[406];
      end;
      if d <> nil then
        dsurface.Draw (SurfaceX(Left + 15), SurfaceY(Top + 33), d.ClientRect, d, TRUE);

      sex := DRESSfeature (UserState1.Feature) mod 2;
      hair := HAIRfeature (UserState1.Feature);
     if UserState1.Job = 5 then begin //»ó´ë¹æ º®Ç÷Àü»ç »óÅÂÃ¢
        pgidx := 379;
        bbx := Left + 8;
        bby := Top + 90;
        d := g_WMainImages.Images[pgidx];
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);

        if UserState1.Mask in [20, 21] then begin
          if UserState1.Mask = 20 then begin
            pgidx := 930;
            bbx := Left + 28;
            bby := Top + 120;
            d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);
            d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
          end else begin
            pgidx := 932;
            bbx := Left + 48;
            bby := Top + 135;
            d := g_WMain2Images.Images[933];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
          end;
          d := g_WMain2Images.Images[pgidx];
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
        end else begin
          if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
            d := g_WMainImages.Images[UserState1.Job * 2 + 320 + sex];
          end else
            d := g_WMainImages.Images[320 + sex];
         if d <> nil then
           dsurface.Draw (SurfaceX(bbx+4), SurfaceY(bby+64), d.ClientRect, d, TRUE);
        end;
        bbx := Left + 8;
        bby := Top - 23;
        if UserState1.UseItems[U_DRESS].S.Name <> '' then begin
         idx := UserState1.UseItems[U_DRESS].S.Looks; //if m_btSex = 1 then idx := 80;
         if idx >= 0 then begin
           if sex = 1 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
               if idx = 86 then
                 e := g_WMain2Images.GetCachedImage(1211, ax, ay);
               if idx = 605 then
                 e := g_WMain2Images.GetCachedImage(1221, ax, ay);
               d := FrmMain.GetWStateWarrWoImg(idx,ax,ay);
             end else begin
               if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1219, ax, ay);
               if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1229, ax, ay);
               d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
             end;
           end else begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
               if idx = 85 then
                 e := g_WMain2Images.GetCachedImage(1210, ax, ay);
               if idx = 595 then
                 e := g_WMain2Images.GetCachedImage(1220, ax, ay);
               d := FrmMain.GetWStateWarrManImg(idx,ax,ay);
             end else begin
               if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1218, ax, ay);
               if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1228, ax, ay);
               d := FrmMain.GetWStateComManImg(idx,ax,ay);
             end;
           end;

           if UserState1.Mask in [20, 21] then begin
            d := nil; e := nil;
           end;
           if d <> nil then
            if sex = 0 then begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-3), SurfaceY(bby+ay-14), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-45), SurfaceY(bby+ay-18), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
              end else begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-23), SurfaceY(bby+ay-12), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-70), SurfaceY(bby+ay-19), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
              end;
            end else begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-68), SurfaceY(bby+ay- 10), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-77), SurfaceY(bby+ay- 20), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end else begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-36), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-61), SurfaceY(bby+ay- 23), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-18), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end;
            end;
         end;
        end;
        //»ó´ë Çì¾î
        idx := 460 + hair;
        if sex = 1 then idx := 500 + hair;
        if UserState1.UseItems[U_HELMET].S.Name <> '' then begin
          idx := UserState1.UseItems[U_HELMET].S.Looks;
          if idx >= 0 then begin
            if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

            end else begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
                d := FrmMain.GetWStateWarrManImg(idx,ax,ay);
              end else
                d := FrmMain.GetWStateComManImg(idx,ax,ay);
             if sex = 1 then
               if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
                 d := FrmMain.GetWStateWarrWoImg(idx,ax,ay);
               end else
                 d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
            end;
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
              end else
               dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
            end else
              if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
                dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end else
                dsurface.Draw (SurfaceX(bbx+ax-18), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
          end;
          idx := 0;
        end;
        if idx > 0 then begin
         if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

         end else
           d := g_WMainImages.GetCachedImage (idx, ax, ay);
         if UserState1.Mask in [20, 21] then d := nil;
         if d <> nil then
           if sex = 0 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
             end else
               dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
           end else
             if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+21), d.ClientRect, d, TRUE);
             end else
               dsurface.Draw (SurfaceX(bbx+ax-18), SurfaceY(bby+ay+21), d.ClientRect, d, TRUE);
        end;

        if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin       //»óÅÂÃ¢ÀÛ¾÷
          idx := UserState1.UseItems[U_WEAPON].S.Looks;
          if idx >= 0 then begin
           if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
             d := FrmMain.GetWStateWarrManImg(idx,ax,ay);
           end else
             d := FrmMain.GetWStateComManImg(idx,ax,ay);
           if sex = 1 then
           if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
             d := FrmMain.GetWStateWarrWoImg(idx,ax,ay);
           end else
             d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
           if UserState1.Mask in [20, 21] then d := nil;
           if d <> nil then
           if sex = 0 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-13), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
             end else
               dsurface.Draw (SurfaceX(bbx+ax-18), SurfaceY(bby+ay+24), d.ClientRect, d, TRUE)
           end else
            if (UserState1.UseItems[U_WEAPON].S.Shape in [73..77]) then begin
              dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
            end else
             dsurface.Draw (SurfaceX(bbx+ax-17), SurfaceY(bby+ay+19), d.ClientRect, d, TRUE);

            if (UserState1.UseItems[U_WEAPON].S.WEffect > 0) then begin
              if (UserState1.UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect) * 10;
                if sex = 0 then
                   d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                if d <> nil then begin
                  if sex = 0 then
                    DrawBlend(dsurface, SurfaceX(bbx + ax - 18), SurfaceY(bby + ay + 24), d, 1)
                  else DrawBlend(dsurface, SurfaceX(bbx + ax - 17), SurfaceY(bby + ay + 19), d, 1);
                end;
              end else begin
                img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect - 72) * 10;
                if sex = 0 then
                  d := g_WState_Eff_Warrior_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                else d := g_WState_Eff_Warrior_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                if d <> nil then begin
                  if sex = 0 then
                    DrawBlend(dsurface, SurfaceX(bbx + ax - 13), SurfaceY(bby + ay + 25), d, 1)
                  else DrawBlend(dsurface, SurfaceX(bbx + ax - 22), SurfaceY(bby + ay + 20), d, 1);
                end;
              end;
            end;
          end;
        end;
     end else begin

     if UserState1.Job = 6 then begin       //»ó´ë¹æ È«Çö¼ú»ç »óÅÂÃ¢
        pgidx := 379;
        bbx := Left + 8;
        bby := Top + 90;
        d := g_WMainImages.Images[pgidx];
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
        if UserState1.Mask in [20, 21] then begin
          if UserState1.Mask = 20 then begin
            pgidx := 930;
            bbx := Left + 28;
            bby := Top + 120;
            d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

            d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
          end else begin
            pgidx := 932;
            bbx := Left + 48;
            bby := Top + 135;
            d := g_WMain2Images.Images[933];
            if d <> nil then
             DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
          end;
          d := g_WMain2Images.Images[pgidx];
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);

        end else begin
          if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
            d := g_WMainImages.Images[UserState1.Job * 2 + 320 + sex];
          end else
            d := g_WMainImages.Images[320 + sex];
          if d <> nil then
           dsurface.Draw (SurfaceX(bbx+10), SurfaceY(bby+68), d.ClientRect, d, TRUE);
        end;
        bbx := Left + 8;
        bby := Top - 23;

        if UserState1.UseItems[U_DRESS].S.Name <> '' then begin
          idx := UserState1.UseItems[U_DRESS].S.Looks; //if m_btSex = 1 then idx := 80;
          if idx >= 0 then begin
           if sex = 1 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
               if idx = 86 then
                 e := g_WMain2Images.GetCachedImage(1213, ax, ay);
               if idx = 605 then
                 e := g_WMain2Images.GetCachedImage(1223, ax, ay);
               d := FrmMain.GetWStateWizWoImg(idx,ax,ay);
             end else begin
               if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1219, ax, ay);
               if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1229, ax, ay);
               d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
             end;
           end else begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
               if idx = 85 then
                 e := g_WMain2Images.GetCachedImage(1212, ax, ay);
               if idx = 595 then
                 e := g_WMain2Images.GetCachedImage(1222, ax, ay);
               d := FrmMain.GetWStateWizManImg(idx,ax,ay);
             end else begin
               if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1218, ax, ay);
               if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1228, ax, ay);
               d := FrmMain.GetWStateComManImg(idx,ax,ay);
             end;
           end;

           if UserState1.Mask in [20, 21] then begin
             d := nil;  e := nil;
           end;
           if d <> nil then
            if sex = 0 then begin
               if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
                 if e <> nil then begin
                   if idx = 85 then
                     dsurface.Draw (SurfaceX(bbx+ax-41), SurfaceY(bby+ay-6), e.ClientRect, e, TRUE);
                   if idx = 595 then
                     dsurface.Draw (SurfaceX(bbx+ax-65), SurfaceY(bby+ay-14), e.ClientRect, e, TRUE);
                 end;
                 dsurface.Draw (SurfaceX(bbx+ax-16), SurfaceY(bby+ay+29), d.ClientRect, d, TRUE)
               end else begin
                 if e <> nil then begin
                   if idx = 85 then
                     dsurface.Draw (SurfaceX(bbx+ax-17), SurfaceY(bby+ay-8), e.ClientRect, e, TRUE);
                   if idx = 595 then
                     dsurface.Draw (SurfaceX(bbx+ax-64), SurfaceY(bby+ay-15), e.ClientRect, e, TRUE);
                 end;
                 dsurface.Draw (SurfaceX(bbx+ax-10), SurfaceY(bby+ay+29), d.ClientRect, d, TRUE)
               end;
            end else begin
               if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
                 if e <> nil then begin
                   if idx = 86 then
                     dsurface.Draw (SurfaceX(bbx+ax-47), SurfaceY(bby+ay- 10), e.ClientRect, e, TRUE);
                   if idx = 605 then
                     dsurface.Draw (SurfaceX(bbx+ax-61), SurfaceY(bby+ay- 19), e.ClientRect, e, TRUE);
                 end;
                 dsurface.Draw (SurfaceX(bbx+ax-13), SurfaceY(bby+ay+24), d.ClientRect, d, TRUE);
               end else begin
                 if e <> nil then begin
                   if idx = 86 then
                     dsurface.Draw (SurfaceX(bbx+ax-30), SurfaceY(bby+ay- 9), e.ClientRect, e, TRUE);
                   if idx = 605 then
                     dsurface.Draw (SurfaceX(bbx+ax-55), SurfaceY(bby+ay- 19), e.ClientRect, e, TRUE);
                 end;
                 dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+24), d.ClientRect, d, TRUE);
               end;
            end;
          end;
        end;
      //»ó´ë Çì¾î
        idx := 460 + hair;
        if sex = 1 then idx := 500 + hair;
        if UserState1.UseItems[U_HELMET].S.Name <> '' then begin
          idx := UserState1.UseItems[U_HELMET].S.Looks;
          if idx >= 0 then begin
           if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

           end else begin
           if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
            d := FrmMain.GetWStateWizManImg(idx,ax,ay);
           end else
            d := FrmMain.GetWStateComManImg(idx,ax,ay);
           if sex = 1 then
           if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
            d := FrmMain.GetWStateWizWoImg(idx,ax,ay);
           end else
            d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
           end;
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+29), d.ClientRect, d, TRUE)
              end else
               dsurface.Draw (SurfaceX(bbx+ax-9), SurfaceY(bby+ay+29), d.ClientRect, d, TRUE)
            end else
              if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-13), SurfaceY(bby+ay+23), d.ClientRect, d, TRUE);
              end else
               dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+23), d.ClientRect, d, TRUE);
          end;
          idx := 0;
        end;
        if idx > 0 then begin
          if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

          end else
            d := g_WMainImages.GetCachedImage (idx, ax, ay);
          if UserState1.Mask in [20, 21] then d := nil;
          if d <> nil then
          if sex = 0 then begin
            if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
              dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+29), d.ClientRect, d, TRUE)
            end else
              dsurface.Draw (SurfaceX(bbx+ax-9), SurfaceY(bby+ay+29), d.ClientRect, d, TRUE)
          end else
           if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
             dsurface.Draw (SurfaceX(bbx+ax-13), SurfaceY(bby+ay +24), d.ClientRect, d, TRUE);
           end else
             dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay +24), d.ClientRect, d, TRUE);
        end;

        if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin       //»óÅÂÃ¢ÀÛ¾÷
          idx := UserState1.UseItems[U_WEAPON].S.Looks;
          if idx >= 0 then begin
            if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
             d := FrmMain.GetWStateWizManImg(idx,ax,ay);
            end else
             d := FrmMain.GetWStateComManImg(idx,ax,ay);
           if sex = 1 then
           if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
             d := FrmMain.GetWStateWizWoImg(idx,ax,ay);
           end else
            d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
                dsurface.Draw (SurfaceX(bbx+ax - 16), SurfaceY(bby+ay+22), d.ClientRect, d, TRUE)
              end else
                dsurface.Draw (SurfaceX(bbx+ax - 11), SurfaceY(bby+ay+27), d.ClientRect, d, TRUE)
            end else
              if (UserState1.UseItems[U_WEAPON].S.Shape in [78..81]) then begin
               dsurface.Draw (SurfaceX(bbx+ax - 13), SurfaceY(bby+ay+19), d.ClientRect, d, TRUE);
              end else
               dsurface.Draw (SurfaceX(bbx+ax - 10), SurfaceY(bby+ay+23), d.ClientRect, d, TRUE);
            if (UserState1.UseItems[U_WEAPON].S.WEffect > 0) then begin
              if (UserState1.UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect) * 10;
                if sex = 0 then
                  d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                if d <> nil then begin
                  if sex = 0 then
                    DrawBlend(dsurface, SurfaceX(bbx + ax - 11), SurfaceY(bby + ay + 27), d, 1)
                  else DrawBlend(dsurface, SurfaceX(bbx + ax - 10), SurfaceY(bby + ay + 23), d, 1);
                end;
              end else begin
                img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect - 77) * 10;
                if sex = 0 then
                  d := g_WState_Eff_Wizard_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                else d := g_WState_Eff_Wizard_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                if d <> nil then begin
                  if sex = 0 then
                    DrawBlend(dsurface, SurfaceX(bbx + ax - 16), SurfaceY(bby + ay + 22), d, 1)
                  else DrawBlend(dsurface, SurfaceX(bbx + ax - 13), SurfaceY(bby + ay + 19), d, 1);
                end;
              end;
            end;

          end;
        end;

     end else begin

     if UserState1.Job = 7 then begin     //»ó´ë¹æ ÀÍ¼±µµ»ç »óÅÂÃ¢
        pgidx := 379;
        bbx := Left + 8;
        bby := Top + 90;
        d := g_WMainImages.Images[pgidx];
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
        if UserState1.Mask in [20, 21] then begin
          if UserState1.Mask = 20 then begin
            pgidx := 930;
            bbx := Left + 28;
            bby := Top + 120;
            d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);
            d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
          end else begin
            pgidx := 932;
            bbx := Left + 48;
            bby := Top + 135;
            d := g_WMain2Images.Images[933];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
          end;
          d := g_WMain2Images.Images[pgidx];
          if d <> nil then
           dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
        end else begin
          if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
            d := g_WMainImages.Images[UserState1.Job * 2 + 320 + sex];
          end else
            d := g_WMainImages.Images[320 + sex];
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx+10), SurfaceY(bby+64), d.ClientRect, d, TRUE);
        end;
        bbx := Left + 8;
        bby := Top - 23;

        if UserState1.UseItems[U_DRESS].S.Name <> '' then begin
          idx := UserState1.UseItems[U_DRESS].S.Looks; //if m_btSex = 1 then idx := 80;
          if idx >= 0 then begin
           if sex = 1 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               if idx = 86 then
                 e := g_WMain2Images.GetCachedImage(1215, ax, ay);
               if idx = 605 then
                 e := g_WMain2Images.GetCachedImage(1225, ax, ay);
               d := FrmMain.GetWStateMonkWoImg(idx,ax,ay);
             end else begin
               if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1219, ax, ay);
               if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1229, ax, ay);
               d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
             end;
           end else begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               if idx = 85 then
                 e := g_WMain2Images.GetCachedImage(1214, ax, ay);
               if idx = 595 then
                 e := g_WMain2Images.GetCachedImage(1224, ax, ay);
               d := FrmMain.GetWStateMonkManImg(idx,ax,ay);
             end else begin
               if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1218, ax, ay);
               if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1228, ax, ay);
               d := FrmMain.GetWStateComManImg(idx,ax,ay);
             end;
           end;
           if UserState1.Mask in [20, 21] then begin
             d := nil;  e := nil;
           end;
           if d <> nil then
            if sex = 0 then begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-38), SurfaceY(bby+ay-13), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-58), SurfaceY(bby+ay-16), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
              end else begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-17), SurfaceY(bby+ay-12), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-64), SurfaceY(bby+ay-19), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-10), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
              end;
            end else begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-44), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-58), SurfaceY(bby+ay- 22), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end else begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-30), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-55), SurfaceY(bby+ay- 23), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      //»ó´ë Çì¾î
        idx := 460 + hair;
        if sex = 1 then idx := 500 + hair;
        if UserState1.UseItems[U_HELMET].S.Name <> '' then begin
          idx := UserState1.UseItems[U_HELMET].S.Looks;
          if idx >= 0 then begin
           if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

           end else begin
           if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
             d := FrmMain.GetWStateMonkManImg(idx,ax,ay);
           end else
             d := FrmMain.GetWStateComManImg(idx,ax,ay);
           if sex = 1 then
           if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
             d := FrmMain.GetWStateMonkWoImg(idx,ax,ay);
           end else
             d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
           end;
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-11), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
             end else
               dsurface.Draw (SurfaceX(bbx+ax-9), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
            end else
             if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE)
             end else
               dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE)
          end;
          idx := 0;
        end;
        if idx > 0 then begin
          if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

          end else
           d := g_WMainImages.GetCachedImage (idx, ax, ay);
          if UserState1.Mask in [20, 21] then d := nil;
          if d <> nil then
          if sex = 0 then begin
             if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-11), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
             end else
               dsurface.Draw (SurfaceX(bbx+ax-9), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
          end else
             if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay +20), d.ClientRect, d, TRUE)
             end else
               dsurface.Draw (SurfaceX(bbx+ax-12), SurfaceY(bby+ay +20), d.ClientRect, d, TRUE)
        end;

        if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin         //»óÅÂÃ¢ÀÛ¾÷
          idx := UserState1.UseItems[U_WEAPON].S.Looks;
          if idx >= 0 then begin
            if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
              d := FrmMain.GetWStateMonkManImg(idx,ax,ay);
            end else
              d := FrmMain.GetWStateComManImg(idx,ax,ay);
          if sex = 1 then
          if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
            d := FrmMain.GetWStateMonkWoImg(idx,ax,ay);
          end else
            d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
              if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-11), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
              end else
               dsurface.Draw (SurfaceX(bbx+ax-11), SurfaceY(bby+ay+23), d.ClientRect, d, TRUE)
            end else
              if (UserState1.UseItems[U_WEAPON].S.Shape in [82..85]) then begin
               dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end else
               dsurface.Draw (SurfaceX(bbx+ax-10), SurfaceY(bby+ay+19), d.ClientRect, d, TRUE);
            if (UserState1.UseItems[U_WEAPON].S.WEffect > 0) then begin
              if (UserState1.UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
                img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect) * 10;
                if sex = 0 then
                  d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                if d <> nil then begin
                  if sex = 0 then
                    DrawBlend(dsurface, SurfaceX(bbx + ax - 11), SurfaceY(bby + ay + 23), d, 1)
                  else DrawBlend(dsurface, SurfaceX(bbx + ax - 10), SurfaceY(bby + ay + 19), d, 1);
                end;
              end else begin
                img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect - 81) * 10;
                if sex = 0 then
                  d := g_WState_Eff_Monk_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
                else d := g_WState_Eff_Monk_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
                if d <> nil then begin
                  if sex = 0 then
                    DrawBlend(dsurface, SurfaceX(bbx + ax - 11), SurfaceY(bby + ay + 25), d, 1)
                  else DrawBlend(dsurface, SurfaceX(bbx + ax - 15), SurfaceY(bby + ay + 20), d, 1);
                end;
              end;
            end;
          end;
        end;
     end else begin

     if UserState1.Job = 8 then begin    //»ó´ë¹æ ºñ¿¬ÀÚ°´ »óÅÂÃ¢
        pgidx := 379;
        bbx := Left + 8;
        bby := Top + 90;
        d := g_WMainImages.Images[pgidx];
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
        if UserState1.Mask in [20, 21] then begin
          if UserState1.Mask = 20 then begin
            pgidx := 930;
            bbx := Left + 28;
            bby := Top + 120;
            d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
            DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);
            d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
          end else begin
            pgidx := 932;
            bbx := Left + 48;
            bby := Top + 135;
            d := g_WMain2Images.Images[933];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
          end;
          d := g_WMain2Images.Images[pgidx];
          if d <> nil then
          dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
        end else begin
          if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
            d := g_WMainImages.Images[UserState1.Job * 2 + 320 + sex];
           end else
           d := g_WMainImages.Images[320 + sex];
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx-2), SurfaceY(bby+64), d.ClientRect, d, TRUE);
        end;
        bbx := Left + 8;
        bby := Top - 23;

        if UserState1.UseItems[U_DRESS].S.Name <> '' then begin
          idx := UserState1.UseItems[U_DRESS].S.Looks;
          if idx >= 0 then begin
           if sex = 1 then begin
             if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
               if idx = 86 then
                 e := g_WMain2Images.GetCachedImage(1217, ax, ay);
               if idx = 605 then
                 e := g_WMain2Images.GetCachedImage(1227, ax, ay);
               d := FrmMain.GetWStateAssWoImg(idx,ax,ay);
             end else begin
               if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1219, ax, ay);
               if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1229, ax, ay);
               d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
             end;
           end else begin
             if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
               if idx = 85 then
                 e := g_WMain2Images.GetCachedImage(1216, ax, ay);
               if idx = 595 then
                 e := g_WMain2Images.GetCachedImage(1226, ax, ay);
               d := FrmMain.GetWStateAssManImg(idx,ax,ay);
             end else begin
               if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1218, ax, ay);
               if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                 e := g_WMain2Images.GetCachedImage(1228, ax, ay);
               d := FrmMain.GetWStateComManImg(idx,ax,ay);
             end;
           end;
           if UserState1.Mask in [20, 21] then begin
             d := nil; e := nil;
           end;
           if d <> nil then
            if sex = 0 then begin
              if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-23), SurfaceY(bby+ay-10), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-50), SurfaceY(bby+ay-15), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-21), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE);
              end else begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-28), SurfaceY(bby+ay-12), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-75), SurfaceY(bby+ay-19), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-21), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE);
              end;
            end else begin
              if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-15), SurfaceY(bby+ay- 9), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-53), SurfaceY(bby+ay- 25), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end else begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-42), SurfaceY(bby+ay- 13), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-67), SurfaceY(bby+ay- 23), e.ClientRect, e, TRUE);
                end;
                dsurface.Draw (SurfaceX(bbx+ax-24), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
        //»ó´ë Çì¾î  ºñ¿¬ÀÚ°´
        idx := 460 + hair;
        if sex = 1 then  idx := 500 + hair;
        if UserState1.UseItems[U_HELMET].S.Name <> '' then begin
          idx := UserState1.UseItems[U_HELMET].S.Looks;
          if idx >= 0 then begin
           if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

           end else begin
           if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
             d := FrmMain.GetWStateAssManImg(idx,ax,ay);
           end else
             d := FrmMain.GetWStateComManImg(idx,ax,ay);
           if sex = 1 then
           if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
             d := FrmMain.GetWStateAssWoImg(idx,ax,ay);
           end else
             d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
           end;
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
             if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
               dsurface.Draw (SurfaceX(bbx+ax - 21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);
             end else
               dsurface.Draw (SurfaceX(bbx+ax - 21), SurfaceY(bby+ay + 25), d.ClientRect, d, TRUE);
            end else
             if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
               dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
             end else
               dsurface.Draw (SurfaceX(bbx+ax - 24), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
          end;
          idx := 0;
        end;
        if idx > 0 then begin
          if (UserState1.UseItems[U_DRESS].S.Shape = 20) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

          end else
            d := g_WMainImages.GetCachedImage (idx, ax, ay);
          if UserState1.Mask in [20, 21] then d := nil;
          if d <> nil then
          if sex = 0 then begin
           if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
            dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
           end else
            dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE)
          end else
          if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
            dsurface.Draw (SurfaceX(bbx+ax - 22), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
          end else
            dsurface.Draw (SurfaceX(bbx+ax - 24), SurfaceY(bby+ay+20), d.ClientRect, d, TRUE);
        end;
        if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin     //»óÅÂÃ¢ÀÛ¾÷
         idx := UserState1.UseItems[U_WEAPON].S.Looks;
         if idx >= 0 then begin
          if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
            d := FrmMain.GetWStateAssManImg(idx,ax,ay);
          end else
            d := FrmMain.GetWStateComManImg(idx,ax,ay);
         if sex = 1 then
          if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
            d := FrmMain.GetWStateAssWoImg(idx,ax,ay);
          end else
            d := FrmMain.GetWStateComWomanImg(idx,ax,ay);
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
            if sex = 0 then begin
               if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
                dsurface.Draw (SurfaceX(bbx+ax-19), SurfaceY(bby+ay+26), d.ClientRect, d, TRUE);
               end else
                dsurface.Draw (SurfaceX(bbx+ax-23), SurfaceY(bby+ay+23), d.ClientRect, d, TRUE);
            end else
               if UserState1.UseItems[U_WEAPON].S.Shape in [86..89,96..98,100..102,104] then begin
                dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+25), d.ClientRect, d, TRUE);
               end else
                dsurface.Draw (SurfaceX(bbx+ax-22), SurfaceY(bby+ay+19), d.ClientRect, d, TRUE);
           if (UserState1.UseItems[U_WEAPON].S.WEffect > 0) then begin
             if (UserState1.UseItems[U_WEAPON].S.WEffect in [34..37,39..41,43..46]) then begin
               img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect) * 10;
               if sex = 0 then
                 d := g_WState_Eff_Common_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
               else d := g_WState_Eff_Common_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
               if d <> nil then begin
                 if sex = 0 then
                   DrawBlend(dsurface, SurfaceX(bbx + ax - 23), SurfaceY(bby + ay + 23), d, 1)
                 else DrawBlend(dsurface, SurfaceX(bbx + ax - 22), SurfaceY(bby + ay + 19), d, 1);
               end;
             end else begin
               img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect - 85) * 10;
               if sex = 0 then
                 d := g_WState_Eff_Assassin_Man.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay )
               else d := g_WState_Eff_Assassin_Woman.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay );
               if d <> nil then begin
                 if sex = 0 then
                   DrawBlend(dsurface, SurfaceX(bbx + ax - 19), SurfaceY(bby + ay + 26), d, 1)
                 else DrawBlend(dsurface, SurfaceX(bbx + ax - 22), SurfaceY(bby + ay + 25), d, 1);
               end;
             end;
           end;
         end;
        end;
     end else begin          //»ó´ë¹æ ÀÏ¹Ý »óÅÂÃ¢
      if UserState1.Mask in [20, 21] then begin
        if UserState1.Mask = 20 then begin
          pgidx := 930;
          bbx := Left + 28;
          bby := Top + 120;

          d := g_WMain2Images.Images[940 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(bbx + 10 ), SurfaceY(bby - 20), d, 1);

          d := g_WMain2Images.Images[950 +  Integer((GetTickCount - AppendTick) div 300 mod 4) ];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(bbx - 10), SurfaceY(bby - 8), d, 1);
        end else begin
           pgidx := 932;
           bbx := Left + 48;
           bby := Top + 135;
           d := g_WMain2Images.Images[933];
           if d <> nil then
           DrawBlend(dsurface, SurfaceX(bbx - 128), SurfaceY(bby - 146), d, 1);
        end;
        d := g_WMain2Images.Images[pgidx];
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
      end else begin
        if UserState1.bHero then begin
          if sex = 1 then pgidx := 346
          else pgidx := 345;
        end else begin
          if sex = 1 then pgidx := 341
          else pgidx := 340;
        end;
        bbx := Left + 8;
        bby := Top + 90;
        d := g_WMainImages.Images[pgidx];
        if d <> nil then
         dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
      end;
      bbx := Left;
      bby := Top;
      if UserState1.UseItems[U_DRESS].S.Name <> '' then begin
         idx := UserState1.UseItems[U_DRESS].S.Looks; //if m_btSex = 1 then idx := 80;
         if idx >= 0 then begin
           if sex = 1 then begin
             if idx = 86 then     //¹«ºÀ(¿©) °ø¿ë
               e := g_WMain2Images.GetCachedImage(1203, ax, ay);
             if idx = 605 then   //Ãµ·æ(¿©) °ø¿ë
                e := g_WMain2Images.GetCachedImage(1205, ax, ay);
           end else begin
             if idx = 85 then     //¹«ºÀ(³²) °ø¿ë
                e := g_WMain2Images.GetCachedImage(1202, ax, ay);
             if idx = 595 then   //Ãµ·æ(³²) °ø¿ë
                e := g_WMain2Images.GetCachedImage(1204, ax, ay);
           end;
            d := FrmMain.GetWStateImg(idx,ax,ay);
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then begin
              if Sex = 1 then begin
                if e <> nil then begin
                  if idx = 86 then
                    dsurface.Draw (SurfaceX(bbx+ax-30), SurfaceY(bby+ay - 31), e.ClientRect, e, TRUE);
                  if idx = 605 then
                    dsurface.Draw (SurfaceX(bbx+ax-38), SurfaceY(bby+ay - 34), e.ClientRect, e, TRUE);
                end;
              end else begin
                if e <> nil then begin
                  if idx = 85 then
                    dsurface.Draw (SurfaceX(bbx+ax-26), SurfaceY(bby+ay - 40), e.ClientRect, e, TRUE);
                  if idx = 595 then
                    dsurface.Draw (SurfaceX(bbx+ax-35), SurfaceY(bby+ay - 40), e.ClientRect, e, TRUE);
                end;
              end;
               dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
              if (UserState1.UseItems[U_DRESS].S.AniCount > 0) and (UserState1.Job in [4, 9]) then begin
                img := 0 + (UserState1.UseItems[U_DRESS].S.AniCount - 1) * 20;
                d := g_WState_Eff_BImages.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 100 mod 12), ax, ay ) ;
                if d <> nil then
                  DrawBlend(dsurface, SurfaceX(bbx + ax + 127), SurfaceY(bby + ay + 222), d, 1);
              end;
            end;
         end;
      end;
      //»ó´ë Çì¾î  ÀÏ¹Ý
      idx := 440 + hair;
      if sex = 1 then
      idx := 480 + hair;
      if UserState1.UseItems[U_HELMET].S.Name <> '' then begin
         idx := UserState1.UseItems[U_HELMET].S.Looks;
         if idx >= 0 then begin
           if (UserState1.UseItems[U_DRESS].S.Shape in [30,111]) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

           end else
            d := FrmMain.GetWStateImg(idx,ax,ay);
            if UserState1.Mask in [20, 21] then d := nil;
            if d <> nil then
               if Sex = 0 then begin
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay+2), d.ClientRect, d, TRUE);
               end else
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
         end;
         idx := 0;
      end;
      if idx > 0 then begin
       if (UserState1.UseItems[U_DRESS].S.Shape in [30,111]) and (UserState1.UseItems[U_DRESS].S.Name <> '') then begin

       end else
         d := g_WMainImages.GetCachedImage (idx, ax, ay);
         if UserState1.Mask in [20, 21] then d := nil;
         if UserState1.Job = 5 then d := nil;
         if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
      end;

      if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin
         idx := UserState1.UseItems[U_WEAPON].S.Looks;
         if idx >= 0 then begin
           d := FrmMain.GetWStateImg(idx,ax,ay);
           if UserState1.Mask in [20, 21] then d := nil;
           if d <> nil then begin
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
             if idx = 923 then begin
               d := FrmMain.GetWStateImg(idx-1,ax,ay);
               if UserState1.Mask in [20, 21] then d := nil;
               if d <> nil then DrawBlend (dsurface,bbx + ax,bby + ay,d, 1);
             end;
             if (UserState1.UseItems[U_WEAPON].S.WEffect > 0) then begin
               if UserState1.UseItems[U_WEAPON].S.WEffect in [93..98] then  //ÀÚ°´ º°µµ
                 img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect + 11 ) * 10
               else
               img := 0 + (UserState1.UseItems[U_WEAPON].S.WEffect ) * 10;
               d := g_WState_Eff.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 200 mod 4), ax, ay ) ;
               if d <> nil then
                 DrawBlend(dsurface, SurfaceX(bbx + ax  ), SurfaceY(bby + ay ), d, 1);
             end;
             if (UserState1.UseItems[U_WEAPON].S.Shape in [11,12,14,15]) and (UserState1.Job in [4, 9]) then begin
               case UserState1.UseItems[U_WEAPON].S.Shape of
                 11: img := 120;
                 12: img := 140;
                 14: img := 100;
                 15: img := 80;
               end;
               d := g_WState_Eff_BImages.GetCachedImage(img + Integer((GetTickCount - AppendTick) div 100 mod 20), ax, ay ) ;
               if d <> nil then
                 DrawBlend(dsurface, SurfaceX(bbx + ax + 127), SurfaceY(bby + ay + 222), d, 1);
             end;
           end;
         end;
      end;
     end;
     end;
     end;
     end;

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := UserState1.NameColor;       //ÀÌ¸§
         tx := 135 - TextWidth(UserState1.UserName) div 2;
         TextOut (SurfaceX(Left + tx),
                  SurfaceY(Top + 16), UserState1.UserName);
         DLoverHeart.Left := tx- 14 ;
         DLoverHeart.Top := 16;

         Case UserState1.Column of
           0:  ;
           1: begin
             Font.Color := clYellow;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), UserState1.ColumName);
           end;
           2: begin
             Font.Color := clYellow;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), UserState1.ColumName);
           end;
           3: begin
             Font.Color := clFuchsia;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), UserState1.ColumName);
           end;
           4: begin
             Font.Color := clFuchsia;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), UserState1.ColumName);
           end;
           5: begin
             Font.Color := clRed;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), UserState1.ColumName);
           end;
           6: begin
             Font.Color := clRed;
             TextOut (SurfaceX(Left + 186), SurfaceY(Top + 16), UserState1.ColumName);
           end;
         end;

         fstr := Copy(UserState1.FameName, 1, pos(' ', UserState1.FameName)-1 );
         tx := 135 - TextWidth(UserState1.FameName) div 2;
         Font.Color := clWhite;
         TextOut (SurfaceX(Left + tx), SurfaceY(Top + 50), UserState1.FameName );
         Font.Color := clLime;
         TextOut (SurfaceX(Left + tx), SurfaceY(Top + 50), fstr );

         Font.Color := clSilver;
         output:= UserState1.GuildName + ' ' + UserState1.GuildRankName;
         TextOut (SurfaceX(Left + 135) - TextWidth(output) div 2, SurfaceY(Top + 33), output);
         Font.Color := ClWhite;
         Release;
      end;
   end;
end;

procedure TFrmDlg.DUserState1MouseDown(Sender: TObject;      //Ã¤ÆÃ Ã¢ ºÎºÐ
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   X := DUserState1.LocalX (X) - DUserState1.Left;
   Y := DUserState1.LocalY (Y) - DUserState1.Top;
   if (X > 42) and (X < 200) and (Y > 32) and (Y < 46) then begin
      //DScreen.AddSysMsg (IntToStr(X) + ' ' + IntToStr(Y) + ' ' + UserState1.GuildName);
      if UserState1.GuildName <> '' then begin
         PlayScene.EdChat.Visible := TRUE;
         PlayScene.EdChat.SetFocus;
         SetImeMode (PlayScene.EdChat.Handle, imSHanguel);   //ÇÑ±Û
         PlayScene.EdChat.Text := UserState1.GuildName;
         PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
         PlayScene.EdChat.SelLength := 0;
      end;
   end;
  if (x > 42) and ( x < 200) and (y > 15) and (y < 31) then begin
    if UserState1.UserName <> '' then begin
      PlayScene.EdChat.Visible :=TRUE;
      PlayScene.EdChat.SetFocus;
      SetImeMode (PlayScene.EdChat.Handle, imSHanguel);   //ÇÑ±Û
      PlayScene.EdChat.Text := '/'+ UserState1.UserName + ' ';
      PlayScene.EdChat.SelStart:= Length(PlayScene.EdChat.Text);
      PlayScene.EdChat.SelLength :=0;
    end;
  end;
end;

procedure TFrmDlg.DUserState1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var                               //»ó´ë¹æ ¾ÆÀÌÅÛ »óÅÂÃ¢
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg, sMsg1: String;
begin
   g_MouseStateItem.S.Name := '';
   DScreen.ClearHint;
   X := DUserState1.LocalX (X) - DUserState1.Left;
   Y := DUserState1.LocalY (Y) - DUserState1.Top;


   if (X > 33) and (X < 236) and (Y > 12) and (Y < 30) or (Sender = DLoverHeart ) then begin
    if UserState1.LoverName <> '' then begin
     sMsg := UserState1.LoverName+'µÄ °®ÈË' ;
     DScreen.ShowHintA (DUserState1.Left + 90, DUserState1.Top + 28,
                           sMsg, clYellow, FALSE);
     exit;
    end;
   end;


   if (X > 17) and (X < 33) and (Y > 12) and (Y < 28) then begin
    if (UserState1.GuildName <> '') and (UserState1.GuildMark <> 0) then begin
      sMsg1 := 'ÕÆÃÅ: ' + UserState1.GuildOwnerName;
      DScreen.ShowHintA (DUserState1.Left + 33, DUserState1.Top + 12,
                           sMsg1, clYellow, FALSE);
      exit;
    end;
   end;

   if (X > 12) and (X < 45) and (Y > 30) and (Y < 62) then begin
      case UserState1.Job of
         0: sMsg1 := 'Õ½Ê¿';
         1: sMsg1 := '·¨Ê¦';
         2: sMsg1 := 'µÀÊ¿';
         3: sMsg1 := '´Ì¿Í';
         4: sMsg1 := 'ºÍÉÐ';
         5: sMsg1 := '±ÌÑªÕ½Ê¿';
         6: sMsg1 := 'ºëÐþ·¨Ê¦';
         7: sMsg1 := 'ñ´ÏÉµÀÊ¿';
         8: sMsg1 := '·ÉÑà´Ì¿Í';
         9: sMsg1 := 'ÆÆ½äÉ®';
      end;
         DScreen.ShowHintA (DUserState1.Left + 15, DUserState1.Top + 15,
                           sMsg1, clYellow, FALSE);
         exit;
   end;


    Butt:=TDButton(Sender);
    if Sender = DUSFriend then sMsg := 'Ìí¼ÓºÃÓÑ'
    else if Sender = DUSGroup then sMsg := 'ÑûÇë×é¶Ó'
    else if Sender = DUSMail then sMsg := '·¢ËÍË½ÁÄ';
    nHintX:=Butt.SurfaceX(Butt.Left + 5);
    nHintY:=Butt.SurfaceY(Butt.Top );
    DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   nLocalX,nLocalY:Integer;
   nHintX,nHintY:Integer;
   sel: integer;
   Butt:TDButton;
   nWhere: Integer;
   List: TStringList;
begin
   sel := -1;
   Butt:=TDButton(Sender);
   if Sender = DDressUS1 then sel := U_DRESS;
   if Sender = DWeaponUS1 then sel := U_WEAPON;
   if Sender = DHelmetUS1 then sel := U_HELMET;
   if Sender = DNecklaceUS1 then sel := U_NECKLACE;
   if Sender = DLightUS1 then sel := U_RIGHTHAND;
   if Sender = DRingLUS1 then sel := U_RINGL;
   if Sender = DRingRUS1 then sel := U_RINGR;
   if Sender = DArmRingLUS1 then sel := U_ARMRINGL;
   if Sender = DArmRingRUS1 then sel := U_ARMRINGR;

   if Sender = DBujukUS1 then sel := U_BUJUK;
   if Sender = DBeltUS1 then sel := U_BELT;
   if Sender = DBootsUS1 then sel := U_BOOTS;
   if Sender = DCharmUS1 then sel := U_CHARM;
   if Sender = DTigerUS1 then sel := U_TIGER; //È£¶ûÀÌ

   if sel >= 0 then begin
      g_MouseItem := UserState1.UseItems[sel];
      if (g_MouseItem.s.Name <> '') then begin
        nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
        if (nWhere >= 0) then begin
          List := TStringList.Create;
          try
            GetMouseItemHint(g_MySelf, @g_MouseItem);
            List.AddStrings(HintList);

            GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
            if HintList.Count > 0 then begin
              HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];     //»ó´ë¹æ »óÅÂÃ¢
            end;
            nLocalX:=Butt.LocalX(X - Butt.Left);
            nLocalY:=Butt.LocalY(Y - Butt.Top);
            nHintX:=Butt.SurfaceX(Butt.Left) + DUserState1.SurfaceX(DUserState1.Left) + nLocalX + 5;
            nHintY:=Butt.SurfaceY(Butt.Top) + DUserState1.SurfaceY(DUserState1.Top) + nLocalY + 5;
            with Butt as TDButton do
              DScreen.ShowHintL(nHintX, nHintY, List, HintList, False);
            HintList.Clear;
          finally
            FreeAndNil(List);
          end;
          g_MouseItem.s.Name := '';
        end else begin
          GetMouseItemHint(g_MySelf, @g_MouseItem);
          nLocalX:=Butt.LocalX(X - Butt.Left);
          nLocalY:=Butt.LocalY(Y - Butt.Top);
          nHintX:=Butt.SurfaceX(Butt.Left) + DUserState1.SurfaceX(DUserState1.Left) + nLocalX + 5;
          nHintY:=Butt.SurfaceY(Butt.Top) + DUserState1.SurfaceY(DUserState1.Top) + nLocalY + 5;
          with Butt as TDButton do
            DScreen.ShowHintB(nHintX, nHintY, HintList, False);
        end;
      end;
   end else begin
     g_MouseItem.s.Name := '';
   end;
end;

procedure TFrmDlg.DCloseUS1Click(Sender: TObject; X, Y: Integer);
begin
   DUserState1.Visible := FALSE;
end;


procedure TFrmDlg.DNecklaceUS1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx, ax, ay, i: Integer;
  d: TDirectDrawSurface;
  nWhere: Integer;
begin
  nWhere := -1;
  if Sender = DWeaponUS1 then nWhere := U_WEAPON;
  if Sender = DDressUS1 then nWhere := U_DRESS;
  if Sender = DHelmetUS1 then nWhere := U_HELMET;
  if Sender = DNecklaceUS1 then nWhere := U_NECKLACE;
  if Sender = DLightUS1 then nWhere := U_RIGHTHAND;
  if Sender = DArmringRUS1 then nWhere := U_ARMRINGR;
  if Sender = DArmringLUS1 then nWhere := U_ARMRINGL;
  if Sender = DRingRUS1 then nWhere := U_RINGR;
  if Sender = DRingLUS1 then nWhere := U_RINGL;
  if Sender = DBujukUS1 then nWhere := U_BUJUK;
  if Sender = DBeltUS1 then nWhere := U_BELT;
  if Sender = DBootsUS1 then nWhere := U_BOOTS;
  if Sender = DCharmUS1 then nWhere := U_CHARM;
  if Sender = DTigerUS1 then nWhere := U_TIGER;

  if nWhere >= 0 then begin
    if UserState1.UseItems[nWhere].s.Name <> '' then begin
      Idx := UserState1.UseItems[nWhere].s.looks;
      if Idx >= 0 then begin
        d := g_WBagItemImages.Images[idx];
        if d <> nil then
          with TDButton(Sender) do
            dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
              SurfaceY(Top + (Height - d.Height) div 2),
              d.ClientRect, d, True);

          if (UserState1.UseItems[nWhere].S.btValue[19] > 2) and        //ºÀÀÎ
            (now < UnixToDateTime(DateTimeToUnix(UserState1.UseItems[nWhere].S.MaxDate))) then begin
            d := g_WStateItemImages.Images[3590];
            if d <> nil then
              with TDButton(Sender) do
              dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2) + 12,
                                SurfaceY(Top + (Height - d.Height) div 2) + 8, d.ClientRect, d, True);
          end;
          if UserState1.UseItems[nWhere].S.ItemGlow <> 0  then
          if (aiShineFrame[nWhere] <> -1) then begin
            d := g_WMainImages.GetCachedImage(ITEMSHINEOFFSET + aiShineFrame[nWhere], ax,ay);
            if d <> nil then begin
              with TDButton(Sender) do
              DrawBlend(dsurface, SurfaceX(Left + ax - 6), SurfaceY(Top + ay) + 41, d, 1);
            end;
          end;
          for i := 0 to 13 do begin
            if GetTickCount > aiShineTime[i] + 80 then begin
              aiShineTime[i] := GetTickCount;
              if aiShineFrame[i] < 9 then
                aiShineFrame[i] := aiShineFrame[i] + 1
              else begin
                aiShineFrame[i] := -1;
                aiShineTime[i] := GetTickCount + 2000 + Random(1500);
              end;
            end;
          end;

      end;
    end;
  end;
end;

procedure TFrmDlg.ShowGuildDlg;
begin
   DGuildDlg.Visible := TRUE;  //not DGuildDlg.Visible;
   DGuildDlg.Top := -3;
   DGuildDlg.Left := 0;
   if DGuildDlg.Visible then begin
      if GuildCommanderMode then begin
         DGDAddMem.Visible := TRUE;
         DGDDelMem.Visible := TRUE;
         DGDEditNotice.Visible := TRUE;
         DGDEditGrade.Visible := TRUE;
         DGDAlly.Visible := TRUE;
         DGDBreakAlly.Visible := TRUE;
         DGDWar.Visible := TRUE;
         DGDCancelWar.Visible := TRUE;
      end else begin
         DGDAddMem.Visible := FALSE;
         DGDDelMem.Visible := FALSE;
         DGDEditNotice.Visible := FALSE;
         DGDEditGrade.Visible := FALSE;
         DGDAlly.Visible := FALSE;
         DGDBreakAlly.Visible := FALSE;
         DGDWar.Visible := FALSE;
         DGDCancelWar.Visible := FALSE;
      end;
   end;
   GuildTopLine := 0;
end;

procedure TFrmDlg.ShowGuildEditNotice;
var
   d: TDirectDrawSurface;
   i: integer;
   data: string;
begin
   with DGuildEditNotice do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
         Left := (g_FScreenWidth - d.Width) div 2;
         Top := (g_FScreenHeight - d.Height) div 2;
      end;
      HideAllControls;
      DGuildEditNotice.ShowModal;

      Memo.Left := SurfaceX(Left+12);  //16
      Memo.Top  := SurfaceY(Top+36);   //36
      Memo.Width := 564;
      Memo.Height := 256;
      Memo.Lines.Assign (GuildNotice);
      Memo.Visible := TRUE;


      while TRUE do begin
         if not DGuildEditNotice.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DGuildEditNotice.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
         data := '';
         for i:=0 to Memo.Lines.Count-1 do begin
            if Memo.Lines[i] = '' then
               data := data + Memo.Lines[i] + ' '#13
            else data := data + Memo.Lines[i] + #13;
         end;
         if Length(data) > 4000 then begin
            data := Copy (data, 1, 4000);
            DMessageDlg ('ÊäÈëµÄÄÚÈÝ³¤¶È¹ý³¤£¬³¬³öµÄ²¿·Ö½«±»×Ô¶¯ÆÁ±Î¡£', [mbOk]);
         end;
         FrmMain.SendGuildUpdateNotice (data);
      end;
   end;
end;

procedure TFrmDlg.ShowGuildEditGrade;
var
   d: TDirectDrawSurface;
   data: string;
   i: integer;
begin
   if GuildMembers.Count <= 0 then begin
      DMessageDlg ('µã»÷[³ÉÔ±ÁÐ±í]½øÐÐ±à¼­¡£', [mbOk]);
      exit;
   end;

   with DGuildEditNotice do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
         Left := (g_FScreenWidth - d.Width) div 2;
         Top := (g_FScreenHeight - d.Height) div 2;
      end;
      HideAllControls;
      DGuildEditNotice.ShowModal;
      ///Guild Members Grade screen
      Memo.Left := SurfaceX(Left+12);  //16
      Memo.Top  := SurfaceY(Top+36);   //36
      Memo.Width := 564;
      Memo.Height := 256;
      Memo.Lines.Assign (GuildMembers);
      Memo.Visible := TRUE;

      while TRUE do begin
         if not DGuildEditNotice.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DGuildEditNotice.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
      //   GuildMembers.Assign (Memo.Lines);

         data := '';
         for i:=0 to Memo.Lines.Count-1 do begin
            data := data + Memo.Lines[i] + #13;
         end;
         if Length(data) > 5000 then begin
            data := Copy (data, 1, 5000);
            DMessageDlg ('ÊäÈëµÄÄÚÈÝ³¤¶È¹ý³¤£¬³¬³öµÄ²¿·Ö½«±»×Ô¶¯ÆÁ±Î¡£', [mbOk]);
         end;
         FrmMain.SendGuildUpdateGrade (data);
      end;
   end;
end;

procedure TFrmDlg.DGuildDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  i, n, bx, by: integer;
begin
   with DGuildDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      d := g_WGuildImages.Images[g_nGuildMark];
      if d <> nil then
       dsurface.Draw (SurfaceX(Left+269), SurfaceY(Top+10), d.ClientRect, d, TRUE);

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         TextOut (Left+306, Top+12, Guild);
         if GuildMode = 0 then begin
           Font.Color := clYellow;
           TextOut (Left+502, Top+12, 'ÖÐÁ¢ÐÐ»á');
         end else begin
           Font.Color := clRed;
           TextOut (Left+502, Top+12, 'µÐ¶ÔÐÐ»á');
         end;

         bx := Left + 10;
         by := Top + 42;      //55
         for i:=GuildTopLine to GuildStrs.Count-1 do begin
            n := i-GuildTopLine;
            if n*14 > 320 then break;
            if Integer(GuildStrs.Objects[i]) <> 0 then Font.Color := TColor(GuildStrs.Objects[i])
            else begin
               if BoGuildChat then Font.Color := GetRGB (2)
               else Font.Color := clSilver;
            end;
            TextOut (bx+5, by + n*14, GuildStrs[i]);
         end;

         Release;
      end;

   end;
end;

procedure TFrmDlg.DGDUpClick(Sender: TObject; X, Y: Integer);
begin
   if GuildTopLine > 0 then Dec (GuildTopLine, 3);
   if GuildTopLine < 0 then GuildTopLine := 0;
end;

procedure TFrmDlg.DGDDownClick(Sender: TObject; X, Y: Integer);
begin
   if GuildTopLine+12 < GuildStrs.Count then Inc (GuildTopLine, 3);
end;

procedure TFrmDlg.DGDCloseClick(Sender: TObject; X, Y: Integer);
begin
   DGuildDlg.Visible := FALSE;
   BoGuildChat := FALSE;
end;

procedure TFrmDlg.DGDHomeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendGuildHome;
      BoGuildChat := FALSE;
   end;
end;

procedure TFrmDlg.DGDListClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendGuildMemberList;
      BoGuildChat := FALSE;
   end;
end;

procedure TFrmDlg.DGDAddMemClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('ÇëÊäÈëÄãÒªÌí¼Óµ½ÐÐ»á-' + Guild + 'ÖÐµÄÈËÔ±µÄÃû×Ö¡£', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendGuildAddMem (DlgEditText);
end;

procedure TFrmDlg.DGDDelMemClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('ÇëÊäÈëÄãÒª´ÓÐÐ»á-' + Guild + 'ÖÐÉ¾³ýµÄ³ÉÔ±µÄÃû×Ö¡£', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendGuildDelMem (DlgEditText);
end;

procedure TFrmDlg.DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
   GuildEditHint := '[ÐÞ¸ÄÐÐ»á¹«¸æÄÚÈÝ]';
   ShowGuildEditNotice;
end;

procedure TFrmDlg.DGDEditGradeClick(Sender: TObject; X, Y: Integer);
begin
   GuildEditHint := '[ÐÞ¸ÄÐÐ»á³ÉÔ±µÄ±àºÅºÍÐòÁÐ¡£ #×¢Òâ: Ìí¼Ó/É¾³ý³ÉÔ±]';
   ShowGuildEditGrade;
end;

procedure TFrmDlg.DGDAllyClick(Sender: TObject; X, Y: Integer);
begin
   if mrOk = DMessageDlg ('Èç¹ûÄãÏëºÍ¶Ô·½ÐÐ»á½áÎªÁªÃËÐÐ»á£¬ÇëÏÈÊäÈë [@ÔÊÐíÁªÃË] \' +
                  'È»ºóË«·½ÕÆÃÅÃæ¶ÔÃæÕ¾×ÅÊäÈë@ÁªÃË\ \' +
                  'ÄãÈ·¶¨ÒªºÍ¶Ô·½ÐÐ»áÁªÃËÂð£¿', [mbOk, mbCancel])
   then
      FrmMain.SendSay ('@Alliance');
end;

procedure TFrmDlg.DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('ÇëÊäÈëÄãÒªÈ¡ÏûÁªÃËµÄÐÐ»áµÄÃû³Æ¡£', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendSay ('@CancelAlliance ' + DlgEditText);
end;


procedure TFrmDlg.DGuildEditNoticeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DGuildEditNotice do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clSilver;

         TextOut (Left+70, Top+307, GuildEditHint);
         Release;
      end;
   end;
end;

procedure TFrmDlg.DGECloseClick(Sender: TObject; X, Y: Integer);
begin
   DGuildEditNotice.Visible := FALSE;
   Memo.Visible := FALSE;
   DMsgDlg.DialogResult := mrCancel;
end;

procedure TFrmDlg.DGEOkClick(Sender: TObject; X, Y: Integer);
begin
   DGECloseClick (self, 0, 0);
   DMsgDlg.DialogResult := mrOk;
end;

procedure TFrmDlg.AddGuildChat (str: string);
var
   i: integer;
begin
   GuildChats.Add (str);
   if GuildChats.Count > 500 then begin
      for i:=0 to 100 do GuildChats.Delete(0);
   end;
   if BoGuildChat then
      GuildStrs.Assign (GuildChats);
end;

function TFrmDlg.ConvertEscChar(str : String) : string;
begin
   // Convert...
   Result := str;
end;

procedure TFrmDlg.DGDChatClick(Sender: TObject; X, Y: Integer);
begin
   BoGuildChat := not BoGuildChat;
   if BoGuildChat then begin
      GuildStrs2.Assign (GuildStrs);
      GuildStrs.Assign (GuildChats);
   end else
      GuildStrs.Assign (GuildStrs2);
end;

procedure TFrmDlg.DGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DGold do begin
    if Downed then
      d := WLib.Images[FaceIndex - 3]
    else
      d := WLib.Images[FaceIndex - 3];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;


{--------------------------------------------------------------}

procedure TFrmDlg.DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
begin
   DAdjustAbility.Visible := FALSE;
   g_nBonusPoint := g_nSaveBonusPoint;
end;

procedure TFrmDlg.DAdjustAbilityDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
   procedure AdjustAb (abil: byte; val: word; var lov, hiv: Word);
   var
      lo, hi: byte;
      i: integer;
   begin
      lo := Lobyte(abil);
      hi := Hibyte(abil);
      lov := 0; hiv := 0;
      for i:=1 to val do begin
         if lo+1 < hi then begin Inc(lo); Inc(lov);
         end else begin Inc(hi); Inc(hiv); end;
      end;
   end;
var
   d: TDirectDrawSurface;
   l, m, adc, amc, asc, aac, amac: integer;
   ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
   Name ,job:String;
begin
   if g_MySelf = nil then exit;
   with dsurface.Canvas do begin
      with DAdjustAbility do begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;

      SetBkMode (Handle, TRANSPARENT);
      Font.Color := clWhite;
      Font.Size := 11;
      Font.Style := [fsBold];
      Case g_MySelf.m_btJob of
       0 : job := 'Õ½Ê¿';
       1 : job := '·¨Ê¦';
       2 : job := 'µÀÊ¿';
       3 : job := '´Ì¿Í';
       4 : job := 'ºÍÉÐ';
       5 : job := '±ÌÑªÕ½Ê¿';
       6 : job := 'ºëÐþ·¨Ê¦';
       7 : job := 'ñ´ÏÉµÀÊ¿';
       8 : job := '·ÉÑà´Ì¿Í';
       9 : job := 'ÆÆ½äÉ®';
      end;
      Name := g_MySelf.m_sUserName + ' ' + 'Lv.' + intToStr(g_MySelf.m_Abil.Level) + 'µÄ ' + job ;
      TextOut (DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 151 - TextWidth(Name) div 2 , DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 7, Name);
      Font.Size := 9;
      Font.Style := [];
      l := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 26;
      m := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 306;

      TextOut (l - 10, m,      'Ê¹ÓÃ½±Àø»ý·ÖÀ´´´½¨×Ô¼ºµÄ½ÇÉ«²¢´´½¨×Ô¼º');
      TextOut (l - 10, m+14,   '¶ÀÌØµÄ¼¼ÄÜ¡£');
      TextOut (l - 10, m+14*2, 'Ê¹ÓÃ(CTRL + Êó±ê×ó¼ü)Ò»´Î¿ÉÒÔÔö¼Ó10¸ö');
      TextOut (l - 10, m+14*3, 'µãÊý¡£');
      TextOut (l, m+14*5, 'Point. ');

      Font.Color := clRed;
      TextOut (l - 10, m+14*7, 'Ò»µ©µã»÷È·¶¨£¬Äã¾ÍÎÞ·¨»¹Ô­ÊôÐÔ¡£');


      Font.Color := clYellow;
      TextOut (l + 50, m+14*5, IntToStr(g_nBonusPoint));

      Font.Color := clWhite;

      l := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 100; //66;
      m := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 60;

      TextOut (l-80, m+0,   '   ¹¥»÷    -');
      TextOut (l-80, m+25,  '   Ä§·¨    -');
      TextOut (l-80, m+50,  '   µÀÊõ    -');
      TextOut (l-80, m+75,  '   ·ÀÓù    -');
      TextOut (l-80, m+100, '   Ä§Óù   -');
      TextOut (l-80, m+125, '   HP    -');
      TextOut (l-80, m+150, '   MP    -');
      TextOut (l-80, m+175, '   ×¼È· -');
      TextOut (l-80, m+200, '   Ãô½Ý -');

      adc := (g_BonusAbilChg.DC) div g_BonusTick.DC;
      amc := (g_BonusAbilChg.MC) div g_BonusTick.MC;
      asc := (g_BonusAbilChg.SC) div g_BonusTick.SC;
      aac := (g_BonusAbilChg.AC) div g_BonusTick.AC;
      amac := (g_BonusAbilChg.MAC) div g_BonusTick.MAC;

      AdjustAb (g_NakedAbil.DC, adc, ldc, hdc);
      AdjustAb (g_NakedAbil.MC, amc, lmc, hmc);
      AdjustAb (g_NakedAbil.SC, asc, lsc, hsc);
      AdjustAb (g_NakedAbil.AC, aac, lac, hac);
      AdjustAb (g_NakedAbil.MAC, amac, lmac, hmac);


      TextOut (l+0, m+0, IntToStr(LoWord(g_MySelf.m_Abil.DC)+ldc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.DC) + hdc));
      TextOut (l+0, m+25, IntToStr(LoWord(g_MySelf.m_Abil.MC)+lmc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MC) + hmc));
      TextOut (l+0, m+50, IntToStr(LoWord(g_MySelf.m_Abil.SC)+lsc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.SC) + hsc));
      TextOut (l+0, m+75, IntToStr(LoWord(g_MySelf.m_Abil.AC)+lac) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.AC) + hac));
      TextOut (l+0, m+100, IntToStr(LoWord(g_MySelf.m_Abil.MAC)+lmac) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MAC) + hmac));
      TextOut (l+0, m+125, IntToStr(g_MySelf.m_Abil.MaxHP + (g_BonusAbil.HP + g_BonusAbilChg.HP) div g_BonusTick.HP));
      TextOut (l+0, m+150, IntToStr(g_MySelf.m_Abil.MaxMP + (g_BonusAbil.MP + g_BonusAbilChg.MP) div g_BonusTick.MP));
      TextOut (l+0, m+175, IntToStr(g_nMyHitPoint + (g_BonusAbil.Hit + g_BonusAbilChg.Hit) div g_BonusTick.Hit));
      TextOut (l+0, m+200, IntToStr(g_nMySpeedPoint + (g_BonusAbil.Speed + g_BonusAbilChg.Speed) div g_BonusTick.Speed));



      Font.Color := clWhite;
      l := DAdjustAbility.SurfaceX(DAdjustAbility.Left) + 155; //66;
      m := DAdjustAbility.SurfaceY(DAdjustAbility.Top) + 60;

      if g_BonusAbilChg.DC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+0, IntToStr(g_BonusAbilChg.DC + g_BonusAbil.DC) + '/' + IntToStr(g_BonusTick.DC));

      if g_BonusAbilChg.MC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+25, IntToStr(g_BonusAbilChg.MC + g_BonusAbil.MC) + '/' + IntToStr(g_BonusTick.MC));

      if g_BonusAbilChg.SC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+50, IntToStr(g_BonusAbilChg.SC + g_BonusAbil.SC) + '/' + IntToStr(g_BonusTick.SC));

      if g_BonusAbilChg.AC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+75, IntToStr(g_BonusAbilChg.AC + g_BonusAbil.AC) + '/' + IntToStr(g_BonusTick.AC));

      if g_BonusAbilChg.MAC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+100, IntToStr(g_BonusAbilChg.MAC + g_BonusAbil.MAC) + '/' + IntToStr(g_BonusTick.MAC));

      if g_BonusAbilChg.HP > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+125, IntToStr(g_BonusAbilChg.HP + g_BonusAbil.HP) + '/' + IntToStr(g_BonusTick.HP));

      if g_BonusAbilChg.MP > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+150, IntToStr(g_BonusAbilChg.MP + g_BonusAbil.MP) + '/' + IntToStr(g_BonusTick.MP));

      if g_BonusAbilChg.Hit > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+175, IntToStr(g_BonusAbilChg.Hit + g_BonusAbil.Hit) + '/' + IntToStr(g_BonusTick.Hit));

      if g_BonusAbilChg.Speed > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      TextOut (l+0, m+200, IntToStr(g_BonusAbilChg.Speed + g_BonusAbil.Speed) + '/' + IntToStr(g_BonusTick.Speed));

      Release;
   end;

end;

procedure TFrmDlg.DPlusDCClick(Sender: TObject; X, Y: Integer);
var
   incp: integer;
begin
   if g_nBonusPoint > 0 then begin
      if IsKeyPressed (VK_CONTROL) and (g_nBonusPoint > 10) then incp := 10
      else incp := 1;
      Dec(g_nBonusPoint, incp);
      if Sender = DPlusDC then Inc (g_BonusAbilChg.DC, incp);
      if Sender = DPlusMC then Inc (g_BonusAbilChg.MC, incp);
      if Sender = DPlusSC then Inc (g_BonusAbilChg.SC, incp);
      if Sender = DPlusAC then Inc (g_BonusAbilChg.AC, incp);
      if Sender = DPlusMAC then Inc (g_BonusAbilChg.MAC, incp);
      if Sender = DPlusHP then Inc (g_BonusAbilChg.HP, incp);
      if Sender = DPlusMP then Inc (g_BonusAbilChg.MP, incp);
      if Sender = DPlusHit then Inc (g_BonusAbilChg.Hit, incp);
      if Sender = DPlusSpeed then Inc (g_BonusAbilChg.Speed, incp);
   end;
end;

procedure TFrmDlg.DMinusDCClick(Sender: TObject; X, Y: Integer);
var
   decp: integer;
begin
   if IsKeyPressed (VK_CONTROL) and (g_nBonusPoint-10 > 0) then decp := 10
   else decp := 1;
   if Sender = DMinusDC then
      if g_BonusAbilChg.DC >= decp then begin
         Dec(g_BonusAbilChg.DC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMC then
      if g_BonusAbilChg.MC >= decp then begin
         Dec(g_BonusAbilChg.MC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusSC then
      if g_BonusAbilChg.SC >= decp then begin
         Dec(g_BonusAbilChg.SC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusAC then
      if g_BonusAbilChg.AC >= decp then begin
         Dec(g_BonusAbilChg.AC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMAC then
      if g_BonusAbilChg.MAC >= decp then begin
         Dec(g_BonusAbilChg.MAC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusHP then
      if g_BonusAbilChg.HP >= decp then begin
         Dec(g_BonusAbilChg.HP, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMP then
      if g_BonusAbilChg.MP >= decp then begin
         Dec(g_BonusAbilChg.MP, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusHit then
      if g_BonusAbilChg.Hit >= decp then begin
         Dec(g_BonusAbilChg.Hit, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusSpeed then
      if g_BonusAbilChg.Speed >= decp then begin
         Dec(g_BonusAbilChg.Speed, decp);
         Inc (g_nBonusPoint, decp);
      end;
end;

procedure TFrmDlg.DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.SendAdjustBonus(g_nBonusPoint, g_BonusAbilChg);
   DAdjustAbility.Visible := FALSE;
end;

procedure TFrmDlg.DAdjustAbilityMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, lx, ly: integer;
   flag: Boolean;
begin
   with DAdjustAbility do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      flag := FALSE;
      if (lx >= 50) and (lx < 150) and (ly >= 372) and (ly < 390) then begin
              DScreen.ShowHintA (SurfaceX(Left) + lx + 10,
                                 SurfaceY(Top) + ly + 5,
                                 '½±Àø»ý·Ö',
                                 clYellow,
                                 FALSE);
              flag := TRUE;
              exit;
      end;
      if (lx >= 50) and (lx < 150) then
         for i:=0 to 8 do begin  //DC,MC,SC..
            if (ly >= 54 + i*25) and (ly < 54 + (i+1)*25) then begin
               DScreen.ShowHintA (SurfaceX(Left) + lx + 10,
                                 SurfaceY(Top) + ly + 5,
                                 AdjustAbilHints[i],
                                 clYellow,
                                 FALSE);
               flag := TRUE;
               break;
            end;
         end;
      if not flag then
         DScreen.ClearHint;
   end;
end;

procedure TFrmDlg.DBotMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nLocalX,nLocalY, nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
begin
  pClickName := nil;
  pClickItem := nil;
  nClickNameIndex := 0;
  nClickItemIndex := 0;
  
  Butt:=TDButton(Sender);
  if Sender = DButtonMenuHero then sMsg := 'Ó¢ÐÛ²Ëµ¥'
  else if Sender = DButtonReCallHero then sMsg := 'ÕÙ»½/ÊÕ»Ø Ó¢ÐÛ'
  else if Sender = DBotItemShop then sMsg:= 'µãÈ¯ÉÌÆÌ<CO$FFFF>(Y)<CE>'
  else if Sender = DBotMenu then sMsg:= '<CO$FFFF>²Ëµ¥<CE>'
  else
  if Sender = DAuctionView then begin
    if AuctionView then sMsg:= '<CO$FFFF>ÏÞÊ±ÅÄÂô<CE>\¹Ø±ÕÅÄÂôÎïÆ·'
    else sMsg:= '<CO$FFFF>ÏÞÊ±ÅÄÂô<CE>\È·¶¨ÅÄÂôÎïÆ·';
  end
  else if Sender = DMyState then sMsg:= '×´Ì¬<CO$FFFF>(F10,C)<CE>'
  else if Sender = DMyBag then sMsg:= '±³°ü<CO$FFFF>(F9,I)<CE>'
  else if Sender = DMyMagic then sMsg:= '¼¼ÄÜ<CO$FFFF>(F11,S)<CE>'
  else if Sender = DBotQuest then sMsg:= 'ÈÎÎñ<CO$FFFF>(Q)<CE>'
  else if Sender = DOption then sMsg:= 'Ñ¡Ïî<CO$FFFF>(O)<CE>'

  else if Sender = DBottom then begin     //·¹º§
    if ((X >= 8) and (X <= 25)) and ((Y >= g_FScreenHeight - 40) and (Y <= g_FScreenHeight - 30)) then begin
      sMsg := '<CO$FFFF>µ±Ç°µÈ¼¶<CE>';
      DScreen.ShowHintA(25, g_FScreenHeight - 30,sMsg, clYellow, TRUE);
      exit;
    end
     //¹«°Ô
    else if ((X >= g_FScreenWidth - 107) and (X <= g_FScreenWidth - 32)) and ((Y >= g_FScreenHeight - 47) and (Y <= g_FScreenHeight - 36)) then begin
      sMsg := format('<CO$FFFF>ÖØÁ¿%d/%d<CE>',[g_MySelf.m_Abil.Weight,g_MySelf.m_Abil.MaxWeight]);
      DScreen.ShowHintA(g_FScreenWidth - 94, g_FScreenHeight - 30,sMsg, clYellow, TRUE);
      exit;
    end
    else if ((X >= 123) and (X <= 143)) and ((Y >= g_FScreenHeight - 40) and (Y <= g_FScreenHeight - 30)) then begin
      if g_MyHero <> nil then sMsg := '<CO$FFFF>Ó¢ÐÛµÈ¼¶<CE>'
      else sMsg := '<CO$FFFF>µ±Ç°µÈ¼¶<CE>';
      DScreen.ShowHintA(143, g_FScreenHeight - 30,sMsg, clYellow, TRUE);
      exit;
    end;
  end;


  nLocalX:=Butt.LocalX(X - Butt.Left);
  nLocalY:=Butt.LocalY(Y - Butt.Top);
  nHintX:=Butt.SurfaceX(Butt.Left) + DBottom.SurfaceX(DBottom.Left) + nLocalX;
  nHintY:=Butt.SurfaceY(Butt.Top) + DBottom.SurfaceY(DBottom.Top) + nLocalY;

  DScreen.ShowHintA(nHintX,nHintY,sMsg, clWhite, True);
end;


procedure TFrmDlg.DBotFriendClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg2.DWinFriend.Visible := not FrmDlg2.DWinFriend.Visible;
end;

procedure TFrmDlg.CancelChanging();    //º¯È¯
begin
  if (g_Changeitem1.S.Name <> '') or (g_Changeitem2.S.Name <> '') or (g_Changeitem3.S.Name <> '')
    or (g_Changeitem4.S.Name <> '') or (g_Changeitem5.S.Name <> '') or (g_Changeitem6.S.Name <> '') then begin
   AddItemBag(g_Changeitem1);
   AddItemBag(g_Changeitem2);
   AddItemBag(g_Changeitem3);
   AddItemBag(g_Changeitem4);
   AddItemBag(g_Changeitem5);
   AddItemBag(g_Changeitem6);
  end;
  g_Changeitem1.S.Name := '';
  g_Changeitem1.MakeIndex :=0;
  g_Changeitem2.S.Name := '';
  g_Changeitem2.MakeIndex :=0;
  g_Changeitem3.S.Name := '';
  g_Changeitem3.MakeIndex :=0;
  g_Changeitem4.S.Name := '';
  g_Changeitem4.MakeIndex :=0;
  g_Changeitem5.S.Name := '';
  g_Changeitem5.MakeIndex :=0;
  g_Changeitem6.S.Name := '';
  g_Changeitem6.MakeIndex :=0;
end;

procedure TFrmDlg.CancelChanging2();   //º¯È¯
begin
    g_Changeitem1.S.Name := '';
    g_Changeitem1.MakeIndex :=0;
    g_Changeitem2.S.Name := '';
    g_Changeitem2.MakeIndex :=0;
    g_Changeitem3.S.Name := '';
    g_Changeitem3.MakeIndex :=0;
    g_Changeitem4.S.Name := '';
    g_Changeitem4.MakeIndex :=0;
    g_Changeitem5.S.Name := '';
    g_Changeitem5.MakeIndex :=0;
    g_Changeitem6.S.Name := '';
    g_Changeitem6.MakeIndex :=0;
end;



procedure TFrmDlg.GetPageInfo(pList: Pointer; var PageNumber: Integer; var PageTotal: Integer; var PageRef: Integer);
var
  PageExtended: Extended;
  List: ^TList;
begin
  List := pList;
  if List.Count > 0 then begin
    PageExtended := (List.Count/10);
    PageTotal := Trunc(PageExtended);
    if Frac(PageExtended) > 0 then inc(PageTotal);
  end
  else PageTotal := 1;

  if PageNumber < 1 then PageNumber := 1
  else if PageNumber > PageTotal then PageNumber := PageTotal;

  PageRef := (PageNumber-1) * 10;
end;


procedure TFrmDlg.GetPageInfo20(pList: Pointer; var PageNumber: Integer; var PageTotal: Integer; var PageRef: Integer);
var
  PageExtended: Extended;
  List: ^TList;
begin
  List := pList;
  if List.Count > 0 then begin
    PageExtended := (List.Count/20);
    PageTotal := Trunc(PageExtended);
    if Frac(PageExtended) > 0 then inc(PageTotal);
  end
  else PageTotal := 1;

  if PageNumber < 1 then PageNumber := 1
  else if PageNumber > PageTotal then PageNumber := PageTotal;

  PageRef := (PageNumber-1) * 20;
end;

procedure TFrmDlg.DMemoB1Click(Sender: TObject; X, Y: Integer);      //¸Þ¸ð
begin
  if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
  // °¢°¡ÀÇ »óÈ²ÀÏ OK µ¿ÀÛ Á¤ÀÇ
   case ViewWindowNo of
   VIEW_MAILSEND:     //ÂÊÁö º¸³»±â
               begin
                 if MemoMail.Text <> '' then
                   FrmMain.SendMail( MemoCharID +'/' + MemoMail.Text );
               end;
   VIEW_MAILREAD:
               begin
                   DMLDelClick(nil, 0, 0);
               end;
   end;

   edCharID.Visible     := FALSE;
   MemoMail.Visible     := FALSE;
   DMemo.Visible        := FALSE;
   MemoMail.ReadOnly    := FALSE;

   DMsgDlg.DialogResult := mrOK;

   SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
  end;
end;

procedure TFrmDlg.ToggleGTListWindow();
begin
  DGTList.Visible:=not DGTList.Visible;
end;

procedure TFrmDlg.ToggleDecoListWindow();
begin
  DDecoListDlg.Visible:=not DDecoListDlg.Visible;
end;

procedure TFrmDlg.ToggleBBSListWindow();        //Àå¿ø°Ô½ÃÆÇ
begin
  CloseMDlg;
  DBBSListDlg.Visible:=not DBBSListDlg.Visible;
end;

procedure TFrmDlg.ToggleBBSMsgWindow();       //Àå¿ø°Ô½ÃÆÇ
begin
  if DBBSMsgDlg.Visible = False then begin
    DBBSMSGReply.Visible := False;
    DBBSMSGMail.Visible := False;
    DBBSMSGDELETE.Visible := False;
    if g_BBSMSG <> '' then begin
      DBBSMSGReply.Visible:=True;
      DBBSMSGMail.Visible := True;
      if GuildCommanderMode then
        DBBSMSGDelete.Visible := True;
    end else begin
      BBSMemo.Text := '';
      BBSMemo.Width := 270;
      BBSMemo.Height := 156;
      BBSMemo.MaxLength := 240;
      BBSMemo.Visible := True;
      FrmDlg.BBSMemo.SetFocus;
      SetDFocus(FrmDlg.DBBSMsgDlg);
    end;
  end else
   BBSMemo.visible := False;
   DBBSMsgDlg.Visible:=not DBBSMsgDlg.Visible;
end;


procedure TFrmDlg.DSalesDirectPaint(Sender: TObject; dsurface: TDirectDrawSurface);
var
  d, e: TDirectDrawSurface;
  lx, ly, i: integer;
  PageNumber, Cost, sName : string;
  hcolor, hcolor2: integer;
begin
  with DSales do begin                 //Î¯ÍÐ´°¿Ú

    if g_AuctionCurrSection = 31 then begin
     d := WLib.Images[FaceIndex + 1];
      if d <> nil then dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      DAuc0.Visible := False; DAuc1.Visible := False; DAuc2.Visible := False; DAuc7.Visible := False;
      DAuc12.Visible := False; DAuc18.Visible := False; DAuc23.Visible := False; DAuc28.Visible := False;
      DAuc29.Visible := False; DAuc30.Visible := False;
      DBotAucFind.SetImgIndex (g_WTitleImages, 693);   //ËÑË÷°´Å¥
      DBotAuction.SetImgIndex (g_WTitleImages, 694);   //Î¯ÍÐ°´Å¥
      DSalesBuy.SetImgIndex (g_WTitleImages, 706);
      DSalesFind.Visible := False; DSalesMail.Visible := False; DAuctionCancel.Visible := True; DAuction.Visible := True;

      CostSalesEdit.Visible := True;
      DAuctionSpot.Visible := True;
      EdSalesEdit.Visible := False;
    end else begin

     d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
      DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
      DAuc29.Visible := True; DAuc30.Visible := True;
      DBotAucFind.SetImgIndex (g_WTitleImages, 692);   //°Ë»ö¹öÆ°
      DBotAuction.SetImgIndex (g_WTitleImages, 695);   //À§Å¹¹öÆ°
      DSalesBuy.SetImgIndex (g_WTitleImages, 703);
      DAuctionCancel.Visible := False; DAuction.Visible := False; DSalesFind.Visible := True; DSalesMail.Visible := True;

      DAuctionSpot.Visible := False;
      EdSalesEdit.Visible := True;
      CostSalesEdit.Visible := False;
    end;
      
      lx := 126;
      ly := 82 + AuctionMenuIndex * 33;
      for i:= 0 to 9 do begin
         if g_AuctionItems[i].StartTime <> 0 then begin
           d := g_WBagItemImages.Images[g_AuctionItems[i].Item.S.Looks];
           if d <> nil then dsurface.Draw (SurfaceX(Left + 146 - (d.Width div 2)), SurfaceY(Top + 99 + (33 * i) - (d.Height div 2)), d.ClientRect, d, TRUE);
         end;
         if i = AuctionMenuIndex then begin
           MemoCharID := g_AuctionItems[i].Seller;
           if g_AuctionItems[i].Item.S.Name <> '' then e := g_WMain2Images.Images[924];
           if e <> nil then dsurface.Draw (SurfaceX(Left+lx), SurfaceX(Top+ly), e.ClientRect, e, TRUE);
         end;
      end;
      sName := '';
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      with dsurface.Canvas do begin
        Font.Color := clWhite;
        PageNumber := inttostr(g_AuctionCurrPage) +'/' +inttostr(g_AuctionAmountofPages);
        TextOut (Left + 294 -(TextWidth(PageNumber) div 2), DSales.Top + 423, PageNumber);

        for i:= 0 to 9 do begin

          if g_AuctionItems[i].StartTime = 0 then break;

             Cost := GetGoldStr(g_AuctionItems[i].Cost);
             hcolor2 := clWhite;
             if g_AuctionItems[i].Cost >= 1000000 then hcolor2 := clLime;
             if g_AuctionItems[i].Cost >= 10000000 then hcolor2 := clYellow;
             if g_AuctionItems[i].Cost >= 100000000 then hcolor2 := $46CF2;
             if g_AuctionItems[i].Cost >= 1000000000 then hcolor2 := $F3A2D3;
             TextOutA (dsurface, Left + 379 - TextWidth(Cost), 94+(33*i)+ Top, hcolor2, Cost);

             if g_AuctionItems[i].Item.UpgradeOpt > 0 then hcolor := TColor($cccc33)
             else hcolor := clWhite;

             if g_AuctionItems[I].Item.S.StdMode in [5,6,90,99,10,11,12,15,19,20,21,22,23,24,26,62,64,46] then
               sName := FilterShowName(g_AuctionItems[I].Item.s, g_AuctionItems[I].Item.s.Name)
             else sName := g_AuctionItems[I].Item.s.Name;

             TextOutA (dsurface, Left + 166, 94+(33*i)+ Top, hcolor, sName);

             if g_AuctionCurrSection = 31 then begin
               if g_AuctionItems[i].Seller = '¼ÄÊÛ³É¹¦' then begin
                 Font.Color := clYellow;
                 TextOut ( Left + 383, 94 +(33*i)+ Top, g_AuctionItems[i].Seller);
               end else
               if g_AuctionItems[i].Seller = '³öÊÛ³¬ÆÚ' then begin
                 Font.Color := clRed;
                 TextOut ( Left + 383, 94 +(33*i)+ Top, g_AuctionItems[i].Seller);
               end else begin
                 Font.Color := clWhite;
                 TextOut ( Left + 383, 94 +(33*i)+ Top, FormatDateTime('yyyy-mm-dd,hh:nn', g_AuctionItems[i].EndTime));
               end;
             end else begin
               Font.Color := clWhite;
               TextOut ( Left + 383, 86 +(33*i)+ Top, g_AuctionItems[i].Seller);
               TextOut ( Left + 383, 100 +(33*i)+ Top, FormatDateTime('yyyy-mm-dd,hh:nn', g_AuctionItems[i].EndTime));
             end;
             if (g_AuctionItems[i].Item.Amount > 0) and (g_AuctionItems[i].Item.S.StdMode in [0,1,3,45,46]) then begin  //¹°¾à
               Font.Color := clYellow;
               TextOut (Left + 160 - TextWidth(IntToStr(g_AuctionItems[i].Item.Amount)), Top + 102 + (33 * i), IntToStr(g_AuctionItems[i].Item.Amount));
             end;

             Font.Color := clWhite;
        end;
      end;
      dsurface.Canvas.Release;
      if ( EdSalesEdit.Left <> SurfaceX(Left + 14)) or (EdShopEdit.Top <> SurfaceY(Top + 454) ) then begin
          EdSalesEdit.Left := SurfaceX(Left + 14);
          EdSalesEdit.Top  := SurfaceY(Top + 454);
      end;
      if ( CostSalesEdit.Left <> SurfaceX(Left + 15)) or (CostSalesEdit.Top <> SurfaceY(Top + 168) ) then begin
          CostSalesEdit.Left := SurfaceX(Left + 15);
          CostSalesEdit.Top  := SurfaceY(Top + 168);
      end;

  end;
  DUpWapondow.Visible := False;
  DUpWeapon.Visible := False;
  CloseDUpWapon;
  DUpCheck.Visible := False;
  CloseDUpWapon2;
end;

procedure TFrmDlg.ToggleAuctionWindow;
begin
  if not DSales.Visible then begin
    DSales.Left := 0;
    DSales.Top := 0;
    DSales.Visible := TRUE;
  end;

  if not DItemBag.Visible then begin
    DItemBag.Left := g_FScreenWidth - 315;
    DItemBag.Top := 0;
    DItemBag.Visible := TRUE;
  end;

  if DSales.Visible then begin
     AuctionPage := 0;
     AuctionMenuIndex := 0;
     g_AucIndex := 0;
     g_MouseItem := g_AuctionItems[AuctionMenuIndex].Item;


     with CostSalesEdit do begin      //À§Å¹ ÆÇ¸Å°¡°ÜÃ¢
        Text  := '0';
        Width := 100;
        Left  := DSales.Left + 15;
        Top   := DSales.Top + 168;
     end;

     with EdSalesEdit do begin         //À§Å¹ °Ë»ö
        Text  := '';
        Width := 100;
        Left  := DSales.Left + 14;
        Top   := DSales.Top + 454;
     end;

     DSales.Show;

     EdSalesEdit.Visible := TRUE;
     EdSalesEdit.SetFocus;
     SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
     if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
  end else begin
     DSalesExitClick(Self,0,0);
  end;


end;

procedure TFrmDlg.ToggleComStorageWindow;  //°ø¿ëÃ¢°í
begin
  if DComStorage.Visible = FALSE then begin
    if DItemBag.Visible = false then
      OpenItemBag();
  end;
  DComStorage.Visible := not DComStorage.Visible;

  ComStorageboots := -1;
  ComStorageMenuIndex := 0;
  g_MouseItem := g_ComStorageItem[ComStorageMenuIndex].Item;
end;


procedure TFrmDlg.ToggleGuildStorageWindow;  //¹®ÆÄÃ¢°í
begin
  if DGuildStorage.Visible = FALSE then begin
    if DItemBag.Visible = false then
      OpenItemBag();
  end;
  DGuildStorage.Visible := not DGuildStorage.Visible;

  GuildStorageboots := -1;
  GuildStorageIndex := 0;
  g_MouseItem := g_GuildStorageItem[GuildStorageIndex].Item;
end;


procedure TFrmDlg.DSalesFindClick(Sender: TObject; X, Y: Integer);
var
   findstr, sData : string;
begin
   sData := '';
   if GetTickCount < LastestClickTime then exit;
   findstr := trim(EdSalesEdit.Text);
   findstr := Copy( findstr, 1, 16);
   if findstr <> '' then begin
     sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(1) + ':' + IntToStr(g_AuctionSortMode) + ':' + findstr;
     SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId, 0, 0, 0, sData);
   end;
   LastestClickTime := GetTickCount + 5000;
end;


procedure TFrmDlg.ClearRentalDlg;   //´ë¿©
begin
  g_RentalItem.StartTime := 0;
 // DScreen.ClearHint;
end;

procedure TFrmDlg.ClearRentalDlg2;   //´ë¿©
begin
  g_OwnerItem.StartTime := 0;
 // DScreen.ClearHint;
end;


procedure TFrmDlg.ClearAuctionDlg;
var
 i: integer;
begin
  for i:= 0 to 9 do g_AuctionItems[i].StartTime := 0;
  DScreen.ClearHint;
  AuctionMenuIndex := 0;
  AuctionPage:=0;
  g_AucIndex := 0;
end;

procedure TFrmDlg.ClearDiceDlg;  //Ç÷·æ»óÀÚ
var
 i: integer;
begin
  for i:=0 to 5 do begin
    g_DiceItems[i].Items.S.Name := '';
  end;
end;

procedure TFrmDlg.ClearWakeDlg;  //°¢¼ºÀç·á
var
 i: integer;
begin
  for i:=0 to 1 do begin
    g_WakeItems[i].WakeItems.S.Name := '';
  end;
  g_sItemWakeUpPriceStr := 0;
end;

procedure TFrmDlg.ClearShopDlg;  //È¯»óÁ¡
var
 i: integer;
begin
  for i:=0 to 7 do begin
    g_ShopItems[i].ShopItems.S.Name := '';
  end;
end;

procedure TFrmDlg.ClearComStorageDlg;   //°ø¿ëÃ¢°í
var
 i: integer;
begin
  for i:=0 to 7 do g_ComStorageItem[i].StartTime := 0;
  DScreen.ClearHint;
  ComStorageMenuIndex := 0;
  ComStorageboots := -1;
end;

procedure TFrmDlg.ClearGuildStorageDlg;   //¹®ÆÄÃ¢°í
var
 i: integer;
begin
  for i:=0 to 49 do g_GuildStorageItem[i].StartTime := 0;
  DScreen.ClearHint;
  GuildStorageIndex := 0;
  GuildStorageboots := -1;
end;

procedure TFrmDlg.ClearPetDlg;   //¿µ¹°
var
 i: integer;
begin
  for i:=0 to 4 do g_PetInfo[i].StartTime := 0;
  DScreen.ClearHint;
  PetInfoBoots := -1;
end;

procedure TFrmDlg.DSalesExitClick(Sender: TObject; X, Y: Integer);
begin
  DSales.Visible := False;
  EdSalesEdit.Visible := False;
  CostSalesEdit.Visible := False;
  SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
end;

procedure TFrmDlg.DSalesBuyClick(Sender: TObject; X, Y: Integer);
var
 sCharName : String;
 sName : String;
 sPrice: String;
begin
  if GetTickCount > g_dwQueryMsgTick then begin
     g_dwQueryMsgTick := GetTickCount + 300;

     sCharName := g_AuctionItems[AuctionMenuIndex].Seller;
     if g_AuctionItems[AuctionMenuIndex].Item.S.StdMode in [5,6,90,99,10,11,12,15,19,20,21,22,23,24,26,62,63,64,46] then begin
       sName := FilterShowName(g_AuctionItems[AuctionMenuIndex].Item.S, g_AuctionItems[AuctionMenuIndex].Item.S.Name);
     end else
      sName := g_AuctionItems[AuctionMenuIndex].Item.S.Name;
     sPrice := GetGoldStr(g_AuctionItems[AuctionMenuIndex].Cost);

     if g_AuctionItems[AuctionMenuIndex].StartTime = 0 then exit;
     if g_AuctionCurrSection <> 31 then begin
       if sCharName = g_MySelf.m_sUserName then begin
         DMessageDlg ('ÄãÎÞ·¨¹ºÂò×Ô¼º¼ÄÊÛµÄÎïÆ·¡£', [mbOk]);
         exit;
       end;
       if g_MySelf.m_nGold < g_AuctionItems[AuctionMenuIndex].Cost then begin
         DMessageDlg ('¹ºÂòÎïÆ·µÄ½ð±Ò²»×ã¡£', [mbOk]);
         exit;
       end;
       if sCharName = '³öÊÛ³É¹¦' then begin
         DMessageDlg ('ÎïÆ·²»´æÔÚ¡£', [mbOk]);
         exit;
       end;
       if sCharName = '¼ÄÊÛµ½ÆÚ' then begin
         DMessageDlg ('ÎïÆ·²»´æÔÚ¡£', [mbOk]);
         exit;
       end;
       if GetBagItemCount = 0 then begin
         DMessageDlg ('ÄãµÄ±³°üÒÑ¾­ÂúÁË¡£', [mbOk]);
         Exit;
       end;
       if mrYes = FrmDlg.DMessageDlg (sName +' È·¶¨ÒªÒÔ ' +sPrice +'½ð±ÒµÄ¼Û¸ñ¹ºÂò´ËÎïÆ·£¿', [mbYes, mbNo]) then begin
         SendClientMessage (CM_BUYAUCTIONITEM, g_MySelf.m_nRecogId, LoWord(g_AuctionItems[AuctionMenuIndex].AuctionID),
                                HiWord(g_AuctionItems[AuctionMenuIndex].AuctionID), 0);
         exit;
       end;
     end else begin
       if sCharName = '³öÊÛ' then begin
         if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨Òª¼ÄÊÛ ' + sName + ' Âð£¿' , [mbYes, mbNo ]) then
           SendClientMessage (CM_GETGOLDITEM, g_MySelf.m_nRecogId, LoWord(g_AuctionItems[AuctionMenuIndex].AuctionID), HiWord(g_AuctionItems[AuctionMenuIndex].AuctionID), 0);
           exit;
       end;
       if sCharName = '¼ÄÊÛ³É¹¦' then begin
         if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨ÒªÊÕÈ¡¼ÄÊÛµÄ·ÑÓÃ²¢Ö§¸¶ÊÖÐø·ÑÂð£¿', [mbYes, mbNo]) then
           SendClientMessage (CM_GETGOLDITEM, g_MySelf.m_nRecogId, LoWord(g_AuctionItems[AuctionMenuIndex].AuctionID), HiWord(g_AuctionItems[AuctionMenuIndex].AuctionID), 0);
           exit;
       end;
       if sCharName = '¼ÄÊÛµ½ÆÚ' then begin
        if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨ÒªÈ¡Ïû¼ÄÊÛµÄ ' + sName + ' Âð£¿' , [mbYes, mbNo ]) then
          SendClientMessage (CM_GETGOLDITEM, g_MySelf.m_nRecogId, LoWord(g_AuctionItems[AuctionMenuIndex].AuctionID), HiWord(g_AuctionItems[AuctionMenuIndex].AuctionID), 0);
          exit;
       end;
     end;

  end;
end;

procedure TFrmDlg.DSalesClick(Sender: TObject; X, Y: Integer);
var                                                 //À§Å¹ ´Ý±â
   idx: integer;
begin
  if (((X<(128+DSales.Left)) OR (X>(480+Dsales.Left))) OR ((Y<(82+DSales.Top)) OR (Y>(412+DSales.Top)))) then exit;
  idx := (Y-(82+DSales.Top)) div 33;
  if g_AuctionItems[idx].StartTime <> 0 then begin
    AuctionMenuIndex := (Y-(82+DSales.Top)) div 33;
    PlaySound (s_glass_button_click);
  end;

  if g_AuctionItems[AuctionMenuIndex].StartTime <> 0 then begin
   g_MouseItem := g_AuctionItems[AuctionMenuIndex].Item;
  end;
end;

procedure TFrmDlg.DSalesNextPageClick(Sender: TObject; X, Y: Integer);
var
 sData:String;
begin
  sData:= '';
  if GetTickCount > g_dwQueryMsgTick then begin
    if (g_AuctionCurrPage = g_AuctionAmountofPages) then exit;
     sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(g_AuctionCurrPage+1) + ':' + IntToStr(g_AuctionSortMode) + ':' + EdSalesEdit.Text;
     SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId, 0, 0, 0, sData);
     g_dwQueryMsgTick := GetTickCount + 1000;
   end;
end;


procedure TFrmDlg.DSalesPrevPageClick(Sender: TObject; X, Y: Integer);
var
 sData:String;
begin
  sData:= '';
  if GetTickCount > g_dwQueryMsgTick then begin
   if (g_AuctionCurrPage = 1) then exit;
     sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(g_AuctionCurrPage-1) + ':' + IntToStr(g_AuctionSortMode) + ':' + EdSalesEdit.Text;
     SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId, 0, 0, 0, sData);
     g_dwQueryMsgTick := GetTickCount + 1000;
   end;
end;


procedure TFrmDlg.DSalesRefreshClick(Sender: TObject; X, Y: Integer);
var
 sData:String;
begin
  sData:= '';
  if GetTickCount > g_dwQueryMsgTick then begin
     sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(g_AuctionCurrPage) + ':' + IntToStr(g_AuctionSortMode) + ':' + EdSalesEdit.Text;
     SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId, 0, 0, 0, sData);
     g_dwQueryMsgTick := GetTickCount + 1000;
  end;
end;


procedure TFrmDlg.DSalesCloseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DSalesCancelDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if not d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex+1];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DBotMemoClick(Sender: TObject; X, Y: Integer);
begin
  //FrmDlg2.DWinEmail.Visible := not FrmDlg2.DWinEmail.Visible;
  ToggleShowMailListDlg;

  if Not WantMailList then begin
    FrmMain.SendMailList;
    WantMailList := true;
  end; 
end;

procedure TFrmDlg.DMailListDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   k ,n, l, t, lx, ly, pos : integer;
   sx, sy : integer;
   NewName : sItemMome;
   str, MemoDate: String;
begin
    DScreen.ClearHint;
    with DMailListDlg do begin

       lx := x - DMailListDlg.Left;
       ly := y - DMailListDlg.Top;
       if (lx > 9) and (lx < 298) and (ly > 54) and (ly < 385) then begin
         pos := (ly - 54) div 33 + MailPage * 10;
         if MailLists.Count > pos then begin
          n := pos;
         end else begin
          n := -1;
         end;
       end;

       if (n >= 0) and (MailLists.Count > 0) then begin 
          str   := PNMailItem(MailLists[n]).Date;
          MemoDate := '20'+str[1] + str[2] + 'Äê ' + str[3]+str[4] +'ÔÂ'+
                    str[5] + str[6]+'ÈÕ '+str[7]+str[8]+':'+str[9]+str[10];
          NewName.sItemopes[0] := 'ÏûÏ¢';
          NewName.nColor[0] := clYellow;
          NewName.sItemopes[1] := 'ÊÕµ½Ê±¼ä: ' + MemoDate;
          NewName.nColor[1] := clWhite;
          case PNMailItem(MailLists[n]).Status of
            0 : begin
              NewName.sItemopes[2] := '[Î´¶Á]';
              NewName.nColor[2] := clRed;
            end;
            1 : begin
              NewName.sItemopes[2] := '';
              NewName.nColor[2] := clRed;
            end;
            2 : begin
              NewName.sItemopes[2] := '[±£»¤]';
              NewName.nColor[2] := clGreen;
            end;
          end;

       end;
       if MailLists.Count > 0 then begin
         t := MailPage * 10;
         l := _MIN(MailPage*10+10, MailLists.Count);

            sx := SurfaceX(Left + 45);
            sy := SurfaceY(Top + 88) + (n-t) * 33;
   
         if n = CurrentMail then begin
           DScreen.NewShowHint2(sx, sy, NewName, FALSE);
         end else DScreen.ClearHint;
       end;
       if (lx > 9) and (lx < 298) and (ly > 54) and (ly < 385) then begin
       end else  DScreen.ClearHint;
    end;


end;

procedure TFrmDlg.DMailListDlgPostDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  if g_Myself = nil then exit;
  with dsurface.Canvas do begin
    SetBkMode (Handle, TRANSPARENT);
    Font.Color := clWhite;
    TextOut (68+DMailListDLG.Left, 36+DMailListDLG.TOP, g_MySelf.m_sUserName);
    release;
  end;
end;

procedure TFrmDlg.DBlockListDlgPostDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  if g_Myself = nil then exit;
  with dsurface.Canvas do begin
    SetBkMode (Handle, TRANSPARENT);
    Font.Color := clWhite;
    TextOut (68+DBlockListDLG.Left, 36+DBlockListDLG.TOP, g_MySelf.m_sUserName);
    release;
  end;
end;

procedure TFrmDlg.DBeltSwapClick(Sender: TObject; X, Y: Integer);
begin
  g_boVerticalBelt := Not g_boVerticalBelt;
  DoBeltSetup();
end;

procedure TFrmDlg.DBeltCloseClick(Sender: TObject; X, Y: Integer);
begin
  DBeltWindow.Visible := not DBeltWindow.Visible;
end;

procedure TFrmDlg.DBotLoverClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowLoverDlg;
end;

procedure TFrmDlg.DBeltWindowMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer); //º§Æ®Ã¢
var
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg: String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);

 { if Sender = DBeltSwap then sMsg := 'º§Æ®ÀÌµ¿\Ctrl-Z'
  else }

  if Sender = DBeltClose then sMsg := 'ÎïÆ·¿ì½ÝÀ¸(Z)';


  nHintX:=Butt.SurfaceX(Butt.Left + 17);
  nHintY:=Butt.SurfaceY(Butt.Top + 18);
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DGroupDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  ShowMsg: string;
begin
  DScreen.ClearHint;
  GroupListMoveIndex := -1;
  UserListMoveIndex := -1;
  with Sender as TDControl do begin
    X := SurfaceX(Left + (X - Left) + 15);
    y := SurfaceY(Top + (y - Top) + 15);
    ShowMsg := '';
    if Sender = DGrpAllowGroup then begin
      if g_boAllowGroup then ShowMsg := 'ÔÊÐí×é¶Ó'
      else ShowMsg := '¾Ü¾ø×é¶Ó';
    end
    else if Sender = DGrpCheckGroup then begin
      ShowMsg := 'Í¬Òâ»òÕß¾Ü¾ø×é¶ÓµÄÑûÇë¡£';
    end
    else if Sender = DGrpCheckHero then begin
      ShowMsg := 'Ð¡×é³ÉÔ±¿ÉÒÔÑ¡ÔñÕÙ»½&ÊÕ»ØÓ¢ÐÛ¡£\ÕÙ»½Ó¢ÐÛÊ±Äã²»ÄÜ»ñµÃ¾­Ñé¼Ó³É¡£';
    end
    else if Sender = DCBGroupItemDef then begin
      ShowMsg := '×ÔÓÉ·ÖÅä±©³öµÄÎïÆ·¡£';
    end
    else if Sender = DCBGroupItemRam then begin
      ShowMsg := 'Ëæ»ú·ÖÅä±©³öµÄÎïÆ·¡£';
    end;
    if ShowMsg <> '' then
      DScreen.ShowHintA(x, y, ShowMsg, clWhite, False);
  end;
end;


procedure TFrmDlg.DCreateChrDirectPaint(Sender: TObject; dsurface: TDirectDrawSurface);
var
   d, e ,f ,g, h: TDirectDrawSurface;
   i : integer;
begin
  with sender as TDWindow do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      if not g_InterfaceMode then begin

        e := g_WTitleImages.Images[20];
        if e <> nil then
          dsurface.Draw (SurfaceX(Left+212), SurfaceY(Top+5), e.ClientRect, e, TRUE);
        f := g_WTitleImages.Images[21];
        if f <> nil then
          dsurface.Draw (SurfaceX(Left+286), SurfaceY(Top+270), f.ClientRect, f, TRUE);
        g := g_WTitleImages.Images[22];
        if g <> nil then
          dsurface.Draw (SurfaceX(Left+286), SurfaceY(Top+300), g.ClientRect, g, TRUE);
        h := g_WTitleImages.Images[23];
        if h <> nil then
          dsurface.Draw (SurfaceX(Left+286), SurfaceY(Top+346), h.ClientRect, h, TRUE);

      end;
      with SelectChrScene do begin
        if not g_InterfaceMode then begin
          with dsurface.Canvas do begin
          SetBkMode(Handle,TRANSPARENT);
          i:=15;
          case ChrArr[NewIndex].UserChr.Job of
           0: begin
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 1) , clWhite, clBlack, 'ÒÔÇ¿×³µÄÌåÁ¦Îª»ù´¡£¬ÓµÓÐÔÚÕ½³¡²»Ò×ËÀÍöµÄÓÅÊÆ£¬ÉÃ³¤');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 2) , clWhite, clBlack, 'Ê¹ÓÃ¶àÖÖÖØÁ¿µÄÎäÆ÷ºÍ³¬ÖØµÄîø¼×£¬ÓëÆäËûÖ°ÒµÏà±È£¬¾ß');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 3) , clWhite, clBlack, 'ÓÐ³öÉ«µÄÉúÃüºÍÁ¦Á¿£¬ËùÒÔÉÃ³¤á÷ÁÔºÍÈâ²«Õ½¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 5) , clWhite, clBlack, 'ÄÜ¹»Ê¹ÓÃ¶àÖÖ¶àÑùµÄ½£Êõ£¬½ü¾àÀëÊ¹ÓÃÆÆ»µÁ¦Ç¿´óµÄ¼¼ÄÜ£¬');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 6) , clWhite, clBlack, 'ÊÇ×îÇ¿µÄ½üÉíÖ°Òµ¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 8) , clWhite, clBlack, 'µ«ÊÇÃ»ÓÐÔ¶¾àÀë×÷Õ½µÄÄÜÁ¦£¬¶ÔÔ¶³Ì¹¥»÷»òÕßÄ§·¨¹¥»÷µÄ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 9) , clWhite, clBlack, '·ÀÓù·Ç³£´àÈõ¡£Òò´Ë£¬ÊìÁ·µÄÕ½Ê¿ÄÜÓÃ¸÷ÖÖ·ÀÓù×°±¸À´ÃÖ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 10) , clWhite, clBlack, '²¹×Ô¼ºµÄ²»×ãÖ®´¦¡£');
           end;
           1: begin
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 1) , clWhite, clBlack, '²»ÊÜÎ»ÖÃºÍ¾àÀëµÄÏÞÖÆ£¬ÒÔ³¤Ê±¼ä¶ÍÁ¶µÄÄÚ¹¦Îª»ù´¡£¬¿É');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 2) , clWhite, clBlack, 'ÒÔÊ¹ÓÃÇ¿´óµÄÄ§·¨½øÐÐ¹¥»÷¡£×î»ªÀöµÄÖ÷ÈË¹«ÀíËùµ±È»µÄ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 3) , clWhite, clBlack, '¾ÍÊÇ·¨Ê¦¡£·¨Ê¦ÔÚÕ½³¡ÉÏ¶ÔµÐÈË¶øÑÔÊÇ¿Ö²ÀµÄ´æÔÚ£¬¶ø¶Ô');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 4) , clWhite, clBlack, 'ÎÒ¾üÀ´Ëµ¿ÉÄÜÊÇ¼áÊµµÄ»ðÁ¦¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 6) , clWhite, clBlack, 'µ«ÊÇ£¬ÒòÎª±¡ÈõµÄÌåÁ¦ºÍÐèÒªÊ±¼äµÈ´ýµÄÄ§·¨ÊÍ·Å¹ý³Ì£¬');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 7) , clWhite, clBlack, 'ËùÒÔ³ýÁËÌåÁ¦Ö®Íâ£¬»¹ÐèÒªÊ±¿Ì½«×¢ÒâÁ¦¼¯ÖÐÔÚÄ§Á¦µÄ¹Ü');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 8) , clWhite, clBlack, 'ÀíÉÏ¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 10) , clWhite, clBlack, 'ÔÚÕâÐ©À§ÄÑµÄ¹ý³ÌÖÐ£¬¸ßË®Æ½µÄ·¨Ê¦½«»á¶Ô×Ô¼ºµÄ¿ØÖÆÁ¦');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 11) , clWhite, clBlack, 'ºÍÅÐ¶ÏÁ¦¸Ðµ½×ÔºÀ¡£');
           end;
           2: begin
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 1) , clWhite, clBlack, 'µÀ½ÌµÄÐÞÁ¶ÕßÃÇ¶ÔÒ½ÊõµÄÔìÒèºÜÉî£¬ÉÃ³¤Ê¹ÓÃ»Ö¸´ÊõºÍ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 2) , clWhite, clBlack, '¶¾Êõ,ÔÚ½£ÊõµÄÊ¹ÓÃÉÏÒ²ÓÐºÜ¸ßµÄÔìÒè,ÊÇ¶à²Å¶àÒÕµÄ½Ç');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 3) , clWhite, clBlack, 'É«¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 5) , clWhite, clBlack, 'µÀÊ¿ÓµÓÐÕâÑùµÄÄÜÁ¦£¬ÔÚÓëÆäËûÈË×é¶ÓÊ±ÄÜ·¢»ÓÆäÕæÕý');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 6) , clWhite, clBlack, 'µÄ¼ÛÖµ£¬ÏíÓÐºÜ¸ßµÄÈËÆø¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 8) , clWhite, clBlack, 'ÎªÁË»îÓÃ¶à²Å¶àÒÕµÄÄÜÁ¦£¬ÐèÒª¶îÍâÊ¹ÓÃ¸¨Öú¹¤¾ß²ÅÄÜ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 9) , clWhite, clBlack, 'Ê¹ÓÃ¸÷ÖÖÎä¹¦£¬ËùÒÔµ±Äã¿ªÊ¼ÌåÑéµÀÊ¿½ÇÉ«Ê±£¬ÒªÖªµÀ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 10) , clWhite, clBlack, 'µÀÊ¿ÊÇºÜÄÑÌá¸ß¾­ÑéµÄ½ÇÉ«£¬µ«ÊÇÔÚ²Î¼Ó¶àÈË×é¶ÓÊ±¿É');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 11) , clWhite, clBlack, 'ÒÔ°ïÖúµ½´ó¼Ò,ÊÇÊÜ»¶Ó­ºÍÊÜ×ðÖØµÄ½ÇÉ«¡£');
           end;
           3: begin
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 1) , clWhite, clBlack, '¾­¹ý¶Ô×ÔÎÒÑÏ¿áµØ¶ÍÁ¶£¬ÒÔ°µÉ±ÎªÄ¿µÄ´Ì¿Í£¬ÒÔÃô½ÝµÄ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 2) , clWhite, clBlack, 'ÉíÌåÄÜÁ¦ºÍ¶àÖÖ¶àÑùµÄÎä¹¦Í»Ï®Ú¤ÏëµÄµÐÈËºÍµÐ·½Ö÷ÒªÈË');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 3) , clWhite, clBlack, 'Îï£¬²¢¶ÔÆäÔì³ÉÖÂÃü´ò»÷£¬´Ó¶ø´øÁìºÍÒýµ¼×Ô¼ºµÄ¶ÓÎéÈ¡');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 4) , clWhite, clBlack, 'µÃÊ¤Àû¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 6) , clWhite, clBlack, '¾ßÓÐÇ¿´óµÄÄ§·¨·ÀÓùÄÜÁ¦£¬Í¬Ê±¿ÉÒÔÓÃÒþÉíÊõºÍ·ÙÉíÊõµÄ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 7) , clWhite, clBlack, '×´Ì¬¸øµÐÈË´øÀ´»ìÂÒ¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 9) , clWhite, clBlack, 'µ«ÓÉÓÚÓµÓÐÄ§·¨·ÀÓùÁ¦ºÍ¶àÑùµÄ¹¥»÷ÎäÆ÷£¬ËùÒÔÎïÀí·ÀÓù');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 10) , clWhite, clBlack, 'Ïà¶Ô´àÈõ£¬Ò»²»Ð¡ÐÄ¾Í»áÃæÁÙÎ£ÏÕµÄÇé¿ö¡£');
           end;
           4: begin
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 1) , clWhite, clBlack, 'Ò»¸öÄÜ¹»Õë¶ÔµÐÈË´´ÔìÈõµã²¢ÄÜ¹»°ÑÕ½¶·Á¦Ïò×Ô¼ºÓÐ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 2) , clWhite, clBlack, 'ÀûµÄ·½Ïò·¢Õ¹µÄ£¬×¿Ô½µÄÉ®ÂÂ¿ÉÒÔÀûÓÃ¸÷ÖÖÇé¿ö½øÐÐ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 3) , clWhite, clBlack, 'Ç¿Á¦µÄ¹¥»÷¡£');

           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 5) , clWhite, clBlack, 'Í¨¹ýÊ¹ÓÃºÍµÐÈËµÄ¾àÀëÉ±µÐ£¬ÓµÓÐ¸üÇ¿µÄÆÆ»µÁ¦¡£');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 6) , clWhite, clBlack, 'µ«ÊÇ£¬±ÈÆäËûÖ°Òµ¸ü´àÈõµÄÌåÁ¦£¬¸üÈÝÒ×Óöµ½Î£ÏÕ');
           BoldTextOut(dsurface, SurfaceX(Left+ 278), SurfaceY(Top + 53 + i * 7) , clWhite, clBlack, '»ºÂýµÄ¹¥»÷ËÙ¶ÈºÜÈÝÒ×Êä¸øµÐÈË¡£');
           end;
          end;
          Release;
          end;
        end else begin
          d := g_WMainImages.Images[440 + (40 * ChrArr[NewIndex].UserChr.Sex) + ChrArr[NewIndex].UserChr.Hair];
          if d <> nil then begin
            dsurface.Draw (SurfaceX(Left + (272 - d.Width) div 2), SurfaceY(Top + (588 - d.Height) div 2), d.ClientRect, d, TRUE);
          end;
          if ChrArr[NewIndex].UserChr.Hair = 0 then begin
            with dsurface.Canvas do begin     //Çì¾î
              SetBkMode (Handle, TRANSPARENT);
              TextOut (SurfaceX(Left + 118), SurfaceY(Top + 290), '¹âÍ·');
              release;
            end;
          end;
        end;

      end;

    end;
  end;
end;

procedure TFrmDlg.DccOkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d, dd, e: TDirectDrawSurface;
   img: Integer;
   ax,ay: integer;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then begin
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;

      d := nil;
     if not g_InterfaceMode then begin
      if Sender = DccWarrior then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 0 then d := WLib.Images[2427];
      end;
      if Sender = DccWizzard then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 1 then d := WLib.Images[2430];
      end;
      if Sender = DccMonk then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 2 then  d := WLib.Images[2433];
      end;
      if Sender = DccAssassin then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 3 then d := WLib.Images[2436];
      end;
      if Sender = DccBonze then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 4 then d := WLib.Images[498];
      end;
      if Sender = DccMale then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Sex = 0 then d := WLib.Images[2421];
      end;
      if Sender = DccFemale then begin
        with SelectChrScene do
         if ChrArr[NewIndex].UserChr.Sex = 1 then d := WLib.Images[2424];
      end;
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
      if d <> nil then begin
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
        if SelectChrScene.ChrArr[SelectChrScene.NewIndex].UserChr.Job = 4 then begin
          img := 470 + SelectChrScene.ChrArr[SelectChrScene.NewIndex].aniIndex;
          e := g_WAresImages.GetCachedImage(img,ax,ay);
          if e <> nil then
            dsurface.Draw (GetScreenX(250 + ax), GetScreenY2(240 + ay), e.ClientRect, e, TRUE);
        end else begin
          img := 20 + SelectChrScene.ChrArr[SelectChrScene.NewIndex].UserChr.Job * 20 + SelectChrScene.ChrArr[SelectChrScene.NewIndex].UserChr.Sex * 280;
          img := img+SelectChrScene.ChrArr[SelectChrScene.NewIndex].aniIndex;
          e := g_WChrSelImages.GetCachedImage(img,ax,ay);
          if e <> nil then
            dsurface.Draw (GetScreenX(230 + ax), GetScreenY2(320 + ay), e.ClientRect, e, TRUE);
        end;
      end;

     end else begin

      if Sender = DccWarrior then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 0 then d := WLib.Images[597];
      end;
      if Sender = DccWizzard then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 1 then d := WLib.Images[600];
      end;
      if Sender = DccMonk then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 2 then  d := WLib.Images[603];
      end;
      if Sender = DccAssassin then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 3 then d := WLib.Images[606];
      end;
      if Sender = DccBonze then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Job = 4 then d := WLib.Images[612];
      end;
      if Sender = DccMale then begin
        with SelectChrScene do
          if ChrArr[NewIndex].UserChr.Sex = 0 then d := WLib.Images[618];
      end;
      if Sender = DccFemale then begin
        with SelectChrScene do
         if ChrArr[NewIndex].UserChr.Sex = 1 then d := WLib.Images[621];
      end;
      if d <> nil then begin
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      end;
     end;
   end;
end;

procedure TFrmDlg.DMemoCloseClick(Sender: TObject; X, Y: Integer);
begin
   DMemo.Visible        := FALSE;
   case ViewWindowNo of
   VIEW_MAILSEND:
      begin
        edCharID.Visible     := FALSE;
        memoMail.ReadOnly    := FALSE;
        memoMail.Visible     := FALSE;
      end;
   VIEW_MAILREAD:
      begin
        memoMail.ReadOnly    := FALSE;
        memoMail.Visible     := FALSE;
      end;
   VIEW_MEMO:
      begin
        memoMail.ReadOnly    := FALSE;
        memoMail.Visible     := FALSE;
      end;
   end;
   DMsgDlg.DialogResult := mrCancel;

   SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
end;

procedure TFrmDlg.DGenericMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DLoverWindowDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e: TDirectDrawSurface;
   started,total:string;
   lx, ly: integer;
begin
   with (Sender as TDWindow) do begin
      if fLover.GetEnable(RsState_Lover) = 1 then
         DLoverAvailable.SetImgIndex(g_WMainImages, 613)
      else
         DLoverAvailable.SetImgIndex(g_WMainImages, 610);

      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      e := g_WMainImages.Images[582];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left+25), SurfaceY(Top+25), e.ClientRect, e, TRUE);


      dsurface.Canvas.Font.Color  := clSilver;
      dsurface.Canvas.Brush.Color := clBlack;
      dsurface.Canvas.Brush.Style := bsClear;

      lx := SurfaceX(26) + Left;
      ly := SurfaceY(42) + Top + (1 * 15);
      dsurface.Canvas.TextOut(lx, ly, fLover.GetDisplay(0));
      ly := SurfaceY(42) + Top + (3 * 15);
      dsurface.Canvas.TextOut(lx, ly, fLover.GetDisplay(1));
      ly := SurfaceY(42) + Top + (5 * 15);
      dsurface.Canvas.TextOut(lx, ly, fLover.GetDisplay(2));

      dsurface.Canvas.Release;

   end;
end;

procedure TFrmDlg.DLoverExitClick(Sender: TObject; X, Y: Integer);
begin
 ToggleShowLoverDlg;
end;

procedure TFrmDlg.DLoverAvailableClick(Sender: TObject; X, Y: Integer);
var
  sendenable: integer;
begin
  if fLover.GetEnable(RsState_Lover) = 1 then
    sendenable := 0
  else
    sendenable := 1;

  FrmMain.SendLMOptionChange(1, sendenable);
end;

procedure TFrmDlg.DLoverAskClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.SendLMRequest(RsState_Lover, RsReq_WantToJoinOther);
end;

procedure TFrmDlg.DLoverDivorceClick(Sender: TObject; X, Y: Integer);
var
  Name: string;
begin
  Name := fLover.GetName(RsState_Lover);
  if mrCancel = DMessageDlg('ÄãÈ·¶¨ÒªÀë»éÂð£¿\Àë»éµÄ»°ÐèÒªÖ§¸¶10Íò½ð±ÒµÄÊÖÐø·Ñ¡£',
    [mbYes, mbCancel]) then
    Exit;
  if Name <> '' then
    FrmMain.SendLMSeparate(RsState_Lover, Name);

end;

procedure TFrmDlg.DLoverWindowMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg: String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);
  if Sender = DLoverAvailable then sMsg:= 'Çó»é¿ª¹Ø'
  else if Sender = DLoverAsk then sMsg:= 'ÔÊÐíÇó»é'
  else if Sender = DLoverDivorce then sMsg:= '¾Ü¾øÇó»é'
  else if Sender = DLoverMail then sMsg:= '·¢ËÍÓÊ¼þ'
  else if Sender = DLoverWhisper then sMsg:= 'Ë½ÁÄ';

  nLocalX:=Butt.LocalX(X - Butt.Left);
  nLocalY:=Butt.LocalY(Y - Butt.Top);
  nHintX:=Butt.SurfaceX(Butt.Left) + DLoverWindow.SurfaceX(DLoverWindow.Left) + nLocalX;
  nHintY:=Butt.SurfaceY(Butt.Top) + DLoverWindow.SurfaceY(DLoverWindow.Top) + nLocalY;
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

{procedure TFrmDlg.DMailListDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  PageRef,PageTotal: Integer;
  Me: TDWindow;
  I,J: Integer;
  d, e: TDirectDrawSurface;
  MailItem: pTMailItem;
  r: TRect;
  sTextOut: String;
  sStatusList: TStringList;
  sStatus: String;
  ReadStatus: Boolean;
Begin
  if g_MySelf = nil then begin
    DBotMemoClick(TObject(DBotMemo),0,0);
    exit;
  end;
  ReadStatus := False;
  if MaxLineHeight = 0 then MaxLineHeight := FrmMain.DXDraw.Surface.Canvas.TextHeight('dp');
  Me := TDWindow(Sender);

  GetPageInfo(@MailList,MailPage,PageTotal,PageRef);


  with DMailListDlg do begin
   d := DMailListDlg.WLib.Images[FaceIndex];
    if d <> nil then dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;

  for I := PageRef to PageRef+9 do begin
    if I >= MailList.Count then break;
    MailItem := PTMailItem(MailList.Items[I]);
    R.Left := 22+Me.Left;
    R.Top := Me.Top+58+(15*(I-PageRef));
    If (MailItem.Status and nMAIL_LOCKED) <> 0 then begin
      e := g_WMainImages.Images[578];
      if e <> nil then dsurface.Draw ((R.Left - 10), (R.Top + 2), e.ClientRect, e, TRUE);
    end;
  end;

  with dsurface.Canvas do begin
    SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
    SetBkMode (Handle, TRANSPARENT);

    Font.Color := clWhite;
    TextOut(Me.Left+125, Me.Top+220, inttostr(MailPage)+'/'+inttostr(PageTotal));

    sStatusList := TStringList.Create;
    for I := PageRef to PageRef+9 do begin
      if I >= MailList.Count then break;
      MailItem := PTMailItem(MailList.Items[I]);

      R.Left := 22+Me.Left;
      R.Top := Me.Top+58+(15*(I-PageRef));
      R.Right := 234+Me.Left; //ÂÊÁöÃ¢
      R.Bottom := R.Top+MaxLineHeight + 2;

      if I = MailIndex then begin   //Å¬¸¯ÇßÀ»¶§
        Font.Color := clSilver;
        Brush.Color := clGray;
        FillRect(R);
      end else begin
        Font.Color := clSilver;
        Brush.Color := clBlack;
      end;

      sStatusList.Clear;
      if not MailItem.Read then begin    //Å¬¸¯ÇßÀ»¶§
        if I = MailIndex then begin
          Font.Color := clWhite;
          Brush.Color := clGray;
            FillRect(R);
        end else begin
          Font.Color := clWhite;
          Brush.Color := clBlack;
        end;
        ReadStatus := True;
      end;
      If (MailItem.Status and nMAIL_SPECIAL) <> 0 then sStatusList.Add('');
      If (MailItem.Status and nMAIL_LOCKED) <> 0 then sStatusList.Add('*');

      if sStatusList.Count > 0 then
        sStatus := '['+Join('/',sStatusList)+']'
      else
        sStatus := '';

      sTextOut := sStatus+MailItem.Content;
      J := Length(sTextOut);
      if J > 39 then j := 39;
      while True do begin
        if R.Left+94+TextWidth(sTextOut) >= R.Right then begin
          sTextOut := sStatus+Copy(MailItem.Content,1,J)+'...';
          Dec(J);
        end else break;
      end;
      TextOut (R.Left, R.Top+ 2, MailItem.Sender);
      TextOut (R.Left+94, R.Top+ 2, sTextOut);
    end;
    sStatusList.Free;
    release;
    dsurface.Canvas.release;
  end;

  g_boHasMail := ReadStatus;
end;        }

procedure TFrmDlg.DMailListDlgDirectPaint(Sender: TObject;  //¸ÞÀÏ
  dsurface: TDirectDrawSurface);
var
   d , e , a, b: TDirectDrawSurface;
   lx, ly, n, t, l, ax, ay : integer;
   Rect : TRect;
   CurrentPage ,maxPage : integer;
   LockStr : string;
begin
   CurrentPage :=  MailPage + 1;
   MaxPage     :=  MailLists.Count div 10 + 1;

   with DMailListDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      d := g_WTitleImages.Images[677];   //¿ìÆí Å¸ÀÌÆ²
      if d <> nil then dsurface.Draw (SurfaceX(Left+33), SurfaceY(Top+5), d.ClientRect, d, TRUE);

      if MailLists.Count > 0 then begin
         t := MailPage * 10;
         l := _MIN(MailPage*10+10, MailLists.Count);

         for n := t to l-1 do begin
            lx := SurfaceX(Left + 14);
            ly := SurfaceY(Top + 63) + (n-t) * 33;
            a := g_WMainImages.Images[540];
            if a <> nil then dsurface.Draw (lx, ly , a.ClientRect, a, TRUE);

            lx := SurfaceX(Left + 16);
            ly := SurfaceY(Top + 74) + (n-t) * 33;
            case PNMailItem(MailLists[n]).Status of
            0 : begin   //»õÆíÁö
                  b := g_WMainImages.Images[550];
                  if b <> nil then dsurface.Draw (lx, ly , b.ClientRect, b, TRUE);
                end;
            1 : begin  //ÀÐÀ½
                  b := nil;
                end;
            2 : begin    //Àá±Ý
                  b := g_WMainImages.Images[551];
                  if b <> nil then dsurface.Draw (lx, ly , b.ClientRect, b, TRUE);
                end;
            end;

            lx := SurfaceX(Left + 7);
            ly := SurfaceY(Top + 52) + (n-t) * 33;
            if n = CurrentMail then begin
              e := g_WMainImages.Images[545];
              if e <> nil then dsurface.Draw (lx, ly , e.ClientRect, e, TRUE);
            end;
          end;

         SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);

         for n := t to l-1 do begin
            LockStr := '';
            case PNMailItem(MailLists[n]).Status of
            0 : dsurface.Canvas.Font.Color := clWhite;
            1 : dsurface.Canvas.Font.Color := clSilver;
            2 : begin
                dsurface.Canvas.Font.Color := clWhite;
                LockStr := '[*]';
                end;
            3 : dsurface.Canvas.Font.Color := clBlue;
            end;

            lx := SurfaceX(48) + Left;
            ly := SurfaceY(63) + Top  + (n-t) * 33;
            dsurface.Canvas.TextOut (lx, ly+2, PNMailItem(MailLists[n]).Sender);

            lx := SurfaceX(182) + Left;
            ly := SurfaceY(63) + Top  + (n-t) * 33;
            dsurface.Canvas.TextOut (lx, ly+2, LockStr + ( Copy(PNMailItem(MailLists[n]).Mail,1,16) ) + '...' )  ;
            dsurface.Canvas.Font.Color := clWhite;
            lx := SurfaceX(50) + Left ;
            ly := SurfaceY(391) + Top  ;
            dsurface.Canvas.TextOut (lx, ly, IntToStr(NotReadMailCount)+'/'+IntToStr(MailLists.Count));

         end;
         dsurface.Canvas.Release;
      end;


      with dsurface.Canvas do
      begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         TextOut(SurfaceX(Left+137),SurfaceY(Top+391), inttostr(CurrentPage)+'/'+inttostr(MaxPage));
         Release;
      end;

   end;
   if NotReadMailCount > 0 then MailAlarm := True else MailAlarm := False;
end;

procedure TFrmDlg.DMailListCloseClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowMailListDlg;
end;

procedure TFrmDlg.DMailListPgUpClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMailListPgUp then begin
      if MailPage > 0 then begin
         Dec (MailPage);
         CurrentMail := -1;
      end;
   end else begin
      if MailPage < (MailLists.Count+9) div 10 - 1 then begin
         Inc (MailPage);
         CurrentMail := -1;
      end;
   end;
end;

procedure TFrmDlg.DMailListDlgClick(Sender: TObject; X, Y: Integer);     //¸ÞÀÏ
var
    lx, ly : integer;
    pos : integer;
begin
    lx := x - DMailListDlg.Left;
    ly := y - DMailListDlg.Top;
    if (lx > 9) and (lx < 298) and (ly > 54) and (ly < 385) then begin
       pos := (ly - 54) div 33 + MailPage * 10;
       if MailLists.Count > pos then begin
          CurrentMail := pos;
       end else begin
          CurrentMail := -1;
       end;
    end;
end;

procedure TFrmDlg.EdSalesEditKeyPress (Sender: TObject; var Key: Char);
begin
   if Key = #13 then begin
      Key := #0;
      FrmDlg.DSalesFindClick(Self,0,0);     //À§Å¹ °Ë»ö
   end;
   if Key = #27 then begin
      Key := #0;
      FrmDlg.DSalesExitClick(Self,0,0);     //À§Å¹ Á¾·á
   end;
end;

procedure TFrmDlg.CostSalesEditKeyPress (Sender: TObject; var Key: Char);
begin
   if Key = #13 then begin
      Key := #0;
      FrmDlg.DAuctionClick(Self,0,0);     //À§Å¹ ÆÇ¸Å
   end;
   if Key = #27 then begin
      Key := #0;
      FrmDlg.DSalesExitClick(Self,0,0);     //À§Å¹ Á¾·á
   end;
end;

procedure TFrmDlg.EdShopEditKeyPress (Sender: TObject; var Key: Char);
begin
   if Key = #13 then begin
      Key := #0;
      FrmDlg.DitemnamertClick(Self,0,0);     //È¯»óÁ¡ °Ë»ö
   end;
   if Key = #27 then begin
      Key := #0;
      FrmDlg.DItemShopCloseClick(Self,0,0);     //È¯»óÁ¡ Á¾·á
   end;
end;

procedure TFrmDlg.EStoragePW1KeyPress(Sender: TObject; var Key: Char);
begin
  if Key = #13 then begin
    Key := #0;
    if DSetPassWd.Visible then begin
      if (EStoragePW1.Text <> '') and (EStoragePW2.Text <> '') then begin
        DCheckStPwClick(Nil, 0, 0);
        exit;
      end;
      if EStoragePW1.Text <> '' then EStoragePW2.SetFocus;
      if EStoragePW2.Text <> '' then EStoragePW1.SetFocus;
    end;
    if DInputStPwd.Visible then begin
      if (EStoragePW1.Text <> '') then begin
        DCheckInPutPwClick(Nil, 0, 0);
        exit;
      end;
      if EStoragePW1.Text <> '' then EStoragePW1.SetFocus;
    end;
    if DChangeStPw.Visible then begin
      if (EStoragePW1.Text <> '') and (EStoragePW2.Text <> '') and (EStoragePW3.Text <> '') then begin
        DCheckChPwClick(Nil, 0, 0);
        exit;
      end;
      if EStoragePW1.Text <> '' then EStoragePW2.SetFocus;
      if EStoragePW2.Text <> '' then EStoragePW3.SetFocus;
      if EStoragePW3.Text <> '' then EStoragePW1.SetFocus;
    end;
  end;
end;

procedure TFrmDlg.BBSTextNotify(Sender: TObject);
var
  i:integer;
  //str,str2,msg:string;
begin
{ started coding this to limit the amount of text that goes onto one line  but dont think that's needed really (hope not)
  msg := BBSMemo.Text;
  while msg <> '' do begin
    msg := GetValidStr3 (msg, str,[#13]);
    if Length(str) > 25 then begin
      str2 := LeftStr(str,25)
    end;
    str2 :=
  end;
}
  for i := 9 to BBSMemo.Lines.Count -1 do begin
    BBSMemo.Lines[i] := '';
  end;
end;

procedure TFrmDlg.DMailListDlgDblClick(Sender: TObject);   //¸ÞÀÏ
begin
     MailListDlgDblClicked := true;
end;

procedure TFrmDlg.DMailListDlgMouseUp(Sender: TObject;           //¸ÞÀÏ
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
     if not MailListDlgDblClicked then Exit;

     MailListDlgDblClicked := false;
     DMLReadClick( nil ,0,0 );
end;

procedure TFrmDlg.DMLReplyClick(Sender: TObject; X, Y: Integer);
begin
  if (not DMemo.Visible) then begin
    if (CurrentMail >= 0) and (PNMailItem(MailLists[CurrentMail]).Sender <> '') then begin
      ViewWindowNo   := VIEW_MAILSEND;
      ViewWindowData := CurrentMail;
      DMemoB1.SetImgIndex(g_WTitleImages, 190);
      DMemoB2.SetImgIndex(g_WTitleImages, 193);
      DMemoB1.Left:=30;
      DMemoB1.Top:=265;
      DMemoB2.Left:=134;
      DMemoB2.Top:=265;
      DMemoB3.Visible := False;
      MemoMail.Clear;
      MemoMail.ReadOnly := false;
      MemoCharID := PNMailItem(MailLists[CurrentMail]).Sender;
      ShowEditMail;
    end;
   end;

end;

{---- Adjust global SVN revision ----}
procedure TFrmDlg.DMLReadClick(Sender: TObject; X, Y: Integer);
var
   str : string;
begin
   if (CurrentMail >= 0) and (PNMailItem(MailLists[CurrentMail]).Sender <> '') then begin

      ViewWindowNo   := VIEW_MAILREAD;
      ViewWindowData := CurrentMail;
      DMemoB1.SetImgIndex(g_WTitleImages, 540);
      DMemoB2.SetImgIndex(g_WTitleImages, 193);  //´Ý±â
      DMemoB1.Left:= 15;
      DMemoB1.Top:= 265;
      DMemoB2.Left:= 151;
      DMemoB2.Top:= 265;
      DMemoB3.Visible := True;
      MemoMail.Text  := PNMailItem(MailLists[ViewWindowData]).Mail;
      MemoMail.ReadOnly := true;
      MemoCharID := PNMailItem(MailLists[ViewWindowData]).Sender;
      str   := PNMailItem(MailLists[ViewWindowData]).Date;
      MemoDate := '20'+str[1] + str[2] + '/' + str[3]+str[4] +'/'+
                  str[5] + str[6]+' '+str[7]+str[8]+':'+str[9]+str[10];
      // ÀÐ¾úÀ½À» Àü¼Û
      if ( PNMailItem(MailLists[CurrentMail]).Status = 0 ) then
      FrmMain.SendReadingMail( PNMailItem(MailLists[CurrentMail]).Id );

      ShowEditMail;

   end;
end;

procedure TFrmDlg.DMLDelClick(Sender: TObject; X, Y: Integer);
begin
  if (CurrentMail >= 0) and (PNMailItem(MailLists[CurrentMail]).Sender <> '') then begin
      if PNMailItem(MailLists[CurrentMail]).Status = 2 then begin
        FrmDlg.DMessageDlg ('ÓÊ¼þ´¦ÓÚËø¶¨µÄ×´Ì¬£¬ÄãÎÞ·¨É¾³ý¡£', [mbOk] );
        exit;
      end;

      if PNMailItem(MailLists[CurrentMail]).Status = 3 then begin
        FrmDlg.DMessageDlg ('ÓÊ¼þÒÑ±»É¾³ý¡£', [mbOk] );
        exit;
      end;

      if mrOk = FrmDlg.DMessageDlg ('ÄãÏëÒªÉ¾³ýÕâ·âÓÊ¼þÂð£¿', [mbOk, mbCancel]) then begin
        FrmMain.SendDelMail ( PNMailItem(MailLists[CurrentMail]).Id );

        edCharID.Visible     := FALSE;
        MemoMail.Visible     := FALSE;
        DMemo.Visible        := FALSE;
        MemoMail.ReadOnly    := FALSE;

        DMsgDlg.DialogResult := mrOK;

        SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
        
      end;
  end;
end;

procedure TFrmDlg.DMemoB3Click(Sender: TObject; X, Y: Integer);
var
   IsLock : Boolean;
   mstate : Byte;
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      mstate := PNMailItem(MailLists[CurrentMail]).Status;

      // »èÁ¦µÈ ³ÑÀÌ¸é Àá±Û¼ö ¾øÀ½
      if ( mstate = 3 ) then exit ;

      if ( mstate = 2 ) then IsLock := TRUE
      else IsLock := FALSE;

      if IsLock then
      FrmMain.SendUnLockMail ( PNMailItem(MailLists[CurrentMail]).Id )
      else
      FrmMain.SendLockMail ( PNMailItem(MailLists[CurrentMail]).Id );
   end;
end;

procedure TFrmDlg.DBeltWindowDirectPaint(Sender: TObject; dsurface: TDirectDrawSurface);      //º§Æ®Ã¢
var
 d, e: TDirectDrawSurface;
begin
  if g_MySelf = nil then
  DBeltWindow.Visible := False
  else
  DBeltWindow.NoPaint := False;

  with DBeltWindow do begin
   d := WLib.Images[FaceIndex];
     if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      if g_boVerticalBelt then
        e := g_WMainImages.Images[1945]
      else
        e := g_WMainImages.Images[1933];
      if e <> nil then
       DrawBlendEx (dsurface, SurfaceX(Left), SurfaceY(Top), e, 0, 0, e.Width, e.Height, 0);
  end;
end;

procedure TFrmDlg.DBLAddClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg.DlgEditText := '';
  FrmDlg.DMessageDlg ('ÇëÊäÈëÄãÒªÌí¼Óµ½ºÚÃûµ¥µÄÈËÔ±µÄÃû×Ö¡£', [mbOk, mbAbort]);

  if BlockLists.Count >= (16 - 1) then begin
    FrmDlg.DMessageDlg ('ÄãµÄºÚÃûµ¥ÈËÔ±ÁÐ±íÒÑ¾­ÂúÔ±¡£', [mbOk]);
    exit;
  end;

  if DlgEditText <> '' then begin
    FrmMain.SendAddReject (DlgEditText );
  end;
end;

procedure TFrmDlg.DBLDelClick(Sender: TObject; X, Y: Integer);
begin
   if CurrentBlock > -1 then begin
     if mrOk = FrmDlg.DMessageDlg ('ÄãÈ·¶¨Òª½«´ËÈË´ÓºÚÃûµ¥ÖÐÉ¾³ýÂð£¿', [mbOk, mbCancel]) then begin
      FrmMain.SendDelReject ( BlockLists[CurrentBlock] );
     end;
   end;
end;

procedure TFrmDlg.DBlockListDlgClick(Sender: TObject; X, Y: Integer);
var
    lx, ly : integer;
    pos : integer;
begin
    EdSalesEdit.Visible := False;
    CostSalesEdit.Visible := False;
    EdShopEdit.Visible := False;
    lx := x - DBlockListDlg.Left;
    ly := y - DBlockListDlg.Top;
    if (lx > 18) and (lx < 239) and (ly > 60) and (ly < 208) then begin
       pos := (lx div 140) + ((ly - (60)) div 15) * 2 + BlockPage * 20;
       if BlockLists.Count > pos then
          CurrentBlock := pos;
    end;
end;

procedure TFrmDlg.DBlockListDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d : TDirectDrawSurface;
   b : TDirectDrawSurface;
   lx, ly, n, t, l, ax, ay : integer;
   Rect : TRect;
   CurrentPage ,maxPage : integer;
begin
   CurrentPage :=  BlockPage + 1;
   MaxPage     :=  BlockLists.Count div 20 + 1;

   b := g_WTitleImages.Images[159];
   with DBlockListDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      dsurface.Draw (SurfaceX(Left+10), SurfaceY(Top+34), b.ClientRect, b, TRUE);
      if BlockLists.Count > 0 then begin
         t := BlockPage * 20;
         l := _MIN(BlockPage*20+20, BlockLists.Count);
         for n := t to l-1 do begin
            if n = CurrentBlock then
            begin
               dsurface.Canvas.Font.Color  := clBlack;
               dsurface.Canvas.Brush.Color := clGray;
               dsurface.Canvas.Brush.Style := bsSolid;
            end
            else
            begin
               dsurface.Canvas.Font.Color  := clSilver;
               dsurface.Canvas.Brush.Color := clBlack;
               dsurface.Canvas.Brush.Style := bsClear;
            end;


               lx := SurfaceX(18) + Left + ((n-t) mod 2) * 120;
               ly := SurfaceY(60) + Top  + ((n-t) div 2) * 15;

               dsurface.Canvas.TextOut (lx, ly, BlockLists[n] );


         end;
         dsurface.Canvas.Release;
      end;

      with dsurface.Canvas do
      begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         TextOut(SurfaceX(Left+125),SurfaceY(Top+220), inttostr(CurrentPage)+'/'+inttostr(MaxPage));
         Release;
      end;
   
   end;
end;

procedure TFrmDlg.DBLPgUpClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DBLPgUp then begin
      if BlockPage > 0 then
         Dec (BlockPage);
   end else begin
      if BlockPage < (BlockLists.Count+19) div 20 - 1 then
         Inc (BlockPage);
   end;
end;

procedure TFrmDlg.DMLBlockClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowBlockListDlg;
end;

procedure TFrmDlg.DBlockListCloseClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowBlockListDlg;
end;

procedure TFrmDlg.DBlockListDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg: String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);

  if Sender = DBLDel then sMsg := '´ÓºÚÃûµ¥É¾³ý'
  else if Sender = DBLAdd then sMsg := 'Ôö¼Óµ½ºÚÃûµ¥';

  nLocalX:=Butt.LocalX(X - Butt.Left);
  nLocalY:=Butt.LocalY(Y - Butt.Top);
  nHintX:=Butt.SurfaceX(Butt.Left) + DBlockListDlg.SurfaceX(DBlockListDlg.Left) + nLocalX;
  nHintY:=Butt.SurfaceY(Butt.Top) + DBlockListDlg.SurfaceY(DBlockListDlg.Top) + nLocalY;
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DBotMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var               //ÂÊÁö¾Ë¶÷
   d, e: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
     if Downed then begin
       d := WLib.Images[FaceIndex + 2];
     end else
     if MouseMoveing then begin
       d := WLib.Images[FaceIndex + 1];
     end else begin
        d := WLib.Images[FaceIndex];
     end;

     if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     if MailAlarm then begin           // ±ô¹ÚÀÓ Ç¥½Ã
       if (GetTickCount mod 1000) > 500 then  e := g_WMainImages.Images[544]
        else e := nil;
        if e <> nil then
          dsurface.Draw (SurfaceX(Left + 1), SurfaceY(Top + 1), e.ClientRect, e, TRUE);
     end;
   end;
end;




procedure TFrmDlg.DHoldClick(Sender: TObject; X, Y: Integer);
begin
  g_boQuickSell := not g_boQuickSell;
  with DHold do
      DScreen.ShowHintA(SurfaceX(Left)+46, SurfaceY(Top)+1, 'HOLD ´¦ÓÚ´ò¿ª×´Ì¬Ê±×Ô¶¯´¦Àí', clYellow, FALSE);
end;

procedure TFrmDlg.DSellDlgOkClick(Sender: TObject; X, Y: Integer);
begin
  DSellOk();
end;

procedure TFrmDlg.DGTListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
const
  sStatus:array[0..3] of String = ('ËùÓÐÈË', '³öÊÛÖÐ','³öÊÛÍê±Ï', '³öÊÛ³¬ÆÚ');
var
  i,rowcount,rowoffset: integer;
  d, e: TDirectDrawSurface;
  output: String;
begin
    with Sender as TDWindow do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      e := g_WTitleImages.Images[54];
      if e <> nil then
      dsurface.Draw (SurfaceX(Left+34), SurfaceY(Top + 5), e.ClientRect, e, TRUE);

      rowcount:=0;
      rowoffset:=14;
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      with dsurface.Canvas do begin
        Font.Color := clWhite;
        TextOut (SurfaceX(Left)+18, SurfaceY(Top)+40, 'ÐòºÅ');
        TextOut (SurfaceX(Left)+78, SurfaceY(Top)+40, 'ÐÐ»áÃû³Æ');
        TextOut (SurfaceX(Left)+250, SurfaceY(Top)+40, 'ÕÆÃÅ');
        TextOut (SurfaceX(Left)+392, SurfaceY(Top)+40, 'ÏúÊÛ½ð¶î');
        TextOut (SurfaceX(Left)+475, SurfaceY(Top)+40, '×´Ì¬');

        TextOut (SurfaceX(Left)+280, SurfaceY(Top)+214, IntToStr(g_GTCurrPage + 1));

        for i:= 0 to g_GTAmountOnPage - 1 do begin
          if g_GTItems[i].Number <= 0 then continue;
          if GTListMenuIndex = i then begin
            Font.Color := clRed;
          end else
            Font.Color := clWhite;
          TextOut (SurfaceX(Left)+16, SurfaceY(Top)+60+(rowoffset*rowcount), IntToStr(g_GTItems[i].Number));
          TextOut (SurfaceX(Left)+56, SurfaceY(Top)+60+(rowoffset*rowcount), g_GTItems[i].GuildName);
          TextOut (SurfaceX(Left)+160, SurfaceY(Top)+60+(rowoffset*rowcount), g_GTItems[i].GuildMasters[0]);
          TextOut (SurfaceX(Left)+260, SurfaceY(Top)+60+(rowoffset*rowcount), ',');
          TextOut (SurfaceX(Left)+270, SurfaceY(Top)+60+(rowoffset*rowcount), g_GTItems[i].GuildMasters[1]);
          TextOut (SurfaceX(Left)+458 - TextWidth(GetGoldStr(g_GTItems[i].SalePrice)), SurfaceY(Top)+60+(rowoffset*rowcount), GetGoldStr(g_GTItems[i].SalePrice));
          TextOut (SurfaceX(Left)+490, SurfaceY(Top)+60+(rowoffset*rowcount), sStatus[g_GTItems[i].Status]);
          inc(rowcount);
        end;
      end;
      dsurface.Canvas.Release;
  end;
end;

procedure TFrmDlg.DGTListCloseClick(Sender: TObject; X, Y: Integer);
begin
  DGTList.Visible := False;
  ClearGTlist();
end;

procedure TFrmDlg.ClearGTlist();
var
  i:integer;
begin
  for i:=0 to 9 do
    g_GTItems[i].Number:=0;
    g_GTCurrPage:=0;
    g_GTAmountOnPage:=0;
    GTListMenuIndex:=10;
end;

procedure TFrmDlg.ClearDecolist();
var
  i:integer;
begin
  for i:=0 to 11 do
    g_DecoItems[i].appr:=255;
    g_GTCurrPage:=0;
    g_GTAmountOnPage:=0;
    GTListMenuIndex:=13;
end;



procedure TFrmDlg.ClearBBSList();     //Àå¿ø°Ô½ÃÆÇ
var
  i:integer;
begin
  for i:=0 to 9 do
    g_BBSMsgList[i].index := -1;
    g_GTCurrPage:=0;
    g_GTAmountOnPage:=0;
    GTListMenuIndex:=10;
end;

procedure TFrmDlg.DGTListClick(Sender: TObject; X, Y: Integer);
begin
  if (((X<(16+DGTList.Left)) OR (X>(552+DGTList.Left))) OR
     ((Y<(58+DGTList.Top)) OR (Y>(198+DGTList.Top)))) then exit;
  GTListMenuIndex:= (Y-(58+DGTList.Top)) div 14;
  PlaySound(s_rock_button_click);
end;

procedure TFrmDlg.DGTListPrevClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if g_GTCurrPage > 0 then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.SendGTListRequest(g_nCurMerchant, g_GTCurrPage - 1);
    end;
  end;
end;

procedure TFrmDlg.DGTListNextClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if g_GTCurrPage + 1 <= g_GTTotalPage then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.SendGTListRequest(g_nCurMerchant, g_GTCurrPage + 1);
    end;
  end;
end;

procedure TFrmDlg.DGTListMailClick(Sender: TObject; X, Y: Integer);
begin
  if g_GTItems[GTListMenuIndex].GuildMasters[0] <> '' then begin

    ViewWindowNo   := VIEW_MAILSEND;
    ViewWindowData := CurrentMail;

    DMemoB1.SetImgIndex(g_WTitleImages, 190);
    DMemoB2.SetImgIndex(g_WTitleImages, 193);
    DMemoB1.Left:=30;
    DMemoB1.Top:=265;
    DMemoB2.Left:=134;
    DMemoB2.Top:=265;
    DMemoB3.Visible := False;

    MemoMail.Clear;

    MemoCharID  := g_GTItems[GTListMenuIndex].GuildMasters[0];

    DMemo.Left := 410;
    DMemo.Top  := 198;
    Memo.Clear;
    ShowEditMail;
  end;
end;

procedure TFrmDlg.DGTListDblClick(Sender: TObject);
begin
  if (GTListMenuIndex < 0) OR
     (GTListMenuIndex > 9) then exit;
  if g_GTItems[GTListMenuIndex].Number <> 0 then begin
    //FrmMain.SendBuyGT(g_nCurMerchant,g_GTItems[GTListMenuIndex].Number);
    //DGTList.Visible := False;
    //ClearGTlist();
  end;
end;

procedure TFrmDlg.DDecoListNextClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if g_GTCurrPage + 1 <= g_GTTotalPage then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.SendDecoListRequest(g_nCurMerchant, g_GTCurrPage + 1);
    end;
  end;
end;

procedure TFrmDlg.DDecoListPrevClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if g_GTCurrPage > 0 then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.SendDecoListRequest(g_nCurMerchant, g_GTCurrPage - 1);
    end;
  end;
end;

procedure TFrmDlg.DDecoListDlgClick(Sender: TObject; X, Y: Integer);
begin
  if (((X<(32+DDecoListDlg.Left)) OR (X>(270+DDecoListDlg.Left))) OR
     ((Y<(94+DDecoListDlg.Top)) OR (Y>(318+DDecoListDlg.Top)))) then exit;
  GTListMenuIndex:= (Y-(94+DDecoListDlg.Top)) div 19;
  PlaySound(s_rock_button_click);
end;

procedure TFrmDlg.DDecoListExitClick(Sender: TObject; X, Y: Integer);
begin
  DDecoListDlg.Visible := False;
  ClearDecolist();
end;


procedure TFrmDlg.DDecoListDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i,rowcount,rowoffset: integer;
  d,e: TDirectDrawSurface;
  dx,dy:integer;
begin
    with Sender as TDWindow do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      rowcount:=0;
      rowoffset:=19;
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      with dsurface.Canvas do begin
        Font.Color := clWhite;
        TextOut (SurfaceX(Left)+87, SurfaceY(Top)+45, '×¯Ô°×°ÊÎÁÐ±í');
        TextOut (SurfaceX(Left)+300, SurfaceY(Top)+388, IntToStr(g_GTCurrPage + 1) + '/' + IntToStr(g_GTTotalPage + 1));
        TextOut (SurfaceX(Left)+66, SurfaceY(Top)+75, 'Ãû³Æ');
        TextOut (SurfaceX(Left)+178, SurfaceY(Top)+75, '³öÊÛ¼Û¸ñ');
        for i:= 0 to g_GTAmountOnPage - 1 do begin
          if GTListMenuIndex = i then begin
            Font.Color := clRed;
          end else
            Font.Color := clWhite;
           TextOut (SurfaceX(Left)+32, SurfaceY(Top)+95+(rowoffset*rowcount),g_DecoItems[i].Name);
           TextOut (SurfaceX(Left)+164, SurfaceY(Top)+95+(rowoffset*rowcount),IntToStr(g_DecoItems[i].Price));
          inc(rowcount);
          if GTListMenuIndex = i then
          Font.Color := clWhite;
          TextOut (SurfaceX(Left)+36, SurfaceY(Top)+334, 'ÄÚ²¿¡¢Íâ²¿¶¼¿ÉÒÔÉèÖÃ¡£');
        end;
      end;
      dsurface.Canvas.Release;
      if (GTListMenuIndex >= 0) and (GTListMenuIndex <= g_GTAmountOnPage) then begin
        e := g_WDecoImages.Images[g_DecoItems[GTListMenuIndex].Appr];
        e := g_WDecoImages.GetCachedImage(g_DecoItems[GTListMenuIndex].Appr, dx, dy);
        if e <> nil then
          dsurface.Draw (SurfaceX(Left)+392+dx, SurfaceY(Top)+240+dy, e.ClientRect, e, TRUE);
      end;
  end;

end;

procedure TFrmDlg.DDecoListBuyClick(Sender: TObject; X, Y: Integer);
begin
  if (GTListMenuIndex < 0) or (GTListMenuIndex > 12) then exit;
  FrmMain.SendBuyDeco(g_nCurMerchant, g_DecoItems[GTListMenuIndex].Appr);
  GTListMenuIndex:=13;//prevent ppl from accidentaly buying 100000 times the same item in one go :p
end;

procedure TFrmDlg.DBBSListDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i,rowcount,rowoffset: integer;
  d,e: TDirectDrawSurface;
  dx,dy:integer;
  msg:string;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    rowcount:=0;
    rowoffset:=18;
    SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
    with dsurface.Canvas do begin
      Font.Color := clWhite;
      TextOut (SurfaceX(Left)+236 - TextWidth(g_sGuildName) div 2, SurfaceY(Top)+48, g_sGuildName);
      TextOut (SurfaceX(Left)+244, SurfaceY(Top)+274, IntToStr(g_GTCurrPage + 1) + '/' + IntToStr(g_GTTotalPage + 1));
      TextOut (SurfaceX(Left)+56, SurfaceY(Top)+77, '·¢²¼ÈË');
      TextOut (SurfaceX(Left)+277, SurfaceY(Top)+77, 'ÄÚ  ÈÝ');
      for i:= 0 to g_GTAmountOnPage - 1 do begin
        if GTListMenuIndex = i then begin
          Font.Color := clRed;
        end else if g_BBSMsgList[i].Sticky then begin
          Font.Color := clYellow;
        end else
          Font.Color := clWhite;
        GetValidStr3 (g_BBSMsgList[i].Msg, msg,[#13]);
        TextOut (SurfaceX(Left)+40, SurfaceY(Top)+94+(rowoffset*rowcount),g_BBSMsgList[i].Poster);
        if g_BBSMsgList[i].index <> g_BBSMsgList[i].MasterIndex then begin
          TextOut (SurfaceX(Left)+180, SurfaceY(Top)+94+(rowoffset*rowcount),msg);
        end else
          TextOut (SurfaceX(Left)+160, SurfaceY(Top)+94+(rowoffset*rowcount),msg);
        inc(rowcount);
      end;
    end;
    dsurface.Canvas.Release;
    rowcount:=0;
    for i:= 0 to g_GTAmountOnPage - 1 do begin
      if g_BBSMsgList[i].index <> g_BBSMsgList[i].MasterIndex then begin
        e:= WLib.Images[690];
        if e <> nil then
          dsurface.Draw (SurfaceX(Left)+160, SurfaceY(Top)+94+(rowoffset*rowcount), e.ClientRect, e, TRUE);
      end;
      inc(rowcount);
    end;
  end;
end;

procedure TFrmDlg.DBBSListDlgClick(Sender: TObject; X, Y: Integer);        //Àå¿ø°Ô½ÃÆÇ
begin
 if (((X<(40+DBBSListDlg.Left)) OR (X>(440+DBBSListDlg.Left))) OR
     ((Y<(93+DBBSListDlg.Top)) OR (Y>(269+DBBSListDlg.Top)))) then exit;
  GTListMenuIndex:= (Y-(93+DBBSListDlg.Top)) div 18;
  PlaySound(s_rock_button_click);
end;

procedure TFrmDlg.DBBSListPrevClick(Sender: TObject; X, Y: Integer);    //Àå¿ø°Ô½ÃÆÇ
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if g_GTCurrPage > 0 then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.SendBBSListRequest(g_nCurMerchant, g_GTCurrPage - 1);
    end;
  end;
end;

procedure TFrmDlg.DBBSListNextClick(Sender: TObject; X, Y: Integer);        //Àå¿ø°Ô½ÃÆÇ
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if g_GTCurrPage + 1 <= g_GTTotalPage then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.SendBBSListRequest(g_nCurMerchant, g_GTCurrPage + 1);
    end;
  end;
end;

procedure TFrmDlg.DBBSListRefreshClick(Sender: TObject; X, Y: Integer);      //Àå¿ø°Ô½ÃÆÇ
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    FrmMain.SendBBSListRequest(g_nCurMerchant, g_GTCurrPage);
  end;
end;

procedure TFrmDlg.DBBSListCloseClick(Sender: TObject; X, Y: Integer);      //Àå¿ø°Ô½ÃÆÇ
begin
  DBBSListDlg.Visible := False;
  ClearBBSlist();
end;

procedure TFrmDlg.DBBSListOKClick(Sender: TObject; X, Y: Integer);        //Àå¿ø°Ô½ÃÆÇ
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if (GTListMenuIndex < 0) or (GTListMenuIndex > 10) then exit;
    if g_BBSMsgList[GTListMenuIndex].index <= 0 then exit;
     g_dwQueryMsgTick := GetTickCount + 1000;
     FrmMain.SendBBSMsgRequest(g_nCurMerchant, g_BBSMsgList[GTListMenuIndex].index);
  end;
end;

procedure TFrmDlg.DBBSMsgCloseClick(Sender: TObject; X, Y: Integer);     //Àå¿ø°Ô½ÃÆÇ
begin
  ToggleBBSMsgWindow;
end;

procedure TFrmDlg.DBBSMsgDlgDirectPaint(Sender: TObject;       //Àå¿ø°Ô½ÃÆÇ
  dsurface: TDirectDrawSurface);
var
  rowcount,rowoffset: integer;
  d: TDirectDrawSurface;
  dx,dy,i:integer;
  msg,str,tempstr:string;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    if g_BBSMSG <> '' then begin
      rowcount:=0;
      rowoffset:=16;
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      msg:=g_BBSMSG;
      with dsurface.Canvas do begin
        Font.Color := clWhite;
        TextOut (SurfaceX(Left)+12, SurfaceY(Top)+35, g_BBSPoster);
        while True do begin
          if (msg = '') or (rowcount > 9) then break;
          msg := GetValidStr3 (msg, str,[#13]);
          if TextWidth(str) > 268 then begin
            tempstr:=str;
            i:=1;
            while TextWidth(tempstr) > 268 do begin
              tempstr:= LeftStr(str,Length(str) - i);
              inc(i);
            end;
            str:= RightStr(str,i);
            msg:= str + #13 + msg;
            str := tempstr;
          end;
          TextOut (SurfaceX(Left)+14, (SurfaceY(Top)+56) + (rowcount * rowoffset), Trim(str));
          inc(rowcount)
        end;
      end;
      dsurface.Canvas.Release;
    end else begin
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      with dsurface.Canvas do begin
        Font.Color := clWhite;
        TextOut (SurfaceX(Left)+26, SurfaceY(Top)+35, g_MySelf.m_sUserName);
      end;
      dsurface.Canvas.Release;
//      HideAllControls;
      BBSMemo.Left := SurfaceX(Left+14);  //16
      BBSMemo.Top  := SurfaceY(Top+56);   //36
      FrmDlg.BBSMemo.SetFocus;
      SetDFocus(FrmDlg.DBBSMsgDlg);
    end;
  end;
end;

procedure TFrmDlg.DBBSListWriteClick(Sender: TObject; X, Y: Integer);     //Àå¿ø°Ô½ÃÆÇ
begin
  g_MasterPost:=0;
  BBSSticky:=0;
  g_BBSMSG := '';
  ToggleBBSMsgWindow;
end;

procedure TFrmDlg.DBBSListNoticeClick(Sender: TObject; X, Y: Integer);     //Àå¿ø°Ô½ÃÆÇ
begin
  g_MasterPost:=0;
  BBSSticky:=1;
  g_BBSMSG := '';
  ToggleBBSMsgWindow;
end;

procedure TFrmDlg.DBBSMsgOkClick(Sender: TObject; X, Y: Integer);   //Àå¿ø°Ô½ÃÆÇ
var
  msg,str,output:string;
  rowcount : integer;
begin
   if g_BBSMSG <> '' then begin
    ToggleBBSMsgWindow;
  end else begin
    ToggleBBSMsgWindow;
    output:='';
    rowcount := 0;
    msg:=BBSMemo.Text;
    while True do begin
      if (msg = '') then break;
      if (rowcount > 8) then begin
        DMessageDlg ('·¢²¼µÄÄÚÈÝ²»ÄÜ³¬¹ý8ÐÐ¡£', [mbOk]);
        break;
      end;
      msg := GetValidStr3 (msg, str,[#13]);
      if rowcount = 0 then begin
        output := str;
      end else
        output := output + #13 + str;
      inc(rowcount)
    end;
    if (output = '') or (rowcount > 8) then exit;
    FrmMain.SendBBSPost(g_nCurMerchant,BBSSticky, g_MasterPost,output);
  end;
end;

procedure TFrmDlg.DBBSMsgReplyClick(Sender: TObject; X, Y: Integer);    //Àå¿ø°Ô½ÃÆÇ
begin
  ToggleBBSMsgWindow;
  g_BBSMSG := '';
  BBSSticky:=0;
  ToggleBBSMsgWindow;
end;

procedure TFrmDlg.DBBSMsgDeleteClick(Sender: TObject; X, Y: Integer);      //Àå¿ø°Ô½ÃÆÇ
begin
   if (GTListMenuIndex < 0) or (GTListMenuIndex > 10) then exit;
  if g_BBSMsgList[GTListMenuIndex].index <= 0 then exit;
  FrmMain.SendBBSDelete(g_nCurMerchant, g_BBSMsgList[GTListMenuIndex].index);
  GTListMenuIndex := 13;
  g_BBSMSG := '';
  ToggleBBSMsgWindow;
end;

procedure TFrmDlg.DOptionsCloseClick(Sender: TObject; X, Y: Integer);
begin
  DOptions.Visible := false;
end;



procedure TFrmDlg.DOptionsDropViewOnClick(Sender: TObject; X, Y: Integer);
begin
  g_boShowAllItem := true;
  DOptionsDropViewOn.SetImgIndex (g_WMain2Images, 458);
  DOptionsDropViewOff.SetImgIndex (g_WMain2Images, 459);
  DScreen.AddChatBoardString ('<Tab¼ü ´ò¿ªÎïÆ·Ãû³ÆÏÔÊ¾>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsDropViewOffClick(Sender: TObject; X, Y: Integer);
begin
  g_boShowAllItem := false;
  DOptionsDropViewOn.SetImgIndex (g_WMain2Images, 456);
  DOptionsDropViewOff.SetImgIndex (g_WMain2Images, 461);
  DScreen.AddChatBoardString ('<Tab¼ü ¹Ø±ÕÎïÆ·Ãû³ÆÏÔÊ¾>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsEffectOffClick(Sender: TObject; X, Y: Integer);
begin
  g_boEffect := false;
  DOptionsEffectOn.SetImgIndex (g_WMain2Images, 456);
  DOptionsEffectOff.SetImgIndex (g_WMain2Images, 461);
  DScreen.AddChatBoardString ('<¹Ø±ÕÌØÐ§ÏÔÊ¾>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsEffectOnClick(Sender: TObject; X, Y: Integer);
begin
  g_boEffect := true;
  DOptionsEffectOn.SetImgIndex (g_WMain2Images, 458);
  DOptionsEffectOff.SetImgIndex (g_WMain2Images, 459);
  DScreen.AddChatBoardString ('<¿ªÆôÌØÐ§ÏÔÊ¾>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsSkillBarOffClick(Sender: TObject; X, Y: Integer);
begin
  DSkillBar.Visible := false;
  if g_MyHero <> nil then DHeroSkillBar.Visible := False;
  DOptionsSkillBarOn.SetImgIndex (g_WMain2Images, 456);
  DOptionsSkillBarOff.SetImgIndex (g_WMain2Images, 461);
  DScreen.AddChatBoardString ('<¹Ø±Õ¼¼ÄÜ¿ì½ÝÀ¸>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsSkillBarOnClick(Sender: TObject; X, Y: Integer);
begin
  DSkillBar.SetImgIndex (g_WMainImages, 2190);
  DSkillBar.Visible := true;
  if (g_MyHero <> nil) then begin
    DHeroSkillBar.SetImgIndex (g_WMainImages, 2192);
    DHeroSkillBar.Visible := true;
  end;
  DOptionsSkillBarOn.SetImgIndex (g_WMain2Images, 458);
  DOptionsSkillBarOff.SetImgIndex (g_WMain2Images, 459);
  DScreen.AddChatBoardString ('<¿ªÆô¼¼ÄÜ¿ì½ÝÀ¸>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsSkillMode1Click(Sender: TObject; X, Y: Integer);
begin
  g_boSkillSetting := true;             //¸Þ½ÃÁö Ã¢
  DOptionsSkillMode1.SetImgIndex (g_WMain2Images, 452);
  DOptionsSkillMode2.SetImgIndex (g_WMain2Images, 453);
end;

procedure TFrmDlg.DOptionsSkillMode2Click(Sender: TObject; X, Y: Integer);
begin
  g_boSkillSetting := False;
  DOptionsSkillMode1.SetImgIndex (g_WMain2Images, 450);
  DOptionsSkillMode2.SetImgIndex (g_WMain2Images, 455);
end;

procedure TFrmDlg.DOptionsNameAllViewOnClick(Sender: TObject; X,
  Y: Integer);
begin
  g_boNameAllView := true;
  DOptionsNameAllViewOn.SetImgIndex (g_WMain2Images, 458);
  DOptionsNameAllViewOff.SetImgIndex (g_WMain2Images, 459);
  if g_boNameChNpView then DNameChNP.SetImgIndex (g_WMain2Images, 458)
  else DNameChNP.SetImgIndex (g_WMain2Images, 459);
  if g_boNameMonView then  DNameMon.SetImgIndex (g_WMain2Images, 458)
  else DNameMon.SetImgIndex (g_WMain2Images, 459);

  if g_boNameChNpView and g_boNameMonView then begin
    DScreen.AddChatBoardString ('<ÏÔÊ¾È«²¿Ãû×Ö>', clGreen, clWhite);
  end else begin
    if g_boNameChNpView then
      DScreen.AddChatBoardString ('<ÏÔÊ¾½ÇÉ«/NPCÃû×Ö>', clGreen, clWhite);
    if g_boNameMonView then
      DScreen.AddChatBoardString ('<ÏÔÊ¾¹ÖÎïÃû×Ö>', clGreen, clWhite);
  end;
end;

procedure TFrmDlg.DOptionsNameAllViewOffClick(Sender: TObject; X,
  Y: Integer);
begin
  g_boNameAllView := false;
  DOptionsNameAllViewOn.SetImgIndex (g_WMain2Images, 456);
  DOptionsNameAllViewOff.SetImgIndex (g_WMain2Images, 461);
  DNameChNP.SetImgIndex (g_WMain2Images, 459);
  DNameMon.SetImgIndex (g_WMain2Images, 459);
  DScreen.AddChatBoardString ('<Ö»ÏÔÊ¾Êó±êËùÖ¸½ÇÉ«µÄÃû³Æ>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsHPView1Click(Sender: TObject; X, Y: Integer);
begin
  g_boHPView := true;
  DOptionsHPView1.SetImgIndex (g_WMain2Images, 464);
  DOptionsHPView2.SetImgIndex (g_WMain2Images, 465);
  DScreen.AddChatBoardString ('<HP/MP ÏÔÊ¾Ä£Ê½ 1>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsHPView2Click(Sender: TObject; X, Y: Integer);
begin
  g_boHPView := false;
  DOptionsHPView1.SetImgIndex (g_WMain2Images, 462);
  DOptionsHPView2.SetImgIndex (g_WMain2Images, 467);
  DScreen.AddChatBoardString ('<HP/MP ÏÔÊ¾Ä£Ê½ 2>', clGreen, clWhite);
end;

procedure TFrmDlg.DSkillBarDirectPaint(Sender: TObject; dsurface: TDirectDrawSurface);

var
   d, e ,f: TDirectDrawSurface;
   magic: PTClientMagic;
   Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
begin

  // Is the NPC dialog open? If it is, don't draw anything!
  if DMerchantDlg.Visible then begin
    DSkillBar1.Visible := false;
    DSkillBar2.Visible := false;
    DSkillBar3.Visible := false;
    DSkillBar4.Visible := false;
    DSkillBar5.Visible := false;
    DSkillBar6.Visible := false;
    DSkillBar7.Visible := false;
    DSkillBar8.Visible := false;
    exit;
  end else if not(DSkillBar1.Visible) then begin
    DSkillBar1.Visible := true;
    DSkillBar2.Visible := true;
    DSkillBar3.Visible := true;
    DSkillBar4.Visible := true;
    DSkillBar5.Visible := true;
    DSkillBar6.Visible := true;
    DSkillBar7.Visible := true;
    DSkillBar8.Visible := true;
  end;
  if DSkillBar.Visible then begin
    if (g_MyHero <> nil) then begin
     // DHeroSkillBar.Visible := True;
    end else begin
      DHeroSkillBar.Visible := False;
    end;
  end;  
  //draw the window
  with Sender as TDWindow do begin
    e := g_WMainImages.Images[2193];
      if e <> nil then
       DrawBlendEx (dsurface, SurfaceX(Left + 12), SurfaceY(Top), e, 0, 0, e.Width, e.Height, 0);

    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    if g_boSkillBarNum = 1 then f := g_WMainImages.Images[2247]
     else f := g_WMainImages.Images[2248];
      if f <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), f.ClientRect, f, TRUE);
    dsurface.Canvas.Release;

    with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);

         Font.Color := clWhite;
         Key1 := 'F1';
         Key2 := 'F2';
         Key3 := 'F3';
         Key4 := 'F4';
         Key5 := 'F5';
         Key6 := 'F6';
         Key7 := 'F7';
         Key8 := 'F8';
         Key9 := 'Ctrl';
         Key10 := '+';
         if g_boSkillBarNum = 1 then begin
         Font.Size := 9;
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+4), '1');
         Font.Size := 8;
         TextOut (SurfaceX(Left + 18), SurfaceY(Top+5), Key1);
         TextOut (SurfaceX(Left + 43), SurfaceY(Top+5), Key2);
         TextOut (SurfaceX(Left + 68), SurfaceY(Top+5), Key3);
         TextOut (SurfaceX(Left + 93), SurfaceY(Top+5), Key4);
         TextOut (SurfaceX(Left + 118), SurfaceY(Top+5), Key5);
         TextOut (SurfaceX(Left + 143), SurfaceY(Top+5), Key6);
         TextOut (SurfaceX(Left + 168), SurfaceY(Top+5), Key7);
         TextOut (SurfaceX(Left + 193), SurfaceY(Top+5), Key8);
         end else begin
         Font.Size := 9;
         TextOut (SurfaceX(Left + 3), SurfaceY(Top+14), '2');
         Font.Size := 8;
         TextOut (SurfaceX(Left + 15), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 40), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 65), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 90), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 115), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 140), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 165), SurfaceY(Top+3), Key9);
         TextOut (SurfaceX(Left + 190), SurfaceY(Top+3), Key9);

         TextOut (SurfaceX(Left + 15), SurfaceY(Top+14), Key1);
         TextOut (SurfaceX(Left + 40), SurfaceY(Top+14), Key2);
         TextOut (SurfaceX(Left + 65), SurfaceY(Top+14), Key3);
         TextOut (SurfaceX(Left + 90), SurfaceY(Top+14), Key4);
         TextOut (SurfaceX(Left + 115), SurfaceY(Top+14), Key5);
         TextOut (SurfaceX(Left + 140), SurfaceY(Top+14), Key6);
         TextOut (SurfaceX(Left + 165), SurfaceY(Top+14), Key7);
         TextOut (SurfaceX(Left + 190), SurfaceY(Top+14), Key8);
         end;
         Font.Size := 9;
         Release;
      end;
  end;

  if g_boSkillBarNum = 1 then begin

    // F keys

    //F1
    magic := frmmain.GetMagicByKey(char ((0) + byte('1')) );
    if magic <> nil then
      DSkillBar1.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar1.SetImgIndex(GetMagicImages(0), -1);

    //F2
    magic := frmmain.GetMagicByKey(char ((1) + byte('1')) );
    if magic <> nil then
      DSkillBar2.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar2.SetImgIndex(GetMagicImages(0), -1);

    //F3
    magic := frmmain.GetMagicByKey(char ((2) + byte('1')) );
    if magic <> nil then
      DSkillBar3.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar3.SetImgIndex(GetMagicImages(0), -1);

    //F4
    magic := frmmain.GetMagicByKey(char ((3) + byte('1')) );
    if magic <> nil then
      DSkillBar4.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar4.SetImgIndex(GetMagicImages(0), -1);

    //F5
    magic := frmmain.GetMagicByKey(char ((4) + byte('1')) );
    if magic <> nil then
      DSkillBar5.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar5.SetImgIndex(GetMagicImages(0), -1);

    //F6
    magic := frmmain.GetMagicByKey(char ((5) + byte('1')) );
    if magic <> nil then
      DSkillBar6.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar6.SetImgIndex(GetMagicImages(0), -1);

    //F7
    magic := frmmain.GetMagicByKey(char ((6) + byte('1')) );
    if magic <> nil then
      DSkillBar7.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar7.SetImgIndex(GetMagicImages(0), -1);

    //F8
    magic := frmmain.GetMagicByKey(char ((7) + byte('1')) );
    if magic <> nil then
      DSkillBar8.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar8.SetImgIndex(GetMagicImages(0), -1);

  end else begin
    // CTRL+F keys

    //F1
    magic := frmmain.GetMagicByKey(char ((0) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar1.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar1.SetImgIndex(GetMagicImages(0), -1);

    //F2
    magic := frmmain.GetMagicByKey(char ((1) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar2.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar2.SetImgIndex(GetMagicImages(0), -1);

    //F3
    magic := frmmain.GetMagicByKey(char ((2) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar3.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar3.SetImgIndex(GetMagicImages(0), -1);

    //F4
    magic := frmmain.GetMagicByKey(char ((3) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar4.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar4.SetImgIndex(GetMagicImages(0), -1);

    //F5
    magic := frmmain.GetMagicByKey(char ((4) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar5.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar5.SetImgIndex(GetMagicImages(0), -1);

    //F6
    magic := frmmain.GetMagicByKey(char ((5) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar6.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar6.SetImgIndex(GetMagicImages(0), -1);

    //F7
    magic := frmmain.GetMagicByKey(char ((6) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar7.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar7.SetImgIndex(GetMagicImages(0), -1);

    //F8
    magic := frmmain.GetMagicByKey(char ((7) + byte('1') + byte($14)) );
    if magic <> nil then
      DSkillBar8.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DSkillBar8.SetImgIndex(GetMagicImages(0), -1);

  end;
end;

procedure TFrmDlg.DSkillBarMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var
  magic: PTClientMagic;
  key: byte;
  MagItem:nMagicType;
  nHintX, nHintY: Integer;
  butt:TDButton;
begin
  DScreen.ClearHint;

  key := 8;
  if Sender = DSkillBar1 then key := 0;
  if Sender = DSkillBar2 then key := 1;
  if Sender = DSkillBar3 then key := 2;
  if Sender = DSkillBar4 then key := 3;
  if Sender = DSkillBar5 then key := 4;
  if Sender = DSkillBar6 then key := 5;
  if Sender = DSkillBar7 then key := 6;
  if Sender = DSkillBar8 then key := 7;

  if g_boSkillBarNum = 1 then begin
    // F keys
    magic := frmmain.GetMagicByKey(char ((key) + byte('1')) );
  end else begin
    // CTRL+F keys
    magic := frmmain.GetMagicByKey(char ((key) + byte('1') + byte($14)) );
  end;

  with Sender as TDButton do begin
    Butt := TDButton(Sender);
    nHintX:=DSkillBar.SurfaceX(DSkillBar.Left);
    nHintY:=Butt.SurfaceY(Butt.Top) + DSkillBar.SurfaceY(DSkillBar.Top) + 24;
      if magic <> nil then begin
         g_MagicItem := magic;
         GetMouseMagicInfo(MagItem);   //¹«°øÁ¤º¸
         if MagItem.MagicStr[0] <> '' then begin
             DScreen.MagicShowHint(nHintX, nHintY, MagItem, clYellow, FALSE, FALSE);
         end;
      end;
      g_MagicItem := nil;
   end;
end;

procedure TFrmDlg.DUSGroupClick(Sender: TObject; X, Y: Integer);
begin

  if UserState1.UserName <> '' then
    if g_MemberGroup.Count = 0 then
      FrmMain.SendCreateGroup(Integer(g_GroupItemMode), Integer(g_boCheckHero), UserState1.UserName)
    else
      FrmMain.SendAddGroupMember(UserState1.UserName);

end;

procedure TFrmDlg.DUSFriendClick(Sender: TObject; X, Y: Integer);
begin
  if UserState1.UserName <> '' then begin
    if g_FriendList.IndexOf(UserState1.UserName) = 0 then begin
      FrmDlg.DMessageDlg (UserState1.UserName+'ÒÑ¾­ÊÇÄãµÄºÃÓÑÁË¡£', [mbOk]);
      exit;
    end;
    if g_FriendList.Count >= (MAXFRIENDS - 1) then begin
      FrmDlg.DMessageDlg ('ÄãµÄºÃÓÑµÄÊýÁ¿ÒÑ¾­´ïµ½×î´óÊýÖµ¡£', [mbOk]);
      exit;
      end;
    SendClientMessage(CM_FRIEND_CHENGE, 0, 0, 0, 0, UserState1.UserName);
  end;
end;

procedure TFrmDlg.DUSMailClick(Sender: TObject; X, Y: Integer);
begin
  if UserState1.UserName <> '' then begin
    ViewWindowNo   := VIEW_MAILSEND;
    ViewWindowData := CurrentMail;

    DMemoB1.SetImgIndex(g_WTitleImages, 190);
    DMemoB2.SetImgIndex(g_WTitleImages, 193);
    DMemoB1.Left:=30;
    DMemoB1.Top:=265;
    DMemoB2.Left:=134;
    DMemoB2.Top:=265;
    DMemoB3.Visible := False;

    MemoMail.Clear;
    MemoMail.ReadOnly := false;
    MemoCharID := UserState1.UserName;
    ShowEditMail;
  end;
end;

procedure TFrmDlg.DSalesMailClick(Sender: TObject; X, Y: Integer);
begin
   if MemoCharID <> '' then begin
      ViewWindowNo   := VIEW_MAILSEND;

      DMemoB1.SetImgIndex(g_WTitleImages, 190);
      DMemoB2.SetImgIndex(g_WTitleImages, 193);
      DMemoB1.Left:=30;
      DMemoB1.Top:=265;
      DMemoB2.Left:=134;
      DMemoB2.Top:=265;
      DMemoB3.Visible := False;

      memoMail.Clear;
      ShowEditMail;
   end else
      DMessageDlg ('¶Ô·½²»ÔÚÏß¡£', [mbOk]);
end;

//ÄÉ¸¯ÅÍ ¼±ÅÃÃ¢
procedure TFrmDlg.DSelectChrClick(Sender: TObject; X, Y: Integer);
begin
 if not FrmDlg.DCreateChr.Visible then begin
   if not g_InterfaceMode then begin
      if (((x>GetScreenX(448)) and (x<GetScreenX(733))) and ((y>GetScreenY2(122)) and (y<GetScreenY2(175)))) then
       SelectChrScene.SelChrSelect1Click
      else if (((x>GetScreenX(448)) and (x<GetScreenX(733))) and ((y>GetScreenY2(226)) and (y<GetScreenY2(279)))) then
       SelectChrScene.SelChrSelect2Click
      else if (((x>GetScreenX(448)) and (x<GetScreenX(733))) and ((y>GetScreenY2(330)) and (y<GetScreenY2(383)))) then
       SelectChrScene.SelChrSelect3Click
      else if (((x>GetScreenX(448)) and (x<GetScreenX(733))) and ((y>GetScreenY2(436)) and (y<GetScreenY2(487)))) then
       SelectChrScene.SelChrSelect4Click
   end else begin
     if (((x>GetScreenX(69)) and (x<GetScreenX(183))) and ((y>GetScreenY(256)) and (y<GetScreenY(530)))) then
      SelectChrScene.SelChrSelect1Click
     else if (((x>GetScreenX(246)) and (x<GetScreenX(362))) and ((y>GetScreenY(182)) and (y<GetScreenY(455)))) then
      SelectChrScene.SelChrSelect2Click
     else if (((x>GetScreenX(448)) and (x<GetScreenX(565))) and ((y>GetScreenY(182)) and (y<GetScreenY(455)))) then
      SelectChrScene.SelChrSelect3Click
     else if (((x>GetScreenX(614)) and (x<GetScreenX(730))) and ((y>GetScreenY(256)) and (y<GetScreenY(530)))) then
      SelectChrScene.SelChrSelect4Click;
   end;

 end;
end;


procedure TFrmDlg.DLoginViewKeyClick(Sender: TObject; X, Y: Integer);
begin
   FrmDlg2.DInputKey.Visible := not FrmDlg2.DInputKey.Visible;
end;

procedure TFrmDlg.DMsgSimpleDlgOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMsgSimpleDlgOk then DMsgSimpleDlg.DialogResult := mrOk;
   if Sender = DMsgSimpleDlgCancel then DMsgSimpleDlg.DialogResult := mrCancel;
   DMsgSimpleDlg.Visible := FALSE;
end;

procedure TFrmDlg.DMsgSimpleDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I: Integer;
  d: TDirectDrawSurface;
  ly: integer;
  str, data: string;
  nX,nY:Integer;
begin
   with Sender as TDWindow do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      if m_boPlayDice then begin
        for I := 0 to m_nDiceCount - 1 do begin
          d:=g_WBagItemImages.GetCachedImage(m_Dice[I].nPlayPoint + 376 - 1,nX,nY);
          if d <> nil then begin
            dsurface.Draw (SurfaceX(Left) + m_Dice[I].nX + nX - 7, SurfaceY(Top) + m_Dice[I].nY + nY {+ 38}, d.ClientRect, d, TRUE);
          end;
        end;
      end;


      ly := msgly;
      str := MsgText;
      while TRUE do begin
         if str = '' then break;
         str := GetValidStr3 (str, data, ['\']);
         if data <> '' then begin
           SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
            BoldTextOut (dsurface, SurfaceX(Left+msglx), SurfaceY(Top+ly), clWhite, clBlack, data);
            dsurface.Canvas.Release;
         end;
         ly := ly + 16;
      end;

   end;
   if ViewDlgEdit then begin
      if not EdDlgEdit.Visible then begin
         SetImeMode (EdDlgEdit.Handle, imSHanguel);
         EdDlgEdit.Visible := TRUE;
         EdDlgEdit.SetFocus;
      end;
   end;
end;

procedure TFrmDlg.DMsgSimpleDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = 13 then begin
      if DMsgSimpleDlgOk.Visible then begin
         DMsgSimpleDlg.DialogResult := mrOk;
         DMsgSimpleDlg.Visible := FALSE;
      end;
   end;
   if Key = 27 then begin
      if DMsgSimpleDlgCancel.Visible then begin
         DMsgSimpleDlg.DialogResult := mrCancel;
         DMsgSimpleDlg.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.DBotHelpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if not d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex+1];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;


procedure TFrmDlg.DBotHelpClick(Sender: TObject; X, Y: Integer);
begin
  OpenHelpWin();
  HelpPage := 0;
end;

procedure TFrmDlg.OpenHelpWin();
begin
  DHelpWin.Visible:=not DHelpWin.Visible;
  HelpPage := 0;
end;

procedure TFrmDlg.DHelpCloseClick(Sender: TObject; X, Y: Integer);
begin
  DHelpWin.Visible:=FALSE;
end;

procedure TFrmDlg.DHelpWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d , e: TDirectDrawSurface;
  i, n, bx, by, bbx, bby: integer;
begin
   with DHelpWin do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      e := g_WTitleImages.Images[57];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left + 30), SurfaceY(Top + 6), e.ClientRect, e, TRUE);

      case HelpPage of
         0: begin
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+42), SurfaceY(Top+86), '¿ì½Ý¼ü');
               TextOut (SurfaceX(Left+250), SurfaceY(Top+86), 'ÄÚ  ÈÝ');
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '1  / 31');
               Release;
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clYellow;
               TextOut (SurfaceX(Left+32), SurfaceY(Top+110), 'Alt + Q');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+130), 'Alt + X');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+150), 'F9, I');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+170), 'F10, C');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+190), 'F11, S');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+210), 'F1 ~ F8');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+230), 'W');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+250), 'P');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+270), 'T');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+290), 'V');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+310), 'G');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+330), 'Y');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+350), 'M');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+370), 'L');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+390), 'Z');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+410), 'O');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+430), 'H');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+450), 'J');
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+120), SurfaceY(Top+110), 'ÍË³öÓÎÏ·');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+130), '×¢ÏúÓÎÏ·');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+150), '´ò¿ª/¹Ø±Õ ×´Ì¬´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+170), '´ò¿ª/¹Ø±Õ ½ÇÉ«×´Ì¬');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+190), '´ò¿ª/¹Ø±Õ ¼¼ÄÜ´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+210), '¼¼ÄÜ¿ì½Ý¼ü');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+230), '´ò¿ª/¹Ø±Õ ÅóÓÑ´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+250), '´ò¿ª/¹Ø±Õ ×é¶Ó´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+270), '´ò¿ª/¹Ø±Õ ½»Ò×´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+290), '´ò¿ª/¹Ø±Õ Ð¡µØÍ¼');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+310), '´ò¿ª/¹Ø±Õ ÐÐ»á´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+330), '´ò¿ª/¹Ø±Õ ÉÌÆÌ´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+350), '´ò¿ª/¹Ø±Õ ÓÊ¼þ´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+370), '´ò¿ª/¹Ø±Õ »éÒö´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+390), '´ò¿ª/¹Ø±Õ ÎïÆ·¿ì½ÝÀ¸');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+410), '´ò¿ª/¹Ø±Õ ÖÃ´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+430), '´ò¿ª/¹Ø±Õ °ïÖú´°¿Ú');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+450), '´ò¿ª/¹Ø±Õ ×øÆï´°¿Ú');
               Release;
            end;
         end;
         1: begin
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+42), SurfaceY(Top+86), '¿ì½Ý¼ü');
               TextOut (SurfaceX(Left+250), SurfaceY(Top+86), 'ÄÚ  ÈÝ');
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '2  / 31');
               Release;
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clYellow;
               TextOut (SurfaceX(Left+32), SurfaceY(Top+110), 'Ctrl + A');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+130), 'Ctrl + F');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+150), 'Ctrl + H');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+270), 'B');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+290), '~');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+310), 'R');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+330), 'D');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+350), 'U');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+370), 'Tab');
               TextOut (SurfaceX(Left+13), SurfaceY(Top+390), 'Ctrl+µã»÷Êó±êÓÒ¼ü');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+410), 'F11');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+430), 'Ctrl + S');
               TextOut (SurfaceX(Left+32), SurfaceY(Top+450), 'N');
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+120), SurfaceY(Top+110), 'ÊôÏÂ×´Ì¬[ÐÝÏ¢/¹¥»÷]');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+130), '¸ü¸ÄÁÄÌìÀ¸ÎÄ×ÖµÄ×ÖÌå');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+150), 'ÇÐ»»¹¥»÷Ä£Ê½');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+170), '[ºÍÆ½¹¥»÷] - Ö»¹¥»÷¹ÖÎï');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+190), '[ÐÐ»á¹¥»÷] - ¹¥»÷³ýÁË±¾ÐÐ»áÍâµÄËùÓÐÄ¿±ê');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+210), '[È«Ìå¹¥»÷] - ¹¥»÷ËùÓÐÄ¿±ê');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+230), '[±à×é¹¥»÷] - ¹¥»÷³ýÁË±¾×éÍâµÄËùÓÐÄ¿±ê');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+250), '[ÉÆ¶ñ¹¥»÷] - Ö»¹¥»÷¹ÖÎïµÄºÍ¶ñÈË');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+270), '´óµØÍ¼¿ì½Ý¼ü');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+290), '¼¼ÄÜ¿ì½ÝÀ¸Ä£Ê½ÇÐ»»');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+310), '¼¼ÄÜ¿ì½ÝÀ¸´°¿Ú¿ª¹Ø');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+330), '¿ªÆô / ¹Ø±Õ ×Ô¶¯ÅÜ¹¦ÄÜ');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+350), 'ÌØÐ§ÏÔÊ¾¡£');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+370), 'ÎïÆ·ÏÔÊ¾¿ª¹Ø');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+390), '²é¿´±»ÈË½ÇÉ«ÐÅÏ¢');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+410), '²é¿´ÁÄÌìÐÅÏ¢');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+430), 'Ë¢ÐÂ°ü¹ü');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+450), '¿ªÆô / ¹Ø±Õ µöÓã');
               Release;
            end;
         end;
         2: begin
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+42), SurfaceY(Top+86), '¿ì½Ý¼ü');
               TextOut (SurfaceX(Left+250), SurfaceY(Top+86), 'ÄÚ  ÈÝ');
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '3  / 31');
               Release;
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clYellow;
               TextOut (SurfaceX(Left+24), SurfaceY(Top+110), '/¾ÆÀÌµð');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+130), '!¸»ÇÏ±â');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+150), '!~¸»ÇÏ±â');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+170), '@±Ó¿§¸»°ÅºÎ');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+190), '@Â÷´Ü ¾ÆÀÌµð');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+210), '@¹®ÆÄÀüÀ½Â÷´Ü');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+230), '¹æÇâÅ°');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+250), ',');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+270), '\');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+290), 'Pause');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+310), '@³»°ø');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+330), '+ , -');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+350), '[');
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clRed;
               TextOut (SurfaceX(Left+120), SurfaceY(Top+110), 'ÇØ´ç ¾ÆÀÌµð');
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+189), SurfaceY(Top+110), '»ç¿ëÀÚ¿¡°Ô ±Ó¼Ó¸» °¡´É');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+130), '¿ÜÄ¡±â°¡ °¡´ÉÇÏ´Ù');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+150), '¹®ÆÄ¿ø¿¡°Ô¸¸ ¸»ÇÏ±â°¡ °¡´ÉÇÏ´Ù');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+170), 'ÀÚ½Å¿¡°Ô ¿À´Â ±Ó¼Ó¸»À» Â÷´Ü / ÇØÁ¦ °¡´É');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+190), 'ÇØ´ç ¾ÆÀÌµð¿¡°Ô¼­ ¿À´Â ±Ó¼Ó¸»À» Â÷´Ü / ÇØÁ¦ °¡´É');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+210), '¹®ÆÄÀüÀ½À» Â÷´Ü / ÇØÁ¦ °¡´É');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+230), 'Áö³ª°£ ºÎºÐÀÇ ´ëÈ­ º¸±â°¡ °¡´É');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+250), '¿¬ÀÎ ±Ó¼Ó¸»');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+270), '»çÁ¦ Ã¤ÆÃ');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+290), 'È­¸é ÀúÀå');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+310), '·¹º§ 50À» ´Þ¼ºÇÏ½Ã¸é ±âÆÛÁü ½ÃÀÛ / ÁßÁö °¡´É');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+330), '»ç¿îµå Á¶Àý (ÃÖ¼Ò: À½¼Ò°Å °¡´É)');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+350), '¿µ¹°ÀÇ ÁÝ±â¹æ½Ä º¯°æ (ÀÚµ¿/¹ÝÀÚµ¿)');
               Release;
            end;
         end;
         3: begin
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+52), SurfaceY(Top+86), 'Lv');
               TextOut (SurfaceX(Left+250), SurfaceY(Top+86), 'ÄÚ  ÈÝ');
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '4  / 31');
               Release;
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clYellow;
               TextOut (SurfaceX(Left+24), SurfaceY(Top+110), 'Lv 1~10');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+130), 'Lv 11~20');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+150), 'Lv 21~30');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+170), 'Lv 31~40');
               TextOut (SurfaceX(Left+24), SurfaceY(Top+190), 'Lv 41~50');
            end;
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+120), SurfaceY(Top+110), 'ºñÃµÇö, ¿ì¸é½£, ¸ùÃÌÅä¼º, µµ°ü, ±â¸¢¼º ÇÊµåÁö¿ª');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+130), '¹ìÀÇ °è°î ÇÊµåÁö¿ª, ¿À¸¶µ¿±¼, ÀÚ¿¬µ¿±¼, ºñÃµÆó±¤, ¿ì¸é½£ ¹ú·¹µ¿±¼');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+150), 'Àý¸í°î, ¿ì¸¶½ÅÀü, ¹Ì¼®±¤»ê, ¼®°¢¹¦, È¯¸ñ¸²');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+170), '¹Ý¾ß ÇÊµåÁö¿ª, ¹Ý¾ß¼®±¼, ¹Ý¾ßµ¿±¼, ¹Ý¾ß½ÅÀü, Àû¿ù°î');
               TextOut (SurfaceX(Left+120), SurfaceY(Top+190), 'ÁÖ¸¶½ÅÀü, °ú°ÅºñÃµ Áö¿ª');
               Release;
            end;
         end;
         4: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[60];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '5  / 31');
               Release;
            end;
         end;
         5: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[61];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '6  / 31');
               Release;
            end;
         end;
         6: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[62];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '7  / 31');
               Release;
            end;
         end;
         7: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[63];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '8  / 31');
               Release;
            end;
         end;
         8: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[64];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '9  / 31');
               Release;
            end;
         end;
         9: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[65];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '10 / 31');
               Release;
            end;
         end;
         10: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[66];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '11 / 31');
               Release;
            end;
         end;
         11: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[73];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '12 / 31');
               Release;
            end;
         end;
         12: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[74];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '13 / 31');
               Release;
            end;
         end;
         13: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[75];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '14 / 31');
               Release;
            end;
         end;
         14: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[76];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '15 / 31');
               Release;
            end;
         end;
         15: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[77];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '16 / 31');
               Release;
            end;
         end;
         16: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[78];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '17 / 31');
               Release;
            end;
         end;

         17: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[79];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '18 / 31');
               Release;
            end;
         end;

         18: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[80];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '19 / 31');
               Release;
            end;
         end;

         19: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[81];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), '20 / 31');
               Release;
            end;
         end;
         20..25: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[48 + HelpPage];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas  do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), IntToStr(HelpPage + 1) +' / 31');
               Release;
            end;
         end;
         26..31: begin
            bbx := Left + 12;
            bby := Top + 75;
            d := g_WTitleImages.Images[56 + HelpPage];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, TRUE);
            with dsurface.Canvas  do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left+238), SurfaceY(Top+485), IntToStr(HelpPage + 1) +' / 31');
               Release;
            end;
         end;

      end;
      if HelpPage = 0 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+208, Top+46, '1. ¿ì½Ý¼üÐÅÏ¢');
        end;
      end;
      if HelpPage = 1 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+186, Top+46, '2. Òþ²ØµÄ¿ì½Ý¼üÐÅÏ¢');
        end;
      end;
      if HelpPage = 2 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+186, Top+46, '3. ÁÄÌì¿ì½Ý¼üÐÅÏ¢');
        end;
      end;
      if HelpPage = 3 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+178, Top+46, '4. ¹ØÓÚá÷ÁÔ³¡µÄµÈ¼¶');
        end;
      end;
      if HelpPage = 4 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '5. ½Ì³Ì1');
        end;
      end;
      if HelpPage = 5 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '6. ½Ì³Ì2');
        end;
      end;
      if HelpPage = 6 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '7. ½Ì³Ì3');
        end;
      end;
      if HelpPage = 7 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '8. ½Ì³Ì4');
        end;
      end;
      if HelpPage = 8 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '9. ½Ì³Ì5');
        end;
      end;
      if HelpPage = 9 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '10. ½Ì³Ì6');
        end;
      end;
      if HelpPage = 10 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+218, Top+46, '11. ½Ì³Ì7');
        end;
      end;
      if HelpPage = 11 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+188, Top+46, 'ÐÐ»á³É³¤ ½Ì³Ì1');
        end;
      end;
      if HelpPage = 12 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+188, Top+46, 'ÐÐ»á³É³¤ ½Ì³Ì2');
        end;
      end;
      if HelpPage = 13 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+188, Top+46, 'ÐÐ»á³É³¤ ½Ì³Ì3');
        end;
      end;
      if HelpPage = 14 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+206, Top+46, '³èÎï ½Ì³Ì1');
        end;
      end;
      if HelpPage = 15 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+206, Top+46, '³èÎï ½Ì³Ì2');
        end;
      end;
      if HelpPage = 16 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+206, Top+46, '³èÎï ½Ì³Ì3');
        end;
      end;
      if HelpPage = 17 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+210, Top+46, 'ÓÊ¼þÏµÍ³1');
        end;
      end;
      if HelpPage = 18 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+210, Top+46, 'ÓÊ¼þÏµÍ³2');
        end;
      end;
      if HelpPage = 19 then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+210, Top+46, 'ÓÊ¼þÏµÍ³3');
        end;
      end;
      if HelpPage in [20..25] then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+206, Top+46, 'Ó¢ÐÛ½Ì³Ì' + IntToStr(HelpPage - 19));
        end;
      end;
      if HelpPage in [26..31] then begin
        with dsurface.Canvas do begin
          SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
          dsurface.Canvas.Font.Color := clWhite;
          dsurface.Canvas.Font.Size :=11;
          dsurface.Canvas.Font.Style:=[fsBold];
          TextOut (Left+210, Top+46, '¾õÐÑÏµÍ³' + IntToStr(HelpPage - 25));
        end;
      end;
          dsurface.Canvas.Font.Style:=[];
          dsurface.Canvas.Font.Size :=9;
          dsurface.Canvas.Release;
   end;
end;


procedure TFrmDlg.DHelpPrevClick(Sender: TObject; X, Y: Integer);
begin
   Dec (HelpPage);
   if HelpPage < 0 then
      HelpPage := MAXHELPPAGE-1;
end;

procedure TFrmDlg.DHelpNextClick(Sender: TObject; X, Y: Integer);
begin
   Inc (HelpPage);
   if HelpPage > MAXHELPPAGE-1 then
      HelpPage := 0;
end;

//»óÀÎ
procedure TFrmDlg.DShopMenuDlgClick(Sender: TObject; X, Y: Integer);     //»óÀÎ
var
   lx, ly, idx: integer;
   tempi:PTClientGoods;
begin
   DScreen.ClearHint;
   lx := DShopMenuDlg.LocalX (X) - DShopMenuDlg.Left;
   ly := DShopMenuDlg.LocalY (Y) - DShopMenuDlg.Top;
   if (lx >= 28) and (lx <= 235) and (ly >= 30) and (ly <= 200)  then begin
      idx := (ly-29) div NEWLISTLINEHEIGHT + MenuTop;
      if idx < MenuList.Count then begin
         PlaySound (s_glass_button_click);
         MenuIndex := idx;
      if  g_dddtypemode then begin
       g_MouseItem := PTClientItem(g_MenuItemList[idx])^;
      end else begin
       g_MouseItem := G_BuyItem[idx].entItem;
       end;
      end;
   end;

end;

procedure TFrmDlg.DShopMenuDlgDirectPaint(Sender: TObject;   //»óÀÎ
  dsurface: TDirectDrawSurface);
var
   d, e: TDirectDrawSurface;
begin
 with DShopMenuDlg do begin
  d := DShopMenuDlg.WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
       if FrmDlg.BoMakeItemMenu then
         e := g_WTitleImages.Images[42]
       else
         e := g_WTitleImages.Images[459];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left+32), SurfaceY(Top+5), e.ClientRect, e, TRUE);

      if FrmDlg.BoPCItemMenu then begin
        with Dsurface.Canvas do begin
         SetBKMode (dSurface.Canvas.Handle,TRANSPARENT);
         BoldTextOut (dSurface ,SurfaceX(Left + 80) , SurfaceY(Top + 10) , clLime ,clBlack , 'PC POINT: ' + IntToStr(g_MySelf.m_nPCPoint));
         dSurface.Canvas.Release;
        end;
     end;
 end;
end;


procedure TFrmDlg.DShopMenuDlgMouseMove(Sender: TObject;   //»óÀÎ
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DShopMenuScrollUpClick(Sender: TObject; X, Y: Integer);   //»óÀÎ
begin
      if Mensellidx > 0 then Dec (Mensellidx);
      if Mensellidx < 0 then Mensellidx:= 0;
      DShopMenuMove.UpHeightout;
   MenuIndex:= -1
end;

procedure TFrmDlg.DShopMenuScrollDownClick(Sender: TObject; X, Y: Integer);     //»óÀÎ
begin
   if Mensellidx < DShopMenuMove.listcont then
      inc(Mensellidx);
      DShopMenuMove.exitHeightout;

   MenuIndex:= -1
end;

procedure TFrmDlg.DShopMenuOkClick(Sender: TObject; X, Y: Integer);
var
   pg: PTClientGoods;
begin
   if GetTickCount < LastestClickTime then exit;
   if (MenuIndex >= 0) and (MenuIndex < MenuList.Count) then begin
      pg := PTClientGoods (MenuList[MenuIndex]);
      LastestClickTime := GetTickCount + 5000;
      if BoMakeItemMenu then begin       //Á¦Á¶½ºÃÄ
        NameMakeItem := pg.Name;
        FrmMain.SendMakeItemSel (g_nCurMerchant, pg.Name);
        MakeItemDlgShow('');
        exit;
      end;

      if BoPCItemMenu then begin       //Á¦Á¶½ºÃÄ
        FrmMain.SendPBuyItem (g_nCurMerchant, pg.Stock, pg.Amount, pg.Name);
        exit;
      end;

      FrmMain.SendBuyItem (g_nCurMerchant, pg.Stock, pg.Amount, pg.Name)
   end;
end;

procedure TFrmDlg.DShopMenuCloseClick(Sender: TObject; X, Y: Integer);
begin
   DShopMenuDlg.Visible := FALSE;
   FillChar (G_BuyItem, sizeof(SBuyItem)*MAXBUYITEM, #0);
   Menboots := -1;
end;

procedure TFrmDlg.DDcJunsaBuffDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with sender as TDWindow do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemStoreDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DItemStore do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      e := g_WTitleImages.Images[0];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left+38), SurfaceY(Top + 4), e.ClientRect, e, TRUE);
      DStoreGrid.Visible := (m_Storemode = 0);
      DHeroStoreGrid.Visible := (m_Storemode = 1);
      if g_MyHero <> nil then begin
        DStore2.Enabled := True;
      end else begin
        DStore2.Enabled := False;
        m_Storemode := 0;
        DStoreGrid.Visible := True;
        DHeroStoreGrid.Visible := False;
      end;
   end;
end;


procedure TFrmDlg.DStoreGridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx: Integer;
  nWhere: Integer;
  List: TStringList;
begin
  DScreen.ClearHint;
  Idx := ACol + ARow * DStoreGrid.ColCount;
  if Idx in [0..STORAGELIMIT - 1] then begin
    g_MouseItem := g_StoreItem[idx];
    if (g_MouseItem.s.Name <> '') then begin

      nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
      if (nWhere >= 0) then begin

        List := TStringList.Create;
        try
          GetMouseItemHint(g_MySelf, @g_MouseItem);
          List.AddStrings(HintList);

          GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
          if HintList.Count > 0 then begin
            HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];   //¿©°ü
          end;
          with DStoreGrid do
            DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
          HintList.Clear;
        finally
          FreeAndNil(List);
        end;
        g_MouseItem.s.Name := '';
      end else begin
        GetMouseItemHint(g_MySelf, @g_MouseItem);
        with DStoreGrid do
          DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
      end;

    end;
  end else begin
   g_MouseItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DStoreGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
var
   idx,i, ii, ax, ay, nInt: integer;
   d,e: TDirectDrawSurface;
   tempsize:integer;
   ItemEffect:pTItemEffect;
   showstr: String;
begin
   idx := ACol + ARow * DStoreGrid.ColCount;
   if idx in [0..STORAGELIMIT-1] then begin
      if g_StoreItem[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_StoreItem[idx].S.Looks];
         if d <> nil then
          with DStoreGrid do begin
             dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 ){+ ACol},
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ ARow,
                              d.ClientRect,
                              d, TRUE);
            if (g_StoreItem[idx].Amount > 0) and (g_StoreItem[idx].S.StdMode in [0,1,3,45,46]) then begin        //¹°¾à
              nInt := g_StoreItem[idx].Amount;
              with dsurface.Canvas do begin
                SetBKMode(Handle, TRANSPARENT);
                showstr := IntToStr(nInt);
                TextOutA(dsurface, SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 -(TextWidth(showstr) div 2) + 20),
                        SurfaceY(Rect.BottomRight.y + 20), clYellow, showstr);
                Release;
              end;
            end;
            if ((g_StoreItem[idx].Dura div 10) > 0) and (g_StoreItem[idx].S.StdMode in [25]) then begin        //¹°¾à
              nInt := (g_StoreItem[idx].Dura div 10);
              with dsurface.Canvas do begin
                SetBKMode(Handle, TRANSPARENT);
                showstr := IntToStr(nInt);
                TextOutA(dsurface, SurfaceX(Rect.Left -(TextWidth(showstr) div 2) + 20),
                        SurfaceY(Rect.BottomRight.y + 20), clYellow, showstr);
                Release;
              end;
            end;
          end;
      end;
   end;
end;


procedure TFrmDlg.DStoreGridGridSelect(Sender: TObject; X, Y: integer; ACol,  //¿©°ü
  ARow: Integer; Shift: TShiftState);
var
   idx, mj: integer;
   temp: TClientItem;
   keyvalue: TKeyBoardState;
   sData, sData1, sData2:String;
begin
 if g_FishingOk = FALSE then begin
   FillChar(keyvalue, sizeof(TKeyboardState), #0);
   GetKeyboardState (keyvalue);
   idx := ACol + ARow * DStoreGrid.ColCount;
   if idx in [0..STORAGELIMIT-1] then begin
      if not g_boItemMoving then begin
         if g_StoreItem[idx].S.Name <> '' then begin
           if ssCtrl in Shift then begin  //º¸¿Á(±¸ ½Ã½ºÅÛ)
                if not PlayScene.EdChat.Visible then begin
                  PlayScene.EdChat.Visible := True;
                  PlayScene.EdChat.SetFocus;
                end;
                if PlayScene.EdChat.SelStart = Length(PlayScene.EdChat.Text) then begin
                    PlayScene.EdChat.Text := PlayScene.EdChat.Text +  '{' + '2' + '/' + IntToStr(g_StoreItem[Idx].MakeIndex) + '}';
                    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                end else begin
                  sData := Copy(PlayScene.EdChat.Text, 1, PlayScene.EdChat.SelStart);
                  sData1 := Copy(PlayScene.EdChat.Text, PlayScene.EdChat.SelStart + 1, Length(PlayScene.EdChat.Text) - PlayScene.EdChat.SelStart);
                  sData2 := '{' + '2' + '/' + IntToStr(g_StoreItem[Idx].MakeIndex) + '}';
                  PlayScene.EdChat.Text := sData + sData2 + sData1;
                  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text) - Length(WideString(sData1));
                end;
                PlayScene.EdChat.SelLength := 0;
                SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
                exit;
           end;
            g_boItemMoving := TRUE;
            g_MovingItem.Index := idx+500;
            g_MovingItem.Item := g_StoreItem[idx];
            g_MovingItem.Owner := DItemStore;
            g_StoreItem[idx].S.Name := '';
            ItemClickSound (g_StoreItem[idx].S);
            g_boStoreToBag := TRUE;
         end;
      end else begin
        mj := g_MovingItem.Index;

        if (g_MovingItem.Owner = DItemStore) and (g_MovingItem.Index >= 500) and (g_MovingItem.Index < 600) then begin
          if g_StoreItem[idx].S.Name <> '' then begin
            if CheckItemMode(g_MovingItem.Item,g_StoreItem[idx]) then begin    //¹°¾à
              FrmMain.BundleStorageItem(g_MovingItem.Item.S.StdMode,g_StoreItem[idx].S.MaxAmount,inttostr(g_MovingItem.Item.MakeIndex)+'/'+inttostr(g_StoreItem[idx].MakeIndex));
              if ((g_MovingItem.Item.S.StdMode in [0,1,3,45,46,49]) and ((g_MovingItem.Item.Dura + g_StoreItem[idx].Dura) <= g_StoreItem[idx].S.MaxAmount)) then begin
                g_MovingItem.Item.S.Name := '';
              end else begin
                AddItemStore (g_MovingItem.Item);
                g_MovingItem.Item.S.Name := '';
              end;
              g_boItemMoving := FALSE;

            end else begin
              temp := g_StoreItem[idx];
              g_StoreItem[idx] := g_MovingItem.Item;
              g_MovingItem.Index := idx+500;
              g_MovingItem.Item := temp;
              g_MovingItem.Owner := DItemStore;
              exit;
            end;
          end else begin
            g_StoreItem[idx] := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
            g_boBagToStore := FALSE;
            g_boStoreToBag := FALSE;
            g_MovingItem.Owner := nil;
            exit;
          end;
        end;

        if (g_MovingItem.Owner = DItemBag) and (SpotDlgMode = dmStorage) and g_boBagToStore and (m_nStorageMode = 0) then begin
           FrmMain.SendStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 0);
           g_SellDlgItemSellWait := g_MovingItem.Item;
           g_MovingItem.Item.S.name := '';
           g_boItemMoving := FALSE;
           g_boBagToStore := FALSE;
           g_MovingItem.Owner := nil;
           exit;
        end else begin
           if (g_MovingItem.Owner = DItemBag) and (SpotDlgMode = dmStorage) and g_boBagToStore and (m_nStorageMode = 1) then begin
             FrmMain.SendStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 1);
             g_SellDlgItemSellWait := g_MovingItem.Item;
             g_MovingItem.Item.S.name := '';
             g_boItemMoving := FALSE;
             g_boBagToStore := FALSE;
             g_MovingItem.Owner := nil;
             exit;
           end;
        end;
      end;
   end;
   ArrangeItemStore;
 end;
end;

procedure TFrmDlg.DItemStoreCloseClick(Sender: TObject; X, Y: Integer);
begin
   DItemStore.Visible := FALSE;
   DItemBag.Left := 0;
   DItemBag.Top := 0;
   m_nStorageMode := 0;
   m_Storemode := 0;
end;

procedure TFrmDlg.DGDWarClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg2.DGuildMarkDlg.Visible := not FrmDlg2.DGuildMarkDlg.Visible;
end;

procedure TFrmDlg.DGDCancelWarClick(Sender: TObject; X, Y: Integer);
begin
  if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨ÒªÈ¡ÏûÐÐ»áÕ½ÕùÂð£¿', [mbYes, mbNo]) then begin
    SendClientMessage(CM_GUILDSET, 0, 0, 0, 0);  //¹®ÆÄ ¸¶Å© »èÁ¦
  end;
end;

procedure TFrmDlg.DBHomeClick(Sender: TObject; X, Y: Integer);
begin
   if not g_boShowHealth then begin
     DScreen.AddChatBoardString('<¿ªÆôÉúÃüÖµÊý×ÖÆ®Ñª>',clGreen,clWhite);
   end else
     DScreen.AddChatBoardString('<¹Ø±ÕÉúÃüÖµÊý×ÖÆ®Ñª>',clGreen,clWhite);
  g_boShowHealth := not g_boShowHealth;
end;

procedure TFrmDlg.DBStorageClick(Sender: TObject; X, Y: Integer);  //»ý·Ö¿ª¹Ø°´¼ü
begin
 if (g_nBonusPoint > 0) {and (DAdjustAbility.Visible = False)} then begin
   OpenAdjustAbility;
 end;

end;

procedure TFrmDlg.DBAuctionClick(Sender: TObject; X, Y: Integer);   //ÒÆ¶¯Î¯ÍÐ
var
  Msg, sData: String;
begin
  if g_FishingOk = FALSE then begin
    if GetTickCount > g_dwQueryMsgTick then begin
      if (FrmDlg.DDealDlg.Visible = False) and (FrmDlg.DDRentalDlg.Visible = False) then begin
        Msg:='ÄãÈ·¶¨ÒªÊ¹ÓÃ¼ÄÊÛÏµÍ³Âð£¿';
        sData := '';
        if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
          g_dwQueryMsgTick := GetTickCount + 1000;
          sData := sData + IntToStr(0) + ':' + IntToStr(1) + ':' + IntToStr(0) + ':' + '';
          SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId , 0, 0, 0, sData);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBScreenClick(Sender: TObject; X, Y: Integer);     //¸¸¹°»óÀÎ
begin
   if not g_boShowGreenHint then begin
     DScreen.AddChatBoardString('<¿ªÆôÆÁÄ»ÏÔÊ¾ÌáÊ¾>',clGreen,clWhite);
   end else
     DScreen.AddChatBoardString('<¹Ø±ÕÆÁÄ»ÏÔÊ¾ÌáÊ¾>',clGreen,clWhite);
   g_boShowGreenHint := not g_boShowGreenHint;
end;

procedure TFrmDlg.DDealMsgDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Deal: String ;
begin
   with DDealMsgDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         Deal := '½»Ò×';
         TextOut (SurfaceX(Left + 4 + (TextWidth(Deal)) div 2), SurfaceY(Top+5), Deal);
         Release;
      end;
   end;
end;

procedure TFrmDlg.DBotTigerClick(Sender: TObject; X, Y: Integer);     //È£¶ûÀÌ ¹öÆ° Å¬¸¯
begin
   if g_UseItems[U_TIGER].S.Name <> '' then
   ToggleShowTigerDlg
   else DScreen.AddChatBoardString ('Äã±ØÐë×°±¸×øÆï²ÅÄÜÊ¹ÓÃ¡£',ClRed,ClWhite);
end;

procedure TFrmDlg.DTigerDirectPaint(Sender: TObject;   //È£¶ûÀÌ
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;

      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DTigerDlgDirectPaint(Sender: TObject;   //È£¶ûÀÌ Ã¢
  dsurface: TDirectDrawSurface);
   function GetDuraStr (dura, maxdura: integer): string;
   begin
      Result := IntToStr(Round(dura/1000)) + '/' + IntToStr(Round(maxdura/1000))
   end;
var
   d, e: TDirectDrawSurface;
   lx, ly, n: integer;
   idx,zx,zy,xxy,ax,ay: integer;
   output:String;
begin
   if g_Myself = nil then exit;
   with DTigerDlg do begin
   if g_UseItems[U_TIGER].S.StdMode = 102 then begin
      d := WLib.Images[FaceIndex];

       zx := 10;
       zy := 70;
       xxy:=175;
   DTigerDlgClose.Left := 297;
   DTigerDlgClose.Top := 3;

   DTigerDlgSet.Left := 254;
   DTigerDlgSet.Top := 70;

   DSPETS5.Visible := True;

   DSPETS1.Left := 37;
   DSPETS1.Top  := 324;

   DSPETS2.Left := 91;
   DSPETS2.Top  := 324;

   DSPETS3.Left := 145;
   DSPETS3.Top  := 324;

   DSPETS4.Left := 199;
   DSPETS4.Top  := 324;

   DSPETS5.Left := 253;
   DSPETS5.Top  := 324;

   end else begin
      d := WLib.Images[160];
      DTigerDlgClose.Left := 246;
      DTigerDlgClose.Top := 3;
       zx := 100;
       zy := 240;
       xxy:=136;
       DSPETS1.Left := 37;
       DSPETS1.Top  := 324;
       DSPETS2.Left := 91;
       DSPETS2.Top  := 324;
       DSPETS3.Left := 145;
       DSPETS3.Top  := 324;
       DSPETS4.Left := 199;
       DSPETS4.Top  := 324;
       DSPETS5.Visible := FALSE;
     //  DSPETS5.Left := 204;
     //  DSPETS5.Top  := 274;
     end;
     if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);


      if GetTickCount - m_Time >= 120 then begin
         m_Time := GetTickCount;
         Inc(m_nCurFrame);
      end;

      if m_nCurFrame >= m_nMaxFrame then begin
         m_nCurFrame := m_nMaxFrame;
         m_nCurFrame := 0;
      end;
      if g_UseItems[U_TIGER].S.StdMode = 101 then begin
      e := g_WMainImages.Images[1170 + g_UseItems[U_TIGER].S.Shape*20 + m_nCurFrame];
      if e <> nil then
       dSurface.Draw (SurfaceX(Left+25), SurfaceY(Top+150), e, TRUE);
      end else begin
      if g_UseItems[U_TIGER].S.StdMode = 102 then begin
      e := g_WMainImages.Images[1470 + g_UseItems[U_TIGER].S.Shape*20 + m_nCurFrame];
      if e <> nil then
        dSurface.Draw (SurfaceX(Left+7), SurfaceY(Top+95), e, TRUE);
      end;
      end;


      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := ClWhite;
         if g_UseItems[U_TIGER].S.StdMode = 101 then begin
            TextOut (SurfaceX(Left + 134 - TextWidth(g_UseItems[U_TIGER].S.Name) div 2 ), SurfaceY(Top + 12), g_UseItems[U_TIGER].S.Name);
         end else
         if g_UseItems[U_TIGER].S.StdMode = 102 then begin
           TextOut (SurfaceX(Left + 159 - TextWidth(g_UseItems[U_TIGER].S.Name) div 2 ), SurfaceY(Top + 12), g_UseItems[U_TIGER].S.Name);
         end;

         output := 'ÖÒ³Ï¶È ' + GetDuraStr(g_UseItems[U_TIGER].Dura,g_UseItems[U_TIGER].DuraMax);
         if g_UseItems[U_TIGER].S.StdMode = 101 then begin
           TextOut (SurfaceX(Left + 134 - TextWidth(output) div 2), SurfaceY(Top + 36), output);
         end else
         if g_UseItems[U_TIGER].S.StdMode = 102 then begin
           TextOut (SurfaceX(Left + 159 - TextWidth(output) div 2), SurfaceY(Top + 36), output);
         end;
         Release;
      end;
   end;
end;

procedure TFrmDlg.DTigerDlgCloseClick(Sender: TObject; X, Y: Integer);      //È£¶ûÀÌ Ã¢ ´Ý±â
begin
   DTigerDlgClose.SetImgIndex (g_WMain2Images, 360);     //È£¶ûÀÌÃ¢
   DTigerDlg.Visible := FALSE;
end;

procedure TFrmDlg.DTigerDlgSetClick(Sender: TObject; X, Y: Integer);
begin
 if GetTickCount - g_dwLastMoveTick > 1000 then begin     //ÀÌµ¿Áß¿¡ Å»°Í Å» ¼ö ¾øÀ½
   if (GetTickCount > g_dwChangeTigerSetTick) and (g_FishingOk = False) then begin
     if g_UseItems[U_TIGER].Dura > 0 then begin
      if (g_UseItems[U_PETS3].S.Name <> '') and (g_UseItems[U_PETS3].Dura > 0) then begin   //¾ÈÀå Âø¿ë
      if not (g_MySelf.m_nState and $00004000 <> 0) and not (g_MySelf.m_nState and $00000080 <> 0) then begin     //¿ù¿µ¼ú ¿ù¿µ¹«
        g_TigerSet := not g_TigerSet;
        g_dwChangeTigerSetTick := GetTickCount + 3000; //3ÃÊ µô·¹ÀÌ
        FrmMain.SendTigerSet (g_TigerSet);
        if g_TigerSet then
        if g_UseItems[U_TIGER].S.StdMode = 101 Then
         PlaySound2(s_TigerSet1)
        else
         PlaySound2(s_TigerSet2);
      end else
      end else begin
      SendClientMessage(CM_TIGERSET, 0, 0, 0, 0);
      DScreen.AddChatBoardString ('Äã±ØÐë×°±¸°°¾ß²ÅÄÜÊ¹ÓÃ¡£',ClRed,ClWhite);
      end;
     end else begin
     SendClientMessage(CM_TIGERSET, 0, 0, 0, 0);
     DScreen.AddChatBoardString ('×øÆïµÄÖÒ³Ï¶ÈÌ«µÍÁË¡£',ClRed,ClWhite);
     end;
   end;
 end;
end;

procedure TFrmDlg.ToggleShowTigerDlg;   //È£¶ûÀÌ
begin
   DTigerDlg.Visible := not DTigerDlg.Visible;
end;

procedure TFrmDlg.DTigerDlgSetDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx:Integer;
begin
  with DTigerDlgSet do begin
    if  (g_UseItems[U_TIGER].S.StdMode = 102) then begin
     idx:= 155;
     DTigerDlgSet.Left := 254;
     DTigerDlgSet.Top := 70;
    end else begin
     idx:= 164;
     DTigerDlgSet.Left := 197;
     DTigerDlgSet.Top := 70;
    end;
    if Downed then begin
      d := g_WMainImages.Images[idx + 2];
    end else
    if MouseMoveing then begin
      d := g_WMainImages.Images[idx + 1];
    end else begin
      d := g_WMainImages.Images[idx];
    end;
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;







procedure TFrmDlg.DMasterWindowDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e: TDirectDrawSurface;
   lx, ly: integer;
begin
   with (Sender as TDWindow) do begin
      if fMentor.GetEnable(RsState_Master) = 1 then
         DMasterAllow.SetImgIndex(g_WMainImages, 117)
      else
         DMasterAllow.SetImgIndex(g_WMainImages, 114);

      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      e := g_WTitleImages.Images[51];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left + 29), SurfaceY(Top + 5), e.ClientRect, e, TRUE);


      dsurface.Canvas.Font.Color  := clWhite;
      dsurface.Canvas.Brush.Color := clBlack;
      dsurface.Canvas.Brush.Style := bsClear;

      lx := SurfaceX(26) + Left;
      ly := SurfaceY(33) + Top + (1 * 15);
      dsurface.Canvas.TextOut(lx, ly, 'Ê¦¸µ');
      ly := SurfaceY(39) + Top + (2 * 15);

       dsurface.Canvas.TextOut(lx - 6, ly, fMentor.GetDisplay(0));
       dsurface.Canvas.TextOut(lx + 90, ly, fMentor.GetDisplay(2));


      ly := SurfaceY(26) + Top + (5 * 15);
      dsurface.Canvas.TextOut(lx, ly, 'Í½µÜ');
      ly := SurfaceY(32) + Top + (6 * 15);
       dsurface.Canvas.TextOut(lx - 6, ly, fMentor.GetDisplay(1));
       dsurface.Canvas.TextOut(lx + 90, ly, fMentor.GetDisplay(3));
      dsurface.Canvas.Release;

   end;
end;

procedure TFrmDlg.DBotMasterClick(Sender: TObject; X, Y: Integer);    //»çÁ¦
begin
   ToggleShowMasterDlg;
end;

procedure TFrmDlg.DMasterWindowMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg: String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);
  if Sender = DMasterAllow then begin
  if fMentor.GetEnable(RsState_Master) = 1 then
    sMsg := 'ÔÊÐí°ÝÊ¦'
  else
    sMsg := '¾Ü¾ø°ÝÊ¦';
  end;

  if Sender = DMasterMentor then sMsg:= '¼ÓÈëÊ¦ÃÅ'
  else if Sender = DMasterSecession then sMsg:= 'ÍÑÀëÊ¦ÃÅ';

  nLocalX:=Butt.LocalX(X - Butt.Left);
  nLocalY:=Butt.LocalY(Y - Butt.Top);
  nHintX:=Butt.SurfaceX(Butt.Left) + DMasterDlg.SurfaceX(DMasterDlg.Left) + nLocalX;
  nHintY:=Butt.SurfaceY(Butt.Top) + DMasterDlg.SurfaceY(DMasterDlg.Top) + nLocalY;
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DMasterExitClick(Sender: TObject; X, Y: Integer);
begin
  ToggleShowMasterDlg;
end;


procedure TFrmDlg.DMasterAvailableDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if not Downed then
        d := WLib.Images[FaceIndex]
      else
        d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DMasterDivorceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DMasterAllowClick(Sender: TObject; X, Y: Integer);
var
  sendenable: integer;
begin
  if fMentor.GetEnable(RsState_Master) = 1 then
    sendenable := 0
  else
    sendenable := 1;

  FrmMain.SendLMOptionChange(2, sendenable);
end;

procedure TFrmDlg.DMentorClick(Sender: TObject; X, Y: Integer);
var
  sMasterAdd: String;
begin
  FrmDlg.DlgEditText := '';
  FrmDlg.DMessageDlg ('ÄãÕýÔÚ½øÐÐ°ÝÊ¦¡£\ÇëÊäÈëÄãÏë°ÝÊ¦µÄ½ÇÉ«Ãû×Ö...', [mbOk, mbAbort]);
  sMasterAdd := Trim(FrmDlg.DlgEditText);

  if sMasterAdd <> '' then begin
    FrmMain.SendMERequest(RsState_Master, RsReq_WantToJoinOther, 0, sMasterAdd);
  end;
end;

procedure TFrmDlg.DMasterSecessionClick(Sender: TObject; X, Y: Integer);
var
  Name: string;
begin
  Name := fMentor.GetName(RsState_Master);
  if Name <> '' then begin
    if mrYes = FrmDlg.DMessageDlg('ÄãÈ·¶¨Òª½â³ýÊ¦Í½¹ØÏµÂð£¿\½â³ýÊ¦Í½¹ØÏµºó3ÌìÄÚ²»ÄÜ½øÐÐ°ÝÊ¦¡£',
            [mbYes, mbNo]) then
      FrmMain.SendMESeparate(RsState_Master, Name);
  end else begin
    if mrYes = DMessageDlg('ÄãÃÇ²»ÊÇÊ¦Í½¹ØÏµ¡£', [mbYes]) then
    Exit;
  end;
end;

procedure TFrmDlg.DMasterAllowDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
        if Downed then begin
         d := WLib.Images[FaceIndex + 2];
        end else
        if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
        end else
         d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;


procedure TFrmDlg.DLoverHeartDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DLoverHeart do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DHeartMyStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DHeartMyState do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DBReady2Click(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  if g_FishingOk = FALSE then begin
    if GetTickCount > g_dwQueryMsgTick then begin
      if (FrmDlg.DDealDlg.Visible = False) and (FrmDlg.DDRentalDlg.Visible = False) then begin
        Msg:='ÄãÏëÊ¹ÓÃÄãµÄ¸öÈËÉÌµêÂð£¿';
        if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
          g_dwQueryMsgTick := GetTickCount + 1000;
          OpenStoreDlg;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBReady3Click(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  if g_FishingOk = FALSE then begin
    if GetTickCount > g_dwQueryMsgTick then begin
      if (not FrmDlg.DDealDlg.Visible) and (not FrmDlg.DDRentalDlg.Visible) then begin
        g_dwQueryMsgTick := GetTickCount + 1000;
        FrmMain.SendSay ('@»óÁ¡¿ÜÄ¡±âÂ÷´Ü');
      end;
    end;
  end;
end;

procedure TFrmDlg.DBReady4Click(Sender: TObject; X, Y: Integer);    //¹®ÆÄ ¸¶Å© ¸ðµå
var
  Msg: String;
begin
   if g_boMarkMode < 2 then begin
    Inc(g_boMarkMode);
   end else
   g_boMarkMode := 0;

end;




procedure TFrmDlg.DTigerDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
Var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);
  if Sender = DTigerDlgSet then sMsg:= 'Ê¹ÓÃ ¿Õ¸ñ¼ü ¼üÉÏÏÂ×øÆï¡£';

  nLocalX:=Butt.LocalX(X - Butt.Left);
  nLocalY:=Butt.LocalY(Y - Butt.Top);
  nHintX:=Butt.SurfaceX(Butt.Left) + DTigerDlg.SurfaceX(DTigerDlg.Left) + nLocalX;
  nHintY:=Butt.SurfaceY(Butt.Top) + DTigerDlg.SurfaceY(DTigerDlg.Top) + nLocalY;
  DScreen.ShowHintA(nHintX,nHintY,sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DUpWapondowDirectPaint(Sender: TObject;  //Àç·Ã
  dsurface: TDirectDrawSurface);
var
   d, e: TDirectDrawSurface;
begin
  if g_MySelf = nil then exit;
   with DUpWapondow do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      e := g_WTitleImages.Images[18];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left + 30), SurfaceY(Top + 5), e.ClientRect, e, TRUE);
   end;
end;


procedure TFrmDlg.DPrevStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DBUpWaponOKClick(Sender: TObject; X, Y: Integer);   //Àç·Ã
var
 i:integer;
 itemidx:string;
 Upteim:TUpwaiItem;
begin
  itemidx := '';
  for i := 0 to 15 do begin
    if G_UpWaponItem[i].S.Name <> '' then begin
     Upteim.Names := G_UpWaponItem[i].S.Name;
     Upteim.ItemID :=G_UpWaponItem[i].MakeIndex;
     itemidx := itemidx + EncodeBuffer(@Upteim,SizeOf(TUpwaiItem))+ '/' + g_UpWapon.S.Name + '/';
    end;
  end;
  if itemidx <> '' then begin
      FrmMain.GotoUpwaoinItem(g_nCurMerchant,g_UpWapon.MakeIndex,itemidx);
      DUpWapondow.Visible := False;
      DUpWeapon.Visible := False;
      g_UpWapon.S.Name := '';
      g_UpWapon.MakeIndex := 0;
  end;
end;

procedure TFrmDlg.DBUpWaponexitClick(Sender: TObject; X, Y: Integer);  //Àç·Ã
begin
  DUpWapondow.Visible := False;
  DUpWeapon.Visible := False;
  CloseDUpWapon;
end;

procedure TFrmDlg.DUpWapItemgridGridPaint(Sender: TObject; ACol,      //Àç·Ã
  ARow: Integer; Rect: TRect; State: TGridDrawState;
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
   idx := ACol + ARow * DUpWapItemgrid.ColCount;
   if idx in [0..15] then begin
      if G_UpWaponItem[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[G_UpWaponItem[idx].S.Looks];
         if d <> nil then
          with DUpWapItemgrid do begin
            dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1)+ACol,
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1)+ARow,
                              d.ClientRect,
                              d, TRUE);
          end;
      end;
   end;
end;

procedure TFrmDlg.DUpWapItemgridGridSelect(Sender: TObject; X, Y: integer; ACol,   //Àç·Ã
  ARow: Integer; Shift: TShiftState);
var
   idx,mi: integer;
   temp: TClientItem;
begin
    idx := ACol + ARow * DUpWapItemgrid.ColCount;
      if not g_boItemMoving then begin
         if idx in [0..15] then
            if G_UpWaponItem[idx].S.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := idx+600;
               g_MovingItem.Item := G_UpWaponItem[idx];
               G_UpWaponItem[idx].S.Name := '';
               g_MovingItem.Owner := DUpWapondow;
               ItemClickSound (g_MovingItem.Item.S);
               Exit;
            end;
      end else begin
        mi := g_MovingItem.Index;
        if (g_MovingItem.Owner = DHeroItemBag) or (g_MovingItem.Owner = DStateWin) or (g_MovingItem.Owner = DHeroStateWin) then Exit;
          if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DUpWapondow) then begin
            if CheckUpwaionmode(g_MovingItem.Item.S.StdMode) then begin
              if not g_MovingItem.Item.S.NonStuff then begin
                if (g_MovingItem.Item.S.btValue[19] = 0) then begin  //±â°£Á¦ ´ë¿©¹«±â Á¦·Ãx
                  if G_UpWaponItem[idx].S.Name <> '' then begin
                    temp := G_UpWaponItem[idx];
                    G_UpWaponItem[idx] := g_MovingItem.Item;
                    g_MovingItem.Index := idx+600;
                    g_MovingItem.Item := temp;
                    g_MovingItem.Owner := DUpWapondow;
                    exit;
                  end else begin
                    G_UpWaponItem[idx] := g_MovingItem.Item;
                    g_MovingItem.Item.S.name := '';
                    g_boItemMoving := FALSE;
                    g_MovingItem.Owner := nil;
                    exit;
                  end;
                end else begin
                 CancelItemMoving;
                 DMessageDlg ('²»ÄÜÊ¹ÓÃ²ÄÁÏ¡£',[mbOk]);
                end;
              end else begin
                CancelItemMoving;
                DMessageDlg ('Ëü²»ÊÇ²ÄÁÏ¡£',[mbOk]);
              end;
            end;
          end;
      end;
end;

procedure TFrmDlg.DUpWapItemgridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx: integer;
   nLocalX,nLocalY:Integer;
   nHintX,nHintY:Integer;
begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
   idx := ACol + ARow * DUpWapItemgrid.ColCount;
   if idx in [0..15] then begin
     g_MouseItem := G_UpWaponItem[idx];
     GetMouseItemHint(g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
       with DUpWapItemgrid do
       DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, FALSE);
     end;
   end;
   if g_MouseItem.S.Name = '' then DScreen.ClearHint;
end;

procedure TFrmDlg.DBotGoldClick(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
   Msg:='ÄãÏë¶Ò»»½ð±ÒÂð£¿';
   if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin

    g_nExChgGoldRate:=0;
    g_nExChgGameGoldRate:=0;

    SendClientMessage(CM_EXCHGAMERATE, 0, 0, 0, 0);  //½Ã¼¼ ¿äÃ»

    g_nExChangeGold := 0;
    g_nExChangeGameGold := 0;
    ExChangePage:=0;
    ExChangePageChanged;
    DExChangeDlg.Visible := True;
    DItemShopCloseClick (DItemShopClose, 0, 0);
   end;
end;

procedure TFrmDlg.DBotRankClick(Sender: TObject; X, Y: Integer);   //·©Å·
begin
   FrmDlg2.DWindowTop.Visible := not FrmDlg2.DWindowTop.Visible;
   FrmDlg2.DWindowTopVisible;
end;


procedure TFrmDlg.DPrevSortDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDButton;
  dd: TDirectDrawSurface;
begin
  if Sender is TDButton then begin
    d := TDButton(Sender);
    if d.Downed then begin
      dd := d.WLib.Images[d.FaceIndex + 1];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end else begin
      dd := d.WLib.Images[d.FaceIndex];
      if dd <> nil then
        dsurface.Draw(d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, True);
    end;
  end;
end;



procedure TFrmDlg.DSalesMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nHintX,nHintY:Integer;
  nWhere: Integer;
  List: TStringList;
begin
  with Sender as TDWindow do begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
   if (((X<(128+DSales.Left)) OR (X>(480+DSales.Left))) OR
     ((Y<(82+DSales.Top)) OR (Y>(412+DSales.Top)))) then exit;
     g_AucIndex := (Y-(82+DSales.Top)) div 33;
   if g_AuctionItems[g_AucIndex].StartTime <> 0 then
   if g_AucIndex in [0..9] then begin
     g_MouseItem := g_AuctionItems[g_AucIndex].Item;
     if g_MouseItem.S.Name <> '' then begin
       nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
       if (nWhere >= 0) then begin
         List := TStringList.Create;
         try
           GetMouseItemHint(g_MySelf, @g_MouseItem);
           List.AddStrings(HintList);

           GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
           if HintList.Count > 0 then begin
             HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];      //°¡¹æ
           end;
           if HintList.Count > 0 then begin
             nHintX := SurfaceX(Left) + DParent.SurfaceX(DParent.Left) + LocalX(X - Left);
             nHintY := SurfaceY(Top) + DParent.SurfaceY(DParent.Top) + LocalY(Y - Top) + 30;
             DScreen.ShowHintk(nHintX, nHintY, List, HintList, False);
           end;
           HintList.Clear;
         finally
           FreeAndNil(List);
         end;
         g_MouseItem.s.Name := '';
       end else begin
        GetMouseItemHint(g_MySelf, @g_MouseItem);
        if HintList.Count > 0 then begin
          nHintX := SurfaceX(Left) + DParent.SurfaceX(DParent.Left) + LocalX(X - Left);
          nHintY := SurfaceY(Top) + DParent.SurfaceY(DParent.Top) + LocalY(Y - Top) + 30;
          DScreen.ShowHintS(nHintX, nHintY, HintList, FALSE);
        end;
       end;
     end;
   end else begin
     g_MouseItem.S.Name := '';
   end;
  end;
end;

procedure TFrmDlg.DBotReady2Click(Sender: TObject; X, Y: Integer);
begin
  if (g_UseItems[U_WEAPON].S.Name <> '') and (g_UseItems[U_WEAPON].S.Shape in [47,48]) then begin
    DFishDlg.Visible := not DFishDlg.Visible;
  end else begin
    DScreen.AddChatBoardString ('Äã±ØÐë°²×°µö¾ß²ÅÄÜÊ¹ÓÃ¡£',ClRed,ClWhite);
  end;
end;

procedure TFrmDlg.DBotQuestClick(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  if g_FishingOk = FALSE then begin
    if GetTickCount > g_dwQueryMsgTick then begin
      if (FrmDlg.DDealDlg.Visible = False) and (FrmDlg.DDRentalDlg.Visible = False) then begin
        Msg:='ÄãÈ·¶¨Òª²é¿´ÈÎÎñÄÚÈÝÂð£¿';
        if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
          g_dwQueryMsgTick := GetTickCount + 1000;
          FrmMain.SendSay ('@ÈÎÎñ');
        end;
      end;
    end;
  end;

end;


procedure TFrmDlg.DBnpcupClick(Sender: TObject; X, Y: Integer);
begin
  DMovenpcbot.inidx := Npcoutindex;
  if Sender = DBnpcup then begin
    if Npcoutindex > 0 then begin
      dec(Npcoutindex);
      ChackMsgstrMond;
      stringtolists(MDlgStr,'\',Npcoutindex,8,NewstrmD);
      RequireAddPoints := TRUE;
    end;
    DMovenpcbot.UpHeightout;
  end else begin
    if Npcoutindex < DMovenpcbot.listcont then begin
      Inc(Npcoutindex);
      ChackMsgstrMond;
      stringtolists(MDlgStr,'\',Npcoutindex,8,NewstrmD);
      RequireAddPoints := TRUE;
    end;
    DMovenpcbot.exitHeightout;
  end;

end;

procedure TFrmDlg.ChackMsgstrMond;
var
  i:Integer;
begin
   if MDlgPoints.Count > 0 then begin
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (PTClickPoint (MDlgPoints[i]));
      MDlgPoints.Clear;
   end;
   if MDlgsier.Count > 0 then begin
   for i:=0 to MDlgsier.Count-1 do
      Dispose (PTClickPoint (MDlgsier[i]));
      MDlgsier.Clear;
   end;
end;


procedure TFrmDlg.ShowCreateHeroNew;
begin
   FillChar(HeroArr, SizeOf(TSelHero) * 4, #0);
   if Not FrmDlg2.DCreateHero.Visible then begin
     HeroIndex := 0;
     HeroArr[HeroIndex].Valid := True;
     HeroArr[HeroIndex].UserChr.job := 5;
     SelHeroNewJob(HeroIndex);
     SelHeroNewm_btSex(HeroIndex);
     FrmDlg2.DCreateHero.Left := (g_FScreenWidth - FrmDlg2.DCreateHero.Width) div 2;
     FrmDlg2.DCreateHero.Top := 20;
     FrmDlg2.DCreateHero.Visible := True;
     EdHeroName.Left := FrmDlg2.DCreateHero.Left + 382;
     EdHeroName.Top  := FrmDlg2.DCreateHero.Top + 275;
     EdHeroName.Visible := True;
     EdHeroName.Text := '';
     EdHeroName.SetFocus;
   end;
end;


procedure TFrmDlg.CloseCreateHero;
begin
   if FrmDlg2.DCreateHero.Visible then begin
     HeroArr[HeroIndex].Valid := False;
     FrmDlg2.DCreateHero.Visible := False;
     HeroArr[HeroIndex].UserChr.job := 5;
     HeroArr[HeroIndex].AniIndex := 0;
     HeroArr[HeroIndex].StartTime := 0;
     EdHeroName.Visible := False;
     HeroArr[HeroIndex].Selected := False;
     FillChar(HeroArr, SizeOf(TSelHero) * 4, #0);

     SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
     LocalLanguage := imSAlpha;
   end;
end;


procedure TFrmDlg.CreateHeroOk;
var
  chrname, shair, sjob, ssex: string;
begin
  chrname := Trim(EdHeroName.Text);
  if HeroArr[HeroIndex].UserChr.job in [4, 5] then begin
    FrmDlg.DMessageDlg ('¶Ô²»Æð£¬ÏÖÔÚ¹­ÊÖºÍºÍÉÐÖ°ÒµÕýÔÚ¸üÐÂµ±ÖÐ¡£', [mbOk]);
  end else begin
    if chrname <> '' then begin
      shair := IntToStr(1 + Random(5));
      sjob := IntToStr(HeroArr[HeroIndex].UserChr.job);
      ssex := IntToStr(HeroArr[HeroIndex].UserChr.sex);
      frmMain.SendNewHero(g_nCurMerchant, chrname, shair, sjob, ssex);
      CloseCreateHero;

      SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
      LocalLanguage := imSAlpha;
    end;
  end;
end;

procedure TFrmDlg.DButBagMode1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DButBagMode1 then BagPage := 0;
 // if Sender = DBagmode2 then BagPage := 1;
end;

procedure TFrmDlg.DButBagMode1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Tag=BagPage then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
    end;
   end;
end;




procedure TFrmDlg.DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
 pm: pTClientMagic;
 idx: Integer;
 nHintX, nHintY: Integer;
 MagItem:nMagicType;
 Butt :TDButton;
begin
   with Sender as TDButton do begin
    Butt := TDButton(Sender);
    idx := _MAX(tag + MagicPage * 6, 0);
    nHintX:=Butt.SurfaceX(Butt.Left) ;
    nHintY:=Butt.SurfaceY(Butt.Top) + 3;
      if idx < g_MagicList.count then begin
         pm := pTClientMagic(g_MagicList[idx]);
         g_MagicItem := PM;
         GetMouseMagicInfo(MagItem);   //¹«°øÁ¤º¸
         if MagItem.MagicStr[0] <> '' then begin
           DScreen.MagicShowHint(nHintX, nHintY, MagItem, clYellow, FALSE, True);
         end;
      end;
      g_MagicItem := nil;
   end;
end;

procedure TFrmDlg.DNewAccountOkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex + 2];
      end else
      if d.MouseMoveing then begin
         dd := d.WLib.Images[d.FaceIndex + 1];
      end else begin
        dd := d.WLib.Images[d.FaceIndex];
      end;

      if dd <> nil then
        dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);

   end;
end;

procedure TFrmDlg.DChgPwDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   i: integer;
begin
   with dsurface.Canvas do begin
      with DChgPw do begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;
end;



procedure TFrmDlg.DBackgroundDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, YSize:integer;
  Time:String;
  Aucbuff : pTAucbuffItem; //°æ¸Å
  MagItem:nMagicType;
begin
    for I := 0 to g_AucList.Count - 1 do begin    //°æ¸Å
      Aucbuff := pTAucbuffItem(g_AucList.Items[I]);
      if (Aucbuff <> nil) and AuctionView then begin
        if DSkillBar.Visible then YSize := 25
        else YSize := 0;
        Time := format('%d·Ö %dÃë', [(Aucbuff.nTime - GetTickCount) Div 60000, ((Aucbuff.nTime - GetTickCount) Div 1000) Mod 60]);
        if (g_nMouseX >= 10 + (i*45)) and (g_nMouseX <= 40 + (i*45)) and (g_nMouseY >= 9 + YSize) and (g_nMouseY <= 44 + YSize) then begin    //°æ¸ÅÀ§Ä¡
           MagItem.MagicStr[0] := 'ÎïÆ·: ' + Aucbuff.str;
           MagItem.StrColor[0] := clWhite;
           if Aucbuff.APrice = 0 then begin
             MagItem.MagicStr[1] := 'µ±Ç°¼Û¸ñ: ' + GetGoldStr(Aucbuff.Price) + '½ð±Ò';
             MagItem.StrColor[1] := clSkyBlue;
           end else begin
             MagItem.MagicStr[1] := 'µ±Ç°¼Û¸ñ: ' + GetGoldStr(Aucbuff.APrice) + '½ð±Ò';
             MagItem.StrColor[1] := clSkyBlue;
           end;
           MagItem.MagicStr[2] := 'Ê£ÓàÊ±¼ä: ' + Time;
           MagItem.StrColor[2] := clYellow;
           DScreen.MagicShowHint(g_nMouseX + 4, g_nMouseY + 4, MagItem, clYellow , FALSE, FALSE);
        end else
      end;
    end;

end;

procedure TFrmDlg.DMovenpcbotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DMovenpcbot do begin
    if Downed then begin
     d := WLib.Images[FaceIndex + 1]
    end else
    if ((GetTickCount - AppendTick) mod 400 < 200) and (listcont > 0) then begin
      d := WLib.Images[FaceIndex + 1];
    end else
      d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMovenpcbotMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  if Npcoutindex <> DMovenpcbot.outidx then begin
   Npcoutindex:=DMovenpcbot.outidx;
   ChackMsgstrMond;
   stringtolists(MDlgStr,'\',Npcoutindex,8,NewstrmD);
   RequireAddPoints := TRUE;
 end;
end;

procedure TFrmDlg.DShopMenuMoveDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DShopMenuMove do begin
    if Downed then begin
     d := WLib.Images[FaceIndex + 1]
    end else
    if ((GetTickCount - AppendTick) mod 400 < 200) and (listcont > 0) then begin
      d := WLib.Images[FaceIndex + 1];
    end else
      d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DMacrosDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, e: TDirectDrawSurface;
  Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8:String;
begin
  d := g_WMainImages.Images[210];
  if d <> nil then begin
    dsurface.Draw(DMacros.Left,DMacros.Top,d,True);
    e := g_WTitleImages.Images[53];
      if e <> nil then
       dsurface.Draw(DMacros.Left + 28, DMacros.Top + 6, e, True);
        with dsurface.Canvas do begin
           SetBkMode (Handle, TRANSPARENT);
           Font.Size := 9;
           Font.Style := [fsBold];
           Font.Color := clWhite;
           Key1 := 'Alt+F1';
           Key2 := 'Alt+F2';
           Key3 := 'Alt+F3';
           Key4 := 'Alt+F4';
           Key5 := 'Alt+F5';
           Key6 := 'Alt+F6';
           Key7 := 'Alt+F7';
           Key8 := 'Alt+F8';
           TextOut ((DMacros.Left + 28), (DMacros.Top+57), Key1);
           TextOut ((DMacros.Left + 28), (DMacros.Top+83), Key2);
           TextOut ((DMacros.Left + 28), (DMacros.Top+110), Key3);
           TextOut ((DMacros.Left + 28), (DMacros.Top+136), Key4);
           TextOut ((DMacros.Left + 28), (DMacros.Top+162), Key5);
           TextOut ((DMacros.Left + 28), (DMacros.Top+188), Key6);
           TextOut ((DMacros.Left + 28), (DMacros.Top+214), Key7);
           TextOut ((DMacros.Left + 28), (DMacros.Top+241), Key8);
           Font.Style := [];
           Font.Size := 9;
           Release;
        end;
  end;

  SetImeMode (EdMacro1.Handle, imSHanguel);
  SetImeMode (EdMacro2.Handle, imSHanguel);
  SetImeMode (EdMacro3.Handle, imSHanguel);
  SetImeMode (EdMacro4.Handle, imSHanguel);
  SetImeMode (EdMacro5.Handle, imSHanguel);
  SetImeMode (EdMacro6.Handle, imSHanguel);
  SetImeMode (EdMacro7.Handle, imSHanguel);
  SetImeMode (EdMacro8.Handle, imSHanguel);
  {move edits}
  if DMacros.Left <> MacrosX then
  begin
    MacrosX := DMacros.Left;
    EdMacro1.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro2.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro3.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro4.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro5.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro6.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro7.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
    EdMacro8.Left    := MacrosX + 164 + (g_FScreenWidth - 800) Div 2;
  end;

  if DMacros.Top <> MacrosY then
  begin
    MacrosY := DMacros.Top;
    EdMacro1.Top     := MacrosY + 212 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro2.Top     := MacrosY + 237 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro3.Top     := MacrosY + 262 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro4.Top     := MacrosY + 287 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro5.Top     := MacrosY + 312 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro6.Top     := MacrosY + 337 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro7.Top     := MacrosY + 363 - 159 + (g_FScreenHeight - 600) Div 2;
    EdMacro8.Top     := MacrosY + 388 - 159 + (g_FScreenHeight - 600) Div 2;
  end;
end;

procedure TFrmDlg.DMacrosKeyPress(Sender: TObject; var Key: Char);
begin
   if Key = #27 then
    if DHelpWin.Visible then
      DHelpWin.Visible := False;
end;

procedure TFrmDlg.DMacrosOKDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DMacrosOKClick(Sender: TObject; X, Y: Integer);
begin
  SetImeMode (EdMacro1.Handle, imSAlpha);
  SetImeMode (EdMacro2.Handle, imSAlpha);
  SetImeMode (EdMacro3.Handle, imSAlpha);
  SetImeMode (EdMacro4.Handle, imSAlpha);
  SetImeMode (EdMacro5.Handle, imSAlpha);
  SetImeMode (EdMacro6.Handle, imSAlpha);
  SetImeMode (EdMacro7.Handle, imSAlpha);
  SetImeMode (EdMacro8.Handle, imSAlpha);

  strlMacros.Strings[0] := EdMacro1.Text;
  strlMacros.Strings[1] := EdMacro2.Text;
  strlMacros.Strings[2] := EdMacro3.Text;
  strlMacros.Strings[3] := EdMacro4.Text;
  strlMacros.Strings[4] := EdMacro5.Text;
  strlMacros.Strings[5] := EdMacro6.Text;
  strlMacros.Strings[6] := EdMacro7.Text;
  strlMacros.Strings[7] := EdMacro8.Text;
  SaveMacros;
  ToggleMacrosFieldVisability;
  DMacros.Visible := False;
  ModalResult := mrOK;
end;

procedure TFrmDlg.DMacrosCancelClick(Sender: TObject; X, Y: Integer);
begin
  SetImeMode (EdMacro1.Handle, imSAlpha);
  SetImeMode (EdMacro2.Handle, imSAlpha);
  SetImeMode (EdMacro3.Handle, imSAlpha);
  SetImeMode (EdMacro4.Handle, imSAlpha);
  SetImeMode (EdMacro5.Handle, imSAlpha);
  SetImeMode (EdMacro6.Handle, imSAlpha);
  SetImeMode (EdMacro7.Handle, imSAlpha);
  SetImeMode (EdMacro8.Handle, imSAlpha);

  ToggleMacrosFieldVisability;
  DMacros.Visible := False;
  ModalResult := mrOK;
  LocalLanguage := imSAlpha;
  SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
end;

procedure TFrmDlg.ToggleMacrosFieldVisability;
begin
  {hide / show edits}
  EdMacro1.Text := strlMacros.Strings[0];
  EdMacro2.Text := strlMacros.Strings[1];
  EdMacro3.Text := strlMacros.Strings[2];
  EdMacro4.Text := strlMacros.Strings[3];
  EdMacro5.Text := strlMacros.Strings[4];
  EdMacro6.Text := strlMacros.Strings[5];
  EdMacro7.Text := strlMacros.Strings[6];
  EdMacro8.Text := strlMacros.Strings[7];

  EdMacro1.Visible := NOT EdMacro1.Visible;
  EdMacro2.Visible := NOT EdMacro2.Visible;
  EdMacro3.Visible := NOT EdMacro3.Visible;
  EdMacro4.Visible := NOT EdMacro4.Visible;
  EdMacro5.Visible := NOT EdMacro5.Visible;
  EdMacro6.Visible := NOT EdMacro6.Visible;
  EdMacro7.Visible := NOT EdMacro7.Visible;
  EdMacro8.Visible := NOT EdMacro8.Visible;
end;


procedure TFrmDlg.DSPETS1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
      if Sender = DSPETS1 then begin
         if g_UseItems[U_PETS1].S.Name <> '' then begin
            idx := g_UseItems[U_PETS1].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DSPETS1.SurfaceX(DSPETS1.Left + (DSPETS1.Width - d.Width) div 2),
                                 DSPETS1.SurfaceY(DSPETS1.Top + (DSPETS1.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DSPETS2 then begin
         if g_UseItems[U_PETS2].S.Name <> '' then begin
            idx := g_UseItems[U_PETS2].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DSPETS2.SurfaceX(DSPETS2.Left + (DSPETS2.Width - d.Width) div 2),
                                 DSPETS2.SurfaceY(DSPETS2.Top + (DSPETS2.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DSPETS3 then begin
         if g_UseItems[U_PETS3].S.Name <> '' then begin
            idx := g_UseItems[U_PETS3].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DSPETS3.SurfaceX(DSPETS3.Left + (DSPETS3.Width - d.Width) div 2),
                                 DSPETS3.SurfaceY(DSPETS3.Top + (DSPETS3.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DSPETS4 then begin
         if g_UseItems[U_PETS4].S.Name <> '' then begin
            idx := g_UseItems[U_PETS4].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DSPETS4.SurfaceX(DSPETS4.Left + (DSPETS4.Width - d.Width) div 2),
                                 DSPETS4.SurfaceY(DSPETS4.Top + (DSPETS4.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DSPETS5 then begin
         if g_UseItems[U_PETS5].S.Name <> '' then begin
            idx := g_UseItems[U_PETS5].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DSPETS5.SurfaceX(DSPETS5.Left + (DSPETS5.Width - d.Width) div 2),
                                 DSPETS5.SurfaceY(DSPETS5.Top + (DSPETS5.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
end;

procedure TFrmDlg.DSPETS1Click(Sender: TObject; X, Y: Integer);
var
   where, n, sel: integer;
   flag, movcancel: Boolean;
begin
 if g_FishingOk = FALSE then begin
   if g_MySelf = nil then exit;
   if g_boItemMoving then begin
      flag := FALSE;
      movcancel := FALSE;
      if (g_MovingItem.Owner = DItemStore) then exit;
      if (g_MovingItem.Owner = DDealDlg) or (g_MovingItem.Owner = DHeroStateWin) then Exit;
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      where := GetTakeOnPositionTiger (g_MovingItem.Item.S.StdMode);
      if g_MovingItem.Index >= 0 then begin
         case where of
            U_PETS1: begin
               if Sender = DSPETS1 then begin
                  where := U_PETS1;
                  flag := TRUE;
               end;
            end;
            U_PETS2: begin
               if Sender = DSPETS2 then begin
                  where := U_PETS2;
                  flag := TRUE;
               end;
            end;
            U_PETS3: begin
               if Sender = DSPETS3 then begin
                  where := U_PETS3;
                  flag := TRUE;
               end;
            end;
            U_PETS4: begin
               if Sender = DSPETS4 then begin
                  where := U_PETS4;
                  flag := TRUE;
               end;
            end;
            U_PETS5: begin
               if Sender = DSPETS5 then begin
                  where := U_PETS5;
                  flag := TRUE;
               end;
            end;
          end;
      end else begin
        if (g_MovingItem.Owner = DStateWin) then begin
          n := -(g_MovingItem.Index+1);
          if n in [0..MAXUSEITEM] then begin   //¾ÆÀÌÅÛ °¹¼ö
            ItemClickSound (g_MovingItem.Item.S);
            g_UseItems[n] := g_MovingItem.Item;
            g_MovingItem.Item.S.Name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
          end;
        end;
      end;
      if flag then begin
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DHeroItemBag) then begin
          if (g_MovingItem.Owner = DItemBag) then begin
            ItemClickSound (g_MovingItem.Item.S);
            g_WaitingUseItem := g_MovingItem;
            g_WaitingUseItem.Index := where;

            FrmMain.SendTakeOnItem (where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
            g_MovingItem.Item.S.Name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
          end else begin
            CancelHeroItemMoving;
            exit;
          end;
        end;
      end;
   end else begin
      flag := FALSE;
      if (g_MovingItem.Item.S.Name <> '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      sel := -1;
      if Sender = DSPETS1 then sel := U_PETS1;
      if Sender = DSPETS2 then sel := U_PETS2;
      if Sender = DSPETS3 then sel := U_PETS3;
      if Sender = DSPETS4 then sel := U_PETS4;
      if Sender = DSPETS5 then sel := U_PETS5;

      if g_MovingItem.Item.S.StdMode in [72] Then begin  //ÀÎÀå ÅÛ »¬ °æ¿ì
         if Flag = False then
         SendClientMessage(CM_TIGERSET, 0, 0, 0, 0);  //³»¸®±â
      end;

      if sel >= 0 then begin
         if g_UseItems[sel].S.Name <> '' then begin
            ItemClickSound (g_UseItems[sel].S);
            g_MovingItem.Index := -(sel+1);
            g_MovingItem.Item := g_UseItems[sel];
            g_UseItems[sel].S.Name := '';
            g_boItemMoving := TRUE;
            g_MovingItem.Owner := DStateWin;
            g_UseItems[sel].S.StdMode := 0;
         end;
      end;
   end;
 end;
end;

procedure TFrmDlg.DSPETS1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  sel: integer;
  Butt:TDButton;
begin
   sel := -1;
   Butt:=TDButton(Sender);
   if Sender = DSPETS1 then sel := U_PETS1
   else if Sender = DSPETS2 then sel := U_PETS2
   else if Sender = DSPETS3 then sel := U_PETS3
   else if Sender = DSPETS4 then sel := U_PETS4
   else if Sender = DSPETS5 then sel := U_PETS5;

   if sel >= 0 then begin
     g_MouseStateItem := g_UseItems[sel];
     g_MouseItem := g_UseItems[sel];
     GetMouseItemHint(g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
       nLocalX:=Butt.LocalX(X - Butt.Left);
       nLocalY:=Butt.LocalY(Y - Butt.Top);
       nHintX:=Butt.SurfaceX(Butt.Left) + DTigerDlg.SurfaceX(DTigerDlg.Left) + nLocalX;
       nHintY:=Butt.SurfaceY(Butt.Top) + DTigerDlg.SurfaceY(DTigerDlg.Top) + nLocalY;
       with Butt as TDButton do
          DScreen.ShowHintB(nHintX, nHintY, HintList, TRUE);
       g_MouseItem.S.Name := '';
     end;
   end;
end;

procedure TFrmDlg.DWItemSepaDirectPaint(Sender: TObject;   //¹°¾à
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   str,str2:string;
begin
 if g_Myself = nil then exit;
  with DWItemSepa do begin
   d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    with dsurface.Canvas do begin
      if QItemAmount > 0 then
      str := 'ÄãÈ·¶¨Òª²ð·Ö '+inttostr(QItemAmount)+' ¸öÎïÆ·³öÀ´Âð£¿';
      SetBkMode (Handle, TRANSPARENT);
      Font.Color:= clWhite;
      TextOut (SurfaceX(Left + 24),SurfaceY(Top + 28), str);
      Font.Color:= clWhite;
      Release;
    end;
    ESitemName.Left := SurfaceX(Left+26);
    ESitemName.Top := SurfaceY(Top+87);
    if not ESitemName.Visible then begin
      PlayScene.EdChat.Visible := FALSE;
      ESitemName.Visible := True;
      ESitemName.SetFocus;
    end;
  end;
end;

procedure TFrmDlg.ItemSepaOkClick(Sender: TObject; X, Y: Integer);    //¹°¾à
var
  strname:string;
begin
  strname := Trim(ESitemName.Text);
  if strname = '' then Exit;
  if (QItemmsIdex > 0) and (HItemmsIdex = -1) then begin
    if not Checkkeyamount(strname) then begin
      if StrToInt(strname) <= QItemAmount then begin
        frmMain.SeparateItem(QItemmsIdex,StrToInt(strname));
        ESitemName.Text := '';
        ESitemName.Visible := False;
        QItemAmount := 0;          //¹°¾à
        DWItemSepa.Visible := False;
      end else
        ESitemName.Text := '';
        ESitemName.Visible := False;
        QItemAmount := 0;          //¹°¾à
        DWItemSepa.Visible := False;
    end else begin
      ESitemName.Text := '';
      ESitemName.Visible := False;
      QItemAmount := 0;          //¹°¾à
      DWItemSepa.Visible := False;
    end;
  end;
  if (HItemmsIdex > 0) and (QItemmsIdex = -1) then begin
    if not Checkkeyamount(strname) then begin
      if StrToInt(strname) <= QItemAmount then begin
        frmMain.HeroSeparateItem(HItemmsIdex,StrToInt(strname));
        ESitemName.Text := '';
        ESitemName.Visible := False;
        QItemAmount := 0;          //¹°¾à
        DWItemSepa.Visible := False;
      end else
        ESitemName.Text := '';
        ESitemName.Visible := False;
        QItemAmount := 0;          //¹°¾à
        DWItemSepa.Visible := False;
    end else begin
        ESitemName.Text := '';
        ESitemName.Visible := False;
        QItemAmount := 0;          //¹°¾à
        DWItemSepa.Visible := False;
    end;
  end;
  PlayScene.EdChat.Visible := FALSE;
end;

procedure TFrmDlg.ItemSepacloseClick(Sender: TObject; X, Y: Integer);   //¹°¾à
begin
  QItemAmount := 0;
  QItemmsIdex := -1;
  HItemmsIdex := -1;
  DWItemSepa.Visible := False;
  ESitemName.Visible := False;
  ESitemName.Text := '';
end;

procedure TFrmDlg.ItemSepaexitClick(Sender: TObject; X, Y: Integer);      //¹°¾à
begin
  QItemAmount := 0;
  QItemmsIdex := -1;
  HItemmsIdex := -1;
  DWItemSepa.Visible := False;
  ESitemName.Visible := False;
  ESitemName.Text := '';
end;


procedure TFrmDlg.Dshoppe1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 idx : integer;
 pg: PTClientGoods;
 d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    idx:= Tag+Mensellidx;
    if idx < MenuList.Count then begin
      pg := PTClientGoods (MenuList[idx]);
     if Menboots = Tag then begin
      MenuIndex := idx;
      d:= g_WMainImages.Images[1001];
      if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
     end;
      d:= g_WBagItemImages.Images[pg.looks];
      if d <> nil then
       dsurface.Draw (SurfaceX(TDButton(Sender).Left + ((TDButton(Sender).Width - 171) - d.Width) div 2) + 3 ,
       SurfaceY(TDButton(Sender).Top + (TDButton(Sender).Height - d.Height) div 2), d.ClientRect, d, TRUE);
      if (pg.Amount > 0) and (pg.modes in [0,1,3,45,46]) then begin             //¹°¾à
       SetBKMode (dSurface.Canvas.Handle,TRANSPARENT);
       dsurface.Canvas.Font.Color := clYellow;
       dsurface.Canvas.TextOut(SurfaceX(Left + 20), SurfaceY(Top + 18), IntToStr(pg.Amount));
       dsurface.Canvas.Font.Color := clWhite;
       dSurface.Canvas.Release;
      end;
      with Dsurface.Canvas do begin
        SetBKMode (dSurface.Canvas.Handle,TRANSPARENT);
         if Menboots = Tag then
         Font.Color := clRed
         else
         Font.Color := clWhite;
         BoldTextOut (Dsurface ,SurfaceX(TDButton(Sender).Left + 41) , SurfaceY(TDButton(Sender).Top + 2) , Font.Color ,clBlack , pg.Name);

         if BoPCItemMenu then begin
           if pg.Grade = -1 then  BoldTextOut (dSurface ,SurfaceX(TDButton(Sender).Left + 41) , SurfaceY(TDButton(Sender).Top + 18) , Font.Color ,clBlack , '¼Û¸ñ:' + GetGoldStr(pg.Price) + 'P');
         end else begin
           if pg.Grade = -1 then  BoldTextOut (dSurface ,SurfaceX(TDButton(Sender).Left + 41) , SurfaceY(TDButton(Sender).Top + 18) , Font.Color ,clBlack , '¼Û¸ñ:' + GetGoldStr(pg.Price));
         end;
         dSurface.Canvas.Release;
      end;
    end;
  end;
end;

procedure TFrmDlg.Dshoppe1Click(Sender: TObject; X, Y: Integer);
var
idx : integer;
pg: PTClientGoods;
begin
  with Sender as TDButton do begin
   idx:= Tag+Mensellidx;
    if idx < MenuList.Count then begin
      Menboots := Tag;
      PlaySound (s_glass_button_click);
      MenuIndex := idx;
      if DMakeItemDlg.Visible then DMakeItemDlgOkClick(DMakeItemDlgCancel, 0, 0);  //Á¦Á¶½ºÃÄ

      if g_dddtypemode then begin
        g_MouseItem := PTClientItem(g_MenuItemList[idx])^;
      end else begin
        g_MouseItem := G_BuyItem[idx].entItem;
      end;

    end;
  end;
end;

procedure TFrmDlg.DShopMenuMoveMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  Mensellidx:=DShopMenuMove.outidx;
   if ssLeft in Shift then begin
    Menboots := -1;
   DSCreen.ClearHint;
  end;
end;


procedure TFrmDlg.ShowDiceGame;     //Ç÷·æ»óÀÚ
begin
    DDiceGame.Visible := True;
    PlaySound(185); //Ç÷·æ»óÀÚ ¿ÀÇÂ ¼Ò¸®
end;

procedure TFrmDlg.DiceImages;       //Ç÷·æ»óÀÚ
begin
    if GetTickCount - Diceimgtime > 130 + TimeToDice then begin
       Diceimgtime := GetTickCount;
       DiceimgIndex := DiceimgIndex + 1;
     if DiceimgIndex > 3 then begin
        DiceimgIndex := 0;
     end;
   end;
end;

procedure TFrmDlg.OpenAction;
begin
  DOnAuction.Visible := True;
  n_ActionPrice := 0;
  if g_ActionItems.S.Name <> '' then begin
     AddItemBag(g_ActionItems);
   end;
  g_ActionItems.S.Name := '';
end;

procedure TFrmDlg.CloseAction;
begin
  DOnAuction.Visible := False;
  n_ActionPrice := 0;
  if g_ActionItems.S.Name <> '' then begin
     AddItemBag(g_ActionItems);
  end;
  g_ActionItems.S.Name := '';
end;


procedure TFrmDlg.OpenAuc;
begin
  n_AucPrice := 0;
  DOffAuction.Visible := True;;
end;


procedure TFrmDlg.CloseAuc;
begin
  n_AucPrice := 0;
  DOffAuction.Visible := False;
end;


procedure TFrmDlg.OpenItemShopDBl;     //È¯»óÁ¡
begin
   DItemShopDlg.Visible:=not DItemShopDlg.Visible;
   if DItemShopDlg.Visible then begin
     DCategories1Click(DCategories1, 0, 0);

     with EdShopEdit do begin         //È¯»óÁ¡
        Text  := '';
        Width := 132;
        Left  := DItemShopDlg.Left+474;
        Top   := DItemShopDlg.Top +46;
     end;

     EdShopEdit.Visible := TRUE;
     EdShopEdit.SetFocus;
     DlgEditText := EdShopEdit.Text;
     SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
     if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
   end else begin
     FrmDlg.DItemShopCloseClick(Self,0,0);
   end;
end;





procedure TFrmDlg.closeGiftsDTListDlg;   //È¯»óÁ¡
var
   i: integer;
begin
   for i:=0 to g_GiftsItemlist.Count-1 do
      Dispose (pTGiveItem (g_GiftsItemlist[i]));
      g_GiftsItemlist.Clear;
   for i := 0 to 6 do begin
   frmDlg.Giftsitemstr[i] := '';
   end;
end;

procedure TFrmDlg.openshopitemint;     //È¯»óÁ¡
begin
  shopbuyamoin := 1;
  shopbuypier := '';
  shopbuysrt := '';
  buyitemk1Click(buyitemk1, 0, 0);
end;

procedure TFrmDlg.Reductionshopitemkey;      //È¯»óÁ¡
begin
    DItemShopJobAll.SetImgIndex (g_WMainImages, 800);
    DItemShopJobWarrior.SetImgIndex (g_WMainImages, 803);
    DItemShopJobWizard.SetImgIndex (g_WMainImages, 805);
    DItemShopJobMonk.SetImgIndex (g_WMainImages, 807);
    DItemShopJobAssas.SetImgIndex (g_WMainImages, 778);
    DItemShopJobBonz.SetImgIndex (g_WAresImages, 412);
    DItemShopJobCommon.SetImgIndex (g_WMainImages, 809);
end;

procedure TFrmDlg.newimgmode;       //È¯»óÁ¡
begin
    if GetTickCount - newimgtime >130 then begin
       newimgtime := GetTickCount;
       newimgIndex := newimgIndex+1;
     if newimgIndex > 3 then begin
        newimgIndex := 0;
     end;
   end;
end;



procedure TFrmDlg.OpenStoreDlg;  //°³ÀÎ»óÁ¡
begin
  if not g_MySelf.m_boStartStore then begin
    DItemBag.Left := g_FScreenWidth - 315;
    DItemBag.Top := 45;
    DItemBag.Visible := True;
  end;

  g_CheckMacro := True;
  FrmMain.StoreMacro.Enabled := True;
  DStoreGridWin.Visible := True;

  EdStoreMsgEdit.Visible := True;
  EdStoreMacrosEdit.Visible := True;
end;

procedure TFrmDlg.CloseStoreDlg;       //°³ÀÎ»óÁ¡
var
  I: Integer;
begin
  if (g_MySelf <> nil) and (not g_MySelf.m_boStartStore) and (not g_boStartStoreing) then begin
    for I := 0 to 14 do begin
      if g_StoreItems[I].Item.s.Name <> '' then begin
        AddItemBag(g_StoreItems[I].Item);
      end;
      g_StoreItems[I].Item.s.Name := '';
    end;
  end;

  DItemBag.Left := 0;
  DItemBag.Top := 10;
  
  EdStoreMsgEdit.Visible := False;
  EdStoreMacrosEdit.Visible := False;
  DStoreGridWin.Visible := False;
  SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
end;

procedure TFrmDlg.OpenUserStoreDlg;      //°³ÀÎ»óÁ¡
begin
  g_SelectStoreItem.Item.s.Name := '';
  DUserStore.Visible := True;
  DScreen.AddChatBoardString('"'+g_sStoreMasterName + '"µÄ¸öÈËÉÌµê',clPurple,clWhite);
end;

procedure TFrmDlg.CloseUserStoreDlg;      //°³ÀÎ»óÁ¡
var
  i: Integer;
begin
  g_SelectStoreItem.Item.s.Name := '';
  for I := 0 to 14 do begin
    if g_StoreRemoteItems[I].Item.S.Name <> '' then
      g_StoreRemoteItems[I].Item.s.Name := '';
  end;
  DUserStore.Visible := False;
end;


function TFrmDlg.DStoreMessageDlg(): TModalResult;
var
  I: Integer;
  lx, ly: Integer;
  d: TDirectDrawSurface;
  procedure ShowDice();
  var
    I: Integer;
    bo05: Boolean;
  begin
    if m_nDiceCount = 1 then begin
      if m_Dice[0].n67C < 20 then begin
        if GetTickCount - m_Dice[0].dwPlayTick > 100 then begin
          if m_Dice[0].n67C div 5 = 4 then begin
            m_Dice[0].nPlayPoint := Random(6) + 1;
          end else begin
            m_Dice[0].nPlayPoint := m_Dice[0].n67C div 5 + 8;
          end;
          m_Dice[0].dwPlayTick := GetTickCount();
          Inc(m_Dice[0].n67C);
        end;
        Exit;
      end;
      m_Dice[0].nPlayPoint := m_Dice[0].nDicePoint;
      if GetTickCount - m_Dice[0].dwPlayTick > 1500 then begin
        DStoreMsgDlg.Visible := False;
      end;
      Exit;
    end;

    bo05 := True;
    for I := 0 to m_nDiceCount - 1 do begin
      if m_Dice[I].n67C < m_Dice[I].n680 then begin
        if GetTickCount - m_Dice[I].dwPlayTick > 100 then begin
          if m_Dice[I].n67C div 5 = 4 then begin
            m_Dice[I].nPlayPoint := Random(6) + 1;
          end else begin
            m_Dice[I].nPlayPoint := m_Dice[I].n67C div 5 + 8;
          end;
          m_Dice[I].dwPlayTick := GetTickCount();
          Inc(m_Dice[I].n67C);
        end;
        bo05 := False;
      end else begin
        m_Dice[I].nPlayPoint := m_Dice[I].nDicePoint;
        if GetTickCount - m_Dice[I].dwPlayTick < 2000 then begin
          bo05 := False;
        end;
      end;
    end; //for
    if bo05 then begin
      DStoreMsgDlg.Visible := False;
    end;
  end;
begin
  for I := 0 to m_nDiceCount - 1 do begin
    m_Dice[I].n67C := 0;
    m_Dice[I].n680 := Random(m_nDiceCount + 2) * 5 + 10;
    m_Dice[I].nPlayPoint := 1;
    m_Dice[I].dwPlayTick := GetTickCount();
  end;

  m_boStoreGold:= 0;
  EdStoreDlgEdit.Text := '';
  DStoreMsgDlg.ShowModal;
  Result := mrOk;

  while True do begin
    if not DStoreMsgDlg.Visible then Break;
    frmMain.ProcOnIdle;
    Application.ProcessMessages;
    if m_nDiceCount > 0 then begin
      m_boPlayDice := True;
      for I := 0 to m_nDiceCount - 1 do begin
        m_Dice[I].nX := ((DStoreMsgDlg.Width div 2 + 6) - ((m_nDiceCount * 32 + m_nDiceCount) div 2)) + (I * 32 + I);
        m_Dice[I].nY := DStoreMsgDlg.Height div 2 - 14;
      end;
      ShowDice();
    end;
    if Application.Terminated then Exit;
    Sleep(1);
  end;

  StoreDlgEditText := Trim(EdStoreDlgEdit.Text);

  Result := DStoreMsgDlg.DialogResult;
  m_nDiceCount := 0;
  m_boPlayDice := False;
end;

function TFrmDlg.AutoTimeIdx:Integer;   //³¬½Ã ³¬±â ¹öÆ°
begin
  if GetTickCount - m_FishTime  >= 100 then begin
    m_FishTime := GetTickCount;
    Inc(FishFrame);
  end;
  if FishFrame >= 9 then begin
    FishFrame := 0;
  end;
 Result:= FishFrame;
end;

function TFrmDlg.AutoTimeIdx2:Integer;   //³¬½Ã ³¬±â ¹öÆ°
begin
  if GetTickCount - m_FishTime2  >= 250 then begin
    m_FishTime2 := GetTickCount;
    Inc(FishFrame2);
  end;
  if FishFrame2 >= 2 then begin
    FishFrame2 := 0;
  end;
 Result:= FishFrame2;
end;



procedure TFrmDlg.DBotItemShopClick(Sender: TObject; X, Y: Integer);
begin
    OpenItemShopDBl();
end;


procedure TFrmDlg.DItemShopDlgDirectPaint(Sender: TObject;     //È¯»óÁ¡
  dsurface: TDirectDrawSurface);
var
  i, n, f : integer;
  d, dd, e, ee: TDirectDrawSurface;
  pagenumstring :String;
  TempList: TStringList;
begin
  if g_MySelf = nil then exit;
  with DItemShopDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
        SetBkMode (Handle, TRANSPARENT);
        if g_ShopItems[GameShopIndex].ShopItems.S.Name <> '' then begin
          g_MouseItem := g_ShopItems[GameShopIndex].ShopItems;
          GetMouseItemHint (g_MySelf, @g_MouseItem);
          TempList := HintList;
          if TempList.Strings[0] <> '' then begin
            TextOutA(dsurface, SurfaceX(Left + 154), SurfaceY(Top + 346), clYellow, TempList.Strings[0]);

            n:=0;
            f:=0;
            for I := 1 to TempList.Count - 1 do begin
              if (I < 3) and (TempList.Strings[i] <> '') then begin
                TextOutA(dsurface, SurfaceX(Left + 154), SurfaceY(Top + 360 + f), clWhite, TempList.Strings[I]);
                Inc(f, 14);
              end;
              if (TempList.Objects[i] = TObject(GetRGB(116))) and (TempList.Strings[i] <> '') then begin
                TextOutA(dsurface, SurfaceX(Left + 432), SurfaceY(Top + 346 + n), clWhite, TempList.Strings[i]);  //È¯¼³¸í
                Inc(n, 14);
              end;
            end;
          end;
        end;
        Font.Color := clWhite;
        Font.Size :=11;
        Font.Style:=[fsBold];
        TextOut (SurfaceX(Left + 303),SurfaceY(Top + 13), '°Ù»õÉÌµê');
        Font.Style:=[];
        Font.Size :=9;
        pagenumstring := inttostr(g_ShopCurrPage) +' / ' +inttostr(g_ShopAmountofPages);
        TextOut (SurfaceX(Left + 383 - (TextWidth(pagenumstring) div 2)),SurfaceY(Top + 402), pagenumstring);
        TextOut (SurfaceX(Left + 490),SurfaceY(Top + 440), GetGoldStr(g_MySelf.m_nGameGold));
        Font.Color := clWhite;
        Release;
      end;

      if ( EdShopEdit.Left <> SurfaceX(Left + 474)) or (EdShopEdit.Top <> SurfaceY(Top + 47) ) then begin
        EdShopEdit.Left := SurfaceX(Left + 474);
        EdShopEdit.Top  := SurfaceY(Top + 47);
      end;
  end;
end;


procedure TFrmDlg.DGotoLeftDirectPaint(Sender: TObject;   //È¯»óÁ¡
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if TDButton(Sender).Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DItemShopDlgMouseMove(Sender: TObject;    //È¯»óÁ¡
  Shift: TShiftState; X, Y: Integer);
var
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;
begin
  DScreen.ClearHint;
  Butt := TDButton(Sender);
  if Sender = DItemShopListPrev then sMsg := 'ÉÏÒ»Ò³'
  else if Sender = DItemShopListNext then sMsg := 'ÏÂÒ»Ò³'
  else if Sender = DItemShopJobAll then sMsg := 'È«²¿'
  else if Sender = DItemShopJobWarrior then sMsg := 'Õ½Ê¿'
  else if Sender = DItemShopJobWizard then sMsg := '·¨Ê¦'
  else if Sender = DItemShopJobMonk then sMsg := 'µÀÊ¿'
  else if Sender = DItemShopJobAssas then sMsg := '´Ì¿Í'
  else if Sender = DItemShopJobBonz then sMsg := 'ºÍÉÐ'
  else if Sender = DItemShopJobCommon then sMsg := 'Í¨ÓÃ'
  else if Sender = DRenovates then sMsg := '²éÕÒ'
  else if Sender = DItemShopGetGift then sMsg := 'ÊÕ¼þÈË'
  else if Sender = DItemShopAddFav then sMsg := 'ÊÕ²Ø'
  else if Sender = DItemShopBye then sMsg := '¹ºÂò'
  else if Sender = DItemShopGift then sMsg := 'ÔùËÍÀñÎï'
  else if Sender = DItemShopPayMoney then sMsg := '¶Ò»»'
  else if Sender = DcGameGold then sMsg := 'Ë¢ÐÂ' ;
  nHintX := Butt.SurfaceX(Butt.Left) {+ DItemShopDlg.SurfaceX(DItemShopDlg.Left)};
  nHintY := Butt.SurfaceY(Butt.Top) {+ DItemShopDlg.SurfaceY(DItemShopDlg.Top)};
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DRenovatesDirectPaint(Sender: TObject;   //È¯»óÁ¡
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if not Downed then
      d := WLib.Images[FaceIndex]
    else d := WLib.Images[FaceIndex + 1];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DRenovatesClick(Sender: TObject; X, Y: Integer);
var
  sData : String;
begin
  sData := '';
  if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      Reductionshopitemkey;
      g_ShopCurrJob := 9;

      sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.GiftsDTClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡ ¼±¹°
var
  I, lx, ly, idx, ids: integer;
  gifs:PTGiveItem;
  TempList: TStringList;
begin
   lx := GiftsDT.LocalX (X) - GiftsDT.Left;
   ly := GiftsDT.LocalY (Y) - GiftsDT.Top;
   if (lx >= 32) and (lx <= 341) and (ly >= 115) and (ly <= 305)  then begin
     idx := (ly-115) div 19;
     if idx < g_GiftsItemlist.Count then begin
       PlaySound(s_rock_button_click);
       Giftsstrcls := idx;
       gifs := PTGiveItem (g_GiftsItemlist[idx]);
       g_MouseItem := gifs.Item;
       GetMouseItemHint (g_MySelf, @g_MouseItem);
       TempList := HintList;
       if TempList.Strings[0] <> '' then begin
         Giftsitemstr[1]:= TempList.Strings[0];
         for I := 1 to TempList.Count - 1 do begin
           if (I < 3) then begin
             Giftsitemstr[I + 1]:= TempList.Strings[I];
           end;
         end;
       end;
       Giftsitemstr[0]:= inttostr(gifs.Item.S.Looks);
       g_MouseItem.S.Name := '';
     end;
   end;
end;

procedure TFrmDlg.GiftsDTDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  var
  n:Integer;
  str,str1,str2:string;
  d,dd: TDirectDrawSurface;
  gifs:PTGiveItem;
begin
  with GiftsDT do begin
   d := WLib.Images[FaceIndex];
    if d <> nil then
    dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    if Giftsitemstr[0] <> '' then begin
    dd := g_WBagItemImages.Images[strtoint(Giftsitemstr[0])];
    if dd <> nil then
     dsurface.Draw (SurfaceX(Left + 32 + ((34 - dd.Width) div 2)),              //20110712
      SurfaceY(Top+ 313 + ((32-dd.Height) div 2)), dd.ClientRect, dd, TRUE);
    end;
    with Dsurface.Canvas do begin
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
         Font.Color := clWhite; //clWhite
         str:='ÀñÆ·Çåµ¥';
         str1:='·¢¼þÈË';
         str2:='ÎïÆ·';
         Font.Size :=11;
         dsurface.Canvas.Font.Style:=[fsBold];
         TextOut (SurfaceX(Left + 197) - (TextWidth(str) div 2), SurfaceY(Top+13), str);      //20110712
         Font.Style:=[];
         Font.Size :=9;
         TextOut (SurfaceX(Left + 95) - (TextWidth(str1) div 2), SurfaceY(Top+93), str1);
         TextOut (SurfaceX(Left + 252) - (TextWidth(str2) div 2), SurfaceY(Top+93), str2);
      dsurface.Canvas.Release;
      with Dsurface.Canvas do begin
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
         Font.Color := clWhite; //clWhite
         str:='ÀñÆ·Çåµ¥';
         str1:='·¢¼þÈË';
         str2:='ÎïÆ·';
         Font.Size :=11;
         dsurface.Canvas.Font.Style:=[fsBold];
         TextOut (SurfaceX(Left + 197) - (TextWidth(str) div 2), SurfaceY(Top+13), str);      //20110712
         Font.Style:=[];
         Font.Size :=9;
         TextOut (SurfaceX(Left + 95) - (TextWidth(str1) div 2), SurfaceY(Top+93), str1);
         TextOut (SurfaceX(Left + 252) - (TextWidth(str2) div 2), SurfaceY(Top+93), str2);
         if Giftsitemstr[0] <> '' then begin
            n := TextWidth (Giftsitemstr[1]);
            Font.Color := clYellow;
            TextOut (SurfaceX(Left+79), SurfaceY(Top+317), Giftsitemstr[1]);
            Font.Color := clWhite;
            Giftsitemstr[2]:= StringReplace(Giftsitemstr[2],'\','',[rfReplaceAll,rfIgnoreCase]);
            Giftsitemstr[3]:= StringReplace(Giftsitemstr[3],'\','',[rfReplaceAll,rfIgnoreCase]);
            TextOut (SurfaceX(Left+79) + n, SurfaceY(Top+317), Giftsitemstr[2]);
            TextOut (SurfaceX(Left+79), SurfaceY(Top+331), Giftsitemstr[3]);
            Font.Color:= clWhite;
            TextOut (SurfaceX(Left+79), SurfaceY(Top+345), Giftsitemstr[4]);
         end;
         dsurface.Canvas.Release;
      end;
     end;
    end;
end;

procedure TFrmDlg.GiftsDTMouseMove(Sender: TObject; Shift: TShiftState; X,    //È¯»óÁ¡ ¼±¹°
  Y: Integer);
begin
   DScreen.ClearHint;
   g_MouseStateItem.S.Name := '';
end;

procedure TFrmDlg.DlipioutDirectPaint(Sender: TObject;   //È¯»óÁ¡ ¼±¹°
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.Giftsdoot1DirectPaint(Sender: TObject;  //È¯»óÁ¡ ¼±¹°¹Þ±â
  dsurface: TDirectDrawSurface);
var
ids: integer;
gps:pTGiveItem;
d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
  ids := _Max(Tag + Giftsidxts * 10,0);
    if ids < g_GiftsItemlist.Count then begin
      gps := pTGiveItem (g_GiftsItemlist[ids]);
      d := g_WMainImages.Images[760];
     if d <> nil then
     dsurface.Draw (SurfaceX(TDButton(Sender).Left) ,
     SurfaceY(TDButton(Sender).Top + (TDButton(Sender).Height - d.Height) div 2), d.ClientRect, d, TRUE);
     with Dsurface.Canvas do begin
       SetBKmode(Handle, TRANSPARENT);
       if Giftsstrcls = ids then
       Font.Color := clRed
       else Font.Color := clSilver;
       TextOut(SurfaceX(TDButton(Sender).Left-249-(TextWidth(gps.mename) div 2)),SurfaceY(TDButton(Sender).Top+3),gps.mename);
       TextOut(SurfaceX(TDButton(Sender).Left-93-(TextWidth(gps.Item.S.Name) div 2)),SurfaceY(TDButton(Sender).Top+3),gps.Item.S.Name);
       Font.Color := clSilver;
       Release;
     end;
     
   end;
 end;
end;

procedure TFrmDlg.Giftsdoot1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
ids: integer;
sMsg:String;
nLocalX,nLocalY:Integer;
nHintX,nHintY:Integer;
Butt:TDButton;
begin
 DScreen.ClearHint;
 Butt:=TDButton(Sender);
 with Sender as TDButton do begin
  ids := _Max(TDButton(Sender).Tag + Giftsidxts * 10,0);
   if ids < g_GiftsItemlist.Count then begin
    sMsg:= 'ÊÕÈ¡ÀñÆ·';
    nLocalX:=Butt.LocalX(X - Butt.Left);
    nLocalY:=Butt.LocalY(Y - Butt.Top);
    nHintX:=Butt.SurfaceX(Butt.Left) + GiftsDT.SurfaceX(GiftsDT.Left) + nLocalX;
    nHintY:=Butt.SurfaceY(Butt.Top) + GiftsDT.SurfaceY(GiftsDT.Top) + nLocalY;
    DScreen.ShowHintA(nHintX,nHintY,sMsg, clYellow, TRUE);
  end;
 end;
end;

procedure TFrmDlg.Giftsdoot1Click(Sender: TObject; X, Y: Integer);       //È¯»óÁ¡ ¼±¹°
var
  I, lx, ly, ids ,idx: integer;
  gps,gifs:pTGiveItem;
  TempList: TStringList;
begin
  with Sender as TDButton do begin //Giftsidxts
    ids := _Max(TDButton(Sender).Tag + Giftsidxts * 10,0);
    if ids < g_GiftsItemlist.Count then begin
      gps := pTGiveItem (g_GiftsItemlist[ids]);

      g_MouseItem := gps.Item;
      GetMouseItemHint (g_MySelf, @g_MouseItem);

      TempList := HintList;
      if TempList.Strings[0] <> '' then begin
        Giftsitemstr[1]:= TempList.Strings[0];
        for I := 1 to TempList.Count - 1 do begin
          if (I < 3) then begin
            Giftsitemstr[I + 1]:= TempList.Strings[I];
          end;
        end;
      end;
      Giftsitemstr[0]:= inttostr(gps.Item.S.Looks);
      g_MouseItem.S.Name := '';

      if mrYes = FrmDlg.DMessageDlg ('ÄãÊÇ·ñ½ÓÊÜ±ðÈËÔùËÍµÄ "' + gps.Itemname + '"' + '£¿', [mbYes, mbNo]) then begin
        SendClientMessage (CM_GIFTITEMTYPE, g_MySelf.m_nRecogId, LoWord(gps.annid), HiWord(gps.annid), 0);
        closeGiftsDTListDlg;
      end;
    end;
  end;
end;

procedure TFrmDlg.GiftsupsClick(Sender: TObject; X, Y: Integer);    //È¯»óÁ¡
var
i:integer;
begin
  if Sender = Giftsups then begin
    if Giftsidxts > 0 then begin
      Dec (Giftsidxts);
      Giftsstrcls := -1;
    for i := 0 to 5 do begin
      Giftsitemstr[i] := '';
    end;
   end;
  end else begin
   if Giftsidxts < (g_GiftsItemlist.Count+9) div 10 - 1 then  begin
     inc (Giftsidxts);
     Giftsstrcls := -1;
    for i := 0 to 5 do begin
      Giftsitemstr[i] := '';
    end;
   end;
  end;
end;

procedure TFrmDlg.GiftsDTEXITClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡ ¼±¹° ¹Þ±â
begin
  GiftsDT.Visible := false;
end;

procedure TFrmDlg.DCategories1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
d: TDButton;
dd, e: TDirectDrawSurface;
ShopCaView:string;
begin
  if Sender = DCategories1 then ShopCaView := 'ÐÂÆ·';
  if Sender = DCategories2 then ShopCaView := 'È«²¿';
  if Sender = DCategories3 then ShopCaView := '¸¨ÖúÎïÆ·';
  if Sender = DCategories4 then ShopCaView := '´ò°üÎïÆ·';
  if Sender = DCategories5 then ShopCaView := 'ÌØÊâÎïÆ·';
  if Sender = DCategories22 then ShopCaView := 'Ó¢  ÐÛ';
  if Sender = DCategories17 then ShopCaView := '³è  Îï';

  if Sender = DCategories11 then ShopCaView := 'Ìí¼ÓÊÕ²Ø';
  if Sender = DCategories12 then ShopCaView := 'È«²¿É¾³ý';
  if Sender = DCategories13 then ShopCaView := 'É¾³ýÑ¡ÖÐ';

   with Sender as TDButton do begin
      d := TDButton(Sender);
      if  g_ShopCurrSection = d.Tag then begin
        e := d.WLib.Images[FaceIndex+1];
      end else begin
        e := nil;
      end;
      if not d.Downed then
         dd := d.WLib.Images[FaceIndex]
      else dd := d.WLib.Images[FaceIndex+1];
      if dd <> nil then
         dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      if e <> nil then
         dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), e.ClientRect, e, TRUE);

   SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
   dsurface.Canvas.Font.Size :=9;
   if Sender <> DCategories11 then
   BoldTextOut (dsurface, SurfaceX(Left + (d.Width - dsurface.Canvas.TextWidth(ShopCaView)) div 2),
   SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(ShopCaView)) div 2), clWhite , clBlack, ShopCaView);
   if Sender = DCategories11 then
   BoldTextOut (dsurface, SurfaceX(Left + 5),
   SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(ShopCaView)) div 2), clWhite , clBlack, ShopCaView);
   dsurface.Canvas.Release;
 end;
end;

procedure TFrmDlg.DCategories1Click(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡
var
  sData : String;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;

      if TDButton(Sender).Tag in [2,5,6,7] then begin
        DCategories6.Visible := True;
        DCategories7.Visible := True;
        DCategories8.Visible := True;
        DCategories9.Visible := FALSE;
        DCategories10.Visible := FALSE;
        DCategories14.Visible := FALSE;
        DCategories15.Visible := FALSE;
        DCategories16.Visible := FALSE;
        DCategories18.Visible := FALSE;
        DCategories19.Visible := FALSE;
        DCategories20.Visible := FALSE;
        DCategories21.Visible := FALSE;
        DCategories4.Left:=26;
        DCategories4.Top:=67+21*6;
        DCategories5.Left:=26;
        DCategories5.Top:=67+21*7;
        DCategories22.Left:=26;
        DCategories22.Top:=67+21*8;
        DCategories17.Left:=26;
        DCategories17.Top:=67+21*9;
      end else begin
      if TDButton(Sender).Tag in [4,8..12] then begin
        DCategories9.Visible := True;
        DCategories10.Visible := True;
        DCategories14.Visible := True;
        DCategories15.Visible := True;
        DCategories16.Visible := True;
        DCategories6.Visible := FALSE;
        DCategories7.Visible := FALSE;
        DCategories8.Visible := FALSE;
        DCategories18.Visible := FALSE;
        DCategories19.Visible := FALSE;
        DCategories20.Visible := FALSE;
        DCategories21.Visible := FALSE;
        DCategories4.Left:=26;
        DCategories4.Top:=78+21*3;
        DCategories5.Left:=26;
        DCategories5.Top:=78+21*4;
        DCategories22.Left:=26;
        DCategories22.Top:=80+21*9;
        DCategories17.Left:=26;
        DCategories17.Top:=80+21*10;
      end else begin
      if TDButton(Sender).Tag in [16..20] then begin
        DCategories18.Visible := True;
        DCategories19.Visible := True;
        DCategories20.Visible := True;
        DCategories21.Visible := True;
        DCategories6.Visible := FALSE;
        DCategories7.Visible := FALSE;
        DCategories8.Visible := FALSE;
        DCategories9.Visible := FALSE;
        DCategories10.Visible := FALSE;
        DCategories14.Visible := FALSE;
        DCategories15.Visible := FALSE;
        DCategories16.Visible := FALSE;
        DCategories4.Left:=26;
        DCategories4.Top:=78+21*3;
        DCategories5.Left:=26;
        DCategories5.Top:=78+21*4;
        DCategories22.Left:=26;
        DCategories22.Top:=78+21*5;
        DCategories17.Left:=26;
        DCategories17.Top:=78+21*6;
      end else begin
        DCategories6.Visible := FALSE;
        DCategories7.Visible := FALSE;
        DCategories8.Visible := FALSE;
        DCategories9.Visible := FALSE;
        DCategories10.Visible := FALSE;
        DCategories14.Visible := FALSE;
        DCategories15.Visible := FALSE;
        DCategories16.Visible := FALSE;
        DCategories18.Visible := FALSE;
        DCategories19.Visible := FALSE;
        DCategories20.Visible := FALSE;
        DCategories21.Visible := FALSE;
        DCategories4.Left:=26;
        DCategories4.Top:=78+21*3;
        DCategories5.Left:=26;
        DCategories5.Top:=78+21*4;
        DCategories22.Left:=26;
        DCategories22.Top:=78+21*5;
        DCategories17.Left:=26;
        DCategories17.Top:=78+21*6;
      end;
      end;
      end;

      DScreen.ClearHint;
      g_ShopCurrSection := TDButton(Sender).Tag;
      g_ShopCurrJob := 9;
      Reductionshopitemkey;

      sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DCategories11Click(Sender: TObject; X, Y: Integer);   //È¯»óÁ¡   //°ü½É
begin
   if GetTickCount > g_dwQueryMsgTick then begin
        g_dwQueryMsgTick := GetTickCount + 1000;

        DCategories6.Visible := FALSE;
        DCategories7.Visible := FALSE;
        DCategories8.Visible := FALSE;
        DCategories9.Visible := FALSE;
        DCategories10.Visible := FALSE;
        DCategories14.Visible := FALSE;
        DCategories15.Visible := FALSE;
        DCategories16.Visible := FALSE;
        DCategories18.Visible := FALSE;
        DCategories19.Visible := FALSE;
        DCategories20.Visible := FALSE;
        DCategories21.Visible := FALSE;
        DCategories4.Left:=26;
        DCategories4.Top:=78+21*3;
        DCategories5.Left:=26;
        DCategories5.Top:=78+21*4;
        DCategories22.Left:=26;
        DCategories22.Top:=78+21*5;
        DCategories17.Left:=26;
        DCategories17.Top:=78+21*6;

        DScreen.ClearHint;
        Reductionshopitemkey;
        SendClientMessage(CM_OPSHOPCART, 0, 0, 0, 0,'');
   end;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DCategories12Click(Sender: TObject; X, Y: Integer);   //È¯»óÁ¡     //°ü½É
var
 Dell :Boolean;
begin  //CM_DELSHOPCART
 Dell:=False;
 if GetTickCount > g_dwQueryMsgTick then begin
   g_dwQueryMsgTick := GetTickCount + 1000;
   if shopbuysrt = '' then begin
    if Sender = DCategories13 then begin
     DMessageDlg ('ÇëÑ¡ÔñÐèÒªÉ¾³ýµÄÎïÆ·¡£', [mbOk]);
     exit;
     end;
   end;
  if Sender = DCategories12 then begin
     SendClientMessage(CM_DELSHOPCART, 1, 0, 0, 0,'');
     DScreen.AddChatBoardString ('ÊÕ²ØÁÐ±íÒÑ±»É¾³ý¡£', clGreen, clWhite);
  end;

  if Sender = DCategories13 then begin
    if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨ÒªÉ¾³ý' + shopbuysrt + 'Âð£¿', [mbYes, mbNo]) then begin
      SendClientMessage(CM_DELSHOPCART, 2, 0, 0, 0,shopbuysrt);
      DScreen.AddChatBoardString (shopbuysrt+'ÒÑ´ÓÊÕ²ØÁÐ±íÖÐÉ¾³ý¡£', clGreen, clWhite);
      shopbuysrt := '';
      Dell:=True;
    end;
  end;
 end;

 if Dell then begin
   SendClientMessage(CM_OPSHOPCART, 0, 0, 0, 0,'');
 end;
end;

procedure TFrmDlg.DItemShopJobAllDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if not d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DItemShopJobAllClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡
var
  sData : String;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 9;
      Reductionshopitemkey;
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopJobWarriorClick(Sender: TObject; X, Y: Integer);    //È¯»óÁ¡
var
  sData : String;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 1;
      DItemShopJobAll.SetImgIndex (g_WMainImages, 801);
      DItemShopJobWarrior.SetImgIndex (g_WMainImages, 802);
      DItemShopJobWizard.SetImgIndex (g_WMainImages, 805);
      DItemShopJobMonk.SetImgIndex (g_WMainImages, 807);
      DItemShopJobAssas.SetImgIndex (g_WMainImages, 778);
      DItemShopJobBonz.SetImgIndex (g_WAresImages, 412);
      DItemShopJobCommon.SetImgIndex (g_WMainImages, 809);
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopJobWizardClick(Sender: TObject; X, Y: Integer);    //È¯»óÁ¡
var
  sData : String;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 2;
      DItemShopJobAll.SetImgIndex (g_WMainImages, 801);
      DItemShopJobWarrior.SetImgIndex (g_WMainImages, 803);
      DItemShopJobWizard.SetImgIndex (g_WMainImages, 804);
      DItemShopJobMonk.SetImgIndex (g_WMainImages, 807);
      DItemShopJobAssas.SetImgIndex (g_WMainImages, 778);
      DItemShopJobBonz.SetImgIndex (g_WAresImages, 412);
      DItemShopJobCommon.SetImgIndex (g_WMainImages, 809);
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopJobMonkClick(Sender: TObject; X, Y: Integer);   //È¯»óÁ¡
var
  sData: string;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 3;
      DItemShopJobAll.SetImgIndex (g_WMainImages, 801);
      DItemShopJobWarrior.SetImgIndex (g_WMainImages, 803);
      DItemShopJobWizard.SetImgIndex (g_WMainImages, 805);
      DItemShopJobMonk.SetImgIndex (g_WMainImages, 806);
      DItemShopJobAssas.SetImgIndex (g_WMainImages, 778);
      DItemShopJobBonz.SetImgIndex (g_WAresImages, 412);
      DItemShopJobCommon.SetImgIndex (g_WMainImages, 809);
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopJobAssasClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡
var
  sData: string;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 1;
      DItemShopJobAll.SetImgIndex (g_WMainImages, 801);
      DItemShopJobWarrior.SetImgIndex (g_WMainImages, 803);
      DItemShopJobWizard.SetImgIndex (g_WMainImages, 805);
      DItemShopJobMonk.SetImgIndex (g_WMainImages, 807);
      DItemShopJobAssas.SetImgIndex (g_WMainImages, 777);
      DItemShopJobBonz.SetImgIndex (g_WAresImages, 412);
      DItemShopJobCommon.SetImgIndex (g_WMainImages, 809);
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopJobBonzClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡
var
  sData: string;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 4;
      DItemShopJobAll.SetImgIndex (g_WMainImages, 801);
      DItemShopJobWarrior.SetImgIndex (g_WMainImages, 803);
      DItemShopJobWizard.SetImgIndex (g_WMainImages, 805);
      DItemShopJobMonk.SetImgIndex (g_WMainImages, 807);
      DItemShopJobAssas.SetImgIndex (g_WMainImages, 778);
      DItemShopJobBonz.SetImgIndex (g_WAresImages, 411);
      DItemShopJobCommon.SetImgIndex (g_WMainImages, 809);
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopJobCommonClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡
var
  sData: string;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrJob := 5;
      DItemShopJobAll.SetImgIndex (g_WMainImages, 801);
      DItemShopJobWarrior.SetImgIndex (g_WMainImages, 803);
      DItemShopJobWizard.SetImgIndex (g_WMainImages, 805);
      DItemShopJobMonk.SetImgIndex (g_WMainImages, 807);
      DItemShopJobAssas.SetImgIndex (g_WMainImages, 778);
      DItemShopJobBonz.SetImgIndex (g_WAresImages, 412);
      DItemShopJobCommon.SetImgIndex (g_WMainImages, 808);
      if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
end;

procedure TFrmDlg.DItemShopCloseClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡ ´Ý±â
begin
  DItemShopDlg.Visible:=FALSE;
  EdShopEdit.Visible := False;
  SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
end;

procedure TFrmDlg.buyitemk1DirectPaint(Sender: TObject;         //È¯»óÁ¡
  dsurface: TDirectDrawSurface);
var
  d, e, ee: TDirectDrawSurface;
  pm: TSeveShopItem;
  newmodes: integer;
  ShopName: String;
begin
  newimgmode;
  with Sender as TDButton do begin
    pm := g_ShopItems[Tag];
    if pm.ShopItems.S.Name <> '' then begin

      if Tag = GameShopIndex then begin
        e := g_WMainImages.Images[811];
         if e <> nil then
           dsurface.Draw (SurfaceX(Left+2), SurfaceY(Top+1), e.ClientRect, e, TRUE);
      end;

      if pm.shopItemnew = 1 then newmodes := 850;
      if pm.ShopItemnew = 2 then newmodes := 845;
      if pm.ShopItemnew = 3 then newmodes := 840;

      if (pm.ShopItemnew in [1..3]) then begin
        ee := g_WMainImages.Images[newmodes + newimgIndex];
        if ee <> nil then
         dsurface.Draw (SurfaceX(Left+50), SurfaceY(Top+40), ee.ClientRect, ee, TRUE);
      end;

      d := g_WBagItemImages.Images[pm.ShopItems.s.Looks];
      if d <> nil then
       dsurface.Draw (SurfaceX(TDButton(Sender).Left + 1 + ((TDButton(Sender).Width - 40) - d.Width) div 2) ,  //20110712
         SurfaceY(TDButton(Sender).Top + ((TDButton(Sender).Height) - d.Height) div 2), d.ClientRect, d, TRUE);

       SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
       if pm.ShopItems.s.StdMode in [0,1,3,45,46] then begin  //¹°¾à
         dsurface.Canvas.Font.Color := clYellow;
         dsurface.Canvas.TextOut(SurfaceX(Left + 6),SurfaceY(Top + 42),IntToStr(pm.shopItemAmount));
         dsurface.Canvas.Font.Color := clWhite;
       end;
       Font.Color := clWhite;
       if pm.ShopItems.S.boOnlyHero then
         ShopName := StringReplace(pm.ShopItems.s.Name, '[Ó¢]', '', [rfReplaceAll])
       else
       ShopName := StringReplace(pm.ShopItems.s.Name, '(³èÎï)', '', [rfReplaceAll]);
       BoldTextOut(dsurface,SurfaceX(Left + 47) - (Dsurface.Canvas.TextWidth(ShopName) div 2),SurfaceY(Top + 8), clWhite, clBlack, ShopName);
       if pm.ShopItems.S.boOnlyHero then
         BoldTextOut(dsurface,SurfaceX(Left + 47) - (Dsurface.Canvas.TextWidth('(Ó¢ÐÛ×¨ÓÃ)') div 2),SurfaceY(Top + 23), clWhite, clBlack, '(Ó¢ÐÛ×¨ÓÃ)');
       BoldTextOut(dsurface,SurfaceX(Left + 46) - (Dsurface.Canvas.TextWidth(IntToStr(pm.ShopItemPrice)) div 2),SurfaceY(Top + 80),clWhite,clBlack, GetGoldStr(pm.ShopItemPrice));
       dsurface.Canvas.Release;
    end;
  end;
end;

procedure TFrmDlg.buyitemk1Click(Sender: TObject; X, Y: Integer);     //È¯»óÁ¡
var
     sData, sData1, sData2:String;
begin
  with Sender as TDButton do begin
    DScreen.ClearHint;
    GameShopIndex := Tag;

    shopbuysrt := g_ShopItems[GameShopIndex].ShopItems.S.Name;
    shopbuyamoin := g_ShopItems[GameShopIndex].ShopItems.Amount;
    shopbuypier := inttostr(g_ShopItems[GameShopIndex].ShopItemPrice);
  end;
end;

procedure TFrmDlg.DItemShopListPrevClick(Sender: TObject; X, Y: Integer);
var
  sData: string;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
     if Sender = DItemShopListPrev then begin
       if (g_ShopCurrPage = 1) then exit;
       if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(g_ShopCurrPage-1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(g_ShopCurrPage-1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
       SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
     end else begin
       if (g_ShopCurrPage = g_ShopAmountofPages) then exit;
       if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(g_ShopCurrPage+1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(g_ShopCurrPage+1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
       SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
     end;
     g_dwQueryMsgTick := GetTickCount + 1000;
   end;
end;

procedure TFrmDlg.DItemShopGetGiftDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
           dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
     end;
   end;
end;

procedure TFrmDlg.DItemShopGetGiftClick(Sender: TObject; X, Y: Integer);      //È¯»óÁ¡
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if not GiftsDT.Visible then begin
      SendClientMessage(CM_GIFTSITEMS, 0, 0, 0, 0,'');
      Giftsstrcls := -1;
    end else begin
      GiftsDT.Visible := false;
      FrmDlg.closeGiftsDTListDlg;
      Giftsstrcls := -1;
    end;
  end;
end;

procedure TFrmDlg.DItemShopAddFavClick(Sender: TObject; X, Y: Integer);  //È¯»óÁ¡   //°ü½É
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if shopbuysrt = '' then begin
     DMessageDlg ('ÇëÑ¡ÔñÒªÌí¼Óµ½ÊÕ²ØÁÐ±íÖÐµÄÎïÆ·¡£', [mbOk]);
     exit;
    end;
    SendClientMessage(CM_MYSHOPCART,  shopbuyamoin, 0, 0, 0, shopbuysrt);
  end;
end;

procedure TFrmDlg.DItemShopByeClick(Sender: TObject; X, Y: Integer);   //È¯»óÁ¡
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if shopbuysrt = '' then begin
      DMessageDlg('ÇëÑ¡ÔñÄúÒª¹ºÂòµÄÎïÆ·¡£', [mbOk]);
      exit;
    end;
    if mrYes = FrmDlg.DMessageDlg('ÄãÏë»¨·Ñ' + shopbuypier + 'µãÈ¯¹ºÂòÉÌÆ·'+ shopbuysrt + 'Âð£¿', [mbYes, mbNo]) then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      FrmMain.Sendshopbuyitem(shopbuysrt);
    end;
  end;
end;

procedure TFrmDlg.DItemShopGiftClick(Sender: TObject; X, Y: Integer);
var
 sGiftAdd:String;
begin
   if shopbuysrt <> '' then begin
     if mrYes = FrmDlg.DMessageDlg('ÄãÏë»¨·Ñ' + shopbuypier + 'µãÈ¯¹ºÂòÉÌÆ·ËÍ¸ø'+ shopbuysrt + 'Âð£¿', [mbYes, mbNo]) then begin

       FrmDlg.DlgEditText := '';
       FrmDlg.DMessageDlg ('ÇëÊäÈëÄãÒªÔùËÍÀñÎïµÄÈËÔ±µÄÃû×Ö¡£', [mbOk, mbAbort]);
       sGiftAdd := Trim(FrmDlg.DlgEditText);
       if (sGiftAdd <> '') and (length(sGiftAdd) >= 3) then begin
         SendClientMessage(CM_LIPEITEMSTR, 0, 0, 0, 0, sGiftAdd + '\' + shopbuysrt+ '\' +shopbuypier);
       end else begin
         DScreen.AddChatBoardString('ÄúµÄÀñÎïÒÑ±»È¡Ïû¡£', clGreen,clWhite);
       end;
     end;

   end else begin
   DMessageDlg ('ÇëÑ¡ÔñÒªÔùËÍµÄÎïÆ·¡£', [mbOk]);
   exit;
   end;
end;

procedure TFrmDlg.DCategories6DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
Var
d: TDButton;
dd, e: TDirectDrawSurface;
ShopCaView:string;
begin
  if Sender = DCategories6 then ShopCaView := 'Ò©Ë®';
  if Sender = DCategories7 then ShopCaView := '¶©µ¥';
  if Sender = DCategories8 then ShopCaView := 'ÆäËû';
  if Sender = DCategories9 then ShopCaView := 'Ãæ¾ß';
  if Sender = DCategories10 then ShopCaView := 'ÁÄÌì';
  if Sender = DCategories14 then ShopCaView := '×øÆï';
  if Sender = DCategories15 then ShopCaView := '³èÎï';
  if Sender = DCategories16 then ShopCaView := 'ÆäËû';
  if Sender = DCategories18 then ShopCaView := '³èÎïµ°';
  if Sender = DCategories19 then ShopCaView := 'ËÇÁÏ';
  if Sender = DCategories20 then ShopCaView := '¹¦ÄÜ';
  if Sender = DCategories21 then ShopCaView := 'ÆäËû';

   with Sender as TDButton do begin
    d := TDButton(Sender);
    if  g_ShopCurrSection = d.Tag then begin
     e := d.WLib.Images[FaceIndex+1];
     end else begin
     e := nil;
     end;
      if not d.Downed then
         dd := d.WLib.Images[FaceIndex]
      else dd := d.WLib.Images[FaceIndex+1];
      if dd <> nil then
         dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      if e <> nil then
         dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), e.ClientRect, e, TRUE);

   SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
   dsurface.Canvas.Font.Size :=9;
   if Sender <> DCategories11 then
   BoldTextOut (dsurface, SurfaceX(Left + 10),
   SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(ShopCaView)) div 2 + 1), clWhite , clBlack, ShopCaView);
   dsurface.Canvas.Release;
 end;
end;

procedure TFrmDlg.DCategories6Click(Sender: TObject; X, Y: Integer);
var
  sData: string;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 1000;
      DScreen.ClearHint;
      g_ShopCurrSection := TDButton(Sender).Tag;
      g_ShopCurrJob := 9;
      Reductionshopitemkey;

      sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
      SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
   g_MouseItem.S.Name := '';
end;


procedure TFrmDlg.DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
Var
 sMsg : String;
 nLocalX, nLocalY, nHintX, nHintY :Integer;
begin
   DScreen.ClearHint;
   if Sender = DBotUp then begin
     nLocalX:=DBotUp.LocalX(X - DBotUp.Left);
     nLocalY:=DBotUp.LocalY(Y - DBotUp.Top);
     nHintX:=DBotUp.SurfaceX(DBotUp.Left) + DItemBag.SurfaceX(DItemBag.Left) + nLocalX;
     nHintY:=DBotUp.SurfaceY(DBotUp.Top) + DItemBag.SurfaceY(DItemBag.Top) + nLocalY;
     sMsg:= 'Ë¢ÐÂ°ü¹ü';
     DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
     exit;
   end else begin
     X := DItemBag.LocalX (X) - DItemBag.Left;
     Y := DItemBag.LocalY (Y) - DItemBag.Top;
     if ((X >=  182) and (X <=  262)) and ((Y >=  216) and (Y <=  222)) then begin
       sMsg := format('ÖØÁ¿%d/%d',[g_MySelf.m_Abil.Weight,g_MySelf.m_Abil.MaxWeight]);
       DScreen.ShowHintA(DItemBag.Left + 196, DItemBag.Top + 230, sMsg, clYellow, TRUE);
       exit;
     end;
   end;
end;


procedure TFrmDlg.DBHomeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin


   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
        dd := d.WLib.Images[d.FaceIndex + 2];
      end else
      if d.MouseMoveing then begin
        dd := d.WLib.Images[d.FaceIndex + 1];
      end else begin
        if Sender = DBStorage then begin
          if (BlinkCount mod 2 = 0) and (g_nBonusPoint > 0) then dd := d.WLib.Images[d.FaceIndex + 1]
          else dd := d.WLib.Images[d.FaceIndex];
        end else begin
          dd := d.WLib.Images[d.FaceIndex];
        end;
      end;
      if dd <> nil then
         dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);

      if GetTickCount - BlinkTime >= 500 then begin
         BlinkTime := GetTickCount;
         Inc (BlinkCount);
         if BlinkCount >= 10 then BlinkCount := 0;
      end;
   end;
end;


procedure TFrmDlg.DBotMenuClick(Sender: TObject; X, Y: Integer);
begin
 DMenuWindows.Visible := not DMenuWindows.Visible;
end;

procedure TFrmDlg.DMenuWindowsMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
begin
  Butt:=TDButton(Sender);
  if Sender = DBotExit then sMsg:= 'ÍË³ö<CO$FFFF>(Alt + Q)<CE>'
  else if Sender = DBotLogout then sMsg:= '×¢Ïú<CO$FFFF>(Alt + X)<CE>'
  else if Sender = DBotHelp then sMsg:= '°ïÖú<CO$FFFF>(H)<CE>'
  else if Sender = DMake then sMsg:= '½»Ò×<CO$FFFF>(T)<CE>'
  else if Sender = DBotPet then sMsg:= '³èÎï<CO$FFFF>(E)<CE>'
  else if Sender = DBotTrade then sMsg:= '½»Ò×<CO$FFFF>(T)<CE>'
  else if Sender = DBotRank then sMsg:= 'ÅÅÐÐ°ñ'
  else if Sender = DBotTiger then sMsg:= '×øÆï<CO$FFFF>(J)<CE>'
  else if Sender = DBotReady2 then sMsg:= 'µöÓã<CO$FFFF>(N)<CE>'
  else if Sender = DBotFriend then sMsg:= 'ÅóÓÑ<CO$FFFF>(W)<CE>'
  else if Sender = DBotLover then sMsg:= '»éÒö<CO$FFFF>(L)<CE>'
  else if Sender = DBotMaster then sMsg:= 'Ê¦Í½<CO$FFFF>(F)<CE>'
  else if Sender = DBotGroup then sMsg:= '×é¶Ó<CO$FFFF>(P)<CE>'
  else if Sender = DBotGuild then sMsg:= 'ÐÐ»á<CO$FFFF>(G)<CE>';


  nHintX:=Butt.SurfaceX(Butt.Left);
  nHintY:=Butt.SurfaceY(Butt.Top + 38);
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clWhite, TRUE);
end;

procedure TFrmDlg.DScrollBottomDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         if not d.DontDrawUp then dd := d.WLib.Images[d.FaceIndex+1]
         else  dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end
      else if not d.DontDrawUp then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DBotOptionClick(Sender: TObject; X, Y: Integer);
begin
 {DBHome.Visible := not DBHome.Visible;
 DBStorage.Visible := not DBStorage.Visible;
 DBAuction.Visible := not DBAuction.Visible;
 DBScreen.Visible := not DBScreen.Visible;
 DBReady2.Visible := not DBReady2.Visible;

 DExpMode.Visible := not DExpMode.Visible;
 DBReady4.Visible := not DBReady4.Visible;
 DLoverMacro.Visible  := not DLoverMacro.Visible;
 DBReady3.Visible  := not DBReady3.Visible;
 DPetEat.Visible  := not DPetEat.Visible;    }
end;


procedure TFrmDlg.DViewMiniMapMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
begin
  DScreen.ClearHint;
  g_nMiniMapX:= -1;
  Butt:=TDButton(Sender);
  if Sender = DBotMiniMap then sMsg:= 'Ð¡µØÍ¼<CO$FFFF>(V)<CE>'
  else if Sender = DBotMemo then sMsg := 'ÓÊ¼þ<CO$FFFF>(M)<CE>'
  else if Sender = DBotBigMap then sMsg := '´óµØÍ¼<CO$FFFF>(B)<CE>'
  else if Sender = DBotDura then sMsg := '<CO$FFFF>Ö÷Ìå³Ö¾Ã¶È<CE>'
  else if Sender = DBotDura2 then sMsg := '<CO$FFFF>×°±¸³Ö¾Ã¶È<CE>'
  else if Sender = DDayBright then begin
      case g_nDayBright of            //¾ÆÄ§ Àú³è »õº®
         0: sMsg := '<CO$FFFF>ÀèÃ÷<CE>';  //»õº®
         1: sMsg := '<CO$FFFF>°×Ìì<CE>';  //³·
         2: sMsg := '<CO$FFFF>»Æ»è<CE>';  //Àú³á
         3: sMsg := '<CO$FFFF>Ò¹Íí<CE>';  //¹ã
      end;
  end;

  nLocalX:=Butt.LocalX(X - Butt.Left);
  nLocalY:=Butt.LocalY(Y - Butt.Top);
  nHintX:=Butt.SurfaceX(Butt.Left) + DViewMiniMap.SurfaceX(DViewMiniMap.Left) + nLocalX;
  nHintY:=Butt.SurfaceY(Butt.Top) + DViewMiniMap.SurfaceY(DViewMiniMap.Top) + nLocalY + 30;

  DScreen.ShowHintA(nHintX,nHintY,sMsg, clWhite, FALSE);
end;

procedure TFrmDlg.DViewMiniMapDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with sender as TDWindow do begin
   if ((g_boViewMiniMap) or (DMiniMap.Visible)) and (g_nMiniMapIndex <> -1) then begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex - 1];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
        DMiniMap.Visible := True;
        DBotMemo.Top := 131;
        DBotBigMap.Top := 131;
        DDayBright.Top := 131;
        DBotDura.Top := 156;
        DBotDura2.Top := 156;
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT) ;

        if g_nAreaStateValue and $01 <> 0 then begin
          BoldTextOut (dsurface, SurfaceX(Left + 63) - dsurface.Canvas.TextWidth(g_sMapTitle + '<Á¬½Ó>') div 2 , SurfaceY(Top + 6), clWhite, clBlack, g_sMapTitle + '<Á¬½Ó>');    //¸ÊÀÌ¸§ ÁÂÇ¥
        end else begin
          BoldTextOut (dsurface, SurfaceX(Left + 63) - dsurface.Canvas.TextWidth(g_sMapTitle) div 2 , SurfaceY(Top + 6), clWhite, clBlack, g_sMapTitle);    //¸ÊÀÌ¸§ ÁÂÇ¥
        end;
        if EffectNum <> 3 then begin
          if g_nMiniMapX >= 0 then begin
            BoldTextOut (dsurface, SurfaceX(Left + 52), SurfaceY(Top + 135), clLime, clBlack, IntToStr(g_nMiniMapMosX) + ':' + IntToStr(g_nMiniMapMosY));
          end else begin
            BoldTextOut (dsurface, SurfaceX(Left + 52), SurfaceY(Top + 135), clWhite, clBlack, IntToStr(g_MySelf.m_nCurrX) + ':' + IntToStr(g_MySelf.m_nCurrY));    //¸ÊÀÌ¸§ ÁÂÇ¥
          end;
        end;
        dsurface.Canvas.Release;
      end;
    end;
   end else begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
        DMiniMap.Visible := False;
        DBotBigMap.Top := 21;
        DBotMemo.Top := 21;
        DDayBright.Top := 21;
        DBotDura.Top := 47;
        DBotDura2.Top := 47;
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT) ;
        if g_nAreaStateValue and $01 <> 0 then begin
          BoldTextOut (dsurface, SurfaceX(Left + 63) - dsurface.Canvas.TextWidth(g_sMapTitle + '<Á¬½Ó>') div 2 , SurfaceY(Top + 6), clWhite, clBlack, g_sMapTitle + '<Á¬½Ó>'); //¸ÊÀÌ¸§ ÁÂÇ¥
        end else begin
          BoldTextOut (dsurface, SurfaceX(Left + 63) - dsurface.Canvas.TextWidth(g_sMapTitle) div 2 , SurfaceY(Top + 6), clWhite, clBlack, g_sMapTitle);  //¸ÊÀÌ¸§ ÁÂÇ¥
        end;
        if EffectNum <> 3 then begin
          if g_nMiniMapX >= 0 then begin
            BoldTextOut (dsurface, SurfaceX(Left + 52), SurfaceY(Top + 26), clLime, clBlack, IntToStr(g_nMiniMapMosX) + ':' + IntToStr(g_nMiniMapMosY));
          end else begin
            BoldTextOut (dsurface, SurfaceX(Left + 52), SurfaceY(Top + 26), clWhite, clBlack, IntToStr(g_MySelf.m_nCurrX) + ':' + IntToStr(g_MySelf.m_nCurrY));    //¸ÊÀÌ¸§ ÁÂÇ¥
          end;
        end;

        dsurface.Canvas.Release;
      end;
    end;

   end;
  end;
end;

procedure TFrmDlg.DBotBigMapClick(Sender: TObject; X, Y: Integer);
begin
   if (g_nMapIndex < 1) then
       DScreen.AddChatBoardString('Ö»ÄÜÏÔÊ¾´óµØÍ¼¡£', clGreen, clWhite)
   else begin
     if (not DBigMapDlg.Visible) and (not g_boViewMap) then begin
       g_nViewMapLv := 1;
       g_boViewMap := TRUE;
       DBigMapDlg.Visible := True;
     end else begin
       if g_nViewMapLv >= 2 then begin
         g_nViewMapLv := 0;
         g_boViewMap := FALSE;
         DBigMapDlg.Visible := False;
       end else Inc(g_nViewMapLv);
     end;
    { if (not FrmDlg.DBigMapDlg.Visible) and (not g_boViewMap) then begin
       g_nViewMapLv := 1;
       g_boViewMap := TRUE;
     end else begin
       if g_nViewMapLv >= 3 then begin
         g_nViewMapLv := 0;
         FrmDlg.DBigMapDlg.Visible := False;
       end else
       if g_nViewMapLv = 2 then begin
         g_nViewMapLv := 3;
         g_boViewMap := FALSE;
         FrmDlg.DBigMapDlg.Visible := True;
       end else Inc(g_nViewMapLv);
     end;   }
   end;
end;

procedure TFrmDlg.DDayBrightDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 d : TDirectDrawSurface;
begin
 with DDayBright do begin
   case g_nDayBright of            //¾ÆÄ§ Àú³è »õº®
     0: d := WLib.Images[2092];  //»õº®
     1: d := WLib.Images[2093];  //³·
     2: d := WLib.Images[2094];  //Àú³á
     3: d := WLib.Images[2095];  //¹ã
   end;
   if d <> nil then
    dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
 end;
end;


procedure TFrmDlg.SetChatFocus;
begin
   EdShopEdit.Visible := False;      //È¯»óÁ¡
   EdSalesEdit.Visible := False;  //À§Å¹
   CostSalesEdit.Visible := False;
   PlayScene.EdChat.Visible := TRUE;
   PlayScene.EdChat.SetFocus;
end;


procedure TFrmDlg.Dshoppe1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx: integer;
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   idx := TDButton(Sender).Tag + Mensellidx;
   Butt:=TDButton(Sender);
   if G_BuyItem[idx].entItem.S.Name <> '' then begin
     g_MouseItem := G_BuyItem[idx].entItem;
     GetMouseItemHint (g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
       nLocalX:=Butt.LocalX(X - Butt.Left);
       nLocalY:=Butt.LocalY(Y - Butt.Top);
       nHintX:=Butt.SurfaceX(Butt.Left) + DShopMenuDlg.SurfaceX(DShopMenuDlg.Left) + nLocalX + 5;
       nHintY:=Butt.SurfaceY(Butt.Top) + DShopMenuDlg.SurfaceY(DShopMenuDlg.Top) + nLocalY + 5;
       DScreen.ShowHintS(nHintX, nHintY, HintList, FALSE);
     end;
   end;
   g_MouseItem.S.Name := '';
end;


procedure TFrmDlg.DShopMenuOkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
   if FrmDlg.BoMakeItemMenu then begin
      DShopMenuOk.SetImgIndex (g_WTitleImages, 456);
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end else begin
      DShopMenuOk.SetImgIndex (g_WTitleImages, 453);
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
  end;
end;




procedure TFrmDlg.DUser2Click(Sender: TObject; X, Y: Integer);
begin
 DUserInfo.Visible := NOT DUserInfo.Visible;
end;

procedure TFrmDlg.DUserInfoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d, e, f: TDirectDrawSurface;
   bbx, bby, l, m, i : integer;
   fstr,fstr1: String;
begin
   with dsurface.Canvas do begin
      with DUserInfo do begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

         if UserState1.Job in [4, 9] then begin
          e := g_WAresImages.Images[495];
          if e <> nil then
            dsurface.Draw (SurfaceX(Left+32), SurfaceY(Top+52), e.ClientRect, e, TRUE);
         end else begin
          i := 1770 + UserState1.Job + (UserState1.Sex * 10);
          e := g_WMainImages.Images[i];
          if e <> nil then
            dsurface.Draw (SurfaceX(Left+32), SurfaceY(Top+52), e.ClientRect, e, TRUE);
         end;

          if UserInfoPage = 1 then begin
            f := g_WGuildImages.Images[USerState1.GuildMark];
               if e <> nil then
                 dsurface.Draw (SurfaceX(Left+40), SurfaceY(Top+130), f.ClientRect, f, TRUE);
          end;

            l := Left + 62;
            m := Top + 110;
            with dsurface.Canvas do begin
               SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
               Font.Color := clWhite;
               Font.Size := 9;

               TextOut (SurfaceX(Left)+ 92 , SurfaceY(Top + 69), 'µÈ¼¶: ' + IntToStr(UserState1.Level));

               fstr := Copy(UserState1.FameName, 1, pos(' ', UserState1.FameName)-1 );
               Font.Color := clWhite;
               TextOut (SurfaceX(Left)+ 92 , SurfaceY(Top + 52), '³ÆºÅ: ' + UserState1.FameName);
               Font.Color := clLime;
               TextOut (SurfaceX(Left)+ 92 , SurfaceY(Top + 52), '¡¡¡¡¡¡' + fstr);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left)+ 14 , SurfaceY(Top + 95), '-----------------------------------------');

               TextOut (SurfaceX(Left)+ 127 , SurfaceY(Top + 296), IntToStr(UserInfoPage+1)+'/2');

             if UserInfoPage = 0 then begin
               Font.Style := [fsBold];
               fstr1 := UserState1.UserName + ' µÄÈËÎïÐÅÏ¢' ;
               TextOut (SurfaceX(Left)+ 137 - TextWidth(fstr1) div 2, SurfaceY(Top + 12), fstr1);
               Font.Style := [];

               TextOut (SurfaceX(l+0), SurfaceY(m),        'AC¡¡¡¡¡¡¡¡¡¡¡¡¡¡' +  IntToStr(LoWord(UserState1.AC)) + '-' + IntToStr(HiWord(UserState1.AC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*1)), 'MAC¡¡¡¡ ¡¡¡¡¡¡¡¡' +  IntToStr(LoWord(UserState1.MAC)) + '-' + IntToStr(HiWord(UserState1.MAC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*2)), 'DC¡¡¡¡¡¡¡¡¡¡¡¡¡¡' +  IntToStr(LoWord(UserState1.DC)) + '-' + IntToStr(HiWord(UserState1.DC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*3)), 'MC¡¡¡¡¡¡¡¡¡¡¡¡¡¡' +  IntToStr(LoWord(UserState1.MC)) + '-' + IntToStr(HiWord(UserState1.MC)));
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*4)), 'SC¡¡¡¡¡¡¡¡¡¡¡¡¡¡' +  IntToStr(LoWord(UserState1.SC)) + '-' + IntToStr(HiWord(UserState1.SC)));
               Font.Color := clCream;
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*5)), 'Kill/Death¡¡¡¡¡¡' +  IntToStr(USerState1.KillPoint) + '/' + IntToStr(USerState1.DeathPoint));
               if USerState1.KillPoint > 0 then
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*6)), 'WinExp¡¡¡¡¡¡¡¡¡¡' +  FormatFloat('0.00%',(USerState1.KillPoint / (USerState1.KillPoint + USerState1.DeathPoint)) * 100))
               else
               TextOut (SurfaceX(l+0), SurfaceY(m+(22*6)), 'WinExp¡¡¡¡¡¡¡¡¡¡' +  '0.00%');
               Font.Color := clWhite;
               Font.Size := 9;
             end else begin
               Font.Style := [fsBold];
               fstr1 := UserState1.UserName + ' µÄÐÐ»áÐÅÏ¢';
               TextOut (SurfaceX(Left)+ 137 - TextWidth(fstr1) div 2, SurfaceY(Top + 12), fstr1);
               Font.Style := [];
               Font.Color := clLime;
               TextOut (SurfaceX(Left + 26), SurfaceY(m),'ÐÐ»áÐÅÏ¢');
               Font.Color := clWhite;
               TextOut (SurfaceX(l+30), SurfaceY(m), 'ÐÐ»áÃû×Ö: ' + UserState1.GuildName);
               TextOut (SurfaceX(l+30), SurfaceY(m+(22)), 'ÐÐ»áÕÆÃÅ: ' + UserState1.GuildOwnerName);
               TextOut (SurfaceX(l+30), SurfaceY(m+(22*2)), 'ÐÐ»á³ÉÔ±Êý: ' + IntToStr(UserState1.GuildList));
             end;

               dsurface.Canvas.Release;
            end;

      end;
   end;
end;

procedure TFrmDlg.DUserInfoExitClick(Sender: TObject; X, Y: Integer);
begin
   DUserInfo.Visible := False;
end;

procedure TFrmDlg.DUserInfoMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);
  if Sender = DPrevInfo then sMsg:= 'ÉÏÒ»Ò³'
  else if Sender = DNextInfo then sMsg:= 'ÏÂÒ»Ò³';

  nHintX:=Butt.SurfaceX(Butt.Left + 20);
  nHintY:=Butt.SurfaceY(Butt.Top + 20);
  DScreen.ShowHintA(nHintX,nHintY,sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.buyitemk1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var                                                 //À§Å¹ ´Ý±â
   adx:Integer;
   nLocalX,nLocalY,nHintX,nHintY:Integer;
   Butt: TDButton;
begin
   DScreen.ClearHint;
   adx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   if g_ShopItems[adx].ShopItems.S.Name <> '' then begin
     g_MouseItem := g_ShopItems[adx].ShopItems;
     GetMouseItemHint (g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
        nLocalX:=Butt.LocalX(X - Butt.Left);
        nLocalY:=Butt.LocalY(Y - Butt.Top);
        nHintX:=Butt.SurfaceX(Butt.Left) + DItemShopDlg.SurfaceX(DItemShopDlg.Left) + nLocalX;
        nHintY:=Butt.SurfaceY(Butt.Top) + DItemShopDlg.SurfaceY(DItemShopDlg.Top) + nLocalY;
       with Butt as TDButton do                      //ÈùÆ®
        DScreen.ShowHintS(nHintX, nHintY, HintList, FALSE);
     end;
   end;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DItmeDuraWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e,f: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DItmeDuraWin do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
       DrawBlendEx (dsurface, SurfaceX(Left),SurfaceY(Top), d, 0, 0, {d.Width} 56 , {d.Height} 80, 0);
      f := g_WMainImages.Images[2105];
      if f <> nil then
        dsurface.Draw (SurfaceX(Left - 2), SurfaceX(Top -2), f.ClientRect, f, TRUE);

      if g_UseItems[U_WEAPON].S.Name <> '' then begin    //¹«±â
        d := g_WMainImages.Images[2125];
       if (g_UseItems[U_WEAPON].Dura / g_UseItems[U_WEAPON].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2126];
       if (g_UseItems[U_WEAPON].Dura / g_UseItems[U_WEAPON].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2127];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 4), SurfaceX(Top + 4), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_DRESS].S.Name <> '' then begin      //¿Ê
        d := g_WMainImages.Images[2149];
       if (g_UseItems[U_DRESS].Dura / g_UseItems[U_DRESS].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2150];
       if (g_UseItems[U_DRESS].Dura / g_UseItems[U_DRESS].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2151];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 16), SurfaceX(Top + 11), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_HELMET].S.Name <> '' then begin       //Åõ±¸
        d := g_WMainImages.Images[2155];
       if (g_UseItems[U_HELMET].Dura / g_UseItems[U_HELMET].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2156];
       if (g_UseItems[U_HELMET].Dura / g_UseItems[U_HELMET].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2157];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 24), SurfaceX(Top + 2), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_RIGHTHAND].S.Name <> '' then begin        //È¶ºÒ
        d := g_WMainImages.Images[2146];
       if (g_UseItems[U_RIGHTHAND].Dura / g_UseItems[U_RIGHTHAND].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2147];
       if (g_UseItems[U_RIGHTHAND].Dura / g_UseItems[U_RIGHTHAND].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2148];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 43), SurfaceX(Top + 7), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_NECKLACE].S.Name <> '' then begin     //¸ñ°ÉÀÌ
        d := g_WMainImages.Images[2122];
       if (g_UseItems[U_NECKLACE].Dura / g_UseItems[U_NECKLACE].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2123];
       if (g_UseItems[U_NECKLACE].Dura / g_UseItems[U_NECKLACE].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2124];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 3), SurfaceX(Top + 66), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_ARMRINGL].S.Name <> '' then begin     //ÆÈÂî¿ÞÂÊ
        d := g_WMainImages.Images[2143];
       if (g_UseItems[U_ARMRINGL].Dura / g_UseItems[U_ARMRINGL].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2144];
       if (g_UseItems[U_ARMRINGL].Dura / g_UseItems[U_ARMRINGL].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2145];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 43), SurfaceX(Top + 45), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_ARMRINGR].S.Name <> '' then begin      //ÆÈÂî ¿À¸¥ÂÊ
        d := g_WMainImages.Images[2143];
       if (g_UseItems[U_ARMRINGR].Dura / g_UseItems[U_ARMRINGR].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2144];
       if (g_UseItems[U_ARMRINGR].Dura / g_UseItems[U_ARMRINGR].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2145];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 3), SurfaceX(Top + 45), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_RINGL].S.Name <> '' then begin      //¹ÝÁö ¿ÞÂÊ
        d := g_WMainImages.Images[2131];
       if (g_UseItems[U_RINGL].Dura / g_UseItems[U_RINGL].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2132];
       if (g_UseItems[U_RINGL].Dura / g_UseItems[U_RINGL].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2133];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 43), SurfaceX(Top + 54), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_RINGR].S.Name <> '' then begin     //¹ÝÁö ¿À¸¥ÂÊ
        d := g_WMainImages.Images[2131];
       if (g_UseItems[U_RINGR].Dura / g_UseItems[U_RINGR].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2132];
       if (g_UseItems[U_RINGR].Dura / g_UseItems[U_RINGR].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2133];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 3), SurfaceX(Top + 54), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_BUJUK].S.Name <> '' then begin  //ºÎÀû
        d := g_WMainImages.Images[2134];
       if (g_UseItems[U_BUJUK].Dura / g_UseItems[U_BUJUK].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2135];
       if (g_UseItems[U_BUJUK].Dura / g_UseItems[U_BUJUK].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2136];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 17), SurfaceX(Top + 54), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_CHARM].S.Name <> '' then begin    //¼öÈ£¼®
        d := g_WMainImages.Images[2137];
       if (g_UseItems[U_CHARM].Dura / g_UseItems[U_CHARM].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2138];
       if (g_UseItems[U_CHARM].Dura / g_UseItems[U_CHARM].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2139];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 30), SurfaceX(Top + 54), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_BELT].S.Name <> '' then begin    //º§Æ®
        d := g_WMainImages.Images[2158];
       if (g_UseItems[U_BELT].Dura / g_UseItems[U_BELT].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2159];
       if (g_UseItems[U_BELT].Dura / g_UseItems[U_BELT].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2160];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 22), SurfaceX(Top + 23), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_BOOTS].S.Name <> '' then begin    //½Å¹ß
        d := g_WMainImages.Images[2152];
       if (g_UseItems[U_BOOTS].Dura / g_UseItems[U_BOOTS].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2153];
       if (g_UseItems[U_BOOTS].Dura / g_UseItems[U_BOOTS].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2154];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 17), SurfaceX(Top + 43), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_TIGER].S.Name <> '' then begin    //Å»°Í
        d := g_WMainImages.Images[2140];
       if (g_UseItems[U_TIGER].Dura / g_UseItems[U_TIGER].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2141];
       if (g_UseItems[U_TIGER].Dura / g_UseItems[U_TIGER].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2142];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 43), SurfaceX(Top + 66), d.ClientRect, d, TRUE);
      end;

   end;
end;

procedure TFrmDlg.DBotDuraClick(Sender: TObject; X, Y: Integer);
begin
   DItmeDuraWin.Visible := not DItmeDuraWin.Visible;
end;

procedure TFrmDlg.DDealDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
 DScreen.ClearHint;
end;

procedure TFrmDlg.DMakeClick(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    FrmMain.SendDealTry;   //°Å·¡
  end;

   {Msg:='Á¦ÀÛ±â¼úÀ» ÀÌ¿ëÇÏ½Ã°Ú½À´Ï±î?';
   if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
        FrmMain.SendSay ('@Á¦ÀÛ±â¼ú');
   end;  }
end;

procedure TFrmDlg.DFishDlgDirectPaint(Sender: TObject;   //³¬½Ã
  dsurface: TDirectDrawSurface);
var
   d,dd: TDirectDrawSurface;
   ax,ay:integer;
begin
  if g_Myself = nil then exit;
   with DFishDlg do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      if g_UseItems[U_WEAPON].S.Name <> '' then begin
        if g_UseItems[U_WEAPON].S.Shape in [47] then begin  //Æò¹ü, ´Ù³¬¾Æ
          if (g_UseItems[U_FISH1].S.Name = '') then
            dd := FrmMain.GetWStateImg(1333, ax, ay)
          else dd := FrmMain.GetWStateImg(1334, ax, ay);
          if dd <> nil then
           dsurface.Draw (SurfaceX(Left+10+ax), SurfaceY(Top+40+ay), dd.ClientRect, dd, TRUE);
        end;
        if g_UseItems[U_WEAPON].S.Shape in [48] then begin   //ÅÂ°ø
          if (g_UseItems[U_FISH1].S.Name = '') then
            dd := FrmMain.GetWStateImg(1335, ax, ay)
          else dd := FrmMain.GetWStateImg(1336, ax, ay);
          if dd <> nil then
           dsurface.Draw (SurfaceX(Left+10+ax), SurfaceY(Top+40+ay), dd.ClientRect, dd, TRUE);
        end;
      end;

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         if (g_UseItems[U_WEAPON].S.Name <> '') and (g_UseItems[U_WEAPON].S.Shape in [47,48]) then begin
           TextOut (SurfaceX(Left + 98 - TextWidth(g_UseItems[U_WEAPON].S.Name) div 2), SurfaceY(Top + 10), g_UseItems[U_WEAPON].S.Name);
         end;
         Release;
      end;
      
   end;
end;

procedure TFrmDlg.DFishDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DSCreen.ClearHint;
  g_MouseStateItem.S.Name := '';
end;

procedure TFrmDlg.DFishExitClick(Sender: TObject; X, Y: Integer);   //³¬½Ã Á¾·á
begin
  DFishDlg.Visible := False;
end;

procedure TFrmDlg.DFISH1DirectPaint(Sender: TObject;  //³¬ÀÌ ¾ÆÀÌÅÛ ºÎºÐ
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
      if Sender = DFISH1 then begin
         if g_UseItems[U_FISH1].S.Name <> '' then begin
            idx := g_UseItems[U_FISH1].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DFISH1.SurfaceX(DFISH1.Left + (DFISH1.Width - d.Width) div 2),
                                 DFISH1.SurfaceY(DFISH1.Top + (DFISH1.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DFISH2 then begin
         if g_UseItems[U_FISH2].S.Name <> '' then begin
            idx := g_UseItems[U_FISH2].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DFISH2.SurfaceX(DFISH2.Left + (DFISH2.Width - d.Width) div 2),
                                 DFISH2.SurfaceY(DFISH2.Top + (DFISH2.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DFISH3 then begin
         if g_UseItems[U_FISH3].S.Name <> '' then begin
            idx := g_UseItems[U_FISH3].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DFISH3.SurfaceX(DFISH3.Left + (DFISH3.Width - d.Width) div 2),
                                 DFISH3.SurfaceY(DFISH3.Top + (DFISH3.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DFISH4 then begin
         if g_UseItems[U_FISH4].S.Name <> '' then begin
            idx := g_UseItems[U_FISH4].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DFISH4.SurfaceX(DFISH4.Left + (DFISH4.Width - d.Width) div 2),
                                 DFISH4.SurfaceY(DFISH4.Top + (DFISH4.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
      if Sender = DFISH5 then begin
         if g_UseItems[U_FISH5].S.Name <> '' then begin
            idx := g_UseItems[U_FISH5].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx);
               if d <> nil then
                  dsurface.Draw (DFISH5.SurfaceX(DFISH5.Left + (DFISH5.Width - d.Width) div 2),
                                 DFISH5.SurfaceY(DFISH5.Top + (DFISH5.Height - d.Height) div 2),
                                 d.ClientRect, d, TRUE);
            end;
         end;
      end;
end;

procedure TFrmDlg.DFISH1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  sel: integer;
  Butt:TDButton;
begin
   sel := -1;
   Butt:=TDButton(Sender);
   if Sender = DFISH1 then sel := U_FISH1
   else if Sender = DFISH2 then sel := U_FISH2
   else if Sender = DFISH3 then sel := U_FISH3
   else if Sender = DFISH4 then sel := U_FISH4
   else if Sender = DFISH5 then sel := U_FISH5;

   if sel >= 0 then begin
     g_MouseItem := g_UseItems[sel];
     GetMouseItemHint (g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
       nLocalX:=Butt.LocalX(X - Butt.Left);
       nLocalY:=Butt.LocalY(Y - Butt.Top);
       nHintX:=Butt.SurfaceX(Butt.Left) + DFishDlg.SurfaceX(DFishDlg.Left) + nLocalX;
       nHintY:=Butt.SurfaceY(Butt.Top) + DFishDlg.SurfaceY(DFishDlg.Top) + nLocalY;
       with Butt as TDButton do
        DScreen.ShowHintB(nHintX, nHintY, HintList, TRUE);
     end else g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DFISH1Click(Sender: TObject; X, Y: Integer); //³¬½Ã ¾ÆÀÌÅÛ Âø¿ë
var
   where, n, sel: integer;
   flag, movcancel: Boolean;
begin
 if g_FishingOk = FALSE then begin
   if g_MySelf = nil then exit;
   if g_boItemMoving then begin
      flag := FALSE;
      movcancel := FALSE;
      if (g_MovingItem.Owner = DItemStore) then exit;
      if (g_MovingItem.Owner = DDealDlg) or (g_MovingItem.Owner = DHeroStateWin) then Exit;
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      where := GetTakeOnPositionTiger (g_MovingItem.Item.S.StdMode);
      if g_MovingItem.Index >= 0 then begin
         case where of
            U_FISH1: begin
               if Sender = DFISH1 then begin
                  where := U_FISH1;
                  flag := TRUE;
               end;
            end;
            U_FISH2: begin
               if Sender = DFISH2 then begin
                  where := U_FISH2;
                  flag := TRUE;
               end;
            end;
            U_FISH3: begin
               if Sender = DFISH3 then begin
                  where := U_FISH3;
                  flag := TRUE;
               end;
            end;
            U_FISH4: begin
               if Sender = DFISH4 then begin
                  where := U_FISH4;
                  flag := TRUE;
               end;
            end;
            U_FISH5: begin
               if Sender = DFISH5 then begin
                  where := U_FISH5;
                  flag := TRUE;
               end;
            end;
          end;
      end else begin
        if (g_MovingItem.Owner = DStateWin) then begin
          n := -(g_MovingItem.Index+1);
          if n in [0..MAXUSEITEM] then begin   //¾ÆÀÌÅÛ °¹¼ö
            ItemClickSound (g_MovingItem.Item.S);
            g_UseItems[n] := g_MovingItem.Item;
            g_MovingItem.Item.S.Name := '';
            g_boItemMoving := FALSE;
          end;
        end;
      end;
      if flag then begin
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DHeroItemBag) then begin
          if (g_MovingItem.Owner = DItemBag) then begin
            ItemClickSound (g_MovingItem.Item.S);
            g_WaitingUseItem := g_MovingItem;
            g_WaitingUseItem.Index := where;
            FrmMain.SendTakeOnItem (where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
            g_MovingItem.Item.S.Name := '';
            g_boItemMoving := FALSE;
          end else begin
            CancelHeroItemMoving;
            exit;
          end;
        end;
      end;
   end else begin
      flag := FALSE;
      if (g_MovingItem.Item.S.Name <> '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      sel := -1;
      if Sender = DFISH1 then sel := U_FISH1;
      if Sender = DFISH2 then sel := U_FISH2;
      if Sender = DFISH3 then sel := U_FISH3;
      if Sender = DFISH4 then sel := U_FISH4;
      if Sender = DFISH5 then sel := U_FISH5;
      
      if sel >= 0 then begin
         if g_UseItems[sel].S.Name <> '' then begin
            ItemClickSound (g_UseItems[sel].S);
            g_MovingItem.Index := -(sel+1);
            g_MovingItem.Item := g_UseItems[sel];
            g_UseItems[sel].S.Name := '';
            g_boItemMoving := TRUE;
            g_MovingItem.Owner := DStateWin;
            g_UseItems[sel].S.StdMode := 0;
         end;
      end;
   end;
 end;
end;

procedure TFrmDlg.DFishProgressDlgDirectPaint(Sender: TObject; //³¬½Ã ÁøÇà¹Ù
  dsurface: TDirectDrawSurface);
var
   d,e,dd: TDirectDrawSurface;
   rc,rd:TRect;
   r: Real;
   strs:string;
begin
 if g_Myself = nil then exit;
  with DFishProgressDlg do begin
   d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
     e:= g_WMainImages.Images[1346];
      if e <> nil then
      dsurface.Draw (SurfaceX(Left + 140), SurfaceY(Top + 34), e.ClientRect, e, TRUE);

     e:= g_WTitleImages.Images[45];
      if e <> nil then
      dsurface.Draw (SurfaceX(Left + 153), SurfaceY(Top + 33), e.ClientRect, e, TRUE);


      if g_UseItems[U_FISH5].S.Name <> '' then begin   //¸± Âø¿ëÇØ¾ß º¸ÀÎ´Ù.
       if g_UseItems[U_FISH5].Dura > 0 then
        DAutoFish.Visible := True;
      end else begin
        DAutoFish.Visible := False;
        g_AutoFish := False;
      end;

      d:= g_WMainImages.Images[1342];  //¼º°ø·ü ¹Ù
      if d <> nil then begin
       if (CheckFishSuccess  > 0) then begin
          rc := d.ClientRect;
          r := 100 / (CheckFishSuccess);
          if r > 0 then begin
             g_FishSuccess := Round (rc.Right / r);
             rc.Right := g_FishSuccess;
          end else
            rc.Right := 0;
          dsurface.Draw (SurfaceX(Left+14), SurfaceY(Top+64), rc, d, TRUE);
       end;
      end;

      if (g_FishTime > g_FishTiming) and (g_FishTime > 165) then begin
        if g_AutoRate = True then begin
           BitingFishExit;
           if g_boFishCatch then begin
             g_boFishCatch := False;
             SendClientMessage(CM_UPONFISH, 0, 0, 0, 0, '');  //³¬½Ã ¾ÆÀÌÅÛ È¹µæ ¿äÃ»
           end;
        end;
      end;

     dd := g_WMainImages.Images[1349];  //ÁøÇà ¹Ù
     if dd <> nil then begin
        rc := dd.ClientRect;
        if g_FishTime >= dd.Width then
          if (g_FishTime > g_FishTiming) then begin   //³¬À» Å¸ÀÌ¹Ö ¿À¸é
             BitingFishExit;
             if g_boFishCatch then begin
               g_boFishCatch := False;
               SendClientMessage(CM_UPONFISH2, 0, 0, 0, 0, '');  //³¬½Ã ¾ÆÀÌÅÛ È¹µæ ¿äÃ»
             end;
          end else begin
            ExitFishing;
          end;

         if g_FishTime > 0 then  rc.Right := g_FishTime
           else rc.Right := 0;
         dsurface.Draw (SurfaceX(Left+14), SurfaceY(Top+79), rc, dd, TRUE);
     end;

     strs := IntToStr(CheckFishSuccess) +'%';
     SetBkMode(dsurface.Canvas.Handle,TRANSPARENT);
     BoldTextOut (dsurface,SurfaceX(Left+122) - dsurface.Canvas.TextWidth(strs) div 2,SurfaceY(Top + 64),clwhite, clblack, strs);
     dsurface.Canvas.Release;
  end;
end;

procedure TFrmDlg.DProgressExitClick(Sender: TObject; X, Y: Integer); //ÁøÇà¹Ù Á¾·á
begin
  ExitFishing;
  g_AutoFish := False;
end;

procedure TFrmDlg.DCatchClick(Sender: TObject; X, Y: Integer);
begin
  if (g_FishTime > g_FishTiming) then begin       //³¬À» Å¸ÀÌ¹Ö ¿Â»óÅ¸
     g_AutoFish := False;
     BitingFishExit;                //³¬±â ¹öÆ° ´©¸¦¶§
     if g_boFishCatch then begin
       g_boFishCatch := False;
       SendClientMessage(CM_UPONFISH, 0, 0, 0, 0, '');  //³¬½Ã ¾ÆÀÌÅÛ È¹µæ ¿äÃ»
     end;
  end;
end;

procedure TFrmDlg.DCatchDirectPaint(Sender: TObject;   //³¬±â
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
        if (g_FishTime > g_FishTiming) then begin    //³¬À» Å¸ÀÌ¹Ö ¿Â»óÅ¸
         if (g_FishTime > 180) then begin
          d := g_WTitleImages.Images[140];
         end else
          d := g_WTitleImages.Images[142];
        end else
         d := WLib.Images[FaceIndex];
         if d <> nil then begin
           dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
         end;
       end else begin
         if (g_FishTime > g_FishTiming) then begin       //³¬À» Å¸ÀÌ¹Ö ¿Â»óÅ¸
          if (g_FishTime > 180) then begin
           d := g_WTitleImages.Images[140];
          end else
           d := g_WTitleImages.Images[170 + AutoTimeIdx];
         end else begin
          d := WLib.Images[FaceIndex];
         end;
          if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
       end;
   end;
end;

procedure TFrmDlg.DFishProgressDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nHintX,nHintY:Integer;
begin
   g_MouseStateItem.S.Name := '';
   DScreen.ClearHint;
   X := DFishProgressDlg.LocalX (X) - DFishProgressDlg.Left;
   Y := DFishProgressDlg.LocalY (Y) - DFishProgressDlg.Top;

   if (X > 14) and (X < 227) and (Y > 64) and (Y < 77) then begin
    DScreen.ShowHintA (DFishProgressDlg.Left, DFishProgressDlg.Top+86,
                        'µ±Ç°µÄµöÓã³É¹¦¸ÅÂÊ£º(×°±¸µÄ³É¹¦¸ÅÂÊ + »·¾³ÒòËØ)ÊÇµöÓãµÄ³É\' +
                        '¹¦¸ÅÂÊ¡£\' +
                        'µ±Äã×°±¸Ì½ÓãÆ÷Ê±£¬Ã¿´ÎµöÓãÊ§°Ü³É¹¦ÂÊ¶¼ÊÇÔö¼Ó£¬Ö±µ½ÄãµöÉÏÓã\' +
                        'ÎªÖ¹¡£', clYellow, FALSE);
     exit;
   end;

end;

procedure TFrmDlg.DCheckEscClick(Sender: TObject; X, Y: Integer);
begin
  g_CheckEsc := Not g_CheckEsc;   //Esc Å°·Î ³¬½Ã Á¾·á ÇÒ°ÇÁö
end;

procedure TFrmDlg.DCheckEscDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if not g_CheckEsc then begin    //Esc Å°·Î ³¬½Ã Á¾·á ÇÒ°ÇÁö
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex + 1];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DAutoFishDirectPaint(Sender: TObject;    //³¬½Ã ÀÚµ¿
  dsurface: TDirectDrawSurface);
var
   d ,e: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
     if g_AutoFish then begin
       d := WLib.Images[FaceIndex + 2];
     end else
     if MouseMoveing then begin
       d := WLib.Images[FaceIndex + 1];
     end else begin
       d := WLib.Images[FaceIndex];
     end;
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     if g_AutoFish then begin
       e := g_WmainImages.Images[1344];
     end else  e := g_WmainImages.Images[1343];
     if e <> nil then
       dsurface.Draw (SurfaceX(Left + 62), SurfaceY(Top), e.ClientRect, e, TRUE);

   end;
end;

procedure TFrmDlg.DAutoFishClick(Sender: TObject; X, Y: Integer);    //ÀÚµ¿ ³¬½Ã
begin
   g_AutoFish := not g_AutoFish;
end;

procedure TFrmDlg.DItmeDuraWin2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e,f: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DItmeDuraWin2 do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
       DrawBlendEx (dsurface, SurfaceX(Left),SurfaceY(Top), d, 0, 0, {d.Width} 56 , {d.Height} 80, 0);
      f := g_WMainImages.Images[2106];
      if f <> nil then
        dsurface.Draw (SurfaceX(Left - 2), SurfaceX(Top -2), f.ClientRect, f, TRUE);

      if g_UseItems[U_PETS1].S.Name <> '' then begin    //°í»ß
        d := g_WMainImages.Images[2122];
       if (g_UseItems[U_PETS1].Dura / g_UseItems[U_PETS1].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2123];
       if (g_UseItems[U_PETS1].Dura / g_UseItems[U_PETS1].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2124];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 3), SurfaceX(Top + 10), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_PETS2].S.Name <> '' then begin      //¹æ¿ï
        d := g_WMainImages.Images[2131];
       if (g_UseItems[U_PETS2].Dura / g_UseItems[U_PETS2].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2132];
       if (g_UseItems[U_PETS2].Dura / g_UseItems[U_PETS2].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2133];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 17), SurfaceX(Top + 10), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_PETS3].S.Name <> '' then begin       //¾ÈÀå
        d := g_WMainImages.Images[2143];
       if (g_UseItems[U_PETS3].Dura / g_UseItems[U_PETS3].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2144];
       if (g_UseItems[U_PETS3].Dura / g_UseItems[U_PETS3].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2155];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 31), SurfaceX(Top + 11), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_PETS4].S.Name <> '' then begin        //È«·ÃÁ¶
        d := g_WMainImages.Images[2128];
       if (g_UseItems[U_PETS4].Dura / g_UseItems[U_PETS4].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2129];
       if (g_UseItems[U_PETS4].Dura / g_UseItems[U_PETS4].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2130];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 45), SurfaceX(Top + 10), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_PETS5].S.Name <> '' then begin     //°¡¸é
        d := g_WMainImages.Images[2119];
       if (g_UseItems[U_PETS5].Dura / g_UseItems[U_PETS5].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2120];
       if (g_UseItems[U_PETS5].Dura / g_UseItems[U_PETS5].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2121];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 45), SurfaceX(Top + 25), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_FISH1].S.Name <> '' then begin     //³¬½ËÁÙ°ú¹Ù´Ã
        d := g_WMainImages.Images[2128];
       if (g_UseItems[U_FISH1].Dura / g_UseItems[U_FISH1].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2129];
       if (g_UseItems[U_FISH1].Dura / g_UseItems[U_FISH1].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2130];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 5), SurfaceX(Top + 40), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_FISH2].S.Name <> '' then begin      //Âî
        d := g_WMainImages.Images[2137];
       if (g_UseItems[U_FISH2].Dura / g_UseItems[U_FISH2].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2138];
       if (g_UseItems[U_FISH2].Dura / g_UseItems[U_FISH2].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2139];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 3), SurfaceX(Top + 55), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_FISH3].S.Name <> '' then begin      //¹Ì³¢
        d := g_WMainImages.Images[2134];
       if (g_UseItems[U_FISH3].Dura / g_UseItems[U_FISH3].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2135];
       if (g_UseItems[U_FISH3].Dura / g_UseItems[U_FISH3].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2136];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 17), SurfaceX(Top + 55), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_FISH4].S.Name <> '' then begin     //¾î±º
        d := g_WMainImages.Images[2131];
       if (g_UseItems[U_FISH4].Dura / g_UseItems[U_FISH4].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2132];
       if (g_UseItems[U_FISH4].Dura / g_UseItems[U_FISH4].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2133];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 31), SurfaceX(Top + 55), d.ClientRect, d, TRUE);
      end;

      if g_UseItems[U_FISH5].S.Name <> '' then begin  //¸±
        d := g_WMainImages.Images[2119];
       if (g_UseItems[U_FISH5].Dura / g_UseItems[U_FISH5].DuraMax) < 50/100 then
        d := g_WMainImages.Images[2120];
       if (g_UseItems[U_FISH5].Dura / g_UseItems[U_FISH5].DuraMax) < 0.2 then
        d := g_WMainImages.Images[2121];
         if d <> nil then
         dsurface.Draw (SurfaceX(Left + 45), SurfaceX(Top + 56), d.ClientRect, d, TRUE);
      end;



   end;
end;

procedure TFrmDlg.DBotDura2Click(Sender: TObject; X, Y: Integer);
begin
  DItmeDuraWin2.Visible := not DItmeDuraWin2.Visible;
end;





procedure TFrmDlg.DDiceGameDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, e: TDirectDrawSurface;
begin
  with DDiceGame do begin
    d := WLib.Images[FaceIndex];
     if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    if StartDice then begin
      DiceImages;
      d := g_WMainImages.Images[290 + DiceimgIndex];
       if d <> nil then
        dsurface.Draw (SurfaceX(Left + 142), SurfaceY(Top + 92), d.ClientRect, d, TRUE);
    end else begin
      d := g_WMainImages.Images[MainDiceimg];
       if d <> nil then
        dsurface.Draw (SurfaceX(Left + 142), SurfaceY(Top + 92), d.ClientRect, d, TRUE);
    end;

    if MaxGame = 6 then begin
      FrmDlg.DDiceSelect1.Visible := True;
      FrmDlg.DDiceSelect2.Visible := True;
      FrmDlg.DDice1.Visible := False;
      FrmDlg.DDice2.Visible := False;
      FrmDlg.DDice3.Visible := False;
      FrmDlg.DDice4.Visible := False;
      FrmDlg.DDice5.Visible := False;
      FrmDlg.DDice6.Visible := False;
    end else begin
      FrmDlg.DDice1.Visible := True;
      FrmDlg.DDice2.Visible := True;
      FrmDlg.DDice3.Visible := True;
      FrmDlg.DDice4.Visible := True;
      FrmDlg.DDice5.Visible := True;
      FrmDlg.DDice6.Visible := True;
      FrmDlg.DDiceSelect1.Visible := False;
      FrmDlg.DDiceSelect2.Visible := False;
    end;
      with dsurface.Canvas do begin
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
        Font.Color := clWhite;
        if (CurrGame > MaxGame) then begin
          TextOut (SurfaceX(Left+14), SurfaceY(Top+12), '¹§Ï²Äã£¬Äã»ñµÃÁËÌôÕ½µÄÊ¤Àû¡£');
          TextOut (SurfaceX(Left+14), SurfaceY(Top+28), 'Çëµã»÷ÁìÈ¡°´Å¥ÁìÈ¡½±ÀøÎïÆ·¡£');
          DiceItemsrt := g_DiceItems[TagItem].Items.S.Name;
          DDiceGet.Visible := True;
          DDiceClose.Visible := False;
        end else begin
        if (SelectDice = 0) and (Succecs) then begin
          TextOut (SurfaceX(Left+14), SurfaceY(Top+12), 'Ñ¡ÔñÖÀ÷»×Ó£¬²¢µã»÷¿ªÊ¼°´Å¥¡£');
          TextOut (SurfaceX(Left+14), SurfaceY(Top+28), 'Äã±ØÐë½ÓÊÜÌôÕ½²ÅÓÐ»ú»á»ñµÃ½±Àø¡£');
          TextOut (SurfaceX(Left+14), SurfaceY(Top+44), 'Çëµã»÷ÁìÈ¡°´Å¥ÁìÈ¡½±ÀøÎïÆ·¡£');
          DiceItemsrt := g_DiceItems[TagItem].Items.S.Name;
          DDiceGet.Visible := True;
          DDiceClose.Visible := False;
        end else begin
        if Not Succecs then begin
          TextOut (SurfaceX(Left+14), SurfaceY(Top+12), 'ÌôÕ½Ê§°Ü£¬ÇëÖØÐÂ½ÓÊÜÌôÕ½¡£');
          DiceItemsrt := '';
          DDiceGet.Visible := False;
          DDiceClose.Visible := True;
        end else begin
        if Succecs then begin
          TextOut (SurfaceX(Left+14), SurfaceY(Top+12), 'Èç¹ûÄãÏë»ñÈ¡ÏÖÔÚµÄ½±Àø£¬Çëµã»÷ÁìÈ¡°´Å¥£»Ê§°ÜµÄ»°Äã½«');
          TextOut (SurfaceX(Left+14), SurfaceY(Top+28), 'Ê§È¥½±Àø¡£');
          TextOut (SurfaceX(Left+14), SurfaceY(Top+44), '3ÃëÖÓºó°´ÏÂÍ£Ö¹°´Å¥£¬ 5ÃëÖÓºó×Ô¶¯Í£Ö¹¡£');
          DiceItemsrt := g_DiceItems[TagItem].Items.S.Name;
          DDiceGet.Visible := True;
          DDiceClose.Visible := False;
        end;
        end;
        end;
        end;
        if StartDice then begin
          if GetTickCount - DiceStartTime > 3 * 1000 then begin
            Inc(TimeToDice , 2);
          end;
          if GetTickCount - DiceStartTime > 5 * 1000 then begin
            DDiceStopClick(Nil, 0, 0);
          end;
        end;
        TextOut (SurfaceX(Left+158), SurfaceY(Top+74), IntToStr(FakeGame) + '/' + IntToStr(MaxGame) + ' ¹Ø');
        TextOut (SurfaceX(Left+14), SurfaceY(Top+76), 'µ±Ç°ÎïÆ·');
        TextOut (SurfaceX(Left+267) , SurfaceY(Top+76), 'ÏÂÒ»¸öÎïÆ·');
        dsurface.Canvas.Release;
      end;

  end;
end;

procedure TFrmDlg.DDiceStartDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DDiceCloseClick(Sender: TObject; X, Y: Integer);
begin
  ClearDiceDlg;
  DDiceGame.Visible := FALSE;
end;

procedure TFrmDlg.DChangeItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, e :TDirectDrawSurface;
begin
  with Sender as TDWindow do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    e := g_WTitleImages.Images[44];
    if e <> nil then
      dsurface.Draw (SurfaceX(Left + 37), SurfaceY(Top + 5), e.ClientRect, e, TRUE);

    SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
    BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 95), clWhite, clBlack, 'ÎïÆ·¸ÄÃû');
    BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 115), clWhite, clBlack, 'ÊÊÓÃÀàÐÍ: ÎäÆ÷/ÒÂ·þ/×øÆï');
    dsurface.Canvas.Release;
  end;
end;

procedure TFrmDlg.DChangeItemMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
 DScreen.ClearHint;
end;

procedure TFrmDlg.DStartChangeClick(Sender: TObject; X, Y: Integer);
var
  ChangeItem:TChangeSystem;
  sData:string;
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 5000;
    ChangeItem.Item1 := g_ChangeItem1.MakeIndex;
    ChangeItem.Item2 := g_ChangeItem2.MakeIndex;
    ChangeItem.Item3 := g_ChangeItem3.MakeIndex;
    ChangeItem.Item4 := g_ChangeItem4.MakeIndex;
    ChangeItem.Item5 := g_ChangeItem5.MakeIndex;
    ChangeItem.Item6 := g_ChangeItem6.MakeIndex;

    SData := IntToStr(ChangeItem.Item1) + '/' + inttostr(ChangeItem.Item2) + '/' + inttostr(ChangeItem.Item3) + '/' + inttostr(ChangeItem.Item4) + '/' + inttostr(ChangeItem.Item5) + '/' + inttostr(ChangeItem.Item6);
    SendClientMessage(CM_CHANGESYSTEM, 0, 0, 0, 0, sData);
  end;
  //DChangeItem.Visible := False;
end;

procedure TFrmDlg.DCloseChangeClick(Sender: TObject; X, Y: Integer);
begin
 CancelChanging;
 DChangeItem.Visible := False;
end;

procedure TFrmDlg.DChangeItem1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
  if not g_boItemMoving then begin
      if g_ChangeItem1.S.Name <> '' then begin
         ItemClickSound (g_ChangeItem1.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -100;
         g_MovingItem.Item := g_ChangeItem1;
         g_ChangeItem1.S.Name := '';
         g_MovingItem.Owner := DChangeItem;
         g_ChangeItem1.MakeIndex := 0;
      end;
  end else begin
    if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.S.ChangeItem) and (g_MovingItem.Item.S.btValue[19] in [0,2]) then begin
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DChangeItem) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_ChangeItem1.S.Name <> '' then begin
          temp:=g_ChangeItem1;
          g_ChangeItem1 := g_MovingItem.Item;
          g_MovingItem.Index := -100;
          g_MovingItem.Owner := DChangeItem;
          g_MovingItem.Item := temp
        end else begin
          g_ChangeItem1 := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_MovingItem.Owner := nil;
          g_boItemMoving := FALSE;
        end;
      end;
    end else begin
      CancelItemMoving;
      DMessageDlg ('Õâ¼þÎïÆ·ÎÞ·¨¸Ä±ä¡£',[mbOk]);
    end;
  end;
end;

procedure TFrmDlg.DChangeItem1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ChangeItem1.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ChangeItem1.S.Looks];
      if d <> nil then
         with DChangeItem1 do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DChangeItem1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_ChangeItem1;
   Butt:=TDButton(Sender);
   GetMouseItemHint(g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DChangeItem.SurfaceX(DChangeItem.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DChangeItem.SurfaceY(DChangeItem.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DChangeItem2Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
  if not g_boItemMoving then begin
      if g_ChangeItem2.S.Name <> '' then begin
         ItemClickSound (g_ChangeItem2.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -100;
         g_MovingItem.Item := g_ChangeItem2;
         g_MovingItem.Owner := DChangeItem;
         g_ChangeItem2.S.Name := '';
         g_ChangeItem2.MakeIndex := 0;
      end;
  end else begin
    if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.S.ChangeItem) and (g_MovingItem.Item.S.btValue[19] in [0,2]) then begin
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DChangeItem) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_ChangeItem2.S.Name <> '' then begin
            temp:=g_ChangeItem2;
            g_ChangeItem2 := g_MovingItem.Item;
            g_MovingItem.Index := -100;
            g_MovingItem.Owner := DChangeItem;
            g_MovingItem.Item := temp
        end else begin
            g_ChangeItem2 := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
        end;
      end;
    end else begin
      CancelItemMoving;
      DMessageDlg ('Õâ¼þÎïÆ·ÎÞ·¨¸Ä±ä¡£',[mbOk]);
    end;
   end;
end;

procedure TFrmDlg.DChangeItem2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ChangeItem2.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ChangeItem2.S.Looks];
      if d <> nil then
         with DChangeItem2 do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DChangeItem2MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_ChangeItem2;
   Butt:=TDButton(Sender);
   GetMouseItemHint(g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DChangeItem.SurfaceX(DChangeItem.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DChangeItem.SurfaceY(DChangeItem.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DChangeItem3Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_ChangeItem3.S.Name <> '' then begin
         ItemClickSound (g_ChangeItem3.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -100;
         g_MovingItem.Item := g_ChangeItem3;
         g_ChangeItem3.S.Name := '';
         g_MovingItem.Owner := DChangeItem;
         g_ChangeItem3.MakeIndex := 0;
      end;
  end else begin
    if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.S.ChangeItem) and (g_MovingItem.Item.S.btValue[19] in [0,2]) then begin
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DChangeItem) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_ChangeItem3.S.Name <> '' then begin
            temp:=g_ChangeItem3;
            g_ChangeItem3 := g_MovingItem.Item;
            g_MovingItem.Index := -100;
            g_MovingItem.Item := temp;
            g_MovingItem.Owner := DChangeItem;
        end else begin
            g_ChangeItem3 := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
        end;
      end;
    end else begin
      CancelItemMoving;
      DMessageDlg ('Õâ¼þÎïÆ·ÎÞ·¨¸Ä±ä¡£',[mbOk]);
    end;  
   end;
end;

procedure TFrmDlg.DChangeItem3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ChangeItem3.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ChangeItem3.S.Looks];
      if d <> nil then
         with DChangeItem3 do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DChangeItem3MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_ChangeItem3;
   Butt:=TDButton(Sender);
   GetMouseItemHint(g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DChangeItem.SurfaceX(DChangeItem.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DChangeItem.SurfaceY(DChangeItem.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DChangeItem4Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_ChangeItem4.S.Name <> '' then begin
         ItemClickSound (g_ChangeItem4.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -100;
         g_MovingItem.Item := g_ChangeItem4;
         g_ChangeItem4.S.Name := '';
         g_MovingItem.Owner := DChangeItem;
         g_ChangeItem4.MakeIndex := 0;
      end;
  end else begin
    if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.S.ChangeItem) and (g_MovingItem.Item.S.btValue[19] in [0,2]) then begin
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DChangeItem) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_ChangeItem4.S.Name <> '' then begin
            temp:=g_ChangeItem4;
            g_ChangeItem4 := g_MovingItem.Item;
            g_MovingItem.Index := -100;
            g_MovingItem.Owner := DChangeItem;
            g_MovingItem.Item := temp
        end else begin
            g_ChangeItem4 := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
        end;
      end;
    end else begin
      CancelItemMoving;
      DMessageDlg ('Õâ¼þÎïÆ·ÎÞ·¨¸Ä±ä¡£',[mbOk]);
    end;  
   end;
end;

procedure TFrmDlg.DChangeItem4DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ChangeItem4.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ChangeItem4.S.Looks];
      if d <> nil then
         with DChangeItem4 do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DChangeItem4MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_ChangeItem4;
   Butt:=TDButton(Sender);
   GetMouseItemHint(g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DChangeItem.SurfaceX(DChangeItem.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DChangeItem.SurfaceY(DChangeItem.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DChangeItem5Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_ChangeItem5.S.Name <> '' then begin
         ItemClickSound (g_ChangeItem5.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -100;
         g_MovingItem.Item := g_ChangeItem5;
         g_MovingItem.Owner := DChangeItem;
         g_ChangeItem5.S.Name := '';
         g_ChangeItem5.MakeIndex := 0;
      end;
  end else begin
    if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.S.ChangeItem) and (g_MovingItem.Item.S.btValue[19] in [0,2]) then begin
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DChangeItem) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_ChangeItem5.S.Name <> '' then begin
            temp:=g_ChangeItem5;
            g_ChangeItem5 := g_MovingItem.Item;
            g_MovingItem.Index := -100;
            g_MovingItem.Item := temp;
            g_MovingItem.Owner := DChangeItem;
        end else begin
            g_ChangeItem5 := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
            g_MovingItem.Owner := nil;
        end;
      end;
    end else begin
      CancelItemMoving;
      DMessageDlg ('Õâ¼þÎïÆ·ÎÞ·¨¸Ä±ä¡£',[mbOk]);
    end;  
   end;
end;

procedure TFrmDlg.DChangeItem5DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ChangeItem5.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ChangeItem5.S.Looks];
      if d <> nil then
         with DChangeItem5 do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DChangeItem5MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_ChangeItem5;
   Butt:=TDButton(Sender);
   GetMouseItemHint(g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DChangeItem.SurfaceX(DChangeItem.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DChangeItem.SurfaceY(DChangeItem.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DChangeItem6Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_ChangeItem6.S.Name <> '' then begin
         ItemClickSound (g_ChangeItem6.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -100;
         g_MovingItem.Item := g_ChangeItem6;
         g_ChangeItem6.S.Name := '';
         g_MovingItem.Owner := DChangeItem;
         g_ChangeItem6.MakeIndex := 0;
      end;
  end else begin
     if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
     if (g_MovingItem.Item.S.ChangeItem) and (g_MovingItem.Item.S.btValue[19] in [0,2]) then begin
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DChangeItem) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_ChangeItem6.S.Name <> '' then begin
            temp:=g_ChangeItem6;
            g_ChangeItem6 := g_MovingItem.Item;
            g_MovingItem.Index := -100;
            g_MovingItem.Owner := DChangeItem;
            g_MovingItem.Item := temp
        end else begin
            g_ChangeItem6 := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
            g_boItemMoving := FALSE;
        end;
      end;
    end else begin
      CancelItemMoving;
      DMessageDlg ('Õâ¼þÎïÆ·ÎÞ·¨¸Ä±ä¡£',[mbOk]);
    end;  
   end;
end;

procedure TFrmDlg.DChangeItem6DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ChangeItem6.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ChangeItem6.S.Looks];
      if d <> nil then
         with DChangeItem6 do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DChangeItem6MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_ChangeItem6;
   Butt:=TDButton(Sender);
   GetMouseItemHint(g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DChangeItem.SurfaceX(DChangeItem.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DChangeItem.SurfaceY(DChangeItem.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;


procedure TFrmDlg.DPrevInfoClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DPrevInfo then begin
    if UserInfoPage > 0 then begin
      UserInfoPage := 0;
   end;
  end else begin
     UserInfoPage := 1;
  end;
end;












procedure TFrmDlg.DUser2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex + 1];
      end else
         d := WLib.Images[FaceIndex];

      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DExChangeDlgDirectPaint(Sender: TObject;   //È¯Àü
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
 with DExChangeDlg do begin
   d := WLib.Images[FaceIndex];
    if d <> nil then
     dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     with Dsurface.Canvas do begin
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      Font.Color := $00ADD6EF;
      Font.Size := 11;
      Font.Style := [fsBold];
      if ExChangePage = 0 then begin
       TextOut (SurfaceX(Left+34), SurfaceY(Top+9), '¶Ò»»: ½ð±Ò=>µãÈ¯');
      end else
       TextOut (SurfaceX(Left+34), SurfaceY(Top+9), '¶Ò»»: µãÈ¯=>½ð±Ò');
      Font.Color := clWhite;
      Font.Size := 9;
      Font.Style := [];

      if ExChangePage = 0 then begin
       TextOut (SurfaceX(Left+34), SurfaceY(Top+34), '½ð±Ò¶Ò»»µãÈ¯');
       Font.Color := clYellow;
       TextOut (SurfaceX(Left+34), SurfaceY(Top+50), '¼Û¸ñ: 10000½ð±Ò¶Ò»»' + FloatToStr(10000 * g_nExChgGameGoldRate) + 'µãÈ¯ (±ÈÀý: ' + FloatToStr(g_nExChgGameGoldRate) + ')' );
       Font.Color := clWhite;
       TextOut (SurfaceX(Left+34), SurfaceY(Top+86), 'Ê¹ÓÃ ½ð±Ò');
       TextOut (SurfaceX(Left+34), SurfaceY(Top+140), '¶Ò»» (µãÈ¯)');
      end else begin
       TextOut (SurfaceX(Left+34), SurfaceY(Top+34), 'µãÈ¯¶Ò»»½ð±Ò');
       Font.Color := clYellow;
       TextOut (SurfaceX(Left+34), SurfaceY(Top+50), '¼Û¸ñ: 1µãÈ¯¶Ò»»' + IntToStr(1 * g_nExChgGoldRate) + '½ð±Ò (±ÈÀý: ' + IntToStr(g_nExChgGoldRate)+ ')' );
       Font.Color := clWhite;
       TextOut (SurfaceX(Left+34), SurfaceY(Top+86), 'Ê¹ÓÃ µãÈ¯');
       TextOut (SurfaceX(Left+34), SurfaceY(Top+140), '¶Ò»» (½ð±Ò)');
      end;

      Font.Size := 10;
      if ExChangePage = 0 then begin
       TextOut (SurfaceX(Left+75), SurfaceY(Top+105), GetGoldStr(g_MySelf.m_nGold) + ' ½ð±Ò');
       TextOut (SurfaceX(Left+75), SurfaceY(Top+159), GetGoldStr(g_nExChangeGameGold) + ' µãÈ¯');
      end else begin
       TextOut (SurfaceX(Left+75), SurfaceY(Top+105), GetGoldStr(g_MySelf.m_nGameGold) + ' µãÈ¯');
       TextOut (SurfaceX(Left+75), SurfaceY(Top+159), GetGoldStr(g_nExChangeGold) + ' ½ð±Ò');
      end;
      Font.Size := 9;
      dsurface.Canvas.Release;
     end;

  end;
end;

procedure TFrmDlg.DExitChangeClick(Sender: TObject; X, Y: Integer);   //È¯Àü
begin
   DExChangeDlg.Visible := False;
   FrmMain.SendCancelExChange;
end;



procedure TFrmDlg.DExGoldChangeClick(Sender: TObject; X, Y: Integer);
begin
  if ExChangePage < 1 then begin
   ExChangePage := 1;
   ExChangePageChanged;
  end else begin
   ExChangePage := 0;
   ExChangePageChanged;
  end;
end;

procedure TFrmDlg.DExGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with Sender as TDButton do begin
    if Downed then
      d := WLib.Images[FaceIndex]
    else
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DExGoldClick(Sender: TObject; X, Y: Integer);
begin
   if g_MySelf = nil then exit;
   if not g_boItemMoving then begin
      if g_MySelf.m_nGold > 0 then begin
         PlaySound (s_money);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -98;
         g_MovingItem.Item.S.Name := g_sGoldName;
      end;
   end else begin
      if (g_MovingItem.Index = -96) or (g_MovingItem.Index = -98) then begin
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name := '';
         if g_MovingItem.Index = -96 then begin
            DealZeroGold;
         end;
      end;
   end;
end;

procedure TFrmDlg.DExHwanClick(Sender: TObject; X, Y: Integer);   //¹ÐÈ¯
begin
   if g_MySelf = nil then exit;
   if not g_boItemMoving then begin
      if g_MySelf.m_nGameGold > 0 then begin
         PlaySound (s_money);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -95;
         g_MovingItem.Item.S.Name := g_sGameGoldName;
      end;
   end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) then begin
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name := '';
         if g_MovingItem.Index = -94 then begin
            DealZeroGold;
         end;
      end;
   end;
end;

procedure TFrmDlg.DDExHwanClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then exit;
   if g_nExChangeGameGold <> 0 then exit;
      if not g_boItemMoving then begin
         if g_nExChangeGold > 0 then begin
            PlaySound (s_money);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := -96;
            g_MovingItem.Item.S.Name := g_sGoldName;
         end;
      end else begin
         if (g_MovingItem.Index = -96) or (g_MovingItem.Index = -98) then begin
            if (g_MovingItem.Index = -98) then begin
               if g_MovingItem.Item.S.Name = g_sGoldName then begin

                  DialogSize := 1;
                  g_boItemMoving := FALSE;
                  g_MovingItem.Item.S.Name := '';
                  DMessageDlg ('ÄãÈ·¶¨Òª¶Ò»» ' +g_sGoldName+ '½ð±ÒÂð£¿'+
                        '\' +' ¡ù×¢Òâ: ËùÓÐ¶¼¿ÉÒÔ¶Ò»»½ð±Ò', [mbOk, mbAbort]);
                  GetValidStrVal (DlgEditText, valstr, [' ']);
                  dgold := Str_ToInt (valstr, 0);
                  if (dgold <= (g_nExChangeGold+g_MySelf.m_nGold)) and (dgold > 9999) then begin
                     FrmMain.SendChangeExChangeGold (dgold);
                  end else
                     dgold := 0;
               end;
            end;
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.Name := '';
         end;
      end;
end;

procedure TFrmDlg.DDExGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then exit;
   if g_nExChangeGold <> 0 then exit;
      if not g_boItemMoving then begin
         if g_nExChangeGameGold > 0 then begin
            PlaySound (s_money);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := -94;
            g_MovingItem.Item.S.Name := g_sGameGoldName;
         end;
      end else begin
         if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) then begin
            if (g_MovingItem.Index = -95) then begin
               if g_MovingItem.Item.S.Name = g_sGameGoldName then begin

                  DialogSize := 1;
                  g_boItemMoving := FALSE;
                  g_MovingItem.Item.S.Name := '';
                  DMessageDlg ('ÄãÈ·¶¨Òª¶Ò»» ' +g_sGameGoldName+ 'µãÈ¯Âð£¿', [mbOk, mbAbort]);
                  GetValidStrVal (DlgEditText, valstr, [' ']);
                  dgold := Str_ToInt (valstr, 0);
                  if (dgold <= (g_nExChangeGameGold+g_MySelf.m_nGameGold)) and (dgold > 0) then begin
                     FrmMain.SendChangeExChangeGameGold (dgold);
                  end else
                     dgold := 0;
               end;
            end;
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.Name := '';
         end;
      end;
end;

procedure TFrmDlg.DGetExChangeClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    if ((g_nExChangeGold = 0) and (g_nExChangeGameGold = 0)) then exit;
       FrmMain.SendExChangeEnd;
       g_dwQueryMsgTick := GetTickCount + 1000;
  end;
end;

procedure TFrmDlg.DUpWeaponDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DUpWeapon do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := $00ADD6EF;
         Font.Style := [fsBold];
         Font.Size := 11;
         TextOut (SurfaceX(Left+36), SurfaceY(Top+12), 'Éý¼¶ÎäÆ÷');
         Font.Size := 9;
         Font.Style := [];
         Release;
      end;
   end;
end;

procedure TFrmDlg.DUpWeaponSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_UpWapon.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_UpWapon.S.Looks];
      if d <> nil then
         with DUpWeaponSpot do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DUpWeaponSpotClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_UpWapon.S.Name <> '' then begin
         ItemClickSound (g_UpWapon.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -99;
         g_MovingItem.Item := g_UpWapon;
         g_MovingItem.Owner := DUpWeapon;
         g_UpWapon.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;

      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DUpWeapon) then begin
         ItemClickSound (g_MovingItem.Item.S);
         if CheckUpWeapon(g_MovingItem.Item.S.StdMode) and (g_MovingItem.Item.S.btValue[19] = 0) then begin  //À¯´ÏÅ© ±â°£Á¦ ´ë¿©¹«±â Á¦·Ãx
           if g_UpWapon.S.Name <> '' then begin
             temp := g_UpWapon;
             g_UpWapon := g_MovingItem.Item;
             g_MovingItem.Index := -99;
             g_MovingItem.Item := temp;
             g_MovingItem.Owner := DUpWeapon;
           end else begin
             g_UpWapon := g_MovingItem.Item;
             g_MovingItem.Item.S.name := '';
             g_MovingItem.Owner := nil;
             g_boItemMoving := FALSE;
           end;
         end else begin
           CancelItemMoving;
           DMessageDlg ('Õâ¼þÎäÆ÷²»ÄÜÉý¼¶¡£',[mbOk]);
         end;
      end;
   end;
end;


procedure TFrmDlg.DUpWeaponSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_UpWapon;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DUpWeapon.SurfaceX(DUpWeapon.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DUpWeapon.SurfaceY(DUpWeapon.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;


procedure TFrmDlg.DStoreGridWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  sStoreName: string;
begin

  with DStoreGridWin do begin
   d := WLib.Images[FaceIndex];
    if d <> nil then
     dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    d:= g_WMainImages.Images[1346];
    if d <> nil then
     dsurface.Draw (SurfaceX(Left + 22), SurfaceY(Top + 290), d.ClientRect, d, TRUE);

    if g_MySelf.m_boStartStore then begin
      EdStoreMsgEdit.Visible := False;
      EdStoreMacrosEdit.Visible := False;
    end else begin
      EdStoreMsgEdit.Left := SurfaceX(Left+82);
      EdStoreMsgEdit.Top := SurfaceY(Top+243);
   //   EdStoreMsgEdit.Visible := True;
      EdStoreMacrosEdit.Left := SurfaceX(Left+82);
      EdStoreMacrosEdit.Top := SurfaceY(Top+214);
   //   EdStoreMacrosEdit.Visible := True;
    end;

    with Dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);
      Font.Color := clWhite;
      Font.Style := [fsBold];
      Font.Size := 10;
      sStoreName := g_MySelf.m_sUserName + ' ÉÌµê';
      TextOut(SurfaceX(Left) + (94 - TextWidth(sStoreName) div 2), SurfaceY(Top) + 51, sStoreName);

      if g_MySelf.m_boStartStore then begin
        Font.Color := clRed;
        TextOut(SurfaceX(Left) + 170, SurfaceY(Top) + 51, 'ÒÑ³öÊÛ');
      end else begin
        Font.Color := clLime;
        TextOut(SurfaceX(Left) + 170, SurfaceY(Top) + 51, '³öÊÛÖÐ');
      end;
      Font.Color := clWhite;
      Font.Size := 9;
      Font.Style := [];
      TextOut(SurfaceX(Left + 43) , SurfaceY(Top) + 291, 'Ê¹ÓÃº°»°');

      if g_MySelf.m_boStartStore then begin
        TextOut(SurfaceX(Left + 82), SurfaceY(Top + 243), Copy(EdStoreMsgEdit.Text,1,28));
        TextOut(SurfaceX(Left + 82), SurfaceY(Top + 214), Copy(EdStoreMacrosEdit.Text,1,28));
      end else begin
        if (not EdStoreMsgEdit.Visible) then begin
          TextOut(SurfaceX(Left + 82), SurfaceY(Top + 243), Copy(EdStoreMsgEdit.Text,1,28));
        end;
        if (not EdStoreMacrosEdit.Visible) then begin
          TextOut(SurfaceX(Left + 82), SurfaceY(Top + 214), Copy(EdStoreMacrosEdit.Text,1,28));
        end;
      end;
      Release;
    end;

  end;
end;

procedure TFrmDlg.DStoreCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseStoreDlg;
end;

procedure TFrmDlg.DStoreDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DGStoreGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx: integer;
   nWhere: Integer;
   List: TStringList;
begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
   idx := ACol + ARow * DGStore.ColCount;
   if idx in [0..14] then begin
     g_MouseItem :=  g_StoreItems[idx].Item;
     if (g_MouseItem.s.Name <> '') then begin
       nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
       if (nWhere >= 0) then begin

         List := TStringList.Create;
         try
           GetMouseItemHint(g_MySelf, @g_MouseItem);
           HintList.AddObject('¡¡',TObject(GetRGB(248)));
           if g_StoreItems[Idx].btSellType = 1 then
             HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreItems[idx].Item.S.Price) + ' ' + GetStorePriceName(g_StoreItems[Idx].btSellType), TObject(clAqua))
           else HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreItems[idx].Item.S.Price) + ' ' + GetStorePriceName(g_StoreItems[Idx].btSellType), TObject(clLime));
           List.AddStrings(HintList);

           GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
           if HintList.Count > 0 then begin
             HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];      //°³ÀÎ»óÁ¡
           end;
           with DGStore do
             DScreen.ShowHintL(SurfaceX(Left + (x - left)) + 30, SurfaceY(Top + (y - Top) + 30), List, HintList, False);
           HintList.Clear;
         finally
           FreeAndNil(List);
         end;
         g_MouseItem.s.Name := '';
       end else begin
         GetMouseItemHint(g_MySelf, @g_MouseItem);
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if g_StoreItems[Idx].btSellType = 1 then
           HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreItems[idx].Item.S.Price) + ' ' + GetStorePriceName(g_StoreItems[Idx].btSellType), TObject(clAqua))
         else HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreItems[idx].Item.S.Price) + ' ' + GetStorePriceName(g_StoreItems[Idx].btSellType), TObject(clLime));

         with DGStore do
           DScreen.ShowHintB(SurfaceX(Left + (x - left)) + 30, SurfaceY(Top + (y - Top) + 30), HintList, False);
       end;
     end;
   end else begin
     g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DGStoreGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TGridDrawState; dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
   idx := ACol + ARow * DGStore.ColCount;
   if idx in [0..14] then begin
      if g_StoreItems[idx].Item.S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_StoreItems[idx].Item.S.Looks];
         if d <> nil then
          with DGStore do begin
            dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 1),
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ARow,
                              d.ClientRect,
                              d, TRUE);

            if (g_StoreItems[idx].Item.Amount > 0)  and (g_StoreItems[idx].Item.S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
               SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
               dsurface.Canvas.Font.Color := clYellow;
               dsurface.Canvas.TextOut(SurfaceX(Rect.BottomRight.x - (Length(IntToStr(g_StoreItems[idx].Item.Amount))div 2) + 22),
                         SurfaceY(Rect.BottomRight.y + 22), IntToStr(g_StoreItems[idx].Item.Amount));
               dsurface.Canvas.Font.Color := clWhite;
               dsurface.Canvas.Release;
            end;

          end;
      end;
   end;
end;

procedure TFrmDlg.DGStoreGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
  Shift: TShiftState);
var
   idx,mi,Price: integer;
   temp: TClientItem;
   sData, sData1, sData2:String;
label InPutPrice;
begin
  if g_MySelf.m_boStartStore or g_boStartStoreing then Exit;
  idx := ACol + ARow * DGStore.ColCount;
  if idx in [0..14] then begin
    if not g_boItemMoving then begin
      if g_StoreItems[idx].Item.S.Name <> '' then begin
        if ssCtrl in Shift then begin  //º¸¿Á(±¸ ½Ã½ºÅÛ)
          if not PlayScene.EdChat.Visible then begin
            PlayScene.EdChat.Visible := True;
            PlayScene.EdChat.SetFocus;
          end;
          if PlayScene.EdChat.SelStart = Length(PlayScene.EdChat.Text) then begin
            PlayScene.EdChat.Text := PlayScene.EdChat.Text + '{' + '0' + '/' + IntToStr(g_StoreItems[Idx].Item.MakeIndex) + '}';
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end else begin
            sData := Copy(PlayScene.EdChat.Text, 1, PlayScene.EdChat.SelStart);
            sData1 := Copy(PlayScene.EdChat.Text, PlayScene.EdChat.SelStart + 1, Length(PlayScene.EdChat.Text) - PlayScene.EdChat.SelStart);
            sData2 := '{' + '0' + '/' + IntToStr(g_StoreItems[Idx].Item.MakeIndex) + '}';
            PlayScene.EdChat.Text := sData + sData2 + sData1;
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text) - Length(WideString(sData1));
          end;
          PlayScene.EdChat.SelLength := 0;
          SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
          exit;
        end;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := idx+500;
         g_MovingItem.Index2 := g_StoreItems[Idx].btSellType;
         g_MovingItem.Item := g_StoreItems[idx].Item;
         ItemClickSound (g_MovingItem.Item.S);
         g_MovingItem.Owner := DStoreGridWin;
         g_StoreItems[idx].Item.S.Name := '';
      end;
    end else begin
      mi := g_MovingItem.Index;
      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DStoreGridWin) then begin
        if (g_MovingItem.Item.S.btValue[19] = 0) and (g_MovingItem.Item.S.StdMode <> 14) then begin      //¹ÝÂ¦ ¾ÆÀÌÅÛ ´ë¿© °³ÀÎ»óÁ¡ ºÒ°¡
          if g_StoreItems[idx].Item.S.Name = '' then begin
            if (g_MovingItem.Owner = DItemBag) then begin
              temp := g_StoreItems[idx].Item;
              g_WaitingStoreItem := g_MovingItem;
              g_boItemMoving := False;
              g_MovingItem.Item.s.Name := '';
              g_MovingItem.Owner := nil;
              InPutPrice:
              if DStoreMessageDlg = mrOk then begin
                Price := Str_ToInt(StoreDlgEditText, 0);
                if Price > 0 then begin
                  case m_boStoreGold of
                    0: g_StoreItems[Idx].btSellType := 0;
                    1: g_StoreItems[Idx].btSellType := 1;
                  end;
                  g_StoreItems[Idx].Item := g_WaitingStoreItem.Item;
                  g_StoreItems[Idx].Item.s.Price := Price;
                  g_WaitingStoreItem.Item.s.Name := '';
                  g_WaitingStoreItem.Owner := nil;
                  g_boItemMoving := False;
                end else begin
                  goto InPutPrice;
                  Exit;
                end;
              end else begin
                AddItemBag(g_WaitingStoreItem.Item);
                g_WaitingStoreItem.Item.s.Name := '';
                g_WaitingStoreItem.Owner := nil;
                g_boItemMoving := False;
              end;
            end else begin
              g_StoreItems[Idx].Item := g_MovingItem.Item;
              g_StoreItems[Idx].btSellType := g_MovingItem.Index2;
              g_MovingItem.Item.s.Name := '';
              g_boItemMoving := False;
              g_MovingItem.Owner := nil;
            end;
          end;
        end;
      end;
    end;
  end;
  ArrangeItemBag;
  EdStoreMsgEdit.Visible := False;
  EdStoreMacrosEdit.Visible := False;
  SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
end;

procedure TFrmDlg.DStoreMsgDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DStoreMsgDlg do begin
   d := WLib.Images[FaceIndex];
    if d <> nil then
    dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    EdStoreDlgEdit.Left := SurfaceX(Left+23);
    EdStoreDlgEdit.Top := SurfaceY(Top+100);
    EdStoreDlgEdit.Visible := True;

     with Dsurface.Canvas do begin
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
      Font.Color := clWhite;
      if m_boStoreGold = 0 then begin
        TextOut(SurfaceX(Left + 23) , SurfaceY(Top + 80), 'ÇëÊäÈëÎïÆ· "' + g_WaitingStoreItem.Item.S.Name + '" µÄÏúÊÛ¼Û¸ñ¡£(½ð±Ò)');
      end else begin
        TextOut(SurfaceX(Left + 23) , SurfaceY(Top + 80), 'ÇëÊäÈëÎïÆ· "' + g_WaitingStoreItem.Item.S.Name + '" µÄÏúÊÛ¼Û¸ñ¡£(µãÈ¯)');
      end;
      dsurface.Canvas.Release;
     end;

    if (EdStoreDlgEdit.Visible) and (EdStoreDlgEdit.Text = '') then EdStoreDlgEdit.SetFocus;
  end;
end;

procedure TFrmDlg.DStoreMsgOkClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DStoreMsgOk then DStoreMsgDlg.DialogResult := mrOk;
  if Sender = DStoreMsgCancel then DStoreMsgDlg.DialogResult := mrCancel;
  if Sender = DStoreMsgClosed then DStoreMsgDlg.DialogResult := mrCancel;
   EdStoreDlgEdit.Visible := false;
   DStoreMsgDlg.Visible := false;
end;




procedure TFrmDlg.DUserStoreMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DUserStoreDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DUserStore do begin
    d := nil;
    if WLib <> nil then
      d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

      with Dsurface.Canvas do begin
        SetBkMode (Handle, TRANSPARENT);
        Font.Style := [fsBold];
        Font.Size := 11;
        TextOutA(Dsurface, SurfaceX(Left) + 78, SurfaceY(Top) + 50, clWhite, '´ýÊÛÉÌÆ·');
        Font.Size := 9;
        Font.Style := [];
        Release;
     end;

  end;
end;

procedure TFrmDlg.DUserStoreCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseUserStoreDlg;
end;

procedure TFrmDlg.DGUserStoreGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx: integer;
   nWhere: Integer;
   List: TStringList;
begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
   idx := ACol + ARow * DGUserStore.ColCount;
   if idx in [0..14] then begin
     g_MouseItem :=  g_StoreRemoteItems[idx].Item;
     if g_MouseItem.s.Name <> '' then begin
       nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
       if (nWhere >= 0) then begin

         List := TStringList.Create;
         try
           GetMouseItemHint(g_MySelf, @g_MouseItem);
           HintList.AddObject('¡¡',TObject(GetRGB(248)));
           if g_StoreRemoteItems[Idx].btSellType = 1 then
             HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreRemoteItems[idx].Item.s.Price) + ' ' + GetStorePriceName(g_StoreRemoteItems[Idx].btSellType), TObject(clAqua))
           else HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreRemoteItems[idx].Item.s.Price) + ' ' + GetStorePriceName(g_StoreRemoteItems[Idx].btSellType), TObject(clLime));
           List.AddStrings(HintList);

           GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
           if HintList.Count > 0 then begin
             HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];   //°³ÀÎ»óÁ¡
           end;
           with DGUserStore do
             DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
           HintList.Clear;
         finally
           FreeAndNil(List);
         end;
         g_MouseItem.s.Name := '';
       end else begin
         GetMouseItemHint(g_MySelf, @g_MouseItem);
         HintList.AddObject('¡¡',TObject(GetRGB(248)));
         if g_StoreRemoteItems[Idx].btSellType = 1 then
           HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreRemoteItems[idx].Item.s.Price) + ' ' + GetStorePriceName(g_StoreRemoteItems[Idx].btSellType), TObject(clAqua))
         else HintList.AddObject('¼Û¸ñ: ' + GetGoldStr(g_StoreRemoteItems[idx].Item.s.Price) + ' ' + GetStorePriceName(g_StoreRemoteItems[Idx].btSellType), TObject(clLime));

         with DGUserStore do
           DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
       end;
     end;
   end else begin
     g_MouseItem.s.Name := '';
   end;
end;

procedure TFrmDlg.DGUserStoreGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState;
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
   rc: TRect;
begin
   idx := ACol + ARow * DGUserStore.ColCount;
   if idx in [0..14] then begin
      if g_StoreRemoteItems[idx].Item.S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_StoreRemoteItems[idx].Item.S.Looks];
         if d <> nil then
          with DGUserStore do begin
            dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 + 1),
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ARow,
                              d.ClientRect,
                              d, TRUE);

            if (g_StoreRemoteItems[idx].Item.Amount > 0)  and (g_StoreRemoteItems[idx].Item.S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
               SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
               dsurface.Canvas.Font.Color := clYellow;
               dsurface.Canvas.TextOut(SurfaceX(Rect.BottomRight.X - (Length(IntToStr(g_StoreRemoteItems[idx].Item.Amount))div 2) + 22),
                         SurfaceY(Rect.BottomRight.y + 22), IntToStr(g_StoreRemoteItems[idx].Item.Amount));
               dsurface.Canvas.Font.Color := clWhite;
               dsurface.Canvas.Release;
            end;
          end;
      end;
      if (g_SelectStoreItem.Item.s.Name <> '') and (gdSelected in State) then begin
        with DGUserStore do begin
          with dsurface do begin
            SetBkMode (Canvas.Handle, TRANSPARENT);
            rc := Bounds(SurfaceX(Rect.Left), SurfaceY(Rect.Top + ARow) - 3, ColWidth, RowHeight + 2);
            Canvas.Brush.Color := clLime;
            Canvas.FrameRect(rc);
            Canvas.Release;
          end;
        end;
      end;
   end;
end;

procedure TFrmDlg.DGUserStoreGridSelect(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx: Integer;
   sData, sData1, sData2:String;
begin
  g_SelectStoreItem.Item.s.Name := '';
  Idx := ACol + ARow * DGUserStore.ColCount;
  if Idx in [0..14] then begin
    if g_StoreRemoteItems[Idx].Item.s.Name <> '' then begin
      g_SelectStoreItem := g_StoreRemoteItems[Idx];
      PlaySound(s_glass_button_click);
    end;
  end;
end;

procedure TFrmDlg.DUserStoreBuyClick(Sender: TObject; X, Y: Integer);
begin
  if g_nStoreMasterRecogId = g_MySelf.m_nRecogId then Exit;
   if g_SelectStoreItem.Item.s.Name <> '' then begin
      if mrOk = DMessageDlg('ÄãµÄÊ¦¸¸' + g_sStoreMasterName + '¸øÄãÔùËÍÁË"' + g_SelectStoreItem.Item.S.Name + '"¡£' , [mbOk, mbCancel]) then begin
       frmMain.SendBuyStoreItem(g_SelectStoreItem.Item.s.Name, g_SelectStoreItem.Item.MakeIndex, g_nStoreMasterRecogId);
      end;
   end;
end;

procedure TFrmDlg.DStoreCancelClick(Sender: TObject; X, Y: Integer);
begin
  if (g_MySelf <> nil) and (not g_MySelf.m_boStartStore) and (not g_boStartStoreing) then begin
    CloseStoreDlg;
  end;
  if not g_MySelf.m_boStartStore then Exit;
  if GetTickCount - g_dwStartStoreTick > 1000 * 3 then begin
    g_dwStartStoreTick := GetTickCount;
    SendClientMessage(CM_STOPSTORE, g_MySelf.m_nRecogId, 0, 0, 0);

    if DItemBag.Visible = False then begin
      DItemBag.Left := g_FScreenWidth - 315;
      DItemBag.Top := 45;
      DItemBag.Visible := True;
      SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
    end;
  end;
end;

procedure TFrmDlg.DStoreOpenClick(Sender: TObject; X, Y: Integer);
begin
  if (GetTickCount - g_dwStartStoreTick > 1000 * 2) and (g_boStartStoreing) then begin
    g_dwStartStoreTick := GetTickCount;
    g_boStartStoreing := False;
  end;

  if g_MySelf.m_boStartStore or g_boStartStoreing then Exit;

  if g_boItemMoving then begin
    DMessageDlg('´¢´æÎïÆ·Ê±ÎÞ·¨Ê¹ÓÃÉÌµê¡£', [mbOk]);
    Exit;
  end;

  if (GetTickCount - g_dwStartStoreTick > 1000 * 2) then begin
    g_dwStartStoreTick := GetTickCount;
    g_boStartStoreing := True;
    frmMain.SendStartStore;
  end;
end;



procedure TFrmDlg.DStoreGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if (m_boStoreGold = 0) then begin
         d := WLib.Images[FaceIndex + 1];
      end else
         d := WLib.Images[FaceIndex];

      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      with Dsurface.Canvas do begin
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
        Font.Style := [fsBold];
        Font.Size := 11;

        TextOut(SurfaceX(Left + 30) , SurfaceY(Top + 3), '½ð±Ò');

        Font.Size := 9;
        Font.Style := [];
        dsurface.Canvas.Release;
     end;
   end;
end;

procedure TFrmDlg.DStoreGGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if (m_boStoreGold = 1) then begin
         d := WLib.Images[FaceIndex + 1];
      end else
         d := WLib.Images[FaceIndex];

      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      with Dsurface.Canvas do begin
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
        Font.Style := [fsBold];
        Font.Size := 11;

        TextOut(SurfaceX(Left + 30) , SurfaceY(Top + 3), 'µãÈ¯');

        Font.Size := 9;
        Font.Style := [];
        dsurface.Canvas.Release;
     end;
   end;
end;

procedure TFrmDlg.DStoreGoldClick(Sender: TObject; X, Y: Integer);
begin
  m_boStoreGold:= 0;
end;

procedure TFrmDlg.DStoreGGoldClick(Sender: TObject; X, Y: Integer);
begin
 m_boStoreGold := 1;
end;



procedure TFrmDlg.DStoreMacroDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if not g_CheckMacro then begin
         dd := d.WLib.Images[d.FaceIndex];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex + 1];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DStoreMacroClick(Sender: TObject; X, Y: Integer);
begin
  g_CheckMacro := not g_CheckMacro;
end;

procedure TFrmDlg.DComStorageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d,g:TDirectDrawSurface;
begin
   with DComStorage do begin                 //À§Å¹ Ã¢
    d := WLib.Images[FaceIndex];
    if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    g := g_WTitleImages.Images[4];
      if g <> nil then
         dsurface.Draw (SurfaceX(Left + 32), SurfaceY(Top + 5), g.ClientRect, g, TRUE);

    SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
    BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 138), clWhite, clBlack, 'µã»÷Äã²éÕÒµ½µÄÎïÆ·²¢ÇÒµã»÷½ÓÊÕÈ¡°´Å¥¡£');
    if g_ComStorageItem[ComStorageboots].StartTime <> 0 then begin
      BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 158), clWhite, clBlack, 'Ñ¡¶¨µÄÎïÆ·: ' + g_ComStorageItem[ComStorageboots].Item.S.Name);
    end else begin
      BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 158), clWhite, clBlack, 'Äã»¹Ã»ÓÐÑ¡¶¨ÎïÆ·¡£ ');
    end;

    dsurface.Canvas.Release;
    
  end;
  DUpWapondow.Visible := False;
  DUpWeapon.Visible := False;
  CloseDUpWapon;
  DUpCheck.Visible := False;
   CloseDUpWapon2;
end;

procedure TFrmDlg.DComStorageMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DComStorageExitClick(Sender: TObject; X, Y: Integer);
begin
   ToggleComStorageWindow;
end;

procedure TFrmDlg.DGetComStorageClick(Sender: TObject; X, Y: Integer);
begin
 if g_ComStorageItem[ComStorageMenuIndex].StartTime = 0 then exit;
   if g_ComStorageItem[ComStorageboots].StartTime = 0 then exit;
     SendClientMessage (CM_ENDCOMSTORAGEITEM, g_MySelf.m_nRecogId, LoWord(g_ComStorageItem[ComStorageMenuIndex].StorageID), HiWord(g_ComStorageItem[ComStorageMenuIndex].StorageID), 0);
     exit;

end;

procedure TFrmDlg.DStorageRefreshClick(Sender: TObject; X, Y: Integer);
begin
  SendClientMessage(CM_GETCOMSTORAGE, g_MySelf.m_nRecogId, 0, 0, 0, '');
end;

procedure TFrmDlg.DCS1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 Cs :TComStorageItem;
 d,e: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    Cs := g_ComStorageItem[Tag];

    if Cs.StartTime <> 0 then begin
      d:= g_WBagItemImages.Images[Cs.Item.S.Looks];
       if d <> nil then
         dsurface.Draw (SurfaceX(TDButton(Sender).Left + ((TDButton(Sender).Width) - d.Width) div 2) + 2,
         SurfaceY(TDButton(Sender).Top + (TDButton(Sender).Height - d.Height) div 2), d.ClientRect, d, TRUE);

       if ComStorageboots = Tag then begin
         e := g_WMain2Images.Images[535];
         if e <> nil then
             dsurface.Draw(SurfaceX(TDButton(Sender).Left), SurfaceY(TDButton(Sender).Top),  e.ClientRect,  e, TRUE);
       end;


       if (Cs.Item.Amount > 0) and (Cs.Item.S.StdMode in [0,1,3,45,46]) then begin             //¹°¾à
         SetBKMode (dSurface.Canvas.Handle,TRANSPARENT);
         dsurface.Canvas.Font.Color := clYellow;
         dsurface.Canvas.TextOut(SurfaceX(Left + 20), SurfaceY(Top + 18), IntToStr(Cs.Item.Amount));
         dsurface.Canvas.Font.Color := clWhite;
         dSurface.Canvas.Release;
       end;
    end;

  end;
end;

procedure TFrmDlg.DCS1Click(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
   g_MouseItem := g_ComStorageItem[Tag].Item;
   if g_ComStorageItem[Tag].StartTime <> 0 then begin
     PlaySound(s_norm_button_click);
     ComStorageboots := Tag;
     ComStorageMenuIndex := Tag;
   end;
  end;
end;

procedure TFrmDlg.DCS1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx: integer;
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
  nWhere: Integer;
  List: TStringList;
begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
   idx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   if g_ComStorageItem[idx].StartTime <> 0 then
     g_MouseItem := g_ComStorageItem[idx].Item;
     if g_MouseItem.S.Name <> '' then begin
       nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
       if (nWhere >= 0) then begin

         List := TStringList.Create;
         try
           GetMouseItemHint(g_MySelf, @g_MouseItem);
           List.AddStrings(HintList);

           GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
           if HintList.Count > 0 then begin
             HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];     //°ø¿ëÃ¢°í
           end;
           nLocalX:=Butt.LocalX(X - Butt.Left);
           nLocalY:=Butt.LocalY(Y - Butt.Top);
           nHintX:=Butt.SurfaceX(Butt.Left) + DComStorage.SurfaceX(DComStorage.Left) + nLocalX;
           nHintY:=Butt.SurfaceY(Butt.Top) + DComStorage.SurfaceY(DComStorage.Top) + nLocalY;
           with Butt as TDButton do
             DScreen.ShowHintL(nHintX, nHintY, List, HintList, False);
           HintList.Clear;
         finally
           FreeAndNil(List);
         end;
         g_MouseItem.s.Name := '';
       end else begin
         GetMouseItemHint(g_MySelf, @g_MouseItem);
         if HintList.Count > 0 then begin
           nLocalX:=Butt.LocalX(X - Butt.Left);
           nLocalY:=Butt.LocalY(Y - Butt.Top);
           nHintX:=Butt.SurfaceX(Butt.Left) + DComStorage.SurfaceX(DComStorage.Left) + nLocalX;
           nHintY:=Butt.SurfaceY(Butt.Top) + DComStorage.SurfaceY(DComStorage.Top) + nLocalY;
           with Butt as TDButton do
             DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
         end;
       end;
     end else begin
       g_MouseItem.s.Name := '';
     end;
end;


procedure TFrmDlg.DGuildStorageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d,g:TDirectDrawSurface;
  GuildName:String;
begin
   with DGuildStorage do begin                 //À§Å¹ Ã¢
    d := WLib.Images[FaceIndex];
    if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    g := g_WTitleImages.Images[8];
      if g <> nil then
         dsurface.Draw (SurfaceX(Left + 32), SurfaceY(Top + 5), g.ClientRect, g, TRUE);

    g := g_WMain2Images.Images[301];
      if g <> nil then
         dsurface.Draw (SurfaceX(Left + 13), SurfaceY(Top + 219), g.ClientRect, g, TRUE);

    g := g_WMain2Images.Images[305];
      if g <> nil then
         dsurface.Draw (SurfaceX(Left + 13), SurfaceY(Top + 383), g.ClientRect, g, TRUE);

    g := g_WMain2Images.Images[305];
      if g <> nil then
         dsurface.Draw (SurfaceX(Left + 13), SurfaceY(Top + 416), g.ClientRect, g, TRUE);


    with dsurface.Canvas do begin
      SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);

      Font.Size := 11;
      Font.Style := [fsBold];
      GuildName := g_sGuildName + 'µÄÐÐ»á²Ö¿â';
      TextOut (SurfaceX(Left + 193 - dsurface.Canvas.TextWidth(GuildName) div 2) , SurfaceY(Top + 44), GuildName);
      Font.Size := 9;
      Font.Style := [];

      BoldTextOut (dsurface, SurfaceX(Left + 18) , SurfaceY(Top + 75), clWhite, clBlack, '²éÕÒÈ¨ÏÞ: ÐÐ»á³ÉÔ±¡¢´æÈ¡È¨ÏÞ: ÐÐ»á³ÉÔ±');
      BoldTextOut (dsurface, SurfaceX(Left + 18) , SurfaceY(Top + 99), clWhite, clBlack, '»ù±¾²Ö¿â');
      BoldTextOut (dsurface, SurfaceX(Left + 24) , SurfaceY(Top + 392), clWhite, clBlack, 'µã»÷Äã²éÕÒµ½µÄÎïÆ·²¢ÇÒµã»÷½ÓÊÕÈ¡°´Å¥¡£');

      if g_GuildStorageItem[GuildStorageboots].StartTime <> 0 then begin
        BoldTextOut (dsurface, SurfaceX(Left + 24) , SurfaceY(Top + 423), clWhite, clBlack, 'Ñ¡¶¨µÄÎïÆ·: ' + g_GuildStorageItem[GuildStorageboots].Item.S.Name);
      end else begin
        BoldTextOut (dsurface, SurfaceX(Left + 24) , SurfaceY(Top + 423), clWhite, clBlack, 'Äã»¹Ã»ÓÐÑ¡¶¨ÎïÆ·¡£ ');
      end;

      dsurface.Canvas.Release;
    end;
    
  end;
  DUpWapondow.Visible := False;
  DUpWeapon.Visible := False;
  CloseDUpWapon;
  DUpCheck.Visible := False;
   CloseDUpWapon2;
end;

procedure TFrmDlg.DGuildStorageMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DGuildStorageExitClick(Sender: TObject; X, Y: Integer);
begin
  ToggleGuildStorageWindow;
end;

procedure TFrmDlg.DGuildStorageReClick(Sender: TObject; X, Y: Integer);
begin
   SendClientMessage(CM_GETGUILDSTORAGE, g_MySelf.m_nRecogId, 0, 0, 0, '');
end;

procedure TFrmDlg.DGetGuildStorageClick(Sender: TObject; X, Y: Integer);
begin
 if g_GuildStorageItem[GuildStorageIndex].StartTime = 0 then exit;
   if g_GuildStorageItem[GuildStorageboots].StartTime = 0 then exit;
     SendClientMessage (CM_ENDGUILDSTORAGEITEM, g_MySelf.m_nRecogId, LoWord(g_GuildStorageItem[GuildStorageIndex].GStorageID), HiWord(g_GuildStorageItem[GuildStorageIndex].GStorageID), 0);
     exit;

end;

procedure TFrmDlg.DGGuildStorageGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState;
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d, e: TDirectDrawSurface;
begin
   idx := ACol + ARow * DGGuildStorage.ColCount;
   if idx in [0..49] then begin

    if g_GuildStorageItem[idx].StartTime <> 0 then begin
      if g_GuildStorageItem[idx].Item.S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_GuildStorageItem[idx].Item.S.Looks];
         if d <> nil then
          with DGGuildStorage do begin
           dsurface.Draw (SurfaceX(Rect.Left + ((ColWidth - 1) - d.Width) div 2 - 2) + 3,
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ ARow,
                              d.ClientRect,
                              d, TRUE);

            if (g_GuildStorageItem[idx].Item.Amount > 0)  and (g_GuildStorageItem[idx].Item.S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
               SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
               dsurface.Canvas.Font.Color := clYellow;
               dsurface.Canvas.TextOut(SurfaceX(Rect.Left + ((ColWidth - 1) - d.Width) div 2  - (Length(IntToStr(g_GuildStorageItem[idx].Item.Amount))div 2) + 18),
                         SurfaceY(Rect.BottomRight.y + 20), IntToStr(g_GuildStorageItem[idx].Item.Amount));
               dsurface.Canvas.Font.Color := clWhite;
               dsurface.Canvas.Release;
            end;
          end;
          if GuildStorageboots = idx then begin
            e := g_WMain2Images.Images[535];
            if e <> nil then
              with DGGuildStorage do begin
               dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - 40) div 2) +1 ,
                            SurfaceY(Rect.Top + (RowHeight - 34) div 2 - 1)+ARow,
                              e.ClientRect,
                              e, TRUE);
              end;
          end;
      end;
    end;
   end;
end;

procedure TFrmDlg.DGGuildStorageGridSelect(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx: Integer;
begin
  Idx := ACol + ARow * DGGuildStorage.ColCount;
  g_MouseItem := g_GuildStorageItem[Idx].Item;
  if g_GuildStorageItem[Idx].StartTime <> 0 then begin
    PlaySound(s_glass_button_click);
    GuildStorageIndex := Idx;
    GuildStorageboots := Idx;
  end;
end;

procedure TFrmDlg.DGGuildStorageGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  nWhere: Integer;
  List: TStringList;
begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
   idx := ACol + ARow * DGGuildStorage.ColCount;
   if idx in [0..49] then begin
    if g_GuildStorageItem[idx].StartTime <> 0 then
     g_MouseItem :=  g_GuildStorageItem[idx].Item;
     if g_MouseItem.S.Name <> '' then begin
       nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
       if (nWhere >= 0) then begin
         List := TStringList.Create;
         try
           GetMouseItemHint(g_MySelf, @g_MouseItem);
           List.AddStrings(HintList);

           GetMouseItemHint(g_MySelf, @g_UseItems[nWhere]);
           if HintList.Count > 0 then begin
             HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0];         //¹®ÆÄÃ¢°í
           end;
           with DGGuildStorage do
             DScreen.ShowHintL(SurfaceX(Left + (x - left)) + 30, SurfaceY(Top + (y - Top) + 30), List, HintList, False);
           HintList.Clear;
         finally
           FreeAndNil(List);
         end;
         g_MouseItem.s.Name := '';
       end else begin
         GetMouseItemHint (g_MySelf, @g_MouseItem);
         if HintList.Count > 0 then begin
           with DGGuildStorage do
             DScreen.ShowHintB(SurfaceX(Left + (x - left)) + 30, SurfaceY(Top + (y - Top) + 30), HintList, FALSE);
         end;
       end;
     end;
   end else begin
     g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DRentalDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d:TDirectDrawSurface;
begin
   with DRentalDlg do begin                 //À§Å¹ Ã¢
    d := WLib.Images[FaceIndex];
    if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    d := g_WTitleImages.Images[41];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left + 30), SurfaceY(Top + 5), d.ClientRect, d, TRUE);


    with dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);

      if RentalPage = 0 then begin    //ºô¸°ÅÛ
        Font.Style := [fsBold];
        TextOutA (dsurface, SurfaceX(Left + 18) , SurfaceY(Top + 60), clWhite, 'ÎïÆ·Ãû³Æ');
        TextOutA (dsurface, SurfaceX(Left + 142) , SurfaceY(Top + 60),clWhite, '³ö ×â ÈË');
        TextOutA (dsurface, SurfaceX(Left + 270) , SurfaceY(Top + 60),clWhite, '×âÁÞÈÕÆÚ');
        Font.Style := [];

        if g_RentalItem.StartTime <> 0 then begin      //¹Ý³³
          TextOutA (dsurface,  Left+18 , Top + 80, clWhite,g_RentalItem.Item.S.Name);
          TextOutA (dsurface,  Left+142, Top + 80, clWhite,g_RentalItem.Owner);
          TextOutA (dsurface,  Left+268, Top + 80, clWhite,FormatDateTime('mmÔÂddÈÕ hhÊ±nn·Ö', g_RentalItem.EndTime));
        end;

      end else begin
        Font.Style := [fsBold];
        TextOutA (dsurface, SurfaceX(Left + 18) , SurfaceY(Top + 60), clWhite, 'ÎïÆ·Ãû³Æ');
        TextOutA (dsurface, SurfaceX(Left + 142) , SurfaceY(Top + 60),clWhite, '³ö ×â ÈË');
        TextOutA (dsurface, SurfaceX(Left + 270) , SurfaceY(Top + 60),clWhite, '×âÁÞÈÕÆÚ');
        Font.Style := [];
        if g_OwnerItem.StartTime <> 0 then begin      //È¸¼ö
          TextOutA (dsurface,  Left+18 , Top + 80, clWhite, g_OwnerItem.Item.S.Name);
          TextOutA (dsurface,  Left+142, Top + 80, clWhite, g_OwnerItem.Owner);
          if (g_OwnerItem.EndTime <= now) or (g_OwnerItem.Withdraw = True) then begin
            TextOutA (dsurface,  Left+268, Top + 80, clWhite, '·µ»¹');
          end else begin
            TextOutA (dsurface,  Left+268, Top + 80, clWhite, FormatDateTime('mmÔÂddÈÕ hhÊ±nn·Ö', g_OwnerItem.EndTime));
          end;
        end;
      end;
      Release;
    end;

    if RentalPage = 0 then begin
      DRentalList.SetImgIndex(g_WTitleImages, 421);
      DBorrowList.SetImgIndex(g_WTitleImages, 422);
      if g_RentalItem.StartTime <> 0 then begin
        DReturn.Visible := True;
      end else begin
        DReturn.Visible := False;
      end;
    end else begin
      DRentalList.SetImgIndex(g_WTitleImages, 420);
      DBorrowList.SetImgIndex(g_WTitleImages, 423);
      if g_OwnerItem.StartTime <> 0 then begin
        if g_OwnerItem.EndTime <= now then begin
          DWithdraw.Visible := True;
        end else begin
         if g_OwnerItem.Withdraw = True then begin
          DWithdraw.Visible := True;
         end else begin
          DWithdraw.Visible := False;
         end;
        end;
      end else begin
         DWithdraw.Visible := False;
      end;
    end;

  end;

end;

procedure TFrmDlg.DRentalListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      d := WLib.Images[FaceIndex];

      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DRentalDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
   DScreen.ClearHint;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DRentalListClick(Sender: TObject; X, Y: Integer);
begin
  RentalPage := 0;
  RentalPageChanged;
end;

procedure TFrmDlg.DBorrowListClick(Sender: TObject; X, Y: Integer);
begin
 RentalPage := 1;
 RentalPageChanged;
end;

procedure TFrmDlg.DRentalExitClick(Sender: TObject; X, Y: Integer);
begin
  DRentalDlg.Visible := False;
end;

procedure TFrmDlg.DRentalClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    FrmMain.SendRentalTry;
  end;
end;

procedure TFrmDlg.DDRentalDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DDRentalDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         if RentalMode = 0 then begin
           TextOut (SurfaceX(Left+62), SurfaceY(Top+46), '×âÁÞÆÚÏÞ: '+ intToStr(g_nRentalDay) + 'ÈÕ');
         end else begin
           TextOut (SurfaceX(Left+62), SurfaceY(Top+46), '½ð¶î: '+ GetGoldStr(g_nRentalGold));
         end;
         TextOut (SurfaceX(Left + 98 - (TextWidth(FrmMain.CharName)) div 2), SurfaceY(Top+11), FrmMain.CharName);
         Release;
      end;

      if RentalMode = 0 then begin
        DRGrid.Visible := True;
     //   DRentalDay.Visible := True;
        DRGold.Visible := False;
      end else begin
        DRGrid.Visible:= False;
     //   DRentalDay.Visible := False;
        DRGold.Visible := True;
      end;
   end;
end;

procedure TFrmDlg.DDRentalDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DRentalCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwRentalActionTick then begin
      CloseRentalDlg;
      FrmMain.SendCancelRental;
   end;
end;

procedure TFrmDlg.DRGridClick(Sender: TObject; X, Y: Integer);
var
   dDay: integer;
   valstr: string;
   mi: Integer;
begin
   if not g_boRentalEnd and (GetTickCount > g_dwRentalActionTick) then begin
      if not g_boItemMoving then begin
         if (g_RentalItems.S.Name <> '') and (g_nRentalDay > 0) then begin
           g_boItemMoving := TRUE;
           g_MovingItem.Index := -36;
           g_MovingItem.Item := g_RentalItems;
           g_RentalItems.S.Name := '';
           g_MovingItem.Owner := DDRentalDlg;
           ItemClickSound (g_MovingItem.Item.S);
         end;
      end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;

         mi := g_MovingItem.Index;
         if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DDRentalDlg) then begin   //´ë¿©

            DialogSize := 1;

            ItemClickSound (g_MovingItem.Item.S);
            g_boItemMoving := FALSE;

            DMessageDlg ('ÇëÊäÈëÄãÒª×âÁÞµÄÆÚÏÞ...\×î´óµÄ×âÁÞÆÚÏÞÎª30Ìì¡£', [mbOk, mbAbort]);
            GetValidStrVal (DlgEditText, valstr, [' ']);
            dDay := Str_ToInt (valstr, 0);
           if (dDay > 0) and (dDay < 31) then begin
            if mi >= 0 then begin
              g_RentalDlgItem := g_MovingItem.Item;
              FrmMain.SendAddRentalItem (g_RentalDlgItem,dDay);
              g_dwRentalActionTick := GetTickCount + 4000;
            end else begin
              AddRentalItem (g_MovingItem.Item);
              g_MovingItem.Item.S.name := '';
              g_MovingItem.Owner := nil;
            end;
           end else begin
              AddItemBag (g_MovingItem.Item);
              g_MovingItem.Item.S.name := '';
              g_MovingItem.Owner := nil;
              dDay := 0;
              DScreen.AddChatBoardString('×â½èµÄÆÚÏÞ×îÉÙÎª1Ìì¡£',clRed,clwhite);
           end;
         end;
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DRGridDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_RentalItems.S.Name <> '' then begin
    d := g_WBagItemImages.Images[g_RentalItems.S.Looks];
      if d <> nil then
      with DRGrid do begin
          dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DRGridMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   nLocalX,nLocalY,nHintX,nHintY:Integer;
   Butt:TDButton;
   NewName: sItemMome;
begin
   g_MouseItem.S.Name := '';
   g_MouseItem := g_RentalItems;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DDRentalDlg.SurfaceX(DDRentalDlg.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DDRentalDlg.SurfaceY(DDRentalDlg.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
   end;
   if g_MouseItem.S.Name = '' then DScreen.ClearHint;
end;

procedure TFrmDlg.DRGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then exit;
   if not g_boRentalEnd and (GetTickCount > g_dwRentalActionTick) then begin
      if not g_boItemMoving then begin
         if g_nRentalGold > 0 then begin
            PlaySound (s_money);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := -97;
            g_MovingItem.Item.S.Name := g_sGoldName;
         end;
      end else begin
         if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
            if (g_MovingItem.Index = -98) then begin
               if g_MovingItem.Item.S.Name = g_sGoldName then begin

                  DialogSize := 1;
                  g_boItemMoving := FALSE;
                  g_MovingItem.Item.S.Name := '';
                  DMessageDlg ('ÇëÊäÈëÄãÒªÈ¡³öµÄ½ð±ÒÊýÁ¿...', [mbOk, mbAbort]);
                  GetValidStrVal (DlgEditText, valstr, [' ']);
                  dgold := Str_ToInt (valstr, 0);
                  if (dgold <= (g_nRentalGold+g_MySelf.m_nGold)) and (dgold > 0) then begin
                     FrmMain.SendChangeRentalGold (dgold);          //´ë¿© ±ÝÀü
                     g_dwRentalActionTick := GetTickCount + 4000;
                  end else
                     dgold := 0;
               end;
            end;
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.Name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DRGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DRGold do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DRentalOkClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
   if RentalMode = 0 then begin
     if g_nRentalDay <= 0 then begin
       DMessageDlg ('Ã»ÓÐ¿ÉÒÔ×âÁÞµÄÎïÆ·¡£', [mbOk]);
       exit;
     end;
     if g_nRentalRemoteGold <= 0 then begin
       DMessageDlg ('×âÁÞµÄ¼Û¸ñ×îÉÙÎª1½ð±Ò¡£', [mbOk]);
       exit;
     end;
   end else begin
     if g_nRentalGold <= 0 then begin
       DMessageDlg ('×âÁÞµÄ¼Û¸ñ×îÉÙÎª1½ð±Ò¡£', [mbOk]);
       exit;
     end;
     if g_nRentalRemoteDay <= 0 then begin
       DMessageDlg ('Ã»ÓÐ¿ÉÒÔ×âÁÞµÄÎïÆ·¡£', [mbOk]);
       exit;
     end;
   end;
   if GetTickCount > g_dwRentalActionTick then begin
      FrmMain.SendRentalEnd;          //´ë¿©
      g_dwRentalActionTick := GetTickCount + 4000;
      g_boRentalEnd := TRUE;

      if g_boItemMoving then begin
         mi := g_MovingItem.Index;
         if (mi = -36) then begin     //°Å·¡
            AddRentalItem (g_MovingItem.Item);
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DRentalRemoteDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DRentalRemoteDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         if RentalMode = 0 then begin
           TextOut (SurfaceX(Left+62), SurfaceY(Top+46), '½ð¶î: ' + GetGoldStr(g_nRentalRemoteGold));
         end else begin
           TextOut (SurfaceX(Left+62), SurfaceY(Top+46), '×âÁÞÆÚÏÞ: ' + IntToStr(g_nRentalRemoteDay) + 'Ìì');
         end;
         TextOut (SurfaceX(Left + 98 - (TextWidth(g_sRentalWho)) div 2), SurfaceY(Top+11), g_sRentalWho);
         Release;
      end;
      if RentalMode = 0 then begin
        DRRGold.Visible := True;
        DRRGrid.Visible := False;
      end else begin
        DRRGold.Visible := False;
        DRRGrid.Visible := True;
      end;

   end;
end;

procedure TFrmDlg.DRentalRemoteDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DRRGridDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_RentalRemoteItems.S.Name <> '' then begin
    d := g_WBagItemImages.Images[g_RentalRemoteItems.S.Looks];
     if d <> nil then
       with DRRGrid do begin
              dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
       end;
   end;
end;

procedure TFrmDlg.DRRGridMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   nLocalX,nLocalY,nHintX,nHintY:Integer;
   Butt:TDButton;
   NewName: sItemMome;
begin
   g_MouseItem.S.Name := '';
   g_MouseItem := g_RentalRemoteItems;
   
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DRentalRemoteDlg.SurfaceX(DRentalRemoteDlg.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DRentalRemoteDlg.SurfaceY(DRentalRemoteDlg.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
   end;
   if g_MouseItem.S.Name = '' then DScreen.ClearHint;
end;

procedure TFrmDlg.DRRGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DRRGold do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DRRentalCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwRentalActionTick then begin
      CloseRentalDlg;
      FrmMain.SendCancelRental;
   end;
end;

procedure TFrmDlg.RentalItemReturnBag (mitem: TClientItem);
begin
   if not g_boRentalEnd then begin
      g_RentalDlgItem := mitem;
      FrmMain.SendDelRentalItem (g_RentalDlgItem);
      g_dwRentalActionTick := GetTickCount + 4000;
   end;
end;

procedure TFrmDlg.DRRentalAllowDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
       d := WLib.Images[FaceIndex];
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DRentalMsgDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Deal: String ;
begin
   with DRentalMsgDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := clWhite;
         Deal := '×âÁÞ½»Ò×';
         TextOut (SurfaceX(Left + 4 + (TextWidth(Deal)) div 2), SurfaceY(Top+5), Deal);
         Release;
      end;
   end;
end;

procedure TFrmDlg.DReturnClick(Sender: TObject; X, Y: Integer);
begin
  if mrYes = FrmDlg.DMessageDlg ('ÄãÏë×âÁÞ ' +g_RentalItem.Item.S.Name +' Âð£¿', [mbYes, mbNo]) then
    SendClientMessage (CM_RRENTALITEM, g_MySelf.m_nRecogId, LoWord(g_RentalItem.RentalID),  HiWord(g_RentalItem.RentalID), 0);
end;

procedure TFrmDlg.DWithdrawClick(Sender: TObject; X, Y: Integer);
begin
    if g_OwnerItem.StartTime = 0 then exit;
    if g_OwnerItem.Withdraw = True then begin

      if mrYes = FrmDlg.DMessageDlg ('ÄãÏë·µ»¹×âÁÞµÄ ' +g_OwnerItem.Item.S.Name +' Âð£¿', [mbYes, mbNo]) then
        SendClientMessage (CM_ENDRENTALITEM, g_MySelf.m_nRecogId, LoWord(g_OwnerItem.RentalID), HiWord(g_OwnerItem.RentalID), 0);

      exit;
    end;
end;

procedure TFrmDlg.DRRefreshClick(Sender: TObject; X, Y: Integer);
begin
  if RentalPage = 0 then begin
    SendClientMessage(CM_GETRENTAL, g_MySelf.m_nRecogId, 0, 0, 0, '');
  end else begin
    SendClientMessage(CM_GETRENTAL2, g_MySelf.m_nRecogId, 0, 0, 0, '');
  end;
end;

procedure TFrmDlg.DUpCheckDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DUpCheck do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Color := $00ADD6EF;
         Font.Style := [fsBold];
         Font.Size := 11;
         TextOut (SurfaceX(Left+40), SurfaceY(Top+12), 'Éý¼¶¼ì²é');
         Font.Size := 9;
         Font.Style := [];
         Release;
      end;
   end;
end;

procedure TFrmDlg.DCheckSpotClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_UpWapon.S.Name <> '' then begin
         ItemClickSound (g_UpWapon.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -99;
         g_MovingItem.Item := g_UpWapon;
         g_MovingItem.Owner := DUpCheck;
         g_UpWapon.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;

      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DUpCheck) then begin
         ItemClickSound (g_MovingItem.Item.S);
         if CheckUpWeapon(g_MovingItem.Item.S.StdMode) and (g_MovingItem.Item.S.btValue[10] > 0) then begin  //´ë¿©¹«±â Á¦·Ãx
           if g_UpWapon.S.Name <> '' then begin
             temp := g_UpWapon;
             g_UpWapon := g_MovingItem.Item;
             g_MovingItem.Index := -99;
             g_MovingItem.Item := temp;
             g_MovingItem.Owner := DUpCheck;
           end else begin
             g_UpWapon := g_MovingItem.Item;
             g_MovingItem.Item.S.name := '';
             g_MovingItem.Owner := nil;
             g_boItemMoving := FALSE;
           end;
         end else begin
           CancelItemMoving;
           DMessageDlg ('Õâ¼þÎäÆ÷ÎÞ·¨Éý¼¶¡£',[mbOk]);
         end;
      end;
   end;
end;

procedure TFrmDlg.DCheckSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_UpWapon.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_UpWapon.S.Looks];
      if d <> nil then
         with DCheckSpot do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DCheckSpotMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   DScreen.ClearHint;
   g_MouseItem := g_UpWapon;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DUpCheck.SurfaceX(DUpCheck.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DUpCheck.SurfaceY(DUpCheck.Top) + nLocalY;

     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DCheckExitClick(Sender: TObject; X, Y: Integer);
begin
  DUpCheck.Visible := FALSE;
  CloseDUpWapon2;
end;

procedure TFrmDlg.DCheckOkClick(Sender: TObject; X, Y: Integer);
begin
   if (g_UpWapon.S.Name = '') and (g_UpWaponWait.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit;

    FrmMain.SendCheckWeaponItem (g_nCurMerchant, g_UpWapon.MakeIndex, g_UpWapon.S.Name);
    LastestClickTime := GetTickCount + 5000;

   g_UpWaponWait := g_UpWapon;
   g_UpWapon.S.Name := '';

end;

procedure TFrmDlg.DUpCheckMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DUpWeaponMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

function  TFrmDlg.MakeItemDlgShow ( msgstr: string ): TModalResult;     //Á¦Á¶½ºÃÄ
var
   i: integer;
begin

   DMakeItemDlg.Left := 252;//140;//291;
   DMakeItemDlg.Top  := 223;//176;

   DMakeItemDlg.Visible := True;

   //¾ÆÀÌÅÛ °¡¹æ¿¡ ÀÜ»óÀÌ ÀÖ´ÂÁö °Ë»ç
   ArrangeItembag;

end;

procedure TFrmDlg.DGuildGrowDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, e: TDirectDrawSurface;
  GuildName ,GuildExp : String;
  I:integer;
  rc:TRect;
  r: Real;
begin
  with DGuildGrowDlg do begin
    d := WLib.Images[FaceIndex];
     if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      case GrowPage of
        0 :begin
         DGuildGrowDlg.SetImgIndex (g_WTitleImages, 518);
         d := g_WTitleImages.Images[547];
           if d <> nil then
              dsurface.Draw (SurfaceX(Left+12), SurfaceY(Top+37), d.ClientRect, d, TRUE);

           if GrowIndex >= 1 then begin
             e := g_WMain2Images.Images[422];
              if e <> nil then
                dsurface.Draw (SurfaceX(Left+17), SurfaceY(Top + (GrowIndex * 38 ) + 49), e.ClientRect, e, TRUE);
           end;
        end;
        1: begin
         DGuildGrowDlg.SetImgIndex (g_WTitleImages, 519);
         d := g_WTitleImages.Images[549];
          if d <> nil then
             dsurface.Draw (SurfaceX(Left+83), SurfaceY(Top+37), d.ClientRect, d, TRUE);

         d := g_WMain2Images.Images[424];
          if d <> nil then
             dsurface.Draw (SurfaceX(Left+22), SurfaceY(Top+102), d.ClientRect, d, TRUE);

          if (GuildGrow1.GuildMaxExp > 0) then begin    //¹®ÆÄ °æÇèÄ¡ °ÔÀÌÁö
            d := g_WMain2Images.Images[423];
             if d <> nil then begin
               rc := d.ClientRect;
               if GuildGrow1.GuildExp > 0 then
                r := GuildGrow1.GuildMaxExp / GuildGrow1.GuildExp
               else
                r := 0;
                if r > 0 then
                 rc.Right := Round (rc.Right / r)
                else
                 rc.Right := 0;
                 dsurface.Draw (SurfaceX(Left+22), SurfaceY(Top+102), rc, d, FALSE);
                 with dsurface.Canvas do begin
                   SetBkMode(dsurface.Canvas.handle, TRANSPARENT);
                   GuildExp := FormatFloat('0%',(GuildGrow1.GuildExp / GuildGrow1.GuildMaxExp) * 100);
                   BoldTextOut (dsurface, SurfaceX(Left+ 150 - TextWidth(GuildExp) div 2), SurfaceY(Top+108) , clWhite, clBlack, GuildExp);
                  dsurface.Canvas.Release;
                 end;
             end;
          end;
        end;
      end;

      
      with Dsurface.Canvas do begin
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
        Font.Color := clWhite;
        Font.Size := 11;
        Font.Style := [fsBold];
        GuildName :=  '[' + GuildGrow1.GuildName + ' Lv' + IntToStr(GuildGrow1.GuildLevel) + ']';
        TextOut (SurfaceX(Left + (152 - TextWidth(GuildName) div 2)), SurfaceY(Top + 8) , GuildName);
        Font.Size := 9;
        Font.Style := [];

        if GrowPage = 0 then begin
          TextOut (SurfaceX(Left + 24), SurfaceY(Top + 69) , 'Ê£ÓàÐÐ»áµã: ' + IntToStr(GuildGrow1.GuildPoint));

          case GuildGrow1.GrowHP of
            0: begin
             DGGrow1.SetImgIndex(g_WGSkillImages, 2);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 92) , 'ÉúÃü');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 106) , '×î´óHP +20');
            end;
            1..4: begin
             DGGrow1.SetImgIndex(g_WGSkillImages, 0);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 92) , 'ÉúÃü');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 92) ,  IntToStr(GuildGrow1.GrowHP)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 106) , '×î´óHP +' + intToStr(GuildGrow1.GrowHP * 20));
            end;
            5 :begin
             DGGrow1.SetImgIndex(g_WGSkillImages, 1);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 92) , 'ÉúÃü');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 92) ,  IntToStr(GuildGrow1.GrowHP)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 106) , '×î´óHP +' + intToStr(GuildGrow1.GrowHP * 20));
            end;
          end;

          case GuildGrow1.GrowMP of
            0: begin
             DGGrow2.SetImgIndex(g_WGSkillImages, 5);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 130) , 'Ä§Á¦');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 144) , '×î´óMP +20');
            end;
            1..4: begin
             DGGrow2.SetImgIndex(g_WGSkillImages, 3);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 130) , 'Ä§Á¦');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 130) ,  IntToStr(GuildGrow1.GrowMP)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 144) , '×î´óMP +' + intToStr(GuildGrow1.GrowMP * 20));
            end;
            5 :begin
             DGGrow2.SetImgIndex(g_WGSkillImages, 4);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 130) , 'Ä§Á¦');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 130) ,  IntToStr(GuildGrow1.GrowMP)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 144) , '×î´óMP +' + intToStr(GuildGrow1.GrowMP * 20));
            end;
          end;


          case GuildGrow1.GrowEXP of
            0: begin
             DGGrow3.SetImgIndex(g_WGSkillImages, 44);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 168) , 'ÀÏÁ·');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 182) , 'PC EXP +4%');
            end;
            1..4: begin
             DGGrow3.SetImgIndex(g_WGSkillImages, 42);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 168) , 'ÀÏÁ·');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 168) ,  IntToStr(GuildGrow1.GrowEXP)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 182) , 'PC EXP +' + intToStr(GuildGrow1.GrowEXP * 4) + '%');
            end;
            5 :begin
             DGGrow3.SetImgIndex(g_WGSkillImages, 43);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 168) , 'ÀÏÁ·');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 168) ,  IntToStr(GuildGrow1.GrowEXP)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 182) , 'PC EXP +' + intToStr(GuildGrow1.GrowEXP * 4) + '%');
            end;
          end;

          case GuildGrow1.GrowAC of
            0: begin
             DGGrow4.SetImgIndex(g_WGSkillImages, 14);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 206) , 'ÈÌÄÍ');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 220) , 'AC +2');
            end;
            1..4: begin
             DGGrow4.SetImgIndex(g_WGSkillImages, 12);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 206) , 'ÈÌÄÍ');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 206) ,  IntToStr(GuildGrow1.GrowAC)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 220) , 'AC +' + intToStr(GuildGrow1.GrowAC * 2));
            end;
            5 :begin
             DGGrow4.SetImgIndex(g_WGSkillImages, 13);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 206) , 'ÈÌÄÍ');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 206) ,  IntToStr(GuildGrow1.GrowAC)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 220) , 'AC +' + intToStr(GuildGrow1.GrowAC * 2));
            end;
          end;



          case GuildGrow1.GrowMAC of
            0: begin
             DGGrow5.SetImgIndex(g_WGSkillImages, 17);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 244) , 'Ú¤Ïë');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 258) , 'MAC +2');
            end;
            1..4: begin
             DGGrow5.SetImgIndex(g_WGSkillImages, 15);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 244) , 'Ú¤Ïë');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 244) ,  IntToStr(GuildGrow1.GrowMAC)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 258) , 'MAC +' + intToStr(GuildGrow1.GrowMAC * 2));
            end;
            5 :begin
             DGGrow5.SetImgIndex(g_WGSkillImages, 16);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 244) , 'Ú¤Ïë');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 244) ,  IntToStr(GuildGrow1.GrowMAC)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 258) , 'MAC +' + intToStr(GuildGrow1.GrowMAC * 2));
            end;
          end;


          case GuildGrow1.GrowPower of
            0: begin
             DGGrow6.SetImgIndex(g_WGSkillImages, 20);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 282) , 'ÓÂÃÍ');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 296) , '¹¥»÷ +6');
            end;
            1..4: begin
             DGGrow6.SetImgIndex(g_WGSkillImages, 18);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 282) , 'ÓÂÃÍ');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 282) ,  IntToStr(GuildGrow1.GrowPower)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 296) , '¹¥»÷ +' + intToStr(5 + GuildGrow1.GrowPower));
            end;
            5 :begin
             DGGrow6.SetImgIndex(g_WGSkillImages, 19);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 282) , 'ÓÂÃÍ');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 282) ,  IntToStr(GuildGrow1.GrowPower)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 296) , '¹¥»÷ +' + intToStr(5 + GuildGrow1.GrowPower));
            end;
          end;


          case GuildGrow1.GrowLuck of
            0: begin
             DGGrow7.SetImgIndex(g_WGSkillImages, 23);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 320) , 'ÐÒÔË');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 334) , 'ÐÒÔË +1');
            end;
            1..4: begin
             DGGrow7.SetImgIndex(g_WGSkillImages, 21);
             Font.Color := $00B58431;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 320) , 'ÐÒÔË');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 320) ,  IntToStr(GuildGrow1.GrowLuck)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 334) , 'ÐÒÔË +1');
            end;
            5 :begin
             DGGrow7.SetImgIndex(g_WGSkillImages, 22);
             Font.Color := $000000DF;
             Font.Style := [fsBold];
             TextOut (SurfaceX(Left + 56), SurfaceY(Top + 320) , 'ÐÒÔË');
             Font.Color := clWhite;
             Font.Style := [];
             TextOut (SurfaceX(Left + 220), SurfaceY(Top + 320) ,  IntToStr(GuildGrow1.GrowLuck)   +'½×¶Î');
             TextOut (SurfaceX(Left + 57), SurfaceY(Top + 334) , 'ÐÒÔË +1');
            end;
          end;

        end else begin
           Font.Color := clWhite;
           Font.Size := 10;
           Font.Style := [fsBold];
           TextOut (SurfaceX(Left + 23), SurfaceY(Top + 66) , 'ÐÐ»áµÈ¼¶');
           TextOut (SurfaceX(Left + 236), SurfaceY(Top + 66) , 'Lv' + IntToStr(GuildGrow1.GuildLevel));
           TextOut (SurfaceX(Left + 23), SurfaceY(Top + 84) , 'ÐÐ»á¾­ÑéÖµ');
           TextOut (SurfaceX(Left + 23), SurfaceY(Top + 132) , '×î¸ß¹±Ï×Õß');
           TextOut (SurfaceX(Left + 23), SurfaceY(Top + 174) , '¹±Ï×ÕßÅÅÃû');
           Font.Size := 9;
           Font.Style := [];
        end;
        dsurface.Canvas.Release;
      end;
  end;
end;

procedure TFrmDlg.DGuildGrowDlgClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: Integer;
begin
  if GrowPage = 0 then begin
    lx := DGuildGrowDlg.LocalX(X) - DGuildGrowDlg.Left;
    ly := DGuildGrowDlg.LocalY(Y) - DGuildGrowDlg.Top - DGuildGrowDlg.SurfaceY(88);
    if (lx >= 18) and (lx <= 270) and (ly >= 0) then begin
      idx := ly div (GROWLINEHEIGHT );
      if idx <= 6 then begin    //¹®ÆÄ¼ºÀå Áö±ÝÀº 7°³
        PlaySound(s_glass_button_click);
        GrowIndex := idx + 1;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGuildGrowDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  sMsg:String;
  nHintX, nHintY: Integer;
  NewName: sItemMome;
begin
  DScreen.ClearHint;
  with Sender as TDWindow do begin



  nHintX := SurfaceX(Left) + DParent.SurfaceX(DParent.Left) + LocalX(X - Left);
  nHintY := SurfaceY(Top) + DParent.SurfaceY(DParent.Top) + LocalY(Y - Top) + 15;

  X := DGuildGrowDlg.LocalX (X) - DGuildGrowDlg.Left;
  Y := DGuildGrowDlg.LocalY (Y) - DGuildGrowDlg.Top;
  if GrowPage = 0 then begin
      if (X > 17) and (X < 270) and (Y > 88) and (Y < 122) then begin
          GetGrowInfo (NewName,1);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX + 8, nHintY, NewName, FALSE);
            exit;
          end;
      end else
      if (X > 17) and (X < 270) and (Y > 126) and (Y < 160) then begin
          GetGrowInfo (NewName,2);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX + 8, nHintY, NewName, FALSE);
            exit;
          end;
      end else
      if (X > 17) and (X < 270) and (Y > 164) and (Y < 198) then begin
          GetGrowInfo (NewName,3);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX + 8, nHintY, NewName, FALSE);
            exit;
          end;
      end else
      if (X > 17) and (X < 270) and (Y > 202) and (Y < 236) then begin
          GetGrowInfo (NewName,4);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX + 8, nHintY, NewName, FALSE);
            exit;
          end;
      end else
      if (X > 17) and (X < 270) and (Y > 240) and (Y < 274) then begin
          GetGrowInfo (NewName,5);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX + 8, nHintY, NewName, FALSE);
            exit;
          end;
      end else
      if (X > 17) and (X < 270) and (Y > 278) and (Y < 312) then begin
          GetGrowInfo (NewName,6);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX+ 8, nHintY, NewName, FALSE);
            exit;
          end;
      end;
      if (X > 17) and (X < 270) and (Y > 316) and (Y < 350) then begin
          GetGrowInfo (NewName,7);
          if NewName.sItemopes[0] <> '' then begin
            DScreen.NewShowHint(nHintX+ 8, nHintY, NewName, FALSE);
            exit;
          end;
      end;
   end;
  end;
end;

procedure TFrmDlg.DGGPage1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DGGPage1Click(Sender: TObject; X, Y: Integer);
begin
  GrowIndex := 0;
  GrowPage := 0;
  GrowPageChanged;
end;

procedure TFrmDlg.DGGPage2Click(Sender: TObject; X, Y: Integer);
begin
  GrowIndex := 0;
  GrowPage := 1;
  GrowPageChanged;
end;


procedure TFrmDlg.DGGrowExitClick(Sender: TObject; X, Y: Integer);
begin
  GrowIndex := 0;
  DGuildGrowDlg.Visible := False;
end;

procedure TFrmDlg.DGGrow1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DGGrow1 then
    GrowIndex := 1;
  if Sender = DGGrow2 then
    GrowIndex := 2;
   if Sender = DGGrow3 then
    GrowIndex := 3;
  if Sender = DGGrow4 then
    GrowIndex := 4;
  if Sender = DGGrow5 then
    GrowIndex := 5;
  if Sender = DGGrow6 then
    GrowIndex := 6;
  if Sender = DGGrow7 then
    GrowIndex := 7;
end;

procedure TFrmDlg.DGGrowUpClick(Sender: TObject; X, Y: Integer);
begin
   if GrowIndex >= 1 then begin
     if GuildGrow1.GuildPoint > 0 then begin
       FrmMain.SendGuildGrowUp(GrowIndex);
     end else begin
       DSimpleMessageDlg2 ('ÐÐ»á¼¼ÄÜµã²»×ã¡£', [mbOk]);
     end;
   end else begin
     DSimpleMessageDlg2 ('ÇëÑ¡ÔñÐèÒªÉý¼¶µÄÐÐ»á¼¼ÄÜ¡£', [mbOk]);
   end;
end;

procedure TFrmDlg.DGDGrowUpClick(Sender: TObject; X, Y: Integer);        //¹®ÆÄ¼ºÀå
begin
  if not DGuildGrowDlg.Visible then begin
    SendClientMessage (CM_QUERYGUILDGROW, g_MySelf.m_nRecogId, 0, 0, 0);
    exit;
  end else begin
    DGuildGrowDlg.Visible := False;
  end;
end;

procedure TFrmDlg.DMakeItemDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_Myself = nil then exit;
   with DMakeItemDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      d := g_WTitleImages.Images[43];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left + 37), SurfaceY(Top + 5), d.ClientRect, d, TRUE);

      with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 95), clWhite, clBlack, 'Çë·ÅÉÏ²ÄÁÏ¡£');
         BoldTextOut (dsurface, SurfaceX(Left + 12) , SurfaceY(Top + 115), clWhite, clBlack, 'ÖÆÔìºóËùÓÐµÄ²ÄÁÏ¶¼»áÏûÊ§¡£');
         Release;
      end;
   end;
end;

procedure TFrmDlg.DMakeItemDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DMakeItemDlgOkClick(Sender: TObject; X, Y: Integer);
var
  data:String;
begin
   if Sender = DMakeItemDlgOk then begin
      DMakeItemDlg.DialogResult := mrOk;
      data := NameMakeItem;
      data := data + '/' + MakeStrMakeItem();
      FrmMain.SendMakeItem(g_nCurMerchant, data);
   end;
   if (Sender = DMakeItemDlgCancel) or (Sender = DMakeItemDlgClose) then begin
      DMakeItemDlg.DialogResult := mrCancel;
   end;
   MoveMakeItemToBag;

   DMakeItemDlg.Visible := False;
   DMakeItemDlgClose.Downed := False;
end;

procedure TFrmDlg.DMakeitemGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState;
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
   idx := ACol + ARow * DMakeitemGrid.ColCount;
   if idx in [0..5] then begin
      if MakeItemArr[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[MakeItemArr[idx].S.Looks];
         if d <> nil then
            with DMakeitemGrid do
               dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1)+ACol,
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1)+ARow,
                              d.ClientRect,
                              d, TRUE);
            // ¾ÆÀÌÅÛ °ãÄ¡±â
            if (MakeItemArr[idx].Amount > 0) and (MakeItemArr[idx].S.StdMode in [0,1,3,45,46]) then begin
               SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
               dsurface.Canvas.Font.Color := clYellow;

               dsurface.Canvas.TextOut (DMakeitemGrid.SurfaceX(Rect.Left +20), DMakeitemGrid.SurfaceY(Rect.Top +20),
                                        IntToStr(MakeItemArr[idx].Amount));
               dsurface.Canvas.Release;
            end;
      end;
   end;

end;


procedure TFrmDlg.DMakeitemGridGridSelect(Sender: TObject; X, Y: integer; ACol, ARow: Integer;
  Shift: TShiftState);
var
   mi, idx: Integer;
begin
      if not g_boItemMoving then begin
         idx := ACol + ARow * DMakeitemGrid.ColCount;
         if idx in [0..5] then
            if MakeItemArr[idx].S.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 46;
               g_MovingItem.Item := MakeItemArr[idx];
               MakeItemArr[idx].S.Name := '';
               g_MovingItem.Owner := DMakeItemDlg;
               ItemClickSound (g_MovingItem.Item.S);
            end;
      end else begin
         mi := g_MovingItem.Index;
         if (g_MovingItem.Owner = DHeroItemBag) or (g_MovingItem.Owner = DStateWin) or (g_MovingItem.Owner = DHeroStateWin) then Exit;
         if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DMakeItemDlg) then begin   //°Å·¡
            ItemClickSound (g_MovingItem.Item.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
              MakingDlgItem := g_MovingItem.Item;
              AddMakeItem(MakingDlgItem);
            end else
              AddMakeItem(g_MovingItem.Item);
            g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
         end;
         if (mi = -97) or (mi = -98) then CancelItemMoving;
      end;
      ArrangeItemBag;
end;


procedure TFrmDlg.DMakeitemGridGridMouseMove(Sender: TObject; X, Y: integer; ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx: integer;
   nHintX,nHintY:Integer;
   iname, d1, d2, d3, d4, d5: string;
   useable, Jobuseable: Boolean;
   hcolor: TColor;
begin
   DScreen.ClearHint;
   idx := ACol + ARow * DMakeitemGrid.ColCount;
   if idx in [0..5] then begin
      g_MouseItem := MakeItemArr[idx];
   end;
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     with DMakeitemGrid do
     DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, True);
   end;
end;

procedure TFrmDlg.DBHelpGuildClick(Sender: TObject; X, Y: Integer);
begin
  DHelpWin.Visible:=not DHelpWin.Visible;
  HelpPage := 11;
end;

procedure TFrmDlg.DOptionsSoundOnDirectPaint(Sender: TObject;        //½ºÃÄ »ç¿îµå
  dsurface: TDirectDrawSurface);
var
 d: TDirectDrawSurface;
 rc:TRect;
  btop, sx, sy, i, fcolor, bcolor , strln: integer;
  r: Real;
begin
  with DOptionsSoundOn do begin
   // º¼·ý °ÔÀÌÁö
     d := g_WMain2Images.Images[468];
     if d <> nil then begin
       rc := d.ClientRect;
       if (g_btSoundVolume) > 0 then  r := 100 / (g_btSoundVolume)
        else r := 0;
       if r > 0 then rc.Right := Round (rc.Right / r)
        else rc.Right := 0;
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), rc, d, FALSE);
     end;
  end;
end;

procedure TFrmDlg.DOptionsSoundOnMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if DOptionsSoundOn.Downed then begin
    if (X > 161) and (X < 238) and (Y > 115) and (Y < 134) then begin
       g_btSoundVolume:= Round((X - 161) * 1.3);
       if g_btSoundVolume <= 0 then begin
         g_boSound := False;
         SilenceSound;
       end else begin
         g_boSound := True;
       end;
       g_Sound.Volume := g_btSoundVolume;
    end;
  end;
end;

procedure TFrmDlg.DOptionsSoundOnMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if DOptionsSoundOn.Downed then begin
    if (X > 161) and (X < 237) and (Y > 117) and (Y < 136) then begin
       g_btSoundVolume:= Round((X - 161) * 1.3);
       if g_btSoundVolume <= 0 then begin
         g_boSound := False;
         SilenceSound;
       end else begin
         g_boSound := True;
       end;
       g_Sound.Volume := g_btSoundVolume;
    end;
  end;
end;

procedure TFrmDlg.DOptionsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
 DScreen.ClearHint;
end;

procedure TFrmDlg.DOptionsDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d :TDirectDrawSurface;
begin
  with DOptions do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLoverMailClick(Sender: TObject; X, Y: Integer);
var
  Name: String;
begin
  Name := fLover.GetName(RsState_Lover);
  if Name <> '' then begin
    ViewWindowNo   := VIEW_MAILSEND;
    ViewWindowData := CurrentMail;

    DMemoB1.SetImgIndex(g_WTitleImages, 190);
    DMemoB2.SetImgIndex(g_WTitleImages, 193);
    DMemoB1.Left:=30;
    DMemoB1.Top:=265;
    DMemoB2.Left:=134;
    DMemoB2.Top:=265;
    DMemoB3.Visible := False;

    MemoMail.Clear;
    MemoMail.ReadOnly := false;
    MemoCharID := Name;
    ShowEditMail;
  end;
end;

procedure TFrmDlg.DLoverWhisperClick(Sender: TObject; X, Y: Integer);
begin
  if Copy(fLover.GetDisplay(0), length(STR_LOVER) + 1, 6) <> '' then begin
      PlayScene.EdChat.Visible :=TRUE;
      PlayScene.EdChat.SetFocus;
      SetImeMode (PlayScene.EdChat.Handle, imSHanguel);   //ÇÑ±Û
      PlayScene.EdChat.Text := '¢½';
      PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
      PlayScene.EdChat.SelLength := 0;
  end;
end;


procedure TFrmDlg.DOptionClick1(Sender: TObject; X, Y: Integer);
begin
  DOptionClick();
end;

procedure TFrmDlg.DWinPetDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d,e,f,g: TDirectDrawSurface;
   rc, rc2:TRect;
   r, r2: Real;
   LeftX, LeftX2 : integer;
   Satiety, Rage, Rage2 :String;
begin
   if g_MySelf = nil then exit;
   with DWinPet do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      e := g_WTitleImages.Images[19];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left+38), SurfaceY(Top + 4), e.ClientRect, e, TRUE);

      e := g_WMain2Images.Images[427];
      if e <> nil then
         dsurface.Draw (SurfaceX(Left+28), SurfaceY(Top + 348), e.ClientRect, e, TRUE);

      if PetInfoBoots >= 0 then begin
        f := g_WMain2Images.Images[530];
        if f <> nil then
           dsurface.Draw (SurfaceX(Left + 185), SurfaceY(Top + 129), f.ClientRect, f, TRUE);

        g := g_WMain2Images.Images[531];
        if g <> nil then begin
          rc := g.ClientRect;
          if g_PetInfo[PetInfoBoots].Satiety > 0 then
            r := 100 / g_PetInfo[PetInfoBoots].Satiety
          else r := 0;
          if r > 0 then rc.Right := Round (rc.Right / r)
          else rc.Right := 0;
          dsurface.Draw (SurfaceX(Left + 185), SurfaceY(Top + 129), rc, g, TRUE);
          LeftX := rc.Right;

          rc2 := g.ClientRect;
          {if g_PetInfo[PetInfoBoots].SatietyLimit > 0 then
            r2 := 100 / (g_PetInfo[PetInfoBoots].SatietyLimit - 1)
          else }r2 := 0;
          if r2 > 0 then rc2.Right := Round (rc2.Right / r2)
           else rc2.Right := 0;
          LeftX2 := rc2.Right;   
        end;

        DPetPickUp.Visible := True;
        DPetFood.Visible := True;

        DPetPickUp.Left :=  177 + LeftX2;
        DPetFood.Left :=  177 + LeftX;
      end else begin
          DPetPickUp.Visible := False;
          DPetFood.Visible := False;
      end;

      with dsurface.Canvas do begin
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);

        if g_PetInfo[PetInfoBoots].StartTime <> 0 then begin
          Font.Color := clWhite;
          TextOut ( Left+172, Top + 56, g_PetInfo[PetInfoBoots].PetName);

          Satiety := IntToStr(g_PetInfo[PetInfoBoots].Satiety);

          BoldTextOut (dsurface, Left+302 - TextWidth(Satiety) div 2, Top + 130, clWhite, clBlack, Satiety);

          if g_PetInfo[PetInfoBoots].Period <> 0 then begin
            if g_PetInfo[PetInfoBoots].EndTime <= now then begin
              TextOut ( Left+238, Top + 91, 'Ê¹ÓÃÊ±¼äµ½ÆÚ¡£');
            end else begin
              TextOut ( Left+180, Top + 91, FormatDateTime('½ØÖ¹ÈÕÆÚ: yyyyÄê mmÔÂ ddÈÕ hhÊ±nn·Ö', g_PetInfo[PetInfoBoots].EndTime));
            end;
          end else begin
            TextOut ( Left+238, Top + 91, 'Ã»ÓÐÊ¹ÓÃÆÚÏÞ¡£');
          end;
          Rage := IntToStr(g_PetInfo[PetInfoBoots].EatRage * 2 + 1);
          Rage2 := IntToStr(g_PetInfo[PetInfoBoots].EatRage * 2 + 3);
          TextOut ( Left+24, Top + 166, 'ÁéÎï¼ñÈ¡ÎïÆ·(' + Rage + 'x' + Rage  +' ×Ô¶¯/ÊÖ¶¯£¬'+ Rage2 + 'x' + Rage2 +' Êó±ê)');
     //     TextOut ( Left+24, Top + 180, 'È«¿Á»ý»ê °¡´É');
          TextOut ( Left+24, Top + 194, 'ÁéÎï¿ÉÒÔ¼ñÈ¡½ð±Ò¡¢Ò©Ë®');
        end;

        dsurface.Canvas.Release;
      end;

      if PetInfoBoots >= 0 then begin
        e := g_WMain2Images.Images[540 + g_PetInfo[PetInfoBoots].PetNumber * 30];
        if e <> nil then
          dSurface.Draw (SurfaceX(Left + 72 - (e.Width) div 2 ), SurfaceY(Top + 94 - (e.Height) div 2 ), e, TRUE);

        if g_PetInfo[PetInfoBoots].ChangName = 0 then begin
          DPetName.Visible := True;
        end else begin
          DPetName.Visible := False;
        end;

      end else begin
        DPetName.Visible := False;
      end;
   end;
end;

procedure TFrmDlg.DPetExitClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowPetDlg;
end;

procedure TFrmDlg.DBotPetClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowPetDlg;
end;

procedure TFrmDlg.DBHelpPetClick(Sender: TObject; X, Y: Integer);
begin
  DHelpWin.Visible:=not DHelpWin.Visible;
  HelpPage := 14;
end;

procedure TFrmDlg.DWinPetMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;
begin
  DScreen.ClearHint;
  Butt := TDButton(Sender);
  if Sender = DPetPickUp then begin
    sMsg := '×Ô¶¯Ê°È¡ÏÔÊ¾¡£\Ö»ÓÐÔÚÒ»¶¨·¶Î§ÄÚ²ÅÄÜ¼ñÈ¡¡£';
    nHintX := Butt.SurfaceX(Butt.Left);
    nHintY := Butt.SurfaceY(Butt.Top);
    DScreen.ShowHintA(nHintX - 30, nHintY, sMsg, clWhite, True);
  end;

  if Sender = DPetFood then begin
    sMsg := '³èÎïµÄ¼ñÈ¡·¶Î§ÏÞÖÆÏÔÊ¾¡£\Ö»ÓÐÌØÊâµÄ³èÎï²ÅÄÜ³¬¹ýÕâ¸öÏÞÖÆ¡£';
    nHintX := Butt.SurfaceX(Butt.Left);
    nHintY := Butt.SurfaceY(Butt.Top);
    DScreen.ShowHintA(nHintX - 30, nHintY + 10, sMsg, clWhite, False);
  end;
end;

procedure TFrmDlg.DPet1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 PetInfo :TPetInfo;
 d,e: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    PetInfo := g_PetInfo[Tag];

    if PetInfo.StartTime <> 0 then begin
       d:= g_WMain2Images.Images[500 + PetInfo.PetNumber];
       if d <> nil then
         dsurface.Draw (SurfaceX(TDButton(Sender).Left + ((TDButton(Sender).Width) - d.Width) div 2) + 2,
         SurfaceY(TDButton(Sender).Top + (TDButton(Sender).Height - d.Height) div 2), d.ClientRect, d, TRUE);

       if PetInfoBoots = Tag then begin
         e := g_WMain2Images.Images[535];
         if e <> nil then
             dsurface.Draw(SurfaceX(TDButton(Sender).Left + 1), SurfaceY(TDButton(Sender).Top - 1),  e.ClientRect,  e, TRUE);
       end;
    end;

  end;
end;

procedure TFrmDlg.DPet1Click(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if g_PetInfo[Tag].StartTime <> 0 then begin
      PlaySound(s_norm_button_click);
      PetInfoBoots := Tag;
    end;
  end;
end;

procedure TFrmDlg.DReleaseClick(Sender: TObject; X, Y: Integer);
begin
   if PetinfoBoots >= 0 then begin
     if mrYes = FrmDlg.DMessageDlg ('ÄãÕæµÄÒª·ÅÆúÕâ¸öÁéÎïÂð£¿', [mbYes, mbNo]) then
       SendClientMessage (CM_DELETEPET, g_MySelf.m_nRecogId, LoWord(g_PetInfo[PetinfoBoots].PetID), HiWord(g_PetInfo[PetinfoBoots].PetID), 0);
       PetinfoBoots := -1;
       if DWinPet.Visible then
        DPet1Click(DPet1,1,1);
   end;
end;

procedure TFrmDlg.DSommonClick(Sender: TObject; X, Y: Integer);
begin
  if not g_MySelf.m_boDeath then begin
    if GetTickCount - g_dwRecallPetTick > 1000 then begin
      if not g_BoPetOn then begin
        if PetinfoBoots >= 0 then begin
          g_dwRecallPetTick := GetTickCount;
          SendClientMessage(CM_SUMMONPET, g_MySelf.m_nRecogId, LoWord(g_PetInfo[PetinfoBoots].PetID), HiWord(g_PetInfo[PetinfoBoots].PetID), 0, sPetOption);
        end;
      end else begin
        g_dwRecallPetTick := GetTickCount;
        SendClientMessage(CM_NOTSUMMONPET, 0, 0, 0, 0, sPetOption);
      end;
    end;
  end;
end;

procedure TFrmDlg.DSommonDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
    if g_BoPetOn then begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 6];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 5];
      end else begin
         d := WLib.Images[FaceIndex + 4];
      end;
    end else begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
    end;

      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DPetNameClick(Sender: TObject; X, Y: Integer);     //¿µ¹° ÀÌ¸§¹Ù²Ù±â
var
  ChangName: String;
begin
  if PetinfoBoots >= 0 then begin
    if g_PetInfo[PetinfoBoots].ChangName = 0 then begin
      FrmDlg.DlgEditText := '';
      FrmDlg.DMessageDlg ('ÇëÊäÈëÒª¸ü¸ÄµÄÃû×Ö...', [mbOk, mbAbort]);
      ChangName := Trim(FrmDlg.DlgEditText);

      if ChangName <> '' then begin
        if length(FrmDlg.DlgEditText) > 14 then begin
          DMessageDlg ('Ãû×ÖµÄ×î´ó³¤¶È²»ÄÜ³¬¹ý7¸öºº×Ö.', [mbOk]);
          exit;
        end;
        SendClientMessage(CM_CHANGPETNAME, g_MySelf.m_nRecogId, LoWord(g_PetInfo[PetinfoBoots].PetID), HiWord(g_PetInfo[PetinfoBoots].PetID), 0, ChangName);
      end;
    end;
  end;
end;

procedure TFrmDlg.DPetPickUpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DPetOptionClick(Sender: TObject; X, Y: Integer);
begin
   ToggleOptionPetDlg;
   DPetOptionDlg.Visible := Not DPetOptionDlg.Visible;
end;

procedure TFrmDlg.DCancelPetClick(Sender: TObject; X, Y: Integer);
begin
  ToggleOptionPetDlg;
  DPetOptionDlg.Visible := False;
end;

procedure TFrmDlg.DPetOptionDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;

   DPetOptionDlg.Left := DWinPet.Left + DWinPet.Width;
   with DPetOptionDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);



      with dsurface.Canvas do begin
        SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);

        Font.Color := clWhite;
        TextOut ( Left+36, Top + 17, 'È«²¿');
        TextOut ( Left+36, Top + 47, '½ð±Ò');
        TextOut ( Left+36, Top + 77, 'ÎäÆ÷');
        TextOut ( Left+36, Top + 107, 'ÒÂ·þ');
        TextOut ( Left+36, Top + 137, 'Í·¿ø');
        TextOut ( Left+36, Top + 167, 'Ñ¥×Ó');
        TextOut ( Left+36, Top + 197, 'Ñü´ø');
        TextOut ( Left+36, Top + 227, 'Ê×ÊÎ');
        TextOut ( Left+36, Top + 257, 'ÆäËû');


        dsurface.Canvas.Release;
      end;
   end;
end;

procedure TFrmDlg.DSavePetClick(Sender: TObject; X, Y: Integer);
var
  sData :String;
begin
  sData := '';

  if GetTickCount > g_dwQueryMsgTick then begin
    if DAllItem.Visible then g_boItemAll := 1 else g_boItemAll := 0;
    if DGoldItem.Visible then g_boItemGold := 1 else g_boItemGold := 0;
    if DWeaponItem.Visible then g_boItemWeapon := 1 else g_boItemWeapon := 0;
    if DDressItem.Visible then g_boItemDress := 1 else g_boItemDress := 0;
    if DHelmatItem.Visible then g_boItemHelmet := 1 else g_boItemHelmet := 0;
    if DBootsItem.Visible then g_boItemBoots := 1 else g_boItemBoots := 0;
    if DBeltItem.Visible then g_boItemBelt := 1 else g_boItemBelt := 0;
    if DAccessoryItem.Visible then g_boItemAccessory := 1 else g_boItemAccessory := 0;
    if DEtcItem.Visible then g_boItemEtc := 1 else g_boItemEtc := 0;
    g_dwQueryMsgTick := GetTickCount + 2000;
    sData := sData + IntToStr(g_boItemAll) + ':' + inttostr(g_boItemGold) + ':' + inttostr(g_boItemWeapon) + ':' + inttostr(g_boItemDress) + ':' + inttostr(g_boItemHelmet) + ':' + inttostr(g_boItemBoots) + ':' + inttostr(g_boItemBelt) + ':' + inttostr(g_boItemAccessory) + ':' + inttostr(g_boItemEtc) + '/';
    sPetOption := IntToStr(g_boItemAll) + ':' + inttostr(g_boItemGold) + ':' + inttostr(g_boItemWeapon) + ':' + inttostr(g_boItemDress) + ':' + inttostr(g_boItemHelmet) + ':' + inttostr(g_boItemBoots) + ':' + inttostr(g_boItemBelt) + ':' + inttostr(g_boItemAccessory) + ':' + inttostr(g_boItemEtc) + '/';
    SendClientMessage(CM_PETOPTION, 0, LoWord(g_PetInfo[PetinfoBoots].PetID), HiWord(g_PetInfo[PetinfoBoots].PetID), 0, sData);
  end;
end;

procedure TFrmDlg.DPetOptionDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   X := DPetOptionDlg.LocalX (X) - DPetOptionDlg.Left;
   Y := DPetOptionDlg.LocalY (Y) - DPetOptionDlg.Top;

   if (X > 16) and (X < 100) and (Y > 13) and (Y < 30) then begin
       DAllItem.Visible := True;
       DGoldItem.Visible := False;
       DWeaponItem.Visible:= False;
       DDressItem.Visible:= False;
       DHelmatItem.Visible:= False;
       DBootsItem.Visible:= False;
       DBeltItem.Visible:= False;
       DAccessoryItem.Visible:= False;
       DEtcItem.Visible:= False;
       PlaySound (s_glass_button_click)
   end else
   if (X > 16) and (X < 100) and (Y > 43) and (Y < 60) then begin
        DGoldItem.Visible := Not DGoldItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end else
   if (X > 16) and (X < 100) and (Y > 73) and (Y < 90) then begin
        DWeaponItem.Visible:= not DWeaponItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end else
   if (X > 16) and (X < 100) and (Y > 103) and (Y < 120) then begin
        DDressItem.Visible:= not DDressItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end else
   if (X > 16) and (X < 100) and (Y > 133) and (Y < 150) then begin
        DHelmatItem.Visible:= Not DHelmatItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end;
   if (X > 16) and (X < 100) and (Y > 163) and (Y < 180) then begin
        DBootsItem.Visible:= not DBootsItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end;
   if (X > 16) and (X < 100) and (Y > 193) and (Y < 210) then begin
        DBeltItem.Visible:= not DBeltItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end;
   if (X > 16) and (X < 100) and (Y > 223) and (Y < 240) then begin
        DAccessoryItem.Visible:= not DAccessoryItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end;
   if (X > 16) and (X < 100) and (Y > 253) and (Y < 270) then begin
        DEtcItem.Visible:= not DEtcItem.Visible;
        DAllItem.Visible := False;
        PlaySound (s_glass_button_click)
   end;
end;

procedure TFrmDlg.DAutoPickUpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if g_boItemAuto = 1 then begin
        if Downed then begin
           d := WLib.Images[FaceIndex + 2];
        end else
        if MouseMoveing then begin
           d := WLib.Images[FaceIndex + 1];
        end else
           d := WLib.Images[FaceIndex];
      end else begin
        if Downed then begin
           d := WLib.Images[FaceIndex + 5];
        end else
        if MouseMoveing then begin
           d := WLib.Images[FaceIndex + 4];
        end else
           d := WLib.Images[FaceIndex + 3];
      end;

      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DAutoPickUpClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
    if g_boItemAuto = 1 then g_boItemAuto := 2 else g_boItemAuto :=1 ;
      g_dwQueryMsgTick := GetTickCount + 2000;
      SendClientMessage(CM_PETAUTO, 0, g_boItemAuto, 0, 0, '');

      if g_boItemAuto = 1 then  DScreen.AddChatBoardString('<¿ªÆô³èÎï×Ô¶¯¼ñÈ¡>',clGreen,clWhite)
       else DScreen.AddChatBoardString('<¹Ø±Õ³èÎï×Ô¶¯¼ñÈ¡>',clGreen,clWhite);
   end;
end;


procedure TFrmDlg.DSUseSortDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if g_ShopSort then begin
        d := g_WMainImages.Images[819];

       if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end else
        d:= nil;
   end;

end;

procedure TFrmDlg.DSUseSortClick(Sender: TObject; X, Y: Integer);
var
  sData: string;
begin
   sData := '';
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    g_ShopSort := Not g_ShopSort;
    if g_ShopSort then begin
       g_ShopSortMode := 2;
       if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
       SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
    end else begin
       g_ShopSortMode := 0;
       if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
        end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
       SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
    end;
  end;
end;

procedure TFrmDlg.DSCostSortDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   ShopCaView: String;
begin
   with Sender as TDButton do begin
     if g_ShopSortMode = 1 then begin
       if Downed then d := WLib.Images[FaceIndex - 1] else d := WLib.Images[FaceIndex - 2];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
     end else begin
       if Downed then d := WLib.Images[FaceIndex + 1] else d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
     end;

     SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
     dsurface.Canvas.Font.Size :=9;
     ShopCaView := '¼Û¡¡¸ñ';
     BoldTextOut (dsurface, SurfaceX(Left + (d.Width - dsurface.Canvas.TextWidth(ShopCaView)) div 2 - 4),
     SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(ShopCaView)) div 2), clWhite , clBlack, ShopCaView);
     dsurface.Canvas.Release;
   end;
end;

procedure TFrmDlg.DSCostSortClick(Sender: TObject; X, Y: Integer);
var
  sData: string;
begin
   sData := '';
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if g_ShopSort then begin
      if g_ShopSortMode = 1 then begin
        g_ShopSortMode := 2;
        if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
         end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
        SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
      end else begin
        g_ShopSortMode := 1;
        if EdShopEdit.Text <> '' then begin sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + EdShopEdit.Text;
         end else sData := sData + IntToStr(g_ShopCurrSection) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + '';
        SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
      end;
    end;
  end;
end;

procedure TFrmDlg.DitemnamertClick(Sender: TObject; X, Y: Integer);
var
   findstr, sData : string;
begin
   sData := '';
   if GetTickCount < LastestClickTime then exit; //Å¬¸¯À» ÀÚÁÖ ¸øÇÏ°Ô Á¦ÇÑ
   findstr := trim(EdShopEdit.Text);
   findstr := Copy( findstr, 1, 14);
   if findstr <> '' then begin
     sData := sData + IntToStr(100) + ':' +  IntToStr(g_ShopCurrJob) + ':' + IntToStr(1) + ':' + IntToStr(g_ShopSortMode) + ':' + findstr;
     SendClientMessage(CM_LOADSHOPITEM, g_MySelf.m_nRecogId , 0, 0, 0, sData);
   end;
   LastestClickTime := GetTickCount + 5000;
end;

procedure TFrmDlg.DItemShopDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   with DItemShopDlg do begin
      DItemShopDlg.EnableFocus := True;
      EdShopEdit.Visible := TRUE;
      EdShopEdit.SetFocus;
      SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
   end;
end;

procedure TFrmDlg.DSalesMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
   if g_AuctionCurrSection = 31 then begin
     with DSales do
        DSales.EnableFocus := True;
        CostSalesEdit.SetFocus;
        CostSalesEdit.Visible := TRUE;
        EdSalesEdit.Visible := False;
        SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
   end else begin
      with DSales do
        DSales.EnableFocus := True;
        EdSalesEdit.Visible := TRUE;
        CostSalesEdit.Visible := False;
        EdSalesEdit.SetFocus;
        SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
   end;
end;

procedure TFrmDlg.DAuc0DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDButton;
  dd, e: TDirectDrawSurface;
  AucCaView:string;
begin
  if Sender = DAuc0 then AucCaView := 'È«²¿';
  if Sender = DAuc1 then AucCaView := 'ÎäÆ÷';
  if Sender = DAuc2 then AucCaView := '·À¾ß';
  if Sender = DAuc7 then AucCaView := 'Ê×ÊÎ';
  if Sender = DAuc12 then AucCaView := 'ÏûºÄÆ·';
  if Sender = DAuc18 then AucCaView := 'Ç¿»¯×°±¸';
  if Sender = DAuc23 then AucCaView := '¼¼ÄÜ';
  if Sender = DAuc28 then AucCaView := 'ÈÎÎñ';
  if Sender = DAuc29 then AucCaView := 'ÆäËû';
  if Sender = DAuc30 then AucCaView := '³õÊ¼»¯';

  with Sender as TDButton do begin
     d := TDButton(Sender);
     if g_AuctionCurrSection = d.Tag then begin
       e := d.WLib.Images[FaceIndex+1];
     end else begin
       e := nil;
     end;
     if not d.Downed then dd := d.WLib.Images[FaceIndex]
      else dd := d.WLib.Images[FaceIndex+1];
     if dd <> nil then dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
     if e <> nil then dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), e.ClientRect, e, TRUE);

     with Dsurface.Canvas do begin
       SetBkMode (Handle, TRANSPARENT);
       Font.Size :=9;
       Font.Color := clWhite;
       TextOut (SurfaceX(Left + (d.Width - TextWidth(AucCaView)) div 2), SurfaceY(Top + (d.Height - TextHeight(AucCaView)) div 2), AucCaView);
       Release;
     end;
  end;
end;

procedure TFrmDlg.DAuc3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDButton;
  dd, e: TDirectDrawSurface;
  AucCaView:string;
begin
  if Sender = DAuc3 then AucCaView := 'Í·¿ø';
  if Sender = DAuc4 then AucCaView := 'ÒÂ·þ';
  if Sender = DAuc5 then AucCaView := 'Ñü´ø';
  if Sender = DAuc6 then AucCaView := 'Ñ¥×Ó';

  if Sender = DAuc8 then AucCaView := 'ÏîÁ´';
  if Sender = DAuc9 then AucCaView := '½äÖ¸';
  if Sender = DAuc10 then AucCaView := 'ÊÖïí&ÊÖÌ×';
  if Sender = DAuc11 then AucCaView := 'ÊØ»¤Ê¯';

  if Sender = DAuc13 then AucCaView := '»Ö¸´';
  if Sender = DAuc14 then AucCaView := 'Ç¿»¯';
  if Sender = DAuc15 then AucCaView := 'ÐÞ¸´';
  if Sender = DAuc16 then AucCaView := '´«ËÍ¾í';
  if Sender = DAuc17 then AucCaView := 'ÆäËû';

  if Sender = DAuc19 then AucCaView := '±¦Óñ';
  if Sender = DAuc20 then AucCaView := '±¦Öé';
  if Sender = DAuc21 then AucCaView := '×£¸£ÓÍ';
  if Sender = DAuc22 then AucCaView := '¿óÊ¯';
  if Sender = DAuc32 then AucCaView := '¾õÐÑ';

  if Sender = DAuc24 then AucCaView := 'Õ½Ê¿ÏµÁÐ';
  if Sender = DAuc25 then AucCaView := '·¨Ê¦ÏµÁÐ';
  if Sender = DAuc26 then AucCaView := 'µÀÊ¿ÏµÁÐ';
  if Sender = DAuc27 then AucCaView := '´Ì¿ÍÏµÁÐ';
  if Sender = DAuc31 then AucCaView := 'ºÍÉÐÏµÁÐ';


  with Sender as TDButton do begin
     d := TDButton(Sender);
     if g_AuctionCurrSection = d.Tag then begin
       e := d.WLib.Images[FaceIndex+1];
     end else begin
       e := nil;
     end;
     if not d.Downed then dd := d.WLib.Images[FaceIndex]
      else dd := d.WLib.Images[FaceIndex+1];
     if dd <> nil then dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
     if e <> nil then dsurface.Draw (SurfaceX(d.Left), SurfaceY(d.Top), e.ClientRect, e, TRUE);

     with Dsurface.Canvas do begin
       SetBkMode (Handle, TRANSPARENT);
       Font.Size :=9;
       Font.Color := clWhite;
       TextOut (SurfaceX(Left + 16), SurfaceY(Top + (d.Height - TextHeight(AucCaView)) div 2), AucCaView);
       Release;
     end;
  end;
end;

procedure TFrmDlg.DAuc0Click(Sender: TObject; X, Y: Integer);
var
  sData : String;
begin
   sData := '';
   if GetTickCount > g_dwQueryMsgTick then begin
     g_dwQueryMsgTick := GetTickCount + 500;

     case TDButton(Sender).Tag of
        2..6: begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := True; DAuc4.Visible := True; DAuc5.Visible := True; DAuc6.Visible := True;
          DAuc8.Visible := False; DAuc9.Visible := False; DAuc10.Visible := False; DAuc11.Visible := False;
          DAuc13.Visible := False; DAuc14.Visible := False; DAuc15.Visible := False; DAuc16.Visible := False; DAuc17.Visible := False;
          DAuc19.Visible := False; DAuc20.Visible := False; DAuc21.Visible := False; DAuc22.Visible := False; DAuc32.Visible := False;
          DAuc24.Visible := False; DAuc25.Visible := False; DAuc26.Visible := False; DAuc27.Visible := False; DAuc31.Visible := False;

          DAuc7.Top:=60+24*7; DAuc12.Top:=60+24*8; DAuc18.Top:=60+24*9; DAuc23.Top:=60+24*10; DAuc28.Top:=60+24*11; DAuc29.Top:=60+24*12;
        end;
        7..11: begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := False; DAuc4.Visible := False; DAuc5.Visible := False; DAuc6.Visible := False;
          DAuc8.Visible := True; DAuc9.Visible := True; DAuc10.Visible := True; DAuc11.Visible := True;
          DAuc13.Visible := False; DAuc14.Visible := False; DAuc15.Visible := False; DAuc16.Visible := False; DAuc17.Visible := False;
          DAuc19.Visible := False; DAuc20.Visible := False; DAuc21.Visible := False; DAuc22.Visible := False; DAuc32.Visible := False;
          DAuc24.Visible := False; DAuc25.Visible := False; DAuc26.Visible := False; DAuc27.Visible := False; DAuc31.Visible := False;

          DAuc7.Top:=60+24*3; DAuc12.Top:=60+24*8; DAuc18.Top:=60+24*9; DAuc23.Top:=60+24*10; DAuc28.Top:=60+24*11; DAuc29.Top:=60+24*12;
        end;
        12..17: begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := False; DAuc4.Visible := False; DAuc5.Visible := False; DAuc6.Visible := False;
          DAuc8.Visible := False; DAuc9.Visible := False; DAuc10.Visible := False; DAuc11.Visible := False;
          DAuc13.Visible := True; DAuc14.Visible := True; DAuc15.Visible := True; DAuc16.Visible := True; DAuc17.Visible := True;
          DAuc19.Visible := False; DAuc20.Visible := False; DAuc21.Visible := False; DAuc22.Visible := False; DAuc32.Visible := False;
          DAuc24.Visible := False; DAuc25.Visible := False; DAuc26.Visible := False; DAuc27.Visible := False; DAuc31.Visible := False;

          DAuc7.Top:=60+24*3; DAuc12.Top:=60+24*4; DAuc18.Top:=60+24*10; DAuc23.Top:=60+24*11; DAuc28.Top:=60+24*12; DAuc29.Top:=60+24*13;
        end;
        18..22,33: begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := False; DAuc4.Visible := False; DAuc5.Visible := False; DAuc6.Visible := False;
          DAuc8.Visible := False; DAuc9.Visible := False; DAuc10.Visible := False; DAuc11.Visible := False;
          DAuc13.Visible := False; DAuc14.Visible := False; DAuc15.Visible := False; DAuc16.Visible := False; DAuc17.Visible := False;
          DAuc19.Visible := True; DAuc20.Visible := True; DAuc21.Visible := True; DAuc22.Visible := True;  DAuc32.Visible := True;
          DAuc24.Visible := False; DAuc25.Visible := False; DAuc26.Visible := False; DAuc27.Visible := False; DAuc31.Visible := False;

          DAuc7.Top:=60+24*3; DAuc12.Top:=60+24*4; DAuc18.Top:=60+24*5; DAuc23.Top:=60+24*11; DAuc28.Top:=60+24*12; DAuc29.Top:=60+24*13;
        end;
        23..27,32: begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := False; DAuc4.Visible := False; DAuc5.Visible := False; DAuc6.Visible := False;
          DAuc8.Visible := False; DAuc9.Visible := False; DAuc10.Visible := False; DAuc11.Visible := False;
          DAuc13.Visible := False; DAuc14.Visible := False; DAuc15.Visible := False; DAuc16.Visible := False; DAuc17.Visible := False;
          DAuc19.Visible := False; DAuc20.Visible := False; DAuc21.Visible := False; DAuc22.Visible := False; DAuc32.Visible := False;
          DAuc24.Visible := True; DAuc25.Visible := True; DAuc26.Visible := True; DAuc27.Visible := True; DAuc31.Visible := True;

          DAuc7.Top:=60+24*3; DAuc12.Top:=60+24*4; DAuc18.Top:=60+24*5; DAuc23.Top:=60+24*6; DAuc28.Top:=60+24*12; DAuc29.Top:=60+24*13;
        end;
        30: begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := False; DAuc4.Visible := False; DAuc5.Visible := False; DAuc6.Visible := False;
          DAuc8.Visible := False; DAuc9.Visible := False; DAuc10.Visible := False; DAuc11.Visible := False;
          DAuc13.Visible := False; DAuc14.Visible := False; DAuc15.Visible := False; DAuc16.Visible := False; DAuc17.Visible := False;
          DAuc19.Visible := False; DAuc20.Visible := False; DAuc21.Visible := False; DAuc22.Visible := False; DAuc32.Visible := False;
          DAuc24.Visible := False; DAuc25.Visible := False; DAuc26.Visible := False; DAuc27.Visible := False; DAuc31.Visible := False;

          DAuc7.Top:=60+24*3; DAuc12.Top:=60+24*4; DAuc18.Top:=60+24*5; DAuc23.Top:=60+24*6; DAuc28.Top:=60+24*7; DAuc29.Top:=60+24*8;
          ClearAuctionDlg;
        end;
        else begin
          DAuc0.Visible := True; DAuc1.Visible := True; DAuc2.Visible := True; DAuc7.Visible := True;
          DAuc12.Visible := True; DAuc18.Visible := True; DAuc23.Visible := True; DAuc28.Visible := True;
          DAuc29.Visible := True; DAuc30.Visible := True;

          DAuc3.Visible := False; DAuc4.Visible := False; DAuc5.Visible := False; DAuc6.Visible := False;
          DAuc8.Visible := False; DAuc9.Visible := False; DAuc10.Visible := False; DAuc11.Visible := False;
          DAuc13.Visible := False; DAuc14.Visible := False; DAuc15.Visible := False; DAuc16.Visible := False; DAuc17.Visible := False;
          DAuc19.Visible := False; DAuc20.Visible := False; DAuc21.Visible := False; DAuc22.Visible := False; DAuc32.Visible := False;
          DAuc24.Visible := False; DAuc25.Visible := False; DAuc26.Visible := False; DAuc27.Visible := False; DAuc31.Visible := False;

          DAuc7.Top:=60+24*3; DAuc12.Top:=60+24*4; DAuc18.Top:=60+24*5; DAuc23.Top:=60+24*6; DAuc28.Top:=60+24*7;DAuc29.Top:=60+24*8;
        end;
     end;

     DScreen.ClearHint;
     g_AuctionCurrSection := TDButton(Sender).Tag;
     if g_AuctionCurrSection <> 30 then begin
       sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(1) + ':' + IntToStr(g_AuctionSortMode) + ':' + EdSalesEdit.Text;
       SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId , 0, 0, 0, sData);
     end;
   end;

   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DAuctionSortClick(Sender: TObject; X, Y: Integer);
var
  sData: string;
begin
  sData := '';
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if g_AuctionSortMode = 0 then g_AuctionSortMode := 1
     else if g_AuctionSortMode = 1 then g_AuctionSortMode := 2
     else if g_AuctionSortMode = 2 then g_AuctionSortMode := 0;

     sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(g_AuctionCurrPage) + ':' + IntToStr(g_AuctionSortMode) + ':' + EdSalesEdit.Text;
     SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId, 0, 0, 0, sData);
  end;
end;

procedure TFrmDlg.DAuctionSortDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      if g_AuctionSortMode = 0 then d := nil
       else if g_AuctionSortMode = 1 then d := g_WMain2Images.Images[925]
       else if g_AuctionSortMode = 2 then d := g_WMain2Images.Images[926];
      if d <> nil then
          dsurface.Draw (SurfaceX(Left + 46), SurfaceY(Top + 6), d.ClientRect, d, TRUE);

   end;
end;

procedure TFrmDlg.DBotAuctionClick(Sender: TObject; X, Y: Integer);
var
  sData: string;
begin
  sData := '';
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 500;

    DScreen.ClearHint;
    g_AuctionCurrSection := TDButton(Sender).Tag;
    sData := sData + IntToStr(g_AuctionCurrSection) + ':' + IntToStr(1) + ':' + IntToStr(g_AuctionSortMode) + ':' + EdSalesEdit.Text;
    SendClientMessage(CM_GETAUCTION, g_MySelf.m_nRecogId , 0, 0, 0, sData);
  end;
end;

procedure TFrmDlg.DBotAucFindDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DSalesKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = 27 then
     if DSales.Visible then CloseItemMarketDlg;

  if Key = 13 then
      DSalesFindClick(DSalesFind, 0, 0);

  DScreen.ClearHint;

  case key of
      VK_UP:
         begin
            if AuctionMenuIndex > 0 then begin
               Dec(AuctionMenuIndex, 1);
               DSalesClick(DSales ,0 ,0);
            end;
         end;
      VK_DOWN:
         begin
            if AuctionMenuIndex < 9 then begin
               Inc(AuctionMenuIndex, 1);
               DSalesClick(DSales ,0 ,0);
            end;
         end;
      VK_LEFT:
         begin
            DSalesPrevPageClick( DSalesPrevPage, 0, 0);
         end;
      VK_RIGHT:
         begin
            DSalesNextPageClick( DSalesNextPage, 0, 0);
         end;
   else
   end;


end;

procedure TFrmDlg.DAuctionSpotClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   if not g_boItemMoving then begin
      if g_MarketDlgItem.S.Name <> '' then begin
         ItemClickSound (g_MarketDlgItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -99;
         g_MovingItem.Item := g_MarketDlgItem;
         g_MovingItem.Owner := DAuctionSort;
         g_MarketDlgItem.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;

      if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DAuctionSort) then begin
         ItemClickSound (g_MovingItem.Item.S);
          if g_MarketDlgItem.S.Name <> '' then begin
            temp := g_MarketDlgItem;
            g_MarketDlgItem := g_MovingItem.Item;
            g_MovingItem.Index := -99;
            g_MovingItem.Owner := DAuctionSort;
            g_MovingItem.Item := temp
          end else begin
            g_MarketDlgItem := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
            g_MovingItem.Owner := nil;
          end;
      end;
   end;

end;

procedure TFrmDlg.DAuctionSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_MarketDlgItem.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_MarketDlgItem.S.Looks];
      if d <> nil then
      with DAuctionSpot do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
            if (g_MarketDlgItem.Amount > 0) and (g_MarketDlgItem.S.StdMode in [0,1,3,45,46]) then begin      //¹°¾à
              SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
              dsurface.Canvas.Font.Color := clYellow;
              dsurface.Canvas.TextOut(SurfaceX(Left + 18),SurfaceY(Top + 20), IntToStr(g_MarketDlgItem.Amount) );
              dsurface.Canvas.Font.Color := clWhite;
              dsurface.Canvas.Release;
            end;
      end;
   end;
end;

procedure TFrmDlg.DAuctionSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
    g_MouseItem := g_MarketDlgItem;
end;

procedure TFrmDlg.DAuctionCancelClick(Sender: TObject; X, Y: Integer);
begin
  if g_MarketDlgItem.S.Name <> '' then
     AddItemBag (g_MarketDlgItem);
   g_MarketDlgItem.S.Name := '';
   CostSalesEdit.Text := '0'
end;

procedure TFrmDlg.DAuctionClick(Sender: TObject; X, Y: Integer);
var
  dlgmessage: string;
  Price: integer;
begin
  if (g_MarketDlgItem.S.Name = '') and (g_MarketDlgItemSellWait.S.Name = '') then exit;
  if GetTickCount < LastestClickTime then exit;
    dlgmessage := Trim(CostSalesEdit.Text);
    if dlgmessage = '' then begin
      DMessageDlg ('ÇëÊäÈëºÏÊÊµÄ½ð¶î¡£', [mbOk]);         //1¾ï5Ãµ
      exit;
    end;
    try                                                 //À§Å¹ ¸Þ½ÃÁö ºÎºÐ
      Price := strtoint(dlgmessage)
    except
      DMessageDlg ('ÇëÊäÈëºÏÊÊµÄ½ð¶î¡£', [mbOk]);
      exit;
    end;
    if Price < 1000 then begin
      DMessageDlg ('³öÊÛµÄ¼Û¸ñ×îÉÙÎª1,000½ð±Ò¡£', [mbOk]);
      exit;
    end;

    if mrYes = DMessageDlg ('Äã×î¶¨ÒªÒÔ ' +GetGoldStr(Price) +' ½ð±ÒµÄ¼Û¸ñ³öÊÛ '+g_MarketDlgItem.S.Name +' Âð£¿', [mbYes, mbNo]) then
       FrmMain.SendConsignItem (g_nCurMerchant, g_MarketDlgItem.MakeIndex, dlgmessage)
    else AddItemBag (g_MarketDlgItem);


  g_MarketDlgItemSellWait := g_MarketDlgItem;
  g_MarketDlgItem.S.Name := '';
  CostSalesEdit.Text := '0';
end;



procedure TFrmDlg.DMemoClick(Sender: TObject; X, Y: Integer);
begin
   EdSalesEdit.Visible := False;
   CostSalesEdit.Visible := False;
   EdShopEdit.Visible := False;
end;

procedure TFrmDlg.DMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d : TDirectDrawSurface;
   b : TDirectDrawSurface;
   lx, ly, n, t, l, ax, ay : integer;
   Rect : TRect;
begin


     case ViewWindowNo of
      VIEW_MAILREAD , VIEW_MAILSEND:   //ÂÊÁöÀÐ±â
            begin
            memoMail.Left  := DMemo.Left+16;
            memoMail.Top   := DMemo.Top+92;

            memoMail.Width := 200;
            memoMail.Height:= 162;

            memoMail.BorderStyle := bsNone;

            DMemoClose.Left := 208;
            DMemoClose.Top := 3;
            end;
      else begin      //¸Þ¸ð VIEW_MEMO
            memoMail.Left := DMemo.Left+12;
            memoMail.Top  := DMemo.Top+32;

            memoMail.Width := 166;
            memoMail.Height := 90;

            memoMail.BorderStyle := bsSingle;

            DMemoClose.Left:=170;
            DMemoClose.Top:=1;
            end;
      end;

   with DMemo do begin
      //ÀÌ¸§...ÂÊÁöº¸±â, ÂÊÁöº¸³»±â½Ã¿¡¸¸ Ãâ·Â, Ä£±¸µî·Ï½Ã´Â ÀÔ·Â¹Ú½º
      case ViewWindowNo of
      VIEW_MAILSEND:  // ÂÊÁöº¸³»±â  À§: ¹Þ´Â»ç¶÷ Ãâ·Â, ¾Æ·¡: ÂÊÁö ³»¿ë ÀÔ·Â
          begin
          d := g_WTitleImages.Images[671];
          if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clWhite;
               TextOut (SurfaceX(Left + 70), SurfaceY(Top + 35), MemoCharID);
               Release;

            end;
          end;
      VIEW_MAILREAD:  // ÂÊÁöº¸±â    À§: º¸³½»ç¶÷ Ãâ·Â, ¾Æ·¡: ÂÊÁö ³»¿ë Ãâ·Â
          begin
          d := g_WTitleImages.Images[672];
          if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color  := clWhite;
               TextOut (SurfaceX(Left + 70), SurfaceY(Top + 54), MemoDate);
               TextOut (SurfaceX(Left + 70), SurfaceY(Top + 35), MemoCharID);
               Release;
            end;

          end;
      VIEW_MEMO:  // Ä£±¸Á¤º¸    À§: Ä£±¸¾ÆÀÌµð Ãâ·Â. ¾Æ·¡: ¸Þ¸ð ÀÔ·Â
          begin
          d := g_WMainImages.Images[537];
          if d <> nil then
            dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

          b := g_WTitleImages.Images[186];
          dsurface.Draw (SurfaceX(Left+18), SurfaceY(Top+8), b.ClientRect, b, TRUE);

            with dsurface.Canvas do begin
               SetBkMode (Handle, TRANSPARENT);
               Font.Color := clSilver;
               TextOut (SurfaceX(Left + 135 - TextWidth(MemoCharID) div 2), SurfaceY(Top + 11), MemoCharID);

               Release;
            end;
          end;
      end;
   end;
end;

procedure TFrmDlg.DMemoKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = 27 then
      if DMemo.Visible then DMemoCloseClick(DMemoClose, 0, 0);
end;

procedure TFrmDlg.DMLSendClick(Sender: TObject; X, Y: Integer);
begin
  if (not DMemo.Visible) then begin
    if (mrOk = FrmDlg.DMessageDlg ('ÇëÊäÈëÄãÒª·¢ËÍÓÊ¼þµÄÈËÔ±µÄÃû×Ö¡£', [mbOk, mbAbort])) and (FrmDlg.DlgEditText <> '') then begin
      ViewWindowNo   := VIEW_MAILSEND;
      DMemoB1.SetImgIndex(g_WTitleImages, 190);
      DMemoB2.SetImgIndex(g_WTitleImages, 193);
      DMemoB1.Left:=30;
      DMemoB1.Top:=265;
      DMemoB2.Left:=134;
      DMemoB2.Top:=265;
      DMemoB3.Visible := False;
      MemoMail.Clear;
      MemoMail.ReadOnly := false;
      MemoCharID := FrmDlg.DlgEditText;
      ShowEditMail;
    end;
  end;
end;

procedure TFrmDlg.DMLSendMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   lx, ly : integer;
   sx, sy : integer;
begin
   with DMLSend do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      sx := SurfaceX(Left)+DMailListDlg.SurfaceX(DMailListDlg.Left)+lx+8;
      sy := SurfaceY(Top) +DMailListDlg.SurfaceX(DMailListDlg.Top) +ly+6;
      DScreen.ShowHintA(sx, sy, '·¢ËÍ', clYellow, FALSE);
   end;
end;

procedure TFrmDlg.DMLReplyMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   lx, ly : integer;
   sx, sy : integer;
begin
   with DMLReply do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      sx := SurfaceX(Left)+DMailListDlg.SurfaceX(DMailListDlg.Left)+lx+8;
      sy := SurfaceY(Top) +DMailListDlg.SurfaceX(DMailListDlg.Top) +ly+6;
      DScreen.ShowHintA(sx, sy, '»Ø¸´', clYellow, FALSE);
   end;
end;

procedure TFrmDlg.DMLReadMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   lx, ly : integer;
   sx, sy : integer;
begin
   with DMLRead do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      sx := SurfaceX(Left)+DMailListDlg.SurfaceX(DMailListDlg.Left)+lx+8;
      sy := SurfaceY(Top) +DMailListDlg.SurfaceX(DMailListDlg.Top) +ly+6;
      DScreen.ShowHintA(sx, sy, 'ÔÄ¶Á', clYellow, FALSE);
   end;
end;

procedure TFrmDlg.DMLDelMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   lx, ly : integer;
   sx, sy : integer;
begin
   with DMLDel do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      sx := SurfaceX(Left)+DMailListDlg.SurfaceX(DMailListDlg.Left)+lx+8;
      sy := SurfaceY(Top) +DMailListDlg.SurfaceX(DMailListDlg.Top) +ly+6;
      DScreen.ShowHintA(sx, sy, 'É¾³ý', clYellow, FALSE);
   end;
end;

procedure TFrmDlg.DMLBlockMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   lx, ly : integer;
   sx, sy : integer;
begin
   with DMLBlock do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      sx := SurfaceX(Left)+DMailListDlg.SurfaceX(DMailListDlg.Left)+lx+8;
      sy := SurfaceY(Top) +DMailListDlg.SurfaceX(DMailListDlg.Top) +ly+6;
      DScreen.ShowHintA(sx, sy, 'ºÚÃûµ¥', clYellow, FALSE);
   end;
end;

procedure TFrmDlg.DHelpMailClick(Sender: TObject; X, Y: Integer);
begin
  DHelpWin.Visible:=not DHelpWin.Visible;
  HelpPage := 17;
end;

procedure TFrmDlg.DMailReMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   lx, ly : integer;
   sx, sy : integer;
begin
   with DMailRe do begin
      lx := LocalX (X - Left);
      ly := LocalY (Y - Top);
      sx := SurfaceX(Left)+DMailListDlg.SurfaceX(DMailListDlg.Left)+lx+8;
      sy := SurfaceY(Top) +DMailListDlg.SurfaceX(DMailListDlg.Top) +ly+6;
      DScreen.ShowHintA(sx, sy, 'ÊÕÐÅ', clYellow, FALSE);
   end;
end;

procedure TFrmDlg.DMailReClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick4 then begin
     g_dwQueryMsgTick4 := GetTickCount + 5000;
     FrmMain.SendMailList;
  end;
end;

procedure TFrmDlg.DBotUpClick(Sender: TObject; X, Y: Integer);
begin
  if ((not DUpWapondow.Visible) and (not DChangeItem.Visible) and (not g_MySelf.m_boStartStore) and (not DOnAuction.Visible)
     and (not DStoreGridWin.Visible) and (not DMakeItemDlg.Visible) and (not DItemWakeUpDlg.Visible)) then begin
     SendClientMessage (CM_QUERYBAGITEMS, 0, 0, 0, 0, VerInfoStr4);
  end;
end;


procedure TFrmDlg.DItemStoreMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DExpModeClick(Sender: TObject; X, Y: Integer);
begin
   g_MoExpMsg := Not g_MoExpMsg;
end;

procedure TFrmDlg.DDisassembleDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DDisaCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseDisassembleDlg;
end;

procedure TFrmDlg.DDisassembleSpotClick(Sender: TObject; X, Y: Integer);
var
  temp: TClientItem;
begin
   if GetTickCount > g_dwQueryMsgTick then begin
   g_sDisassemblePriceStr := '';
   if not g_boItemMoving then begin
      if g_DisassembleDlgItem.S.Name <> '' then begin
         ItemClickSound (g_DisassembleDlgItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -93;
         g_MovingItem.Item := g_DisassembleDlgItem;
         g_MovingItem.Owner := DDisassembleDlg;
         g_DisassembleDlgItem.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if g_MovingItem.Item.S.DisassembleItem and (g_MovingItem.Item.S.btValue[19] = 0) then begin
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DDisassembleDlg) then begin
           ItemClickSound (g_MovingItem.Item.S);
           g_dwQueryMsgTick := GetTickCount + 1000;
           if g_DisassembleDlgItem.S.Name <> '' then begin
             temp := g_DisassembleDlgItem;
             g_DisassembleDlgItem := g_MovingItem.Item;
             g_MovingItem.Index := -93;
             g_MovingItem.Owner := DDisassembleDlg;
             g_MovingItem.Item := temp
           end else begin
              g_DisassembleDlgItem := g_MovingItem.Item;
              g_MovingItem.Item.S.name := '';
              g_MovingItem.Owner := nil;
              g_boItemMoving := FALSE;
           end;
           FrmMain.SendDisassemblePrice (g_nCurMerchant, g_DisassembleDlgItem.MakeIndex, g_DisassembleDlgItem.S.Name);
        end;
      end else begin
        CancelItemMoving;
        DMessageDlg ('´ËÎïÆ·ÎÞ·¨·Ö½â¡£',[mbOk]);
      end;
   end;
   end;
end;

procedure TFrmDlg.DDisassembleStartClick(Sender: TObject; X, Y: Integer);
begin
   if (g_DisassembleDlgItem.S.Name = '') and (g_DisassembleDlgItemWait.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit;

   FrmMain.SendDisassembleItem (g_nCurMerchant, g_DisassembleDlgItem.MakeIndex, g_DisassembleDlgItem.S.Name);
   LastestClickTime := GetTickCount + 5000;

   g_DisassembleDlgItemWait := g_DisassembleDlgItem;
   g_DisassembleDlgItem.S.Name := '';
   g_sDisassemblePriceStr := '';
end;

procedure TFrmDlg.DDisassembleSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
  iname, d1, d2, d3, d4, d5: string;
  useable, Jobuseable: Boolean;
  hcolor: TColor;
begin
   DScreen.ClearHint;
   g_MouseItem := g_DisassembleDlgItem;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DDisassembleDlg.SurfaceX(DDisassembleDlg.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DDisassembleDlg.SurfaceY(DDisassembleDlg.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DDisassembleSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_DisassembleDlgItem.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_DisassembleDlgItem.S.Looks];
      if d <> nil then
         with DDisassembleSpot do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DDisassembleDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DDisassembleDlg do begin
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     with Dsurface.Canvas do begin
        SetBkMode (Handle, TRANSPARENT);
        Font.Color := ClWhite;
        TextOut (SurfaceX(Left+40), SurfaceY(Top+165), '·Ö½â¼Û¸ñ: ' + g_sDisassemblePriceStr);
        Release;
     end;

  end;
end;

procedure TFrmDlg.DLoverMacroClick(Sender: TObject; X, Y: Integer);
begin
  if not FrmMain.LoverMacro.Enabled then begin
    FrmMain.LoverMacro.Enabled := True;
    DScreen.AddChatBoardString('¿ªÆôÇéÂÂ¶Ô»°¡£',ClWhite,ClGreen);
  end else begin
    FrmMain.LoverMacro.Enabled := False;
    DScreen.AddChatBoardString('¹Ø±ÕÇéÂÂ¶Ô»°¡£',ClWhite,ClRed);
  end;
end;

procedure TFrmDlg.DBReady6Click(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  if not g_FishingOk then begin               //´«ËÍ»Ø°²È«Çø
    if GetTickCount > g_dwQueryMsgTick then begin
      Msg:='Äã½«Òª·µ»Øµ½×îºóÍ£ÁôµÄ´å×¯¡£\ÄãÈ·¶¨Òª·µ»ØÂð£¿';
      if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
         g_dwQueryMsgTick := GetTickCount +
          1000;
         FrmMain.SendSay ('@HomeMove');
      end;
    end;
  end;
end;

procedure TFrmDlg.DDiceCurrDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, e, ee: TDirectDrawSurface;
  pm: TDiceGameItem;
  newmodes: integer;
begin
   with Sender as TDButton do begin
     TagItem := Tag + FakeGame - 1;
     pm := g_DiceItems[TagItem];
     if pm.Items.S.Name <> '' then begin

       d := g_WBagItemImages.Images[pm.Items.s.Looks];
       if d <> nil then
        dsurface.Draw (SurfaceX(TDButton(Sender).Left + 1 + ((TDButton(Sender).Width - 40) - d.Width) div 2) ,  //20110712
        SurfaceY(TDButton(Sender).Top + ((TDButton(Sender).Height) - d.Height) div 2), d.ClientRect, d, TRUE);

       SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
       if pm.Items.s.StdMode in [0,1,3,45,46] then begin  //¹°¾à
         dsurface.Canvas.Font.Color := clYellow;
         dsurface.Canvas.TextOut(SurfaceX(Left + 8),SurfaceY(Top + 28),IntToStr(pm.Amount));
         dsurface.Canvas.Font.Color := clWhite;
       end;
       Font.Color := clWhite;
       dsurface.Canvas.Release;
     end;
   end;
end;

procedure TFrmDlg.DDiceCurrMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var                                                 //À§Å¹ ´Ý±â
   adx:Integer;
   nLocalX,nLocalY,nHintX,nHintY:Integer;
   iname, d1, d2, d3, d4, d5: string;
   useable, Jobuseable: Boolean;
   hcolor: TColor;
   Butt: TDButton;
begin
   DScreen.ClearHint;
   adx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   if g_DiceItems[TagItem].Items.S.Name <> '' then begin
     g_MouseItem := g_DiceItems[TagItem].Items;
     GetMouseItemHint (g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
       nLocalX:=Butt.LocalX(X - Butt.Left);
       nLocalY:=Butt.LocalY(Y - Butt.Top);
       nHintX:=Butt.SurfaceX(Butt.Left) + DDiceGame.SurfaceX(DDiceGame.Left) + nLocalX;
       nHintY:=Butt.SurfaceY(Butt.Top) + DDiceGame.SurfaceY(DDiceGame.Top) + nLocalY;
       with Butt as TDButton do                      //ÈùÆ®
         DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
     end;
   end;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DDiceGameMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
  FrmDlg2.FaceSelectindex := -1;
  FrmDlg2.GuldSelectindex := -1;
end;

procedure TFrmDlg.DDiceStartClick(Sender: TObject; X, Y: Integer);
begin
   if SelectDice = 0 then begin

   end else begin
     if (CurrGame <= MaxGame) and (Not StartDice )then begin
       DiceStartTime := GetTickCount();
       StartDice:= TRUE;
       PlaySound2(Dice);
     end;
   end;
end;

procedure TFrmDlg.DDiceStopClick(Sender: TObject; X, Y: Integer);
begin
   if StartDice and Succecs and (SelectDice <> 0) and (GetTickCount - DiceStartTime > 2 * 1000) and (CurrGame <= MaxGame) then begin
     DiceRand := (1 + Random(5));
     StartDice:= False;
     MainDiceimg := 281 + DiceRand;
     DiceStartTime := 0;
     TimeToDice := 0;
     if (MaxGame = 6) then begin
       if (DiceRand in [1,2,3]) and (SelectDice = 1) then begin
          CurrGame := CurrGame + 1;
          if CurrGame <= MaxGame then
            FakeGame := FakeGame + 1;
          Succecs := True;
          DDiceGet.Visible := True;
          DDiceClose.Visible := False;
       end else begin
       if (DiceRand in [4,5,6]) and (SelectDice = 2) then begin
          CurrGame := CurrGame + 1;
          if CurrGame <= MaxGame then
            FakeGame := FakeGame + 1;
          Succecs := True;
          DDiceGet.Visible := True;
          DDiceClose.Visible := False;
       end else begin
          SelectDice := 0;
          Succecs := False;
          DDiceGet.Visible := False;
          DDiceClose.Visible := True;
       end;
       end;
    end else begin
      if DiceRand = SelectDice then begin
        CurrGame := CurrGame + 1;
        if CurrGame <= MaxGame then
          FakeGame := FakeGame + 1;
        Succecs := True;
        DDiceGet.Visible := True;
        DDiceClose.Visible := False;
      end else begin
        SelectDice := 0;
        Succecs := False;
        DDiceGet.Visible := False;
        DDiceClose.Visible := True;
      end;
   end;
   end;
end;

procedure TFrmDlg.DDiceSelect1Click(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if Succecs and (Not StartDice) then
      SelectDice := Tag;
  end;
end;

procedure TFrmDlg.DDiceSelect1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
     if SelectDice = Tag then  d := WLib.Images[FaceIndex + 1]
     else d := WLib.Images[FaceIndex];
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DDiceNextDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, e, ee: TDirectDrawSurface;
  pm: TDiceGameItem;
  newmodes, FaceItem: integer;
begin
   with Sender as TDButton do begin
     FaceItem := Tag + FakeGame - 1;
     pm := g_DiceItems[FaceItem];
     if pm.Items.S.Name <> '' then begin

       d := g_WBagItemImages.Images[pm.Items.s.Looks];
       if d <> nil then
        dsurface.Draw (SurfaceX(TDButton(Sender).Left + 1 + ((TDButton(Sender).Width - 40) - d.Width) div 2) ,  //20110712
        SurfaceY(TDButton(Sender).Top + ((TDButton(Sender).Height) - d.Height) div 2), d.ClientRect, d, TRUE);

       SetBKMode(dsurface.Canvas.Handle, TRANSPARENT);
       if pm.Items.s.StdMode in [0,1,3,45,46] then begin  //¹°¾à
         dsurface.Canvas.Font.Color := clYellow;
         dsurface.Canvas.TextOut(SurfaceX(Left + 8),SurfaceY(Top + 28),IntToStr(pm.Amount));
         dsurface.Canvas.Font.Color := clWhite;
       end;
       Font.Color := clWhite;
       dsurface.Canvas.Release;
     end;
   end;
end;

procedure TFrmDlg.DDiceGetClick(Sender: TObject; X, Y: Integer);
begin
  if (Not StartDice) and (Succecs) then begin
    if DiceItemsrt = '' then exit;
    if mrYes = FrmDlg.DMessageDlg('ÄãÈ·¶¨Òª½ÓÊÕ ' + DiceItemsrt + ' Âð£¿', [mbYes, mbNo]) then begin
      FrmMain.SendDiceitem(g_DiceItems[TagItem].ID,DiceItemsrt);
    end;
  end;
end;

procedure TFrmDlg.DDiceNextMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var                                                 //À§Å¹ ´Ý±â
   adx, FaceItem:Integer;
   nLocalX,nLocalY,nHintX,nHintY:Integer;
   iname, d1, d2, d3, d4, d5: string;
   useable, Jobuseable: Boolean;
   hcolor: TColor;
   Butt: TDButton;
begin
   DScreen.ClearHint;
   adx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   FaceItem := adx + FakeGame - 1;
   if g_DiceItems[FaceItem].Items.S.Name <> '' then begin
     g_MouseItem := g_DiceItems[FaceItem].Items;
     GetMouseItemHint (g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then begin
       nLocalX:=Butt.LocalX(X - Butt.Left);
       nLocalY:=Butt.LocalY(Y - Butt.Top);
       nHintX:=Butt.SurfaceX(Butt.Left) + DDiceGame.SurfaceX(DDiceGame.Left) + nLocalX;
       nHintY:=Butt.SurfaceY(Butt.Top) + DDiceGame.SurfaceY(DDiceGame.Top) + nLocalY;
       with Butt as TDButton do                      //ÈùÆ®
         DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
     end;
   end;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DDice1Click(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if Succecs and (Not StartDice) then
      SelectDice := Tag;
  end;
end;

procedure TFrmDlg.DDice1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
     if SelectDice = Tag then d := WLib.Images[FaceIndex + 1]
     else d := WLib.Images[FaceIndex];
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DOnAuctionDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DOnAuction do begin
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     d := g_WAresImages.Images[125];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left + 25), SurfaceY(Top + 70), d.ClientRect, d, TRUE);

      with Dsurface.Canvas do begin
          SetBKMode (Handle, TRANSPARENT);
          Font.Color := clAqua;
          TextOut(SurfaceX(Left + 67) , SurfaceY(Top + 42), '¿ªÊ¼ÊµÊ±ÅÄÂô');
          Font.Color := clWhite;
          TextOut(SurfaceX(Left + 85) , SurfaceY(Top + 70), '¿ªÊ¼ÅÄÂô');
          TextOut(SurfaceX(Left + 85) , SurfaceY(Top + 84), 'Çë´ó¼Ò½«»õÎïÉÏ¼Ü¡£');
          Font.Color := clRed;
          TextOut(SurfaceX(Left + 85) , SurfaceY(Top + 114), '¡ù ×¢ÒâÊÂÏî ¡ù');
          Font.Color := clYellow;
          TextOut(SurfaceX(Left + 14) , SurfaceY(Top + 130), '1. ±£Ö¤½ðÊÇ³ö¼ÛµÄ 10% ');
          TextOut(SurfaceX(Left + 14) , SurfaceY(Top + 145), '   ÅÄÂôÍê±Ïºó½«ÍË»¹ÄãµÄ±£Ö¤½ð¡£');
          TextOut(SurfaceX(Left + 14) , SurfaceY(Top + 160), '2. Èç¹ûÄãÔÚÅÄÂô¹ý³ÌÖÐÈ¡ÏûÅÄÂô');
          TextOut(SurfaceX(Left + 14) , SurfaceY(Top + 175), '   ±£Ö¤½ðºÍÎïÆ·²»ÄÜÍË»¹¡£');
          TextOut(SurfaceX(Left + 14) , SurfaceY(Top + 190), '3. ÅÄÂôµÄÊ±¼äÎª3·ÖÖÓ¡£');
          TextOut(SurfaceX(Left + 14) , SurfaceY(Top + 205), '4. È¡ÏûÅÄÂôÎïÆ·²»ÄÜÍË»Ø¡£');

          Font.Color := clLime;
          TextOut(SurfaceX(Left + 26) , SurfaceY(Top + 235), 'ÇëÊäÈëÄãÒªÅÄÂôµÄ¼Û¸ñ¡£');
          Font.Color := clWhite;

          TextOut(SurfaceX(Left + 29) , SurfaceY(Top + 254), GetGoldStr(n_ActionPrice));
          Release;
      end;
   end;
end;

procedure TFrmDlg.DAuctionCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseAction;
end;

procedure TFrmDlg.DOnAuctionMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DAucItemClick(Sender: TObject; X, Y: Integer);
var
  valstr: string;
  temp: TClientItem;
  mi: Integer;
begin
   if (GetTickCount > g_dwAucActionTick) then begin
      if not g_boItemMoving then begin
         if (g_ActionItems.S.Name <> '') then begin
           g_boItemMoving := TRUE;
           g_MovingItem.Index := -52;
           g_MovingItem.Item := g_ActionItems;
           g_ActionItems.S.Name := '';
           g_MovingItem.Owner := DOnAuction;
           ItemClickSound (g_MovingItem.Item.S);
         end;
      end else begin
        mi := g_MovingItem.Index;
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DOnAuction) then begin   //´ë¿©
          DialogSize := 1;
          ItemClickSound (g_MovingItem.Item.S);
          g_boItemMoving := FALSE;

          DMessageDlg ('ÇëÊäÈëÅÄÂôµÄ¼Û¸ñ¡£\ÅÄÂô¼Û¸ñÎª 1,000½ð±Ò ~ 200,000,000½ð±ÒÖ®¼ä¡£', [mbOk, mbAbort]);
          GetValidStrVal (DlgEditText, valstr, [' ']);
          n_ActionPrice := Str_ToInt (valstr, 0);
          if (n_ActionPrice >= 1000) and (n_ActionPrice <= 200000000) then begin
            if g_ActionItems.S.Name <> '' then begin
               g_ActionItems := g_MovingItem.Item;
               g_dwAucActionTick := GetTickCount + 1000;
            end else begin
               AddAutItem(g_MovingItem.Item);
               g_MovingItem.Item.S.name := '';
               g_MovingItem.Owner := nil;
            end;
          end else begin
            AddItemBag (g_MovingItem.Item);
            g_MovingItem.Item.S.name := '';
            n_ActionPrice := 0;
            DScreen.AddChatBoardString('ÅÄÂô¼Û¸ñÎª 1,000½ð±Ò ~ 200,000,000½ð±ÒÖ®¼ä¡£',clRed,clwhite);
          end;
        end;
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DAucItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ActionItems.S.Name <> '' then begin
    d := g_WBagItemImages.Images[g_ActionItems.S.Looks];
      if d <> nil then
      with DAucItem do begin
          dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DAucItemMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
begin
   g_MouseItem.S.Name := '';
   g_MouseItem := g_ActionItems;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DOnAuction.SurfaceX(DOnAuction.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DOnAuction.SurfaceY(DOnAuction.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
   end;
   if g_MouseItem.S.Name = '' then DScreen.ClearHint;
end;

procedure TFrmDlg.DGetAuctionClick(Sender: TObject; X, Y: Integer);
begin
   if (g_ActionItems.S.Name = '') and (g_ActionItemWait.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit;

   FrmMain.SendAddAutItem(g_ActionItems, n_ActionPrice);
   LastestClickTime := GetTickCount + 5000;

   g_ActionItemWait := g_ActionItems;
   g_ActionItems.S.Name := '';
   n_ActionPrice := 0;
end;

procedure TFrmDlg.DExitAuctionClick(Sender: TObject; X, Y: Integer);
begin
  DOnAuction.Visible := Not DOnAuction.Visible;
end;

procedure TFrmDlg.DAuctionViewClick(Sender: TObject; X, Y: Integer);
begin
  AuctionView := not AuctionView;
end;

procedure TFrmDlg.DGetAuctionDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else begin
         d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
   end;
end;

procedure TFrmDlg.DOffAuctionDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Aucbuff : pTAucbuffItem; //°æ¸Å
  Time: String;
begin
   with DOffAuction do begin
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     d := g_WAresImages.Images[125];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left + 25), SurfaceY(Top + 70), d.ClientRect, d, TRUE);
        with Dsurface.Canvas do begin
          SetBKMode (Handle, TRANSPARENT);
          Aucbuff := pTAucbuffItem(g_AucList.Items[nAucItemIndex]);
          Time := format('%d·Ö %dÃë', [(Aucbuff.nTime - GetTickCount) Div 60000, ((Aucbuff.nTime - GetTickCount) Div 1000) Mod 60]);

          Font.Color := clYellow;
          TextOut(SurfaceX(Left + 25) , SurfaceY(Top + 50), 'ÅÄÂôÕýÔÚ½øÐÐµ±ÖÐ¡£');
          Font.Color := clWhite;
          TextOut(SurfaceX(Left + 65) , SurfaceY(Top + 73),  'ÅÄÂôµ×¼Û: ' + GetGoldStr(Aucbuff.Price) + '½ð±Ò');
          TextOut(SurfaceX(Left + 65) , SurfaceY(Top + 89), '½ØÖ¹Ê±¼ä: ' + Time );
          Font.Color := clLime;
          TextOut(SurfaceX(Left + 30) , SurfaceY(Top + 150), '¡ù ¾¯¸æ ¡ù');
          TextOut(SurfaceX(Left + 30) , SurfaceY(Top + 165), 'Äã²»ÄÜÔÙÅÄÂô½áÊøÊ±È¡»Ø±£Ö¤½ð');
          TextOut(SurfaceX(Left + 30) , SurfaceY(Top + 180), 'ºÍÎïÆ·¡£');
          Font.Color := clWhite;
          TextOut(SurfaceX(Left + 26) , SurfaceY(Top + 220), 'ÇëÊäÈëÄãÒªÅÄÂôµÄÎïÆ·µÄ¼Û¸ñ¡£');
          TextOut(SurfaceX(Left + 26) , SurfaceY(Top + 235), 'Õâ¼þÎïÆ·µ±Ç°µÄ×î¸ß¼ÛÇ®Îª ' + GetGoldStr(Aucbuff.APrice) + ' ½ð±Ò¡£');

          TextOut(SurfaceX(Left + 29) , SurfaceY(Top + 254), GetGoldStr(n_AucPrice));
          Font.Color := clWhite;
          Release;
        end;

   end;
end;


procedure TFrmDlg.DAucCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseAuc;
end;

procedure TFrmDlg.DOffAucItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   Aucbuff : pTAucbuffItem; //°æ¸Å
begin
   Aucbuff := pTAucbuffItem(g_AucList.Items[nAucItemIndex]);
   if Aucbuff.Item.S.Name <> '' then begin
     d := g_WBagItemImages.Images[Aucbuff.Item.S.Looks];
       if d <> nil then
       with DOffAucItem do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2 + 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
       end;
   end;
end;

procedure TFrmDlg.DOffAucItemMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   nLocalX,nLocalY,nHintX,nHintY:Integer;
   Butt:TDButton;
   NewName: sItemMome;
   Aucbuff : pTAucbuffItem; //°æ¸Å
begin
   g_MouseItem.S.Name := '';
   Aucbuff := pTAucbuffItem(g_AucList.Items[nAucItemIndex]);
   g_MouseItem := Aucbuff.Item;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DOffAuction.SurfaceX(DOffAuction.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DOffAuction.SurfaceY(DOffAuction.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, FALSE);
   end;
   if g_MouseItem.S.Name = '' then DScreen.ClearHint;
end;

procedure TFrmDlg.DOffAuctionClick(Sender: TObject; X, Y: Integer);
var
  valstr: string;
  lx, ly: Integer;
begin
    lx := DOffAuction.LocalX(X) - DOffAuction.Left;
    ly := DOffAuction.LocalY(Y) - DOffAuction.Top;
    if (lx >= 26) and (lx <= 254) and (ly >= 250) and (lx <= 268) then begin
      DialogSize := 1;

      DMessageDlg ('ÇëÊäÈëÒª¾ºÅÄµÄ¼Û¸ñ\ÊäÈëµÄ¼Û¸ñ±ØÐë¸ßÓÚÅÄÂô¼Û¸ñ¡£', [mbOk, mbAbort]);
      GetValidStrVal (DlgEditText, valstr, [' ']);
      n_AucPrice := Str_ToInt (valstr, 0);
    end;
end;

procedure TFrmDlg.DOffAucClick(Sender: TObject; X, Y: Integer);
var
  Aucbuff : pTAucbuffItem; //°æ¸Å
begin
   Aucbuff := pTAucbuffItem(g_AucList.Items[nAucItemIndex]);
   if GetTickCount < LastestClickTime then exit;
   if g_MySelf.m_sUserName = Aucbuff.Seller then begin
    n_AucPrice := 0;
    DScreen.AddChatBoardString('Äã²»ÄÜ¶Ô×Ô¼ºÅÄÂôµÄÎïÆ·½øÐÐ¾ºÅÄ¡£',clWhite,clGreen);
    exit;
   end;

   if (n_AucPrice > 500000000) then begin
     DScreen.AddChatBoardString('Í¶±êµÄ×î¸ß¼ÛÇ®Îª 500,000,000 ½ð±Ò¡£',clWhite,clGreen);
     exit;
   end;

   if (Aucbuff <> nil) then begin
    if (Aucbuff.APrice = 0) then begin
      if (n_AucPrice > Aucbuff.Price) then begin
        SendClientMessage2 (CM_BUYAUCITEM, g_MySelf.m_nRecogId, LoWord(Aucbuff.Item.MakeIndex), HiWord(Aucbuff.Item.MakeIndex), 0, IntToStr(n_AucPrice));
        LastestClickTime := GetTickCount + 5000;
        CloseAuc;
        exit;
      end else begin
        n_AucPrice := 0;
        DScreen.AddChatBoardString('ÄãÊäÈëµÄ¼Û¸ñ²»ÄÜµÍÓÚ¾ºÅÄ¼Û¸ñ¡£',clRed,clwhite);
        exit;
      end;
    end else begin
      if (n_AucPrice > Aucbuff.APrice) then begin
        SendClientMessage2 (CM_BUYAUCITEM, g_MySelf.m_nRecogId, LoWord(Aucbuff.Item.MakeIndex), HiWord(Aucbuff.Item.MakeIndex), 0, IntToStr(n_AucPrice));
        LastestClickTime := GetTickCount + 5000;
        CloseAuc;
        exit;
      end else begin
        n_AucPrice := 0;
        DScreen.AddChatBoardString('ÄãÊäÈëµÄ¼Û¸ñµÍÓÚµ±Ç°µÄ¼Û¸ñ¡£',clRed,clwhite);
        exit;
      end;
    end;
   end;
end;

procedure TFrmDlg.DWndGroupMemberDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, n: Integer;
  d: TDirectDrawSurface;
  GroupMember: pTGroupMember;
begin
  with DWndGroupMember do begin
    d := WLib.Images[FaceIndex];
    d := nil;
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DGroupCloseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
begin
  with Sender as TDButton do begin
    if DWndGroupMember.Visible then
      idx := 0
    else
      idx := 4;
    if Downed then begin
      inc(idx, 2)
    end
    else if MouseMoveing then begin
      Inc(idx, 1)
    end;
    d := WLib.Images[FaceIndex + idx];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DGroupCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWndGroupMember.Visible := not DWndGroupMember.Visible;
end;

procedure TFrmDlg.DGroupMember1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rect: TRect;
  i, n, idx: Integer;
  GroupMember, GroupOwner: pTGroupMember;
  Window: TDWindow;
  r: Real;
  sHP, sMP :String;
begin

  if g_FScreenMode = 1 then begin
   DGroupMember1.Top := 0;
   DGroupMember2.Top := 35;
   DGroupMember3.Top := 70;
   DGroupMember4.Top := 105;
   DGroupMember5.Top := 140;
   DGroupMember6.Top := 175;
   DGroupMember7.Top := 210;
   DGroupMember8.Top := 245;
   DGroupMember9.Top := 280;
   DGroupMember10.Top := 315;
   DGroupMember11.Top := 350;
   DGroupMember12.Top := 385;
  end else begin
   DGroupMember1.Top := 0;
   DGroupMember2.Top := 29;
   DGroupMember3.Top := 58;
   DGroupMember4.Top := 87;
   DGroupMember5.Top := 116;
   DGroupMember6.Top := 145;
   DGroupMember7.Top := 174;
   DGroupMember8.Top := 203;
   DGroupMember9.Top := 232;
   DGroupMember10.Top := 261;
   DGroupMember11.Top := 290;
   DGroupMember12.Top := 319;
  end;

  if Sender = DGroupMember1 then begin
    n := 0;
    for i := 0 to g_MemberGroup.Count - 1 do begin
      GroupMember := g_MemberGroup[i];
      GroupOwner := g_MemberGroup[0];
      if GroupMember.ClientGroup.UserID = g_MySelf.m_nRecogId then
        Continue;
      case n of
        0: Window := DGroupMember1;
        1: Window := DGroupMember2;
        2: Window := DGroupMember3;
        3: Window := DGroupMember4;
        4: Window := DGroupMember5;
        5: Window := DGroupMember6;
        6: Window := DGroupMember7;
        7: Window := DGroupMember8;
        8: Window := DGroupMember9;
        9: Window := DGroupMember10;
        10: Window := DGroupMember11;
        11: Window := DGroupMember12;
      else
        Exit;
        Window := DGroupMember1;
      end;
      with Window do begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            DrawBlendEx (dsurface, SurfaceX(Left), SurfaceY(Top), d, 0, 0, d.Width , d.Height, 0);

          AppendData := GroupMember;

          d := WLib.Images[413];
          if d <> nil then begin       //Ã¼·Â
            rect := d.ClientRect;
            if GroupMember.ClientGroup.HP > 0 then
              r := GroupMember.ClientGroup.MaxHP / GroupMember.ClientGroup.HP
            else
              r := 0;
            if r > 0 then
              rect.Right := Round(rect.Right / r)
            else
              rect.Right := 0;
            dsurface.Draw(SurfaceX(Left + 2), SurfaceY(Top + 14), rect, d, TRUE);
          end;


          d := WLib.Images[414];
          if d <> nil then begin          //¸¶·Â
            rect := d.ClientRect;
            if GroupMember.ClientGroup.MP > 0 then
              r := GroupMember.ClientGroup.MaxMP / GroupMember.ClientGroup.MP
            else
              r := 0;
            if r > 0 then
              rect.Right := Round(rect.Right / r)
            else
              rect.Right := 0;
            dsurface.Draw(SurfaceX(Left + 2), SurfaceY(Top + 20), rect, d, TRUE);
          end;

          if GroupMember.ClientGroup.UserName = GroupOwner.ClientGroup.UserName then begin   //±×·ìÀå º°
            idx := (GetTickCount - AppendTick) div 200 mod 12;
            if idx in [0..11] then begin
              d := g_WAresImages.Images[160 + idx];
              if d <> nil then begin
                dsurface.Draw(SurfaceX(Left + 72), SurfaceY(Top + 11), d, TRUE);
              end;
            end;
          end;


          if m_boChangeGroup then begin
            with dsurface do begin
               SetBKMode (Canvas.Handle, TRANSPARENT);
               if GroupMember.ClientGroup.UserID = g_MySelf.m_nRecogId then Continue;
               Canvas.Font.Size := 8;
               if GroupMember.ClientGroup.HP = 0 then begin
                 BoldTextOut(dsurface, SurfaceX(Left + 2), SurfaceY(Top + 2), clRed, clBlack, GroupMember.ClientGroup.UserName);
               end else begin
                 if GroupMember.isScreen = nil then begin
                   BoldTextOut(dsurface, SurfaceX(Left + 2), SurfaceY(Top + 2), clSilver, clBlack, GroupMember.ClientGroup.UserName);
                 end else begin
                   BoldTextOut(dsurface, SurfaceX(Left + 2), SurfaceY(Top + 2), clWhite, clBlack, GroupMember.ClientGroup.UserName);
                 end;
               end;
               Canvas.Font.Size := 9;
               Canvas.Release;
            end;
          end;
      end;
      Inc(n);
    end;
  end;
end;

procedure TFrmDlg.DGroupMember1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nHintX, nHintY: Integer;
  smsg: string;
  GroupMember: pTGroupMember;
begin
  DScreen.ClearHint;
  with Sender as TDWindow do begin
    if AppendData <> nil then begin
      GroupMember := AppendData;
      sMsg := '';
      sMsg := sMsg + '¶ÓÎéÃû: <CO$FFFF>' + GroupMember.ClientGroup.UserName + '(' + IntToStr(GroupMember.ClientGroup.Level) + ')' +'<CE>\';
      sMsg := sMsg + 'Ö°  Òµ: <CO$FF00>' + GetJobName(GroupMember.ClientGroup.btJob) + '<CE>\';
      sMsg := sMsg + Format('HP : %d/%d\', [GroupMember.ClientGroup.HP, GroupMember.ClientGroup.MaxHP]);
      sMsg := sMsg + Format('MP : %d/%d\', [GroupMember.ClientGroup.MP, GroupMember.ClientGroup.MaxMP]);
      if GroupMember.isScreen <> nil then
          sMsg := sMsg + 'Î»ÖÃ: <CO$FFFF>' + IntToStr(TActor(GroupMember.isScreen).m_nCurrX) + ':' + IntToStr(TActor(GroupMember.isScreen).m_nCurrY) + '<CE>\'
      else
          sMsg := sMsg + 'Î»ÖÃ: <CO$FF>²»ÔÚÏß<CE>\';

      nHintX := SurfaceX(Left) + DParent.SurfaceX(DParent.Left) + LocalX(X - Left);
      nHintY := SurfaceY(Top) + DParent.SurfaceY(DParent.Top) + LocalY(Y - Top) + 30;

      DScreen.ShowHintA(nHintX, nHintY, sMsg, clWhite, False);
    end;
  end;
end;

procedure TFrmDlg.DSellDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWndGroupMemberMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWndGroupMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DDismantleDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DDismantleDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DDismantleDlg do begin
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     with Dsurface.Canvas do begin
        SetBkMode (Handle, TRANSPARENT);
        Font.Color := ClWhite;
        TextOut (SurfaceX(Left+24), SurfaceY(Top+165), 'Ò»°ã·Ö½â·ÑÓÃ: ' + g_sDismantlePriceStr);
        Release;
     end;

  end;
end;

procedure TFrmDlg.DDismantleSpotClick(Sender: TObject; X, Y: Integer);
var
  temp: TClientItem;
begin
   if GetTickCount > g_dwQueryMsgTick then begin
   g_sDismantlePriceStr := '';
   if not g_boItemMoving then begin
      if g_DismantleDlgItem.S.Name <> '' then begin
         ItemClickSound (g_DismantleDlgItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -91;
         g_MovingItem.Item := g_DismantleDlgItem;
         g_MovingItem.Owner := DDismantleDlg;
         g_DismantleDlgItem.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if g_MovingItem.Item.S.DisassembleItem then begin
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DDismantleDlg) then begin
           ItemClickSound (g_MovingItem.Item.S);
           g_dwQueryMsgTick := GetTickCount + 1000;
           if g_DismantleDlgItem.S.Name <> '' then begin
             temp := g_DismantleDlgItem;
             g_DismantleDlgItem := g_MovingItem.Item;
             g_MovingItem.Index := -91;
             g_MovingItem.Owner := DDismantleDlg;
             g_MovingItem.Item := temp
           end else begin
              g_DismantleDlgItem := g_MovingItem.Item;
              g_MovingItem.Item.S.name := '';
              g_MovingItem.Owner := nil;
              g_boItemMoving := FALSE;
           end;
           FrmMain.SendDismantlePrice (g_nCurMerchant, g_DismantleDlgItem.MakeIndex, g_DismantleDlgItem.S.Name);
        end;
      end else begin
        CancelItemMoving;
        DMessageDlg ('´ËÎïÆ·ÎÞ·¨·Ö½â¡£',[mbOk]);
      end;
   end;
   end;
end;

procedure TFrmDlg.DDismantleSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_DismantleDlgItem.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_DismantleDlgItem.S.Looks];
      if d <> nil then
         with DDismantleSpot do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
   end;
end;

procedure TFrmDlg.DDismantleCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseDismantleDlg;
end;

procedure TFrmDlg.DDismantleStartClick(Sender: TObject; X, Y: Integer);
begin
   if (g_DismantleDlgItem.S.Name = '') and (g_DismantleDlgItemWait.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit;
   
 //  if mrYes = FrmDlg.DMessageDlg('"' + g_DismantleDlgItem.S.Name + '" Àåºñ¸¦ ºÐÇØÇÏ·Á°í ÇÕ´Ï´Ù.\ºÐÇØ ½Ã, ÇØ´ç Àåºñ´Â »èÁ¦µÇ¸ç, Àç·á¸¦ ¾òÀ» ¼ö ÀÖ½À´Ï´Ù.\'
  //     + 'Á¤¸»·Î ºÐÇØÇÏ½Ã°Ú½À´Ï±î?', [mbYes, mbNo]) then begin

      FrmMain.SendDismantleItem (g_nCurMerchant, g_DismantleDlgItem.MakeIndex, g_DismantleDlgItem.S.Name);

      LastestClickTime := GetTickCount + 5000;

      g_DismantleDlgItemWait := g_DismantleDlgItem;
      g_DismantleDlgItem.S.Name := '';
      g_sDismantlePriceStr := '';
  // end;

end;

procedure TFrmDlg.DItemWakeUpDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  ItemColor : TColor;
begin
  with DItemWakeUpDlg do begin
     DItemWakeUpDlg.Left := 0;
     DItemWakeUpDlg.Top  := 0;
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     DWakeUpList.Left := 60;
     DWakeUpList.Top := 170;
     with Dsurface do begin
        SetBkMode (Dsurface.Canvas.Handle, TRANSPARENT);
        if g_WakeUpItem <> -1 then begin
          if (g_ItemWakeUpList.Count > 0) and (g_ItemWakeUpDlgItem.S.Name <> '') then begin
            TextOutA (Dsurface, SurfaceX(Left+66), SurfaceY(Top+154), clBlack, g_ItemWakeUpList.Strings[g_WakeUpItem]);
            TextOutA (Dsurface, SurfaceX(Left+123), SurfaceY(Top+271), ClWhite, GetGoldStr(g_sItemWakeUpPriceStr));
          end;
        end else begin
          if (g_ItemWakeUpDlgItem.S.Name <> '')  then
          TextOutA (Dsurface, SurfaceX(Left+66), SurfaceY(Top+154), clBlack, 'ÇëÑ¡Ôñ...');
        end;
        if (g_ItemWakeUpDlgItem.S.Name <> '') and (g_ItemWakeUpDlgItem.S.btValue[18] = 0) then
        TextOutA (Dsurface, SurfaceX(Left+85), SurfaceY(Top+138), ClWhite, 'Ñ¡Ôñ¾õÐÑÀàÐÍ');

        if g_WakeItems[0].WakeItems.S.Name <> '' then begin
          if g_WakeItems[0].WakeItems.S.Grade = 1 then begin
            ItemColor := clWhite;
          end;
          if g_WakeItems[0].WakeItems.S.Grade = 2 then begin
            ItemColor := TColor($00FFDF42);
          end;
          if g_WakeItems[0].WakeItems.S.Grade = 3 then begin
            ItemColor := TColor($000075FF);
          end;
          if g_WakeItems[0].WakeItems.S.Grade = 4 then begin
            ItemColor := TColor($00FFAADE);
          end;
          TextOutA (Dsurface, SurfaceX(Left+93), SurfaceY(Top+194), ItemColor, FilterShowName(g_WakeItems[0].WakeItems.S,  g_WakeItems[0].WakeItems.S.Name));
          TextOutA (Dsurface, SurfaceX(Left+93), SurfaceY(Top+208), clWhite, IntToStr(g_WakeItems[0].WakeItemAmount) + ' ¸ö');
        end;
        if g_WakeItems[1].WakeItems.S.Name <> '' then begin
          if g_WakeItems[1].WakeItems.S.Grade = 1 then begin
            ItemColor := clWhite;
          end;
          if g_WakeItems[1].WakeItems.S.Grade = 2 then begin
            ItemColor := TColor($00FFDF42);
          end;
          if g_WakeItems[1].WakeItems.S.Grade = 3 then begin
            ItemColor := TColor($000075FF);
          end;
          if g_WakeItems[1].WakeItems.S.Grade = 4 then begin
            ItemColor := TColor($00FFAADE);
          end;
          TextOutA (Dsurface, SurfaceX(Left+93), SurfaceY(Top+233), ItemColor, FilterShowName(g_WakeItems[1].WakeItems.S, g_WakeItems[1].WakeItems.S.Name));
          TextOutA (Dsurface, SurfaceX(Left+93), SurfaceY(Top+248), clWhite, IntToStr(g_WakeItems[1].WakeItemAmount) + ' ¸ö');
        end;
        Dsurface.Canvas.Release;
     end;

  end;
end;

procedure TFrmDlg.DItemWakeUpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_ItemWakeUpDlgItem.S.Name <> '' then begin
      d := g_WBagItemImages.Images[g_ItemWakeUpDlgItem.S.Looks];
      if d <> nil then
         with DItemWakeUp do begin
            dsurface.Draw (SurfaceX(Left + (Width - d.Width) div 2),
                           SurfaceY(Top + (Height - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
         end;
      if (g_ItemWakeUpDlgItem.S.btValue[12] > 0) then DWakePopup.Visible := false
      else DWakePopup.Visible := True;
   end else begin
      DWakePopup.Visible := false;
   end;

end;

procedure TFrmDlg.DCloseWakeUpClick(Sender: TObject; X, Y: Integer);
begin
  CloseItemWakeUpDlg;
end;

procedure TFrmDlg.DWakeUpListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  I, DIndex: Integer;
begin
  with DWakeUpList do begin
    d := nil;
    case g_ItemWakeUp of
      0, 1: DIndex := 29;
      2: DIndex := 28;
      3: DIndex := 19;
    end;
    if WLib <> nil then
      d := WLib.Images[DIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);


    with Dsurface do begin

      for I := 0 to g_ItemWakeUpList.Count -1 do begin
        if I = g_WakeUpItem then begin
         d := g_WMain2Images.Images[928];
         if d <> nil then
           dsurface.Draw (SurfaceX(Left - 1), SurfaceX((Top + 16 + (g_WakeUpItem - 1) * 14)), d.ClientRect, d, TRUE);
        end;
        SetBkMode (Canvas.Handle, TRANSPARENT);
          TextOutA (Dsurface, SurfaceX(Left+4), SurfaceY(Top+2 + (I * 14)), clBlack, g_ItemWakeUpList.Strings[I]);
        Canvas.Release;
        if g_ItemWakeUpList.Strings[I] = '' then break;
      end;
    end;

  end;
end;

procedure TFrmDlg.DWakeUpListMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
 nIdx : integer;
begin
  if (((X<(2+DWakeUpList.Left)) OR (X>(138+DWakeUpList.Left))) OR ((Y<(2+DWakeUpList.Top)) OR (Y>(42+DWakeUpList.Top)))) then exit;
  nIdx := (Y-(2+DWakeUpList.Top)) div 14;
  if g_ItemWakeUpList.Strings[nIdx] <> '' then begin
    g_WakeUpItem := (Y-(2+DWakeUpList.Top)) div 14;
    g_WakeUpMode := g_WakeUpItem;
  end;
end;

procedure TFrmDlg.DWakeUpListClick(Sender: TObject; X, Y: Integer);
var
 nIdx : integer;
begin
  if (((X<(2+DWakeUpList.Left)) OR (X>(138+DWakeUpList.Left))) OR ((Y<(2+DWakeUpList.Top)) OR (Y>(42+DWakeUpList.Top)))) then exit;
  nIdx := (Y-(2+DWakeUpList.Top)) div 14;
  if g_ItemWakeUpList.Strings[nIdx] <> '' then begin
    g_WakeUpItem := (Y-(2+DWakeUpList.Top)) div 14;
    g_WakeUpMode := g_WakeUpItem;
    PlaySound (s_glass_button_click);
  end;
  DWakeUpList.Visible := False;
  FrmMain.SendItemWakeUp (g_WakeUpMode, g_ItemWakeUpDlgItem.MakeIndex);
end;

procedure TFrmDlg.DWake1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  pm: TWakeItem;
begin
 with Sender as TDButton do begin
   pm := g_WakeItems[Tag];
   if pm.WakeItems.S.Name <> '' then begin
     d := g_WBagItemImages.Images[pm.WakeItems.s.Looks];
     if d <> nil then
     with TDButton(Sender) do
        dsurface.Draw (SurfaceX(Left + 18)- d.Width div 2 ,SurfaceY(Top + 17)- d.Height div 2, d.ClientRect, d, TRUE);

     With dsurface do begin
       SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
       if pm.WakeItems.s.StdMode in [0,1,3,45,46,49] then begin  //¹°¾à
         TextOutA(dsurface, SurfaceX(Left + 20),SurfaceY(Top + 20), clYellow, IntToStr(pm.WakeItemAmount));
       end;
       dsurface.Canvas.Release;
     end;
   end;
 end;
end;

procedure TFrmDlg.DWake1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   adx:Integer;
   Butt: TDButton;
begin
   DScreen.ClearHint;
   adx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   if g_WakeItems[adx].WakeItems.S.Name <> '' then begin
     g_MouseItem := g_WakeItems[adx].WakeItems;
     GetMouseItemHint (g_MySelf, @g_MouseItem);
     if HintList.Count > 0 then
       DScreen.ShowHintB(DItemWakeUpDlg.Left + X + 6, DItemWakeUpDlg.Top + Y + 6, HintList, False);
   end;
   g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.DWakePopupClick(Sender: TObject; X, Y: Integer);
begin
  DWakeUpList.Visible := not DWakeUpList.Visible;
end;

procedure TFrmDlg.DWakeUpStartClick(Sender: TObject; X, Y: Integer);
var
  data, sMsg : String;
begin
  data := '';
  sMsg := '';
  if g_WakeUpItem <> - 1 then begin
    if g_ItemWakeUpDlgItem.S.btValue[18] = 0 then
    sMsg :='ÄãÈ·¶¨ÒªÊ¹ÓÃ ' +  g_ItemWakeUpList.Strings[g_WakeUpItem] + '¾õÐÑ ' + g_ItemWakeUpDlgItem.S.Name + 'Âð£¿'
    else sMsg := 'ÄãÏëÒªÊ¹ ' +g_ItemWakeUpList.Strings[g_WakeUpItem] + '´Ó' + IntToStr(g_ItemWakeUpDlgItem.S.btValue[18]) + '½×¶Î ' + g_ItemWakeUpDlgItem.S.Name + '¾õÐÑÂð£¿';
    if mrYes = FrmDlg.DMessageDlg(sMsg, [mbYes, mbNo]) then begin
      DItemWakeUpDlg.Visible := FALSE;
      DItemBag.Visible := False;

      data := data + StrWakeUpItem();
      FrmMain.SendWakeUp(g_ItemWakeUpDlgItem.MakeIndex, g_WakeUpMode, data);

      MoveWakeUpItemToBag;
      m_boWakeUp := True;
    end;
  end;
end;

procedure TFrmDlg.DWakeArr1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   idx: integer;
   d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
   idx := TDButton(Sender).Tag;
   if idx in [0..1] then begin
      if WakeUpItemArr[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[WakeUpItemArr[idx].S.Looks];
         if d <> nil then
            with TDButton(Sender) do
               dsurface.Draw (SurfaceX(Left + 18) - d.Width div 2,  SurfaceY(Top + 16) - d.Height div 2,d.ClientRect, d, TRUE);
            // ¾ÆÀÌÅÛ °ãÄ¡±â
              with dsurface do begin
                 SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
                 if (WakeUpItemArr[idx].Amount > 0) and (WakeUpItemArr[idx].S.StdMode in [0,1,3,45,46,49]) then begin
                   TextOutA (dsurface, SurfaceX(Left + 20), SurfaceY(Top + 20), clYellow, IntToStr(WakeUpItemArr[idx].Amount));
                 end;
                 dsurface.Canvas.Release;
              end;

      end;
   end;
  end;
end;

procedure TFrmDlg.DWakeArr1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  iname, d1, d2, d3: string;
  useable: Boolean;
  nHintX, nHintY, idx: integer;
begin
  DScreen.ClearHint;
  idx := TDButton(Sender).Tag;
  g_MouseItem := WakeUpItemArr[idx];
  if g_MouseItem.s.Name <> '' then begin
    GetMouseItemHint(g_MySelf, @g_MouseItem);
    if HintList.Count > 0 then begin
      nHintX:= DItemWakeUpDlg.Left + X + 6;
      nHintY:= DItemWakeUpDlg.Top + Y + 6;

      with DItemWakeUpDlg do
        DScreen.ShowHintB(nHintX, nHintY, HintList, False);
    end;
  end;
end;

procedure TFrmDlg.DWakeArr1Click(Sender: TObject; X, Y: Integer);
var
   mi, idx: Integer;
begin
      if not g_boItemMoving then begin
         idx := TDButton(Sender).Tag;
         if idx in [0..1] then
            if WakeUpItemArr[idx].S.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 77;
               g_MovingItem.Item := WakeUpItemArr[idx];
               WakeUpItemArr[idx].S.Name := '';
               g_MovingItem.Owner := DItemWakeUpDlg;
               ItemClickSound (g_MovingItem.Item.S);
            end;
      end else begin
        if (g_MovingItem.Owner = DHeroItemBag) or (g_MovingItem.Owner = DStateWin) or (g_MovingItem.Owner = DHeroStateWin) then Exit;
        if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DItemWakeUpDlg) then begin
          mi := g_MovingItem.Index;
          if (mi >= 0) or (mi <= -77) and (mi > -81) then begin   //°Å·¡
            ItemClickSound (g_MovingItem.Item.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
              WakeUpDlgItem := g_MovingItem.Item;
              AddWakeUpItem(WakeUpDlgItem);
            end else
              AddWakeUpItem(g_MovingItem.Item);
              g_MovingItem.Item.S.name := '';
            g_MovingItem.Owner := nil;
          end;
          if (mi = -97) or (mi = -98) then CancelItemMoving;
        end;
      end;
      ArrangeItemBag;
end;

procedure TFrmDlg.DItemWakeUpDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DItemWakeUpDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  DWakeUpList.Visible := False;
end;

procedure TFrmDlg.DItemWakeUpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  iname, d1, d2, d3: string;
  useable: Boolean;
  nHintX, nHintY: integer;
begin
  DScreen.ClearHint;
  g_MouseItem := g_ItemWakeUpDlgItem;
  if g_MouseItem.s.Name <> '' then begin
    GetMouseItemHint(g_MySelf, @g_MouseItem);
    if HintList.Count > 0 then begin
      nHintX:= DItemWakeUpDlg.Left + X + 6;
      nHintY:= DItemWakeUpDlg.Top + Y + 6;

      with DItemWakeUp do
        DScreen.ShowHintB(nHintX, nHintY, HintList, False);
    end;
  end;
end;

procedure TFrmDlg.DItemWakeUpClick(Sender: TObject; X, Y: Integer);
var
  temp: TClientItem;
begin
   if GetTickCount > g_dwQueryMsgTick then begin
   g_sItemWakeUpPriceStr := 0;
   if not g_boItemMoving then begin
      if g_ItemWakeUpDlgItem.S.Name <> '' then begin
         ItemClickSound (g_ItemWakeUpDlgItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -92;
         g_MovingItem.Item := g_ItemWakeUpDlgItem;
         g_MovingItem.Owner := DItemWakeUpDlg;
         g_ItemWakeUpDlgItem.S.Name := '';
         ClearWakeDlg;
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if CheckCanWakeUp(g_MovingItem.Item) then begin
        if g_MovingItem.Item.S.btValue[18] < 5 then begin
         if (g_MovingItem.Owner = DItemBag) or (g_MovingItem.Owner = DItemWakeUpDlg) then begin
           ItemClickSound (g_MovingItem.Item.S);
           g_dwQueryMsgTick := GetTickCount + 1000;
           if g_ItemWakeUpDlgItem.S.Name <> '' then begin
             temp := g_ItemWakeUpDlgItem;
             g_ItemWakeUpDlgItem := g_MovingItem.Item;
             g_MovingItem.Index := -92;
             g_MovingItem.Owner := DItemWakeUpDlg;
             g_MovingItem.Item := temp;
             ClearWakeDlg;
           end else begin
             g_ItemWakeUpDlgItem := g_MovingItem.Item;
             g_MovingItem.Item.S.name := '';
             g_MovingItem.Owner := nil;
             g_boItemMoving := FALSE;
           end;
           g_WakeUpItem := -1;
           g_WakeUpMode := -1;
           if g_ItemWakeUpDlgItem.S.StdMode in [5,6,99,90] then begin   //¹«±â
              if g_ItemWakeUpDlgItem.S.btValue[12] = 1 then begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('ÓÂÃÍµÄ¾õÐÑ');
                g_ItemWakeUp := 1;
                g_WakeUpItem := 0;
                g_WakeUpMode := 0;
              end else begin
              if g_ItemWakeUpDlgItem.S.btValue[12] = 2 then begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('Ä§Ê¥µÄ¾õÐÑ');
                g_ItemWakeUp := 1;
                g_WakeUpItem := 0;
                g_WakeUpMode := 1;
              end else begin
              if g_ItemWakeUpDlgItem.S.btValue[12] = 3 then begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('ÏÉ½çµÄ¾õÐÑ');
                g_ItemWakeUp := 1;
                g_WakeUpItem := 0;
                g_WakeUpMode := 2;
              end else begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('ÓÂÃÍµÄ¾õÐÑ');
                g_ItemWakeUpList.Add('Ä§Ê¥µÄ¾õÐÑ');
                g_ItemWakeUpList.Add('ÏÉ½çµÄ¾õÐÑ');
                g_ItemWakeUp := 3;
              end;
              end;
              end;
           end;
           if g_ItemWakeUpDlgItem.S.StdMode = 15 then begin   //Åõ±¸
              if g_ItemWakeUpDlgItem.S.btValue[12] = 4 then begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('ÊØ»¤µÄ¾õÐÑ');
                g_ItemWakeUp := 1;
                g_WakeUpItem := 0;
                g_WakeUpMode := 0;
              end else begin
              if g_ItemWakeUpDlgItem.S.btValue[12] = 5 then begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('³ýÄ§µÄ¾õÐÑ');
                g_ItemWakeUp := 1;
                g_WakeUpItem := 0;
                g_WakeUpMode := 1;
              end else begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('ÊØ»¤µÄ¾õÐÑ');
                g_ItemWakeUpList.Add('³ýÄ§µÄ¾õÐÑ');
                g_ItemWakeUp := 2;
              end;
              end;
           end;
           if g_ItemWakeUpDlgItem.S.StdMode in [10,11,12] then begin  //°©¿Ê
             if g_ItemWakeUpDlgItem.S.btValue[12] = 6 then begin
                g_ItemWakeUpList.Clear;
                g_ItemWakeUpList.Add('¿áº®µÄ¾õÐÑ');
                g_ItemWakeUp := 1;
                g_WakeUpItem := 0;
                g_WakeUpMode := 0;
             end else begin
               g_ItemWakeUpList.Clear;
               g_ItemWakeUpList.Add('¿áº®µÄ¾õÐÑ');
               g_ItemWakeUp := 1;
             end;
           end;
           if g_WakeUpItem <> -1 then begin
             if g_ItemWakeUpDlgItem.S.btValue[12] = 1 then
                FrmMain.SendItemWakeUp (0, g_ItemWakeUpDlgItem.MakeIndex);
             if g_ItemWakeUpDlgItem.S.btValue[12] = 2 then
                FrmMain.SendItemWakeUp (1, g_ItemWakeUpDlgItem.MakeIndex);
             if g_ItemWakeUpDlgItem.S.btValue[12] = 3 then
                FrmMain.SendItemWakeUp (2, g_ItemWakeUpDlgItem.MakeIndex);
             if g_ItemWakeUpDlgItem.S.btValue[12] = 4 then
                FrmMain.SendItemWakeUp (0, g_ItemWakeUpDlgItem.MakeIndex);
             if g_ItemWakeUpDlgItem.S.btValue[12] = 5 then
                FrmMain.SendItemWakeUp (1, g_ItemWakeUpDlgItem.MakeIndex);
             if g_ItemWakeUpDlgItem.S.btValue[12] = 6 then
                FrmMain.SendItemWakeUp (0, g_ItemWakeUpDlgItem.MakeIndex);
           end;
        end;
        end else begin
          CancelItemMoving;
          DMessageDlg ('Äã²»ÄÜÔÙ¾õÐÑ¡£',[mbOk]);
        end;
      end else begin
        CancelItemMoving;
        DMessageDlg ('Õâ¼þÎïÆ·²»ÄÜ¾õÐÑ¡£',[mbOk]);
      end;
   end;
   end;
   if g_ItemWakeUpDlgItem.S.Name = '' then  DWakeUpList.Visible := FALSE;
end;

procedure TFrmDlg.DDismantleSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY,nHintX,nHintY:Integer;
  Butt:TDButton;
  iname, d1, d2, d3, d4, d5: string;
  useable, Jobuseable: Boolean;
  hcolor: TColor;
begin
   DScreen.ClearHint;
   g_MouseItem := g_DismantleDlgItem;
   Butt:=TDButton(Sender);
   GetMouseItemHint (g_MySelf, @g_MouseItem);
   if HintList.Count > 0 then begin
     nLocalX:=Butt.LocalX(X - Butt.Left);
     nLocalY:=Butt.LocalY(Y - Butt.Top);
     nHintX:=Butt.SurfaceX(Butt.Left) + DDismantleDlg.SurfaceX(DDismantleDlg.Left) + nLocalX;
     nHintY:=Butt.SurfaceY(Butt.Top) + DDismantleDlg.SurfaceY(DDismantleDlg.Top) + nLocalY;
     DScreen.ShowHintB(nHintX, nHintY, HintList, True);
   end;
end;

procedure TFrmDlg.DRenewChrClick(Sender: TObject; X, Y: Integer);
var
  lx, ly, idx: integer;
begin
  lx := DRenewChr.LocalX(X) - DRenewChr.Left;
  ly := DRenewChr.LocalY(Y) - DRenewChr.Top;
  if (lx >= 17) and (lX <= DRenewChr.Width - 17) and (lY >= 76) and (lY <= (265)) then begin
    idx := (lY - 76) div 19;
    if idx in [Low(SelectChrScene.RenewChr)..high(SelectChrScene.RenewChr)] then begin
      if SelectChrScene.RenewChr[idx].Name <> '' then begin
        PlaySound(s_glass_button_click);
        RenewChrIdx := idx + 1;
      end;
      exit;
    end;
  end;
  RenewChrIdx := 0;
end;

procedure TFrmDlg.DRenewChrDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  ax, ay: integer;
  sMan: string;
  I: integer;
  FontColor: TColor;
  rc: TRect;
begin
  with Sender as TDWindow do begin
    ax := SurfaceX(Left);
    ay := SurfaceY(Top);
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    with SelectChrScene do begin
      for I := Low(RenewChr) to high(RenewChr) do begin
        if RenewChr[I].Name <> '' then begin
          with dsurface do begin
            SetBkMode (Canvas.Handle, TRANSPARENT);
            if I = RenewChrIdx - 1 then begin
              FontColor := $82FF;
              rc := Bounds(Left + 16, Top + 76 + I * 19, 327, 19);
              Canvas.Brush.Color := clSkyBlue;
              Canvas.FrameRect(rc);
            end else begin
              FontColor := clWhite;
            end;
            TextOutA(dsurface, ax + 35, ay + 80 + I * 19, FontColor, RenewChr[I].Name);
            sMan := IntToStr(RenewChr[I].Level);
            TextOutA(dsurface, ax + 72  + (166  - Canvas.TextWidth(sMan)) div 2, ay + 80 + I * 19, FontColor, sMan);
            sMan := GetJobName(RenewChr[I].Job);
            TextOutA(dsurface, ax + 110 + (226 - Canvas.TextWidth(sMan)) div 2, ay + 80 + I * 19, FontColor, sMan);
            sMan := GetsexName(RenewChr[I].Sex);
            TextOutA(dsurface, ax + 158 + (284 - Canvas.TextWidth(sMan)) div 2, ay + 80 + I * 19, FontColor, sMan);
            Canvas.Release;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DButRenewChrDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if Downed then begin
         d := WLib.Images[FaceIndex + 2];
      end else
      if MouseMoveing then begin
         d := WLib.Images[FaceIndex + 1];
      end else
         d := WLib.Images[FaceIndex];

      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBtnSayAllMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  ShowMsg: string;
begin
  with Sender as TDControl do begin
    X := SurfaceX(Left);
    y := SurfaceY(Top) - 2;
    ShowMsg := '';
    if Sender = DBtnSayHear then begin
      ShowMsg := '<CO$FFFF>¶Ô»°<CE>';
      X := x - 15;
    end
    else if Sender = DBtnSayCry then begin
      ShowMsg := '<CO$FFFF>º°»°<CE>';
      //ShowMsg := '<CO$FFFF>º°»°<CE>\¿ì Å¬¸¯ ½Ã ÇÊÅÍ¸µ È°¼ºÈ­/ºñÈ°¼ºÈ­¸¦ ÇÒ ¼ö ÀÖ½À´Ï´Ù.\¶ÇÇÑ ¿ì Å¬¸¯ ½Ã <CO$FFFF>¸ô¾Æº¸±â<CE>°¡ °¡´ÉÇÕ´Ï´Ù.';
      X := x - 10;
    end
    else if Sender = DBtnSayWhisper then begin
      ShowMsg := '<CO$FFFF>Ë½ÁÄ<CE>/';
      //ShowMsg := '<CO$FFFF>Ë½ÁÄ<CE>\`/Ä³¸¯ÅÍ¸í ±Ó¼Ó¸» ³»¿ë`À» 1È¸ÀÌ»ó ÀÔ·Â ½Ã »ç¿ë °¡´ÉÇÕ´Ï´Ù.\¿ì Å¬¸¯ ½Ã ÇÊÅÍ¸µ È°¼ºÈ­/ºñÈ°¼ºÈ­¸¦ ÇÒ ¼ö ÀÖ½À´Ï´Ù.\¶ÇÇÑ ¿ì Å¬¸¯ ½Ã <CO$FFFF>¸ô¾Æº¸±â<CE>°¡ °¡´ÉÇÕ´Ï´Ù.';
      X := x - 10;
    end
    else if Sender = DBtnSayGroup then begin
      ShowMsg := '<CO$FFFF>×é¶Ó<CE>';
      X := x - 15;
    end
    else if Sender = DBtnSayGuild then begin
      ShowMsg := '<CO$FFFF>ÐÐ»á<CE>';
      X := x - 15;
    end
    else if Sender = DBtnSayLover then begin
      ShowMsg := '<CO$FFFF>·òÆÞ<CE>';
      X := x - 15;
    end
    else if Sender = DBtnSayMaster then begin
      ShowMsg := '<CO$FFFF>Ê¦Í½<CE>';
    //  ShowMsg := '<CO$FFFF>Ê¦Í½<CE>\¿ì Å¬¸¯ ½Ã ÇÊÅÍ¸µ È°¼ºÈ­/ºñÈ°¼ºÈ­¸¦ ÇÒ ¼ö ÀÖ½À´Ï´Ù.\¶ÇÇÑ ¿ì Å¬¸¯ ½Ã <CO$FFFF>¸ô¾Æº¸±â<CE>°¡ °¡´ÉÇÕ´Ï´Ù.';
      X := x - 15;
    end
    else if Sender = DBtnSaySys then begin
      ShowMsg := '<CO$FFFF>ÏµÍ³ÏûÏ¢<CE>';
      X := x - 30;
    end;
    if ShowMsg <> '' then
      DScreen.ShowHintA(x, y, ShowMsg, clWhite, True);
  end;
end;

procedure TFrmDlg.DBtnSayAllMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  UserSayType: TUserSayType;
begin
  if Button = mbLeft then begin
    g_SayMode := TUserSayMode(TDButton(Sender).Tag - 1);
    if (g_SayMode <> usm_sys) then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
      SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
      case g_SayMode of
          usm_Hear: PlayScene.EdChat.Text := '';
          usm_Whisper: PlayScene.EdChat.Text := '/';
          usm_Cry: PlayScene.EdChat.Text := '!';
          usm_Group: PlayScene.EdChat.Text := '!!';
          usm_Guild: PlayScene.EdChat.Text := '!~';
          usm_Lover: PlayScene.EdChat.Text := '¢½';
          usm_Master: PlayScene.EdChat.Text := '¡Ý';
      end;
      PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
      PlayScene.EdChat.SelLength := 0;
    end;
  end;
  if Button = mbRight then begin
    if (g_boModeC = 1) then begin  //ÇÊÅÍ¸µ
      UserSayType := TUserSayType(TDButton(Sender).Tag);
      if g_SayShowType <> UserSayType then begin
        g_SayShowType := UserSayType;
        g_SayEffectIndex[UserSayType] := False;
        case UserSayType of
          us_All: DScreen.ChangeTransferMsg([us_Hear, us_Whisper, us_Cry, us_Group, us_Guild, us_GuildAlly,us_Sys], 0);
          us_Hear: DScreen.ChangeTransferMsg([us_Whisper, us_Cry, us_Group, us_Guild, us_GuildAlly, us_Lover, us_Master, us_Sys], 0);
          us_Whisper: DScreen.ChangeTransferMsg([us_Hear, us_Cry, us_Group, us_Guild, us_GuildAlly, us_Lover, us_Master, us_Sys], 0);
          us_Cry: DScreen.ChangeTransferMsg([us_Hear, us_Whisper, us_Group, us_Guild, us_GuildAlly, us_Lover, us_Master, us_Sys], 0);
          us_Group: DScreen.ChangeTransferMsg([us_Hear, us_Cry, us_Whisper, us_Guild, us_GuildAlly, us_Lover, us_Master, us_Sys], 0);
          us_Guild: DScreen.ChangeTransferMsg([us_Hear, us_Cry, us_Whisper, us_Group, us_GuildAlly, us_Lover, us_Master, us_Sys], 0);
          us_Lover: DScreen.ChangeTransferMsg([us_Hear, us_Cry, us_Whisper, us_Group, us_Guild, us_GuildAlly, us_Master, us_Sys], 0);
          us_Master: DScreen.ChangeTransferMsg([us_Hear, us_Cry, us_Whisper, us_Group, us_Guild, us_GuildAlly, us_Lover, us_Sys], 0);
          us_Sys: DScreen.ChangeTransferMsg([us_Hear, us_Whisper, us_Cry, us_Group, us_Guild, us_GuildAlly, us_Master, us_Lover], 0);
          us_GuildAlly: DScreen.ChangeTransferMsg([us_Hear, us_Cry, us_Whisper, us_Group, us_Guild, us_Lover, us_Master, us_Sys], 0);
        end;
      end else begin
        g_SayShowType := us_All;
        DScreen.ChangeTransferMsg([us_Hear, us_Whisper, us_Cry, us_Group, us_Guild, us_GuildAlly, us_Lover, us_Master, us_Sys], 1);
      end;
      g_boModeC := 0;
    end else begin    //¸ô¾Æº¸±â
      g_SayType := TUserSayType(TDButton(Sender).Tag);
      g_SayEffectIndex[g_SayType] := False;
      case g_SayType of
          us_Hear,
          us_Whisper,
          us_Cry,
          us_Group,
          us_Guild,
          us_GuildAlly,
          us_Lover,
          us_Master,
          us_Sys: DScreen.ChangeTransferMsg([g_SayType]);
      end;
      g_boModeC := 1;
    end;
  end;
end;

procedure TFrmDlg.DBtnSayAllDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: integer;
  UserSayType: TUserSayType;
begin
  with Sender as TDButton do begin
    UserSayType := TUserSayType(Integer(AppendData));
    if WLib <> nil then begin
      idx := FaceIndex;
      if g_SayEffectIndex[UserSayType] then begin
        if ((GetTickCount - AppendTick) div 200 mod 2 = 0) then begin
          idx := FaceIndex + 1;
        end;
      end else begin
      if (g_SayType = UserSayType) and (g_boModeC = 1) then begin  //¸ô¾Æº¸±â
        idx := 2067;
      end else if (g_SayShowType = UserSayType) and (g_boModeC = 0) then begin   //Â÷´Ü
        idx := 2066;
      end else if g_SayMode = TUserSayMode(Tag - 1) then begin
        idx := FaceIndex + 2;
      end else if MouseMoveing then begin
        idx := FaceIndex + 1;
      end;
      end;
      d := WLib.Images[idx];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBotChatTransClick(Sender: TObject; X, Y: Integer);
begin
  g_boChatModeTrens := Not g_boChatModeTrens;
end;

procedure TFrmDlg.DTopMsgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  ax, ay: integer;
  nParam: Integer;
  wFontWidth: Word;
  wIndex: Word;
  nLeft: Integer;
  WideStr: WideString;
  I: Integer;
  tStr, AddStr, cmdstr, sbcolor, sfcolor: string;
  boBeginColor: Boolean;
  nFColor, nBColor: TColor;
  d: TDirectDrawSurface;
begin
  with Sender as TDWindow do begin
    if GSurface = nil then Exit;
    ax := SurfaceX(Left);
    ay := SurfaceY(Top);
    d := g_WMainImages.Images[1361];
    if d <> nil then
     DrawBlendEx (dsurface, ax, ay, d, 0, 0, Width, Height, 0);
    with GSurface.Canvas do begin
      if m_TopMsgList.Count > 0 then begin

        WideStr := m_TopMsgList[0];
        nParam := Integer(m_TopMsgList.Objects[0]);
        if nParam = 0 then begin
          wFontWidth := TextWidth(m_TopMsgList[0]) + 4 + Width;
          wIndex := 0;
          AppendTick := 0;
        end else begin
          wFontWidth := LoWord(nParam);
          wIndex := HiWord(nParam);
        end;
        if GetTickCount > AppendTick then begin
          AppendTick := GetTickCount + 10;
          GSurface.Fill(0);
          Inc(wIndex, 2);
          if wIndex > (wFontWidth) then begin
            m_TopMsgList.Delete(0);
            Exit;
          end;
          m_TopMsgList.Objects[0] := TObject(MakeLong(wFontWidth, wIndex));
          nLeft := Width - (wIndex mod wFontWidth);
          boBeginColor := False;
          AddStr := '';
          cmdstr := '';
          nFColor := $FFFFFF;
          nBColor := clBlack;
          SetBkMode (Handle, TRANSPARENT);
          for I := 1 to Length(WideStr) do begin
            tStr := WideStr[i];
            if boBeginColor then begin
              if tstr = #6 then begin
                boBeginColor := False;
                sbcolor := GetValidStr3(cmdstr, sfcolor, ['/']);
                nFColor := StrToIntDef('$' + sfcolor, $FFFF);
                nBColor := StrToIntDef('$' + sbcolor, 0);
                cmdstr := '';
              end else cmdstr := cmdstr + tstr;
            end else begin
              if tstr = #6 then begin
                boBeginColor := True;
                BoldTextOut(GSurface, nLeft, 2, nFColor, nBColor, AddStr);
                Inc(nLeft, TextWidth(AddStr));
                AddStr := '';
                cmdstr := '';
              end else
              if tstr = #5 then begin
                BoldTextOut(GSurface, nLeft, 2, nFColor, nBColor, AddStr);
                Inc(nLeft, TextWidth(AddStr));
                AddStr := '';
                cmdstr := '';
                nFColor := $FFFFFF;
                nBColor := 0;
              end else AddStr := AddStr + tstr;
            end;
          end;
          if AddStr <> '' then begin
            BoldTextOut(GSurface, nLeft, 2, nFColor, nBColor, AddStr);
          end;
          Release;
        end;
        DrawBlendEx (dsurface, ax, ay, GSurface, 0, 0, GSurface.Width, GSurface.Height, 1);
      end else begin
        Visible := False;
        DTopMsg.GSurface.Fill(0);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBTCheck1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx, nid: integer;
  ClientCheckMsg: pTClientCheckMsg;
begin
  with Sender as TDButton do begin
    if (Tag >= 0) and (Tag < g_QuestMsgList.Count) then begin
      ClientCheckMsg := g_QuestMsgList[Tag];
      if (GetTickCount > ClientCheckMsg.EndTime) then begin
        nid := ClientCheckMsg.MsgIndex;
        Dispose(ClientCheckMsg);
        g_QuestMsgList.Delete(Tag);
        Visible := False;
        FrmDlg.RefCheckButtonXY;
        frmMain.SendCheckMsgDlgSelect(nid, 0);
        exit;
      end;
      idx := 0;
      case ClientCheckMsg.MsgType of
        tmc_Group: idx := 0;
        tmc_Friend: idx := 3;
        tmc_Guild: idx := 6;
        tmc_Time: idx := 9;
        tmc_Deal: idx := 12;
        //CHECK_FRIEND : idx := 3;
      end;
    end
    else begin
      Visible := False;
      exit;
    end;
    //idx := 0;
    if WLib <> nil then begin
      {if Downed then begin
        inc(idx, 2)
      end
      else if (MouseEntry = msIn) or }
      if (((GetTickCount - ClientCheckMsg.ShowTime) mod 400) > 200) then begin
        Inc(idx, 1)
      end;
      d := WLib.Images[FaceIndex + idx];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBTCheck1Click(Sender: TObject; X, Y: Integer);
var
  ClientCheckMsg: pTClientCheckMsg;
  str: string;
  nid: integer;
begin
  with Sender as TDButton do begin
    if (Tag >= 0) and (Tag < g_QuestMsgList.Count) then begin
      Downed := False;
      ClientCheckMsg := g_QuestMsgList[Tag];
      str := ClientCheckMsg.str;
      nid := ClientCheckMsg.MsgIndex;
      Dispose(ClientCheckMsg);
      g_QuestMsgList.Delete(Tag);
      Visible := False;
      FrmDlg.RefCheckButtonXY;
      if mrYes = DMessageDlg(str, [mbYes, mbNo]) then
        frmMain.SendCheckMsgDlgSelect(nid, 1)
      else
        frmMain.SendCheckMsgDlgSelect(nid, 0);
    end
    else begin
      Visible := False;
      exit;
    end;
  end;
end;

procedure TFrmDlg.DBigMapDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  mx, my, i: integer;
  sText: string;
  rc, dc: TRect;
  actor: TActor;
  cX, cY: integer;
  btColor: Byte;
  boMove: Boolean;
  ax, ay: integer;
  nWidth, nHeight: Integer;

  MapDescInfo: pTMapDescInfo;
  DescList: TList;
  MapDesc: pTMapDesc;
begin
  with DBigMapDlg do begin
    Left := (g_FScreenWidth - 565) div 2;       //Å«¸Ê
    Top := (g_FScreenHeight - 370) div 2 - 50;
    if g_MySelf = nil then exit;
    if GetTickCount > m_dwBlinkTime + 300 then begin
      m_dwBlinkTime := GetTickCount;
      m_boViewBlink := not m_boViewBlink;    //º»ÀÎÀ§Ä¡ ±ôºý °Å¸®´Â°Å
    end;
    if g_nMiniMapIndex < 1000 then begin
      d := g_WMMapImages.Images[g_nMiniMapIndex]
    end else begin
      if (g_nMiniMapIndex >= 2500) and (g_nMiniMapIndex < 3000) then
        d := g_WSMMapImages.Images[g_nMiniMapIndex - 2500]
      else
      if (g_nMiniMapIndex >= 1000) and (g_nMiniMapIndex < 1500) then
        d := g_WFMMapImages.Images[g_nMiniMapIndex - 999]
      else d := g_WMMapMir3Images.Images[g_nMiniMapIndex - 1500];        //Å«¸Ê
    end;

    if d = nil then begin
      DBigMapDlg.Visible := False;
      exit;
    end;
    cx := -1;
    cy := 0;

    ax := SurfaceX(Left);
    ay := SurfaceY(Top);

    nWidth := _MIN(d.ClientRect.Right, Width);
    nHeight := _MIN(d.ClientRect.Bottom, Height);

    dc.Left := ax + (Width - nWidth) div 2;
    dc.Top := ay + (Height - nHeight) div 2;
    dc.Right := dc.Left + nWidth;
    dc.Bottom := dc.Top + nHeight;
    rc.Left := 0;
    rc.Top := 0;
    rc.Right := d.ClientRect.Right;
    rc.Bottom := d.ClientRect.Bottom;

    if g_nViewMapLv = 1 then
      dsurface.DrawAlpha (dc, rc, d, True, 152)
    else dsurface.DrawAlpha (dc, rc, d, True, 253);

    if (g_nMiniMapMaxX >= dc.Left) and (g_nMiniMapMaxX <= dc.Right) and
      (g_nMiniMapMaxY >= dc.Top) and (g_nMiniMapMaxY <= dc.Bottom) then begin
      cX := (g_nMiniMapMaxX - dc.Left) * 32 * rc.Right div nWidth div 48;
      cy := (g_nMiniMapMaxY - dc.Top) * rc.Bottom div nHeight;
    end;

    if cx > -1 then begin
      g_nMiniMapMaxMosX := cX;
      g_nMiniMapMaxMosY := cY;
    end
    else begin
      g_nMiniMapMaxMosX := g_MySelf.m_nCurrX;
      g_nMiniMapMaxMosY := g_MySelf.m_nCurrY;
    end;

    with dsurface do begin
      SetBkMode (Canvas.Handle, TRANSPARENT);
      Canvas.Brush.Color := clYellow;
      Canvas.FrameRect(dc);
      Canvas.Release;
      if (g_nMiniMapPath <> nil) and (High(g_nMiniMapPath) > 0) then begin
        boMove := False;
        mx := -1;
        my := -1;
        for I := Low(g_nMiniMapPath) to High(g_nMiniMapPath) do begin
          mx := dc.Left + Trunc((g_nMiniMapPath[i].X * 48) * (nWidth / rc.Right)) div 32 + 2;
          my := dc.Top + Trunc(g_nMiniMapPath[i].Y * (nHeight / rc.Bottom)) + 2;
          if boMove then begin
            dsurface.Pixels[mx, my] := clGreen;
            dsurface.Pixels[mx + 1, my] := clGreen;
            dsurface.Pixels[mx - 1, my] := clGreen;
            dsurface.Pixels[mx, my + 1] := clGreen;
            dsurface.Pixels[mx, my - 1] := clGreen;
          end else begin
            dsurface.Pixels[mx, my] := clGreen;
            dsurface.Pixels[mx + 1, my] := clGreen;
            dsurface.Pixels[mx - 1, my] := clGreen;
            dsurface.Pixels[mx, my + 1] := clGreen;
            dsurface.Pixels[mx, my - 1] := clGreen;
          end;
          boMove := True;
        end;
        d := g_WAresImages.Images[221];
        if d <> nil then
          DSurface.Draw(mx, my + 1 - d.Height, d.ClientRect, d, True);
      end;
    end;
    TempsList.Clear;
    for I := 0 to PlayScene.m_ActorList.Count - 1 do begin
      actor := TActor(PlayScene.m_ActorList.Items[I]);
      if (actor <> nil) and (actor <> g_MySelf) and (not actor.m_boDeath) and
        (abs(g_MySelf.m_nCurrX - actor.m_nCurrX) < 20) and (abs(g_MySelf.m_nCurrY - actor.m_nCurrY) < 20) then begin
        mx := dc.Left + Trunc((actor.m_nCurrX * 48) * (nWidth / rc.Right)) div 32;
        my := dc.Top + Trunc(actor.m_nCurrY * (nHeight / rc.Bottom));
        btColor := 0;
        case Actor.m_btRace of
          0 : if (nil <> fLover) and  (Length( Trim(Actor.m_sUserName)) > 0) and ( Actor.m_sUserName = Copy(fLover.GetDisplay(0), length(STR_LOVER)+1, 20)) then begin
                btColor := 222    //¿¬ÀÎ ÇÏÆ®
              end else
              if (actor.m_Group <> nil) then begin
                btColor := 224;    //±×·ì¿ø
              end else btColor := 240;
          50:               btColor := 223;  //¿£ÇÇ¾¾ ³ë¶û»ö
          12, 24:           btColor := 216;   //°æºñ
          54, 55, 81, 82:       btColor := 225;    //½Å¼ö ¿ù·É µî..
          95, 96, 98, 99:       btColor := 0;    //»çºÏ¼º¹®
          90, 240..251:         btColor := 0;    //¿µ¹°
          else if ( (Actor.m_boVisible) and (not Actor.m_boDeath) and (pos('(', Actor.m_sUserName) = 0)) then btColor := 217;
        end;
        d := g_WAresImages.Images[btColor];
        if btColor = 0 then d := nil;
        if d <> nil then begin
          if (actor <> g_MySelf) and ((actor.m_nState and $00000200 <> 0) or (actor.m_nState and $00000080 <> 0)) and not (frmMain.IsGroupMember(actor.m_sUserName)) then begin

          end else begin
            if (actor <> g_MySelf) and (actor.m_nState and $00004000 <> 0 ) and (actor.m_btRace = 157) then begin  //»ç·É¸÷ ¾Èº¸ÀÌ°Ô ÇÇÅë
            end else begin
              if (actor <> g_MySelf) and (actor.m_nState and $00004000 <> 0) and     //¿ù¿µ¼ú ¾Èº¸ÀÌ°Ô ¹Ì´Ï¸Ê Á¡
                ((abs(actor.m_nCurrX - g_MySelf.m_nCurrX) > 2) OR (abs(actor.m_nCurrY - g_MySelf.m_nCurrY) > 2)) and not (frmMain.IsGroupMember(actor.m_sUserName)) then begin
              end else begin
                dsurface.Draw(mx - d.Width div 2 + 4, my - d.Height div 2 + 2, d.ClientRect, d, True);
              end;
            end;
          end;
        end;
      end;
    end;

    if (g_MapDesc <> nil)  then begin
      for i := 0 to g_MapDesc.MaxList.Count - 1 do begin
        MapDesc := g_MapDesc.MaxList[i];
        if MapDesc.nColor > 0 then begin
          mx := dc.Left + Trunc((MapDesc.nX * 48) * (nWidth / rc.Right)) div 32;
          my := dc.Top + Trunc((MapDesc.nY * 32) * (nHeight / rc.Bottom)) div 32;
          with dsurface.Canvas do begin
            SetBkMode (Handle, TRANSPARENT);
            Font.Size := 8;
            BoldTextOut(dsurface, mx - TextWidth(MapDesc.sName) div 2, my, MapDesc.nColor, clBlack, MapDesc.sName);
            Font.Size := 9;
            Release;
          end;
        end;
      end;
    end;

    if not m_boViewBlink then begin
      mx := dc.Left + Trunc((g_MySelf.m_nCurrX * 48) * (nWidth / rc.Right)) div 32;
      my := dc.Top + Trunc(g_MySelf.m_nCurrY * (nHeight / rc.Bottom));
      d := g_WAresImages.Images[220];      //³ª ÀÚ½Å
      if d <> nil then
        dsurface.Draw(mx - d.Width div 2 + 4, my - d.Height div 2 + 2,
          d.ClientRect, d, True);
      with dsurface do begin
        SetBkMode (Canvas.Handle, TRANSPARENT);
        sText := IntToStr(g_MySelf.m_nCurrX) + ':' + IntToStr(g_MySelf.m_nCurrY);
        BoldTextOut(dsurface, mx - d.Width div 2 + 12, my - d.Height div 2 , clWhite, clBlack, sText);
        Canvas.Release;
      end;
    end;
    if cx > -1 then begin
      mx := dc.Left + Trunc((cX * 48) * (nWidth / rc.Right)) div 32;
      my := dc.Top + Trunc(cY * (nHeight / rc.Bottom)) + 2;
      d := g_WAresImages.Images[221];       //µµÂøÁ¡
      if d <> nil then
        DSurface.Draw(mx, my - d.Height, d.ClientRect, d, True);
    end;

  end;
end;

procedure TFrmDlg.DBigMapDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  ShowStr: string;
begin
  ShowStr := '';
  g_nMiniMapMaxX := DBigMapDlg.SurfaceX(x);
  g_nMiniMapMaxY := DBigMapDlg.SurfaceY(Y);
  if (g_nMiniMapIndex >= 1000) then begin
    ShowStr := g_sMapTitle + ' (<CO$FFFF>' + IntToStr(g_nMiniMapMaxMosX) + ',' + IntToStr(g_nMiniMapMaxMosY) + '<CE>)\ \';
    ShowStr := ShowStr + '* ×Ô¶¯ÒÆ¶¯¹¦ÄÜ\';
    ShowStr := ShowStr + '* <CO$FFFF>±¾µØÍ¼²»Ö§³Ö×Ô¶¯ÒÆ¶¯<CE>';
  end else begin
    if g_nMiniMapMoseX <> -1 then begin
      ShowStr := g_sMapTitle + ' (<CO$FFFF>' + IntToStr(g_nMiniMapMaxMosX) + ',' + IntToStr(g_nMiniMapMaxMosY) + '<CE>)\ \';
      ShowStr := ShowStr + '* Ä¿µÄµØ (<CO$FFFF>' + IntToStr(g_nMiniMapMoseX) + ',' + IntToStr(g_nMiniMapMoseY) + '<CE>)\';
      ShowStr := ShowStr + '* ËùÐèÊ±¼ä: <CO$FFFF>' + IntToStr(High(g_nMiniMapPath)) + 'Ãë<CE>';
    end else begin
      ShowStr := g_sMapTitle + ' (<CO$FFFF>' + IntToStr(g_nMiniMapMaxMosX) + ',' + IntToStr(g_nMiniMapMaxMosY) + '<CE>)\ \';
      ShowStr := ShowStr + '* ÒÆ¶¯·½Ê½(<CO$FFFF>Ê¹ÓÃÊó±ê<CE>)\';
      ShowStr := ShowStr + '* <CO$FFFF>ÒÆ¶¯<CE> : µ¥»÷Êó±ê×ó¼ü\';                //Å«¸Ê   Var_Mir2
      ShowStr := ShowStr + '* <CO$FFFF>Í£Ö¹<CE> : µ¥»÷Êó±êÓÒ¼ü';
    end;
  end;
  if (ShowStr <> '') and ((g_nMiniMapMaxMosX <> g_MySelf.m_nCurrX) or (g_nMiniMapMaxMosY <> g_MySelf.m_nCurrY)) then
    DScreen.ShowHintA(X + 10, Y + 10, ShowStr, clWhite, False);
end;

procedure TFrmDlg.DBigMapDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if g_MySelf.m_boStartStore or g_boStartStoreing then Exit;
  if Button = mbMiddle then begin
    g_boAutoMoveing := False;
    g_boNpcMoveing := False;
    FrmMain.SendSay('@×Ô¶¯ÒÆ¶¯' + ' ' + IntToStr(g_nMiniMapMaxMosX) + ' ' + IntToStr(g_nMiniMapMaxMosY));
  end else begin
    if (g_nMiniMapIndex >= 1000) and (g_nMiniMapIndex < 2500) then exit;
    if Button = mbRight then begin
      if g_boAutoMoveing then begin
        g_boAutoMoveing := False;
        g_boNpcMoveing := False;
        g_nMiniMapMoseX := -1;
        g_nMiniMapMoseY := -1;
        g_nMiniMapOldX := -1;
        DScreen.AddSysMsg('[Í£Ö¹×Ô¶¯ÒÆ¶¯¡£]', 40, 60, clYellow);
        g_nMiniMapPath := nil;
      end;
    end else begin
      g_nMiniMapPath := FindPath(g_nMiniMapMaxMosX, g_nMiniMapMaxMosY);
      if High(g_nMiniMapPath) > 2 then begin
        g_boAutoMoveing := False;
        g_nMiniMapMoseX := g_nMiniMapMaxMosX;
        g_nMiniMapMoseY := g_nMiniMapMaxMosY;
        g_boAutoMoveing := True;
        g_boNpcMoveing := False;
      end
      else begin
        g_nMiniMapMoseX := -1;
        g_nMiniMapMoseY := -1;
        DScreen.AddSysMsg('[ÎÞ·¨ÒÆ¶¯µ½Ä¿µÄµØ]', 40, 60, clRed);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBigMapDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  case key of
   27 :  if DBigMapDlg.Visible then DBigMapDlg.Visible := False;
   byte('V'), byte('v'): begin
        DBotMiniMapClick(Nil,0,0);
      end;
   byte('B'), byte('b'): begin
        DBotBigMapClick(Nil,0,0);
      end;
   13: //¿£ÅÍ
            begin
               PlayScene.EdChat.Visible := TRUE;
               PlayScene.EdChat.SetFocus;
               SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
             {  if FrmDlg.BoGuildChat then begin
                  PlayScene.EdChat.Text := '!~';
                  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                  PlayScene.EdChat.SelLength := 0;
               end else begin     }
                 if g_SayMode <> usm_Hear then begin
                   case g_SayMode of
                     usm_Whisper: PlayScene.EdChat.Text := '/';
                     usm_Cry: PlayScene.EdChat.Text := '!';
                     usm_Group: PlayScene.EdChat.Text := '!!';
                     usm_Guild: PlayScene.EdChat.Text := '!~';
                     usm_Lover: PlayScene.EdChat.Text := '¢½';
                     usm_Master: PlayScene.EdChat.Text := '¡Ý';
                   end;
                   PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                   PlayScene.EdChat.SelLength := 0;
                 end else begin
                   PlayScene.EdChat.Text := '';
                 end;
            //   end;
            end;
  end;

  DScreen.ClearHint;    
end;

procedure TFrmDlg.DMiniMapDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  mx, my, i, nLen: integer;
  rc: TRect;
  actor: TActor;
  cX, cY: integer;
  btColor: Byte;
  boMove: Boolean;
  ax, ay: integer;
  MapDesc: pTMapDesc;
  str: String;
begin
  with DMiniMap do begin
    if g_MySelf = nil then exit;

    if GetTickCount > m_dwBlinkTime + 300 then begin
      m_dwBlinkTime := GetTickCount;
      m_boViewBlink := not m_boViewBlink;
    end;

    if g_nMiniMapIndex < 1000 then begin
      d := g_WMMapImages.Images[g_nMiniMapIndex]
    end else begin
      if (g_nMiniMapIndex >= 2500) and (g_nMiniMapIndex < 3000) then
        d := g_WSMMapImages.Images[g_nMiniMapIndex - 2500]
      else
      if (g_nMiniMapIndex >= 1000) and (g_nMiniMapIndex < 1500) then
        d := g_WFMMapImages.Images[g_nMiniMapIndex - 999]
      else d := g_WMMapMir3Images.Images[g_nMiniMapIndex - 1500];       //¹Ì´Ï¸Ê
    end;

    cx := -1;
    cy := 0;

    ax := SurfaceX(Left);
    ay := SurfaceY(Top);


    mx := (g_MySelf.m_nCurrX * 48) div 32 + 4;
    my := (g_MySelf.m_nCurrY * 32) div 32 + 4;
    rc.Left := _MAX(0, mx - 64);
    rc.Top := _MAX(0, my - 64);
    if d = nil then begin
      rc.Right := rc.Left + Width;
      rc.Bottom := rc.Top + Height;
    end
    else begin
      rc.Right := _MIN(d.ClientRect.Right, rc.Left + Width);
      rc.Bottom := _MIN(d.ClientRect.Bottom, rc.Top + Height);
    end;
    if g_nMiniMapX >= 0 then begin
        cX := (g_nMiniMapX + rc.Left - ax) * 32 div 48;
        cy := (g_nMiniMapY + rc.Top - ay) * 32 div 32 - 22;
    end;


    if cx > -1 then begin
      g_nMiniMapMosX := cX;
      g_nMiniMapMosY := cY;
    end
    else begin
      g_nMiniMapMosX := g_MySelf.m_nCurrX;
      g_nMiniMapMosY := g_MySelf.m_nCurrY;
    end;
    if d <> nil then begin
      if g_nViewMinMapLv = 1 then
        DrawBlendalpha(DSurface, ax, ay , d, rc.Left, rc.Top, rc.Right - rc.Left, rc.Bottom - rc.Top, 132)
      else DSurface.Draw(ax, ay, rc, d, FALSE);
    end;
    with DSurface do begin
      if (g_nMiniMapPath <> nil) and (High(g_nMiniMapPath) > 0) then begin
        boMove := False;
        mx := -1;
        my := -1;
        for I := Low(g_nMiniMapPath) to High(g_nMiniMapPath) do begin
          mx := (g_nMiniMapPath[i].X * 48) div 32 - rc.Left + 3;
          my := (g_nMiniMapPath[i].Y * 32) div 32 - rc.Top + 2;
          if (mx < 0) or (my < 0) or (mx > dsurface.Width) or (my > dsurface.Height) or (mx > 120) or (my > 108) then
            Continue;
          if boMove then begin
            dsurface.Pixels[ax + mx, ay + my] := clGreen;
            dsurface.Pixels[ax + mx + 1, ay +my] := clGreen;
            dsurface.Pixels[ax + mx - 1, ay +my] := clGreen;
            dsurface.Pixels[ax + mx, ay +my + 1] := clGreen;
            dsurface.Pixels[ax + mx, ay +my - 1] := clGreen;
          end else begin
            dsurface.Pixels[ax + mx, ay +my] := clGreen;
            dsurface.Pixels[ax + mx + 1, ay +my] := clGreen;
            dsurface.Pixels[ax + mx - 1, ay +my] := clGreen;
            dsurface.Pixels[ax + mx, ay +my + 1] := clGreen;
            dsurface.Pixels[ax + mx, ay +my - 1] := clGreen;
          end;
          boMove := True;
        end;
        if (g_nMiniMapPath <> nil) and (High(g_nMiniMapPath) > 0) then begin
          mx := (g_nMiniMapPath[High(g_nMiniMapPath)].X * 48) div 32 - rc.Left + 2;
          my := (g_nMiniMapPath[High(g_nMiniMapPath)].Y * 32) div 32 - rc.Top;
          if (mx > 0) and (my > 0) and (mx < dsurface.Width) and (my < dsurface.Height) and (mx < 120) and (my < 108) then begin
            d := g_WAresImages.Images[221];
            if d <> nil then
              DSurface.Draw(ax + mx - 2, ay + my + 2 - d.Height, d, True);
          end;
        end;
      end;
    end;
    TempsList.Clear;
    for I := 0 to PlayScene.m_ActorList.Count - 1 do begin
      actor := TActor(PlayScene.m_ActorList.Items[I]);
      if (actor <> nil) and (actor <> g_MySelf) and (not actor.m_boDeath) and
        (abs(g_MySelf.m_nCurrX - actor.m_nCurrX) < 20) and (abs(g_MySelf.m_nCurrY - actor.m_nCurrY) < 20) then begin
        mx := ax + (actor.m_nCurrX * 48) div 32 - rc.Left + 4;
        my := ay + (actor.m_nCurrY * 32) div 32 - rc.Top + 2;
        btColor := 0;
        case Actor.m_btRace of
          0 : if (nil <> fLover) and  (Length( Trim(Actor.m_sUserName)) > 0) and ( Actor.m_sUserName = Copy(fLover.GetDisplay(0), length(STR_LOVER)+1, 20)) then begin
                btColor := 222    //¿¬ÀÎ ÇÏÆ®
              end else
              if (actor.m_Group <> nil) then begin
                btColor := 224;    //±×·ì¿ø
              end else btColor := 0;    //´Ù¸¥»ç¶÷ Ãâ·Â ¾ÈÇÔ
          50:               btColor := 216;  //¿£ÇÇ¾¾ ³ë¶û»ö
          12, 24:           btColor := 223;   //°æºñ
          54, 55, 81, 82:       btColor := 0;    // ½Å¼ö Ãâ·ÂÇÏÁö ¾ÊÀ½...
          95, 96, 98, 99:       btColor := 0;    //»çºÏ¼º¹®
          90, 240..251:         btColor := 0;    //¿µ¹°
          else if ( (Actor.m_boVisible) and (not Actor.m_boDeath) and (pos('(', Actor.m_sUserName) = 0)) then btColor := 217;
        end;
        d := g_WAresImages.Images[btColor];
        if btColor = 0 then d := nil;
        if d <> nil then begin
          if (actor <> g_MySelf) and ((actor.m_nState and $00000200 <> 0) or (actor.m_nState and $00000080 <> 0)) and not (frmMain.IsGroupMember(actor.m_sUserName)) then begin

          end else begin
            if (actor <> g_MySelf) and (actor.m_nState and $00004000 <> 0 ) and (actor.m_btRace = 157) then begin  //»ç·É¸÷ ¾Èº¸ÀÌ°Ô ÇÇÅë
            end else begin
              if (actor <> g_MySelf) and (actor.m_nState and $00004000 <> 0) and     //¿ù¿µ¼ú ¾Èº¸ÀÌ°Ô ¹Ì´Ï¸Ê Á¡
                ((abs(actor.m_nCurrX - g_MySelf.m_nCurrX) > 2) OR (abs(actor.m_nCurrY - g_MySelf.m_nCurrY) > 2)) and not (frmMain.IsGroupMember(actor.m_sUserName)) then begin
              end else begin
                dsurface.Draw(mx - d.Width div 2, my - d.Height div 2, d.ClientRect, d, True);
              end;
            end;
          end;
        end;
      end;
    end;

    if (g_MapDesc <> nil) then begin
      for i := 0 to g_MapDesc.MinList.Count - 1 do begin
        MapDesc := g_MapDesc.MinList[i];
        if MapDesc.nColor > 0 then begin
          mx := (MapDesc.nX * 48) div 32 - rc.Left;
          my := (MapDesc.nY * 32) div 32 - rc.Top + 2;
          with dsurface.Canvas do begin
            SetBkMode (Handle, TRANSPARENT);
            Font.Size := 8;
            nLen := TextWidth(MapDesc.sName) div 2;
            mx := mx - nLen;
            if ((mx + nLen ) > 0) and (my > 2) and (mx < Width) and (my < Height - 10) then
              BoldTextOut(dsurface, ax + mx, ay + my, MapDesc.nColor, clBlack, MapDesc.sName);
            Font.Size := 9;
            Release;
          end;
        end;
      end;
    end;
    if not m_boViewBlink then begin
      mx := ax + (g_MySelf.m_nCurrX * 48) div 32 - rc.Left + 4;
      my := ay + (g_MySelf.m_nCurrY * 32) div 32 - rc.Top + 2;
      d := g_WAresImages.Images[220];      //³ª ÀÚ½Å
      if d <> nil then
        dsurface.Draw(mx - d.Width div 2, my - d.Height div 2,
          d.ClientRect, d, True);
    end;
    if cx > -1 then begin
      mx := ax + (cX * 48) div 32 - rc.Left;
      my := ay + (cY * 32) div 32 - rc.Top;
      d := g_WAresImages.Images[221];       //µµÂøÁ¡
      if d <> nil then
        DSurface.Draw(mx, my - d.Height, d.ClientRect, d, True);
    end;


  {  if g_nMiniMapMoseX >= 0 then begin
      str := '¼Ò¿ä½Ã°£ : ' + IntToStr(High(g_nMiniMapPath)) + 'ÃÊ';
      g_DXCanvas.TextOut(ax + 64 - g_DXCanvas.TextWidth(str) div 2, ay + 98, $8CEFF7, str);
    end;       }

  end;
end;

procedure TFrmDlg.DMiniMapMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if g_MySelf.m_boStartStore or g_boStartStoreing then Exit;
  if Button = mbMiddle then begin
    g_boAutoMoveing := False;
    g_boNpcMoveing := False;
    FrmMain.SendSay('@×Ô¶¯ÒÆ¶¯{Áø±ÍÇÑÀÌµ¿}' + ' ' + IntToStr(g_nMiniMapMosX) + ' ' + IntToStr(g_nMiniMapMosY));
  end else begin
    if (g_nMiniMapIndex >= 1000) and (g_nMiniMapIndex < 2500) then exit;
  if Button = mbRight then begin
    if g_boAutoMoveing then begin
      g_boAutoMoveing := False;
      g_boNpcMoveing := False;
      g_nMiniMapMoseX := -1;
      g_nMiniMapMoseY := -1;
      g_nMiniMapOldX := -1;
      DScreen.AddSysMsg('[Í£Ö¹×Ô¶¯ÒÆ¶¯¡£]', 40,60, clYellow);
      g_nMiniMapPath := nil;
    end;
  end else begin
    g_nMiniMapOldX := -1;
    g_nMiniMapPath := FindPath(g_nMiniMapMosX, g_nMiniMapMosY);
    if High(g_nMiniMapPath) > 2 then begin
      g_boAutoMoveing := False;
      g_nMiniMapMoseX := g_nMiniMapMosX;
      g_nMiniMapMoseY := g_nMiniMapMosY;
      g_boAutoMoveing := True;
      g_boNpcMoveing := False;
    end
    else begin
      g_nMiniMapMoseX := -1;
      g_nMiniMapMoseY := -1;
      DScreen.AddSysMsg('[ÎÞ·¨ÒÆ¶¯µ½Ä¿µÄµØ¡£]', 40, 60, clRed);
    end;
  end;
  end;
end;

procedure TFrmDlg.DMiniMapMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  g_nMiniMapX := DMiniMap.SurfaceX(x);
  g_nMiniMapY := DMiniMap.SurfaceY(DMiniMap.Top + Y);
end;

procedure TFrmDlg.DMiniMapKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  case key of
   byte('V'), byte('v'): begin
        DBotMiniMapClick(Nil,0,0);
      end;
   byte('B'), byte('b'): begin
        DBotBigMapClick(Nil,0,0);
      end;
   13: //¿£ÅÍ
            begin
               PlayScene.EdChat.Visible := TRUE;
               PlayScene.EdChat.SetFocus;
               SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
             {  if FrmDlg.BoGuildChat then begin
                  PlayScene.EdChat.Text := '!~';
                  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                  PlayScene.EdChat.SelLength := 0;
               end else begin   }
                 if g_SayMode <> usm_Hear then begin
                   case g_SayMode of
                     usm_Whisper: PlayScene.EdChat.Text := '/';
                     usm_Cry: PlayScene.EdChat.Text := '!';
                     usm_Group: PlayScene.EdChat.Text := '!!';
                     usm_Guild: PlayScene.EdChat.Text := '!~';
                     usm_Lover: PlayScene.EdChat.Text := '¢½';
                     usm_Master: PlayScene.EdChat.Text := '¡Ý';
                   end;
                   PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                   PlayScene.EdChat.SelLength := 0;
                 end else begin
                   PlayScene.EdChat.Text := '';
                 end;
             //  end;
            end;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DMerchantDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DOptionsMp3OnDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
 d: TDirectDrawSurface;
 rc:TRect;
  btop, sx, sy, i, fcolor, bcolor , strln: integer;
  r: Real;
begin
  with DOptionsMp3On do begin
   // º¼·ý °ÔÀÌÁö
     d := g_WMain2Images.Images[468];
     if d <> nil then begin
       rc := d.ClientRect;
       if (g_btMP3Volume) > 0 then  r := 100 / (g_btMP3Volume)
        else r := 0;
       if r > 0 then rc.Right := Round (rc.Right / r)
        else rc.Right := 0;
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), rc, d, FALSE);
     end;
  end;
end;

procedure TFrmDlg.DOptionsMp3OnMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if DOptionsMp3On.Downed then begin
    if (X > 161) and (X < 238) and (Y > 141) and (Y < 160) then begin
       g_btMP3Volume:= Round((X - 161) * 1.3);       //½ºÃÄ »ç¿îµå
    end;
  end;
  if g_boBGSound and (g_btMP3Volume > 0) then begin
    if g_boSound then begin
      if MusicHS >= BASS_ERROR_ENDED then begin
        if BASS_ChannelIsActive(MusicHS) <> BASS_ACTIVE_PLAYING then begin
          PlayMapMusic(True);
        end else
          BASS_ChannelSetAttribute(MusicHS, BASS_ATTRIB_VOL, g_btMP3Volume / 100);
      end else
        PlayMapMusic(True);
    end;
  end
  else ClearBGM;
end;

procedure TFrmDlg.DOptionsMp3OnMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if DOptionsMp3On.Downed then begin
    if (X > 162) and (X < 238) and (Y > 141) and (Y < 160) then begin
      g_btMP3Volume:= Round((X - 161) * 1.3);       //½ºÃÄ »ç¿îµå
    end;
  end;
  if g_boBGSound and (g_btMP3Volume > 0) then begin
    if g_boSound then begin
      if MusicHS >= BASS_ERROR_ENDED then begin
        if BASS_ChannelIsActive(MusicHS) <> BASS_ACTIVE_PLAYING then begin
          PlayMapMusic(True);
        end else
          BASS_ChannelSetAttribute(MusicHS, BASS_ATTRIB_VOL, g_btMP3Volume / 100);
      end else
        PlayMapMusic(True);
    end;
  end
  else ClearBGM;
end;

procedure TFrmDlg.DOptionsFullClick(Sender: TObject; X, Y: Integer);
begin
  g_boFullScreen2 := true;
  DOptionsFull.SetImgIndex (g_WMain2Images, 458);
  DOptionsWin.SetImgIndex (g_WMain2Images, 459);
  DScreen.AddChatBoardString ('<ÖØÐÂµÇÂ¼Ê±Ê¹ÓÃÈ«ÆÁÄ£Ê½>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsWinClick(Sender: TObject; X, Y: Integer);
begin
  g_boFullScreen2 := false;
  DOptionsFull.SetImgIndex (g_WMain2Images, 456);
  DOptionsWin.SetImgIndex (g_WMain2Images, 461);
  DScreen.AddChatBoardString ('<ÖØÐÂµÇÂ¼Ê±Ê¹ÓÃ´°¿ÚÄ£Ê½>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsHintOnClick(Sender: TObject; X, Y: Integer);
begin
  g_bobuttHint := True;
  DOptionsHintOn.SetImgIndex (g_WMain2Images, 458);
  DOptionsHintOff.SetImgIndex (g_WMain2Images, 459);
  DScreen.AddChatBoardString ('<²é¿´ÎïÆ·ÏêÏ¸ÐÅÏ¢>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsHintOffClick(Sender: TObject; X, Y: Integer);
begin
  g_bobuttHint := false;
  DOptionsHintOn.SetImgIndex (g_WMain2Images, 456);
  DOptionsHintOff.SetImgIndex (g_WMain2Images, 461);
  DScreen.AddChatBoardString ('<Ê¹ÓÃ Ctrl¼ü ²é¿´ÎïÆ·ÏêÏ¸ÐÅÏ¢>', clGreen, clWhite);
end;

procedure TFrmDlg.DSetPassWdDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DSetPassWd do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    Left := (g_FScreenWidth - d.Width) div 2;
    Top := (g_FScreenHeight - d.Height) div 2;
    with dsurface.Canvas do begin
      SetBkMode(Handle, TRANSPARENT);
      Font.Color := clWhite;
      TextOut(SurfaceX(Left + 22), SurfaceY(Top + 36), 'µ±Ç°²Ö¿âÎ´ÉèÖÃÃÜÂë');
      TextOut(SurfaceX(Left + 22), SurfaceY(Top + 54), 'ÇëÉèÖÃ²Ö¿âÃÜÂë (³¤¶ÈÎª6¸ö×Ö·û)');
      TextOut(SurfaceX(Left + 34), SurfaceY(Top + 82), 'ÉèÖÃÃÜÂë');
      TextOut(SurfaceX(Left + 34), SurfaceY(Top + 135), 'È·ÈÏÃÜÂë');
      Release;
    end;
    if (EStoragePW1.Left <> SurfaceX(Left + 36)) or (EStoragePW1.Top <> SurfaceY(Top + 105)) then begin
       EStoragePW1.Left := SurfaceX(Left + 36);
       EStoragePW1.Top := SurfaceY(Top + 105);
    end;
    if (EStoragePW2.Left <> SurfaceX(Left + 36)) or (EStoragePW2.Top <> SurfaceY(Top + 159)) then begin
       EStoragePW2.Left := SurfaceX(Left + 36);
       EStoragePW2.Top := SurfaceY(Top + 159);
    end;
  end;
end;


procedure TFrmDlg.DSetPWCloseClick(Sender: TObject; X, Y: Integer);
begin
  DSetPassWd.Visible := Not DSetPassWd.Visible;

  EStoragePW1.Visible := False;
  EStoragePW2.Visible := False;

  LocalLanguage := imSAlpha;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
end;

procedure TFrmDlg.DStRePWClick(Sender: TObject; X, Y: Integer);
begin
  EStoragePW1.Text := '';
  EStoragePW1.SetFocus;
  EStoragePW2.Text := '';
end;

procedure TFrmDlg.DCheckStPwClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if Length(EStoragePW1.Text) < 6 then begin
      DMessageDlg('ÇëÊäÈëÄãµÄ6Î»ÊýÃÜÂë...', [mbOk]);
      EStoragePW1.SetFocus;
      exit;
    end else begin
      if Not IsStringNumber(EStoragePW1.Text) then begin
         DMessageDlg('ÃÜÂëµÄ¸ñÊ½Ö»ÄÜÎªÊý×Ö¡£', [mbOk]);
         EStoragePW1.SetFocus;
         exit;
      end;
    end;

    if Length(EStoragePW2.Text) < 6 then begin
      DMessageDlg('ÇëÊäÈëÄãµÄ6Î»ÊýÃÜÂë...', [mbOk]);
      EStoragePW2.SetFocus;
      exit;
    end else begin
      if Not IsStringNumber(EStoragePW2.Text) then begin
         DMessageDlg('ÃÜÂëµÄ¸ñÊ½Ö»ÄÜÎªÊý×Ö¡£', [mbOk]);
         EStoragePW2.SetFocus;
         exit;
      end;
    end;
    if EStoragePW1.Text = EStoragePW2.Text then begin
      FrmMain.SendStoragePassWord (g_MySelf.m_nRecogId, 1, EStoragePW2.Text + '/');
      DSetPWCloseClick(Nil, 0, 0);
      if DStoragePWDlg.Visible then DStPWCloseClick(Nil, 0, 0);
    end else begin
      DMessageDlg('ÄãÊäÈëµÄÃÜÂëºÍÈ·ÈÏÃÜÂë²»Ò»Ñù¡£', [mbOk]);
      exit;
    end;
  end;
end;

procedure TFrmDlg.DStScPWClick(Sender: TObject; X, Y: Integer);
var
  i: integer;
  aDButton: Array[0..9] of TDButton;
  aold: TPoint;
  iSwap: Integer;
begin
  aDButton[0] := DStPw0;
  aDButton[1] := DStPw1;
  aDButton[2] := DStPw2;
  aDButton[3] := DStPw3;
  aDButton[4] := DStPw4;
  aDButton[5] := DStPw5;
  aDButton[6] := DStPw6;
  aDButton[7] := DStPw7;
  aDButton[8] := DStPw8;
  aDButton[9] := DStPw9;
  for i := 0 to 9 do begin
    aold.X := aDButton[i].Left;
    aold.Y := aDButton[i].Top;
    iSwap := Random(10);
    while iSwap = i do begin
      iSwap := Random(10);
    end;
    aDButton[i].Left := aDButton[iSwap].Left;
    aDButton[i].Top := aDButton[iSwap].Top;
    aDButton[iSwap].Left := aold.X;
    aDButton[iSwap].Top := aold.Y;
  end;
  DStoragePWDlg.Visible := True;
end;

procedure TFrmDlg.DStoragePWDlgMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DStPWCloseClick(Sender: TObject; X, Y: Integer);
begin
    DStoragePWDlg.Visible := False;
end;

procedure TFrmDlg.DStPwInputClick(Sender: TObject; X, Y: Integer);
var
  EdDlgEdit:hwnd;
  keyname:integer;
begin
  EdDlgEdit := GetFocus;
  PostMessage(EdDlgEdit,WM_KEYDOWN,13,0);
end;

procedure TFrmDlg.DStPwDelClick(Sender: TObject; X, Y: Integer);
var
  EdDlgEdit:hwnd;
  keyname:integer;
begin
  EdDlgEdit := GetFocus;
  PostMessage(EdDlgEdit,WM_KEYDOWN,8,0);
end;

procedure TFrmDlg.DStPw0DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   keyview:string;               //·Î±×ÀÎ º¸Á¶(¸¶¿ì½ºÅ¬¸¯)
begin
  if Sender = DStPw0 then begin
  keyview := '0';
  end;
  if Sender = DStPw1 then begin
  keyview := '1';
  end;
  if Sender = DStPw2 then begin
  keyview := '2';
  end;
  if Sender = DStPw3 then begin
  keyview := '3';
  end;
  if Sender = DStPw4 then begin
  keyview := '4';
  end;
  if Sender = DStPw5 then begin
  keyview := '5';
  end;
  if Sender = DStPw6 then begin
  keyview := '6';
  end;
  if Sender = DStPw7 then begin
  keyview := '7';
  end;
  if Sender = DStPw8 then begin
  keyview := '8';
  end;
  if Sender = DStPw9 then begin
  keyview := '9';
  end;
   with Sender as TDButton do begin
     if Downed then begin
        d := WLib.Images[FaceIndex+2]
     end else
     if MouseMoveing then begin
        d := WLib.Images[FaceIndex+1];
     end else begin
        d := WLib.Images[FaceIndex];
     end;
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

     SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
     dsurface.Canvas.Font.Size :=9;
     if TDButton(Sender).Downed then begin
       BoldTextOut (dsurface, SurfaceX(Left + (d.Width - dsurface.Canvas.TextWidth(keyview)) div 2 -2), SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(keyview)) div 2) + 1, clWhite , clBlack, keyview);
     end else begin
       BoldTextOut (dsurface, SurfaceX(Left + (d.Width - dsurface.Canvas.TextWidth(keyview)) div 2 -2), SurfaceY(Top + (d.Height -dsurface.Canvas.TextHeight(keyview)) div 2) + 1, clWhite , clBlack, keyview);
     end;
     dsurface.Canvas.Font.Size :=9;
     dsurface.Canvas.Release;
   end;
end;

procedure TFrmDlg.DStPw0Click(Sender: TObject; X, Y: Integer);
var
  EdDlgEdit:hwnd;
  keyname:integer;
begin
  keyname := 0;
  EdDlgEdit := GetFocus;
  if Sender = DStPw0 then begin
  keyname := $30;
  end;
  if Sender = DStPw1 then begin
  keyname := $31;
  end;
  if Sender = DStPw2 then begin
  keyname := $32;
  end;
  if Sender = DStPw3 then begin
  keyname := $33;
  end;
  if Sender = DStPw4 then begin
  keyname := $34;
  end;
  if Sender = DStPw5 then begin
  keyname := $35;
  end;
  if Sender = DStPw6 then begin
  keyname := $36;
  end;
  if Sender = DStPw7 then begin
  keyname := $37;
  end;
  if Sender = DStPw8 then begin
  keyname := $38;
  end;
  if Sender = DStPw9 then begin
  keyname := $39;
  end;
  PostMessage(EdDlgEdit,WM_KEYDOWN,keyname,0);
end;

procedure TFrmDlg.DInputStPwdDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DInputStPwd do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
   // Left := 287;
   // Top := 227;
    Left := (g_FScreenWidth - d.Width) div 2;
    Top := (g_FScreenHeight - d.Height) div 2;
    with dsurface.Canvas do begin
      SetBkMode(Handle, TRANSPARENT);
      Font.Color := clWhite;
      TextOut(SurfaceX(Left + 19), SurfaceY(Top + 15), 'ÃÜÂë³¤¶È (6Î»Êý×Ö)');
      Release;
    end;
    if (EStoragePW1.Left <> SurfaceX(Left + 19)) or (EStoragePW1.Top <> SurfaceY(Top + 38)) then begin
       EStoragePW1.Left := SurfaceX(Left + 19);
       EStoragePW1.Top := SurfaceY(Top + 38);
    end;
  end;
end;


procedure TFrmDlg.DInputStCloseClick(Sender: TObject; X, Y: Integer);
begin
  DInputStPwd.Visible := Not DInputStPwd.Visible;

  EStoragePW1.Visible := False;

  LocalLanguage := imSAlpha;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
end;

procedure TFrmDlg.DCheckInPutPwClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if Length(EStoragePW1.Text) < 6 then begin
      DMessageDlg('ÇëÊäÈëÄãµÄ6Î»ÊýÃÜÂë...', [mbOk]);
      EStoragePW1.SetFocus;
      exit;
    end else begin
      if Not IsStringNumber(EStoragePW1.Text) then begin
         DMessageDlg('ÃÜÂëµÄ¸ñÊ½Ö»ÄÜÎªÊý×Ö¡£', [mbOk]);
         EStoragePW1.SetFocus;
         exit;
      end;
    end;
    if m_nStorageMode > 0 then begin
      FrmMain.SendStoragePassWord (g_MySelf.m_nRecogId, 4, EStoragePW1.Text + '/');
    end else begin
      FrmMain.SendStoragePassWord (g_MySelf.m_nRecogId, 2, EStoragePW1.Text + '/' + IntToStr(g_nCurMerchant) + '/');
    end;
    DInputStCloseClick(Nil, 0, 0);
    if DStoragePWDlg.Visible then DStPWCloseClick(Nil, 0, 0);
  end;
end;

procedure TFrmDlg.DChangeStPwDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DChangeStPw do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
   // Left := 250;
   // Top := 140;
    Left := (g_FScreenWidth - d.Width) div 2;
    Top := (g_FScreenHeight - d.Height) div 2;
    with dsurface.Canvas do begin
      SetBkMode(Handle, TRANSPARENT);
      Font.Color := clWhite;
      TextOut(SurfaceX(Left + 24), SurfaceY(Top + 28), '½ÇÉ«Ãû¡¡¡¡¡¡¡¡' + g_MySelf.m_sUserName);
      TextOut(SurfaceX(Left + 24), SurfaceY(Top + 61), 'ÊäÈëµ±Ç°ÃÜÂë');
      TextOut(SurfaceX(Left + 24), SurfaceY(Top + 114), 'ÉèÖÃÐÂÃÜÂë');
      TextOut(SurfaceX(Left + 24), SurfaceY(Top + 167), 'È·ÈÏÐÂÃÜÂë');
      Release;
    end;
    if (EStoragePW1.Left <> SurfaceX(Left + 21)) or (EStoragePW1.Top <> SurfaceY(Top + 80)) then begin
       EStoragePW1.Left := SurfaceX(Left + 21);
       EStoragePW1.Top := SurfaceY(Top + 80);
    end;
    if (EStoragePW2.Left <> SurfaceX(Left + 21)) or (EStoragePW2.Top <> SurfaceY(Top + 133)) then begin
       EStoragePW2.Left := SurfaceX(Left + 21);
       EStoragePW2.Top := SurfaceY(Top + 133);
    end;
    if (EStoragePW3.Left <> SurfaceX(Left + 21)) or (EStoragePW3.Top <> SurfaceY(Top + 186)) then begin
       EStoragePW3.Left := SurfaceX(Left + 21);
       EStoragePW3.Top := SurfaceY(Top + 186);
    end;
  end;
end;

procedure TFrmDlg.DChRePwClick(Sender: TObject; X, Y: Integer);
begin
  EStoragePW1.Text := '';
  EStoragePW1.SetFocus;
  EStoragePW2.Text := '';
  EStoragePW3.Text := '';
end;

procedure TFrmDlg.DCloseChPwClick(Sender: TObject; X, Y: Integer);
begin
  DChangeStPw.Visible := Not DChangeStPw.Visible;

  EStoragePW1.Visible := False;
  EStoragePW2.Visible := False;
  EStoragePW3.Visible := False;

  LocalLanguage := imSAlpha;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
end;

procedure TFrmDlg.DCheckChPwClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if Length(EStoragePW1.Text) < 6 then begin
      DMessageDlg('ÇëÊäÈëÄãµÄ6Î»ÊýÃÜÂë...', [mbOk]);
      EStoragePW1.SetFocus;
      exit;
    end else begin
      if Not IsStringNumber(EStoragePW1.Text) then begin
         DMessageDlg('ÃÜÂëµÄ¸ñÊ½Ö»ÄÜÎªÊý×Ö¡£', [mbOk]);
         EStoragePW1.SetFocus;
         exit;
      end;
    end;

    if Length(EStoragePW2.Text) < 6 then begin
      DMessageDlg('ÇëÊäÈëÄãµÄ6Î»ÊýÃÜÂë¡£', [mbOk]);
      EStoragePW2.SetFocus;
      exit;
    end else begin
      if Not IsStringNumber(EStoragePW2.Text) then begin
         DMessageDlg('ÃÜÂëµÄ¸ñÊ½Ö»ÄÜÎªÊý×Ö¡£', [mbOk]);
         EStoragePW2.SetFocus;
         exit;
      end;
    end;

    if Length(EStoragePW3.Text) < 6 then begin
      DMessageDlg('ÇëÊäÈëÄãµÄ6Î»ÊýÃÜÂë¡£', [mbOk]);
      EStoragePW3.SetFocus;
      exit;
    end else begin
      if Not IsStringNumber(EStoragePW3.Text) then begin
         DMessageDlg('ÃÜÂëµÄ¸ñÊ½Ö»ÄÜÎªÊý×Ö¡£', [mbOk]);
         EStoragePW3.SetFocus;
         exit;
      end;
    end;

    if (EStoragePW2.Text = EStoragePW3.Text) then begin
      FrmMain.SendStoragePassWord (g_MySelf.m_nRecogId, 3, EStoragePW1.Text + '/' + EStoragePW3.Text + '/');
    end else begin
      DMessageDlg('ÄãÊäÈëµÄÃÜÂëºÍÈ·ÈÏÃÜÂë²»Ò»Ñù¡£', [mbOk]);
      exit;
    end;
  end;
end;

procedure TFrmDlg.DStoragePWClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    SendClientMessage(CM_CHECKSTORAGEPW, g_MySelf.m_nRecogId, 0, 0, 0);
  end;
end;

procedure TFrmDlg.DOptionsScreen1Click(Sender: TObject; X, Y: Integer);
begin
  g_FScreenMode2 := 0;
  DOptionsScreen1.SetImgIndex (g_WMain2Images, 464);
  DOptionsScreen2.SetImgIndex (g_WMain2Images, 465);
  DScreen.AddChatBoardString ('<ÖØÐÂµÇÂ¼Ê±ÒÔ 800 x 600 ·Ö±æÂÊÏÔÊ¾>', clGreen, clWhite);
end;

procedure TFrmDlg.DOptionsScreen2Click(Sender: TObject; X, Y: Integer);
begin
  g_FScreenMode2 := 1;
  DOptionsScreen1.SetImgIndex (g_WMain2Images, 462);
  DOptionsScreen2.SetImgIndex (g_WMain2Images, 467);
  DScreen.AddChatBoardString ('<ÖØÐÂµÇÂ¼Ê±ÒÔ 1024 x 768 ·Ö±æÂÊÏÔÊ¾>', clGreen, clWhite);
end;

procedure TFrmDlg.DNewAccountCancelDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex];
      end else
        d := nil;
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DStoreGridWinMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   if g_MySelf.m_boStartStore then exit;
   X := DStoreGridWin.LocalX (X) - DStoreGridWin.Left;
   Y := DStoreGridWin.LocalY (Y) - DStoreGridWin.Top;

   if (X > 78) and (X < 249) and (Y > 126) and (Y < 230) then begin
     EdStoreMacrosEdit.Visible := True;
     SetImeMode (EdStoreMacrosEdit.Handle, imSHanguel);
     EdStoreMacrosEdit.SetFocus;
     EdStoreMsgEdit.Visible := False;
   end else begin
     if (X > 78) and (X < 249) and (Y > 240) and (Y < 261) then begin
       EdStoreMsgEdit.Visible := True;
       SetImeMode (EdStoreMsgEdit.Handle, imSHanguel);
       EdStoreMsgEdit.SetFocus;
       EdStoreMacrosEdit.Visible := False;
     end else begin
       EdStoreMsgEdit.Visible := False;
       EdStoreMacrosEdit.Visible := False;
       SetImeMode (PlayScene.EdChat.Handle, imSAlpha);
     end;
   end;
end;

procedure TFrmDlg.DNameChNPClick(Sender: TObject; X, Y: Integer);
begin
  if g_boNameAllView then begin
    g_boNameChNpView := Not g_boNameChNpView;
    if g_boNameChNpView and g_boNameAllView then begin
      DNameChNP.SetImgIndex (g_WMain2Images, 458);
      DScreen.AddChatBoardString ('<ÏÔÊ¾È«²¿½ÇÉ«ºÍNPCÃû×Ö>', clGreen, clWhite);
    end else begin
      DNameChNP.SetImgIndex (g_WMain2Images, 459);
      DScreen.AddChatBoardString ('<ÏÔÊ¾¹â±êÖ¸ÏòµÄ½ÇÉ«Ãû×Ö>', clGreen, clWhite);
      if not g_boNameMonView and not g_boNameChNpView then begin
        g_boNameAllView := False;
        DOptionsNameAllViewOn.SetImgIndex (g_WMain2Images, 456);
        DOptionsNameAllViewOff.SetImgIndex (g_WMain2Images, 461);
      end;
    end;
  end;
end;

procedure TFrmDlg.DNameMonClick(Sender: TObject; X, Y: Integer);
begin
  if g_boNameAllView then begin
    g_boNameMonView := Not g_boNameMonView;
    if g_boNameMonView and g_boNameAllView then begin
      DNameMon.SetImgIndex (g_WMain2Images, 458);
      DScreen.AddChatBoardString ('<ÏÔÊ¾¹ÖÎïµÄÃû×Ö>', clGreen, clWhite);
    end else begin
      DNameMon.SetImgIndex (g_WMain2Images, 459);
      DScreen.AddChatBoardString ('<ÏÔÊ¾¹â±êÖ¸ÏòµÄ¹ÖÎïÃû×Ö>', clGreen, clWhite);
      if not g_boNameMonView and not g_boNameChNpView then begin
        g_boNameAllView := False;
        DOptionsNameAllViewOn.SetImgIndex (g_WMain2Images, 456);
        DOptionsNameAllViewOff.SetImgIndex (g_WMain2Images, 461);
      end;
    end;
  end;
end;

procedure TFrmDlg.DNewSayDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ii: integer;
  sx, sy: integer;
  d: TDirectDrawSurface;
  nCount: integer;
  pMessage: pTSayMessage;
  SayImage: pTSayImage;
  nx, ny, ax, ay, nLeft: Integer;
  py: smallint;
  sStr: string;
  ClickName: pTClickName;
  ClickItem: pTClickItem;
  dc, rc :TRect;
begin
  with Sender as TDWindow do begin
    if not g_boChatModeTrens then
      dsurface.FillRectAlpha(Rect(SurfaceX(Left), SurfaceX(Top), SurfaceX(Left) + Width, SurfaceX(Top) + Height + 18), clWhite, 255)
    else
    dsurface.FillRectAlpha(Rect(SurfaceX(Left), SurfaceX(Top), SurfaceX(Left) + Width, SurfaceX(Top) + Height + 18), clBlack, 120);
    SetBkMode (dsurface.Canvas.Handle, TRANSPARENT);
    dsurface.Canvas.Brush.Color := $004A7DA5;
    dsurface.Canvas.FrameRect(Rect(SurfaceX(Left), SurfaceX(Top - 1), SurfaceX(Left) + (Width + 1), SurfaceX(Top) + (Height) + 4));
    dsurface.Canvas.Brush.Color := $004A7DA5;
    dsurface.Canvas.FrameRect(Rect(SurfaceX(Left), (SurfaceX(Top) + (Height) + 3) , SurfaceX(Left) + (Width + 1),  SurfaceX(Top) + (Height) + 2 + 16));
    dsurface.Canvas.Release;
    sx := SurfaceX(Left) + 2;
    sy := SurfaceX(Top) + (SAYLISTHEIGHT - 12) div 2 + 2;

    case g_FScreenMode of
    1:
      begin
        d := g_WAresImages.Images[279];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left), (705 - DNewSay.Height ), d.ClientRect, d, True);
        end;
      end;
    else
      begin
        d := g_WMainImages.Images[2035];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left), (537 - DNewSay.Height ), d.ClientRect, d, True);
        end;
      end;
    end;

    nCount := Height div SAYLISTHEIGHT;
    with DScreen do begin
      DSayUpDown.MaxPosition := _MAX(0, m_SayTransferList.count - nCount);
      for i := DSayUpDown.Position to (DSayUpDown.Position + nCount - 1) do begin
        if i > m_SayTransferList.count - 1 then
          break;
        pMessage := m_SayTransferList[i];
        ClickName := nil;
        ClickItem := nil;
        if (pClickName <> nil) and (nClickNameIndex > 0) and (pMessage.ClickList <> nil) and
          (pMessage.ClickList.Count > 0) then begin
          for ii := 0 to pMessage.ClickList.Count - 1 do begin
            if pTClickName(pMessage.ClickList[ii]).Index = nClickNameIndex then begin
              ClickName := pMessage.ClickList[ii];
              break;
            end;
          end;
        end
        else if (pClickItem <> nil) and (nClickItemIndex > 0) and (pMessage.ItemList <> nil) and
          (pMessage.ItemList.Count > 0) then begin
          for ii := 0 to pMessage.ItemList.Count - 1 do begin
            if pTClickItem(pMessage.ItemList[ii]).Index = nClickItemIndex then begin
              ClickItem := pMessage.ItemList[ii];
              break;
            end;
          end;
        end;
        ax := sx;
        ay := sy + (i - DSayUpDown.Position) * SAYLISTHEIGHT;
        dsurface.Draw(ax, ay, pMessage.SaySurface.ClientRect, pMessage.SaySurface, True);
        if (pMessage.ImageList <> nil) and (pMessage.ImageList.Count > 0) then begin
          for ii := 0 to pMessage.ImageList.Count - 1 do begin
            SayImage := pMessage.ImageList[ii];
            if (SayImage.nIndex <= High(g_FaceIndexInfo)) then begin
              d := g_WFaceImages.GetCachedImage(g_FaceIndexInfo[SayImage.nIndex].ImageIndex, nx, ny);
              if d <> nil then begin
                dc.Left := ax + SayImage.nLeft;
                dc.Top := ay + (SAYLISTHEIGHT - d.Height) div 2 + 2;
                dc.Right := dc.Left + 15;
                dc.Bottom := dc.Top + 15;
                rc.Left := 0;
                rc.Top := 0;
                rc.Right := d.ClientRect.Right;
                rc.Bottom := d.ClientRect.Bottom;
                dsurface.DrawAlpha (dc, rc, d, True, 255);
                py := ny;
                if (GetTickCount - g_FaceIndexInfo[SayImage.nIndex].dwShowTime) > LongWord(nx) then begin
                  g_FaceIndexInfo[SayImage.nIndex].ImageIndex := g_FaceIndexInfo[SayImage.nIndex].ImageIndex + py;
                  g_FaceIndexInfo[SayImage.nIndex].dwShowTime := GetTickCount;
                end;
              end;
            end;
          end;
        end;
        if (i = pClickIndex) then begin
          sStr := '';
          nLeft := 0;
          if pClickName <> nil then begin
            sStr := pClickName.sStr;
            nLeft := pClickName.nLeft;
          end
          else if pClickItem <> nil then begin
            sStr := pClickItem.sStr;
            nLeft := pClickItem.nLeft;
          end;
          if sStr <> '' then begin
            with dsurface.Canvas do begin
              SetBkMode(Handle, TRANSPARENT);
              if sStr[1] = '[' then begin
                Font.Style := [fsBold];
                if SayDlgDown then
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clBlack, clWhite, sstr)
                else
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clYellow, clBlack, sstr);
                Font.Style := [];
              end else begin
                if SayDlgDown then
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clBlack, clWhite, sstr)
                else
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clYellow, clBlack, sstr);
              end;
              Release;
            end;
          end;
        end
        else begin
          sStr := '';
          nLeft := 0;
          if ClickName <> nil then begin
            sStr := ClickName.sStr;
            nLeft := ClickName.nLeft;
          end
          else if ClickItem <> nil then begin
            sStr := ClickItem.sStr;
            nLeft := ClickItem.nLeft;
          end;
          if sStr <> '' then begin
            with dsurface.Canvas do begin
              SetBkMode(Handle, TRANSPARENT);
              if sStr[1] = '[' then begin
                Font.Style := [fsBold];
                if SayDlgDown then
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clBlack, clWhite, sstr)
                else
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clYellow, clBlack, sstr);
                Font.Style := [];
              end else begin
                if SayDlgDown then
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clBlack, clWhite, sstr)
                else
                  BoldTextOut(dsurface, ax + nLeft, ay + 0, clYellow, clBlack, sstr);
              end;
              Release;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DNewSayInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var
  ii, nX, nY: integer;
  pMessage: pTSayMessage;
  ClickName: pTClickName;
  ClickItem: pTClickItem;
begin
  IsRealArea := False;
  with Sender as TDWindow do begin
    pClickName := nil;
    pClickItem := nil;
    nClickNameIndex := 0;
    nClickItemIndex := 0;
    nX := X - 2;
    nY := Y;
    pClickIndex := DSayUpDown.Position + nY div SAYLISTHEIGHT;
    with DScreen do begin
      if (pClickIndex >= 0) and (pClickIndex < m_SayTransferList.count) then begin
        pMessage := m_SayTransferList[pClickIndex];
        if (pMessage.ClickList <> nil) and (pMessage.ClickList.Count > 0) then begin
          for ii := 0 to pMessage.ClickList.Count - 1 do begin
            ClickName := pMessage.ClickList[ii];
            if (nX >= ClickName.nLeft) and (nX <= ClickName.nRight) then begin
              pClickName := ClickName;
              nClickNameIndex := ClickName.Index;
              IsRealArea := True;
              break;
            end;
          end;
        end;
        if (pClickName = nil) and (pMessage.ItemList <> nil) and (pMessage.ItemList.Count > 0) then begin
          for ii := 0 to pMessage.ItemList.Count - 1 do begin
            ClickItem := pMessage.ItemList[ii];
            if (nX >= ClickItem.nLeft) and (nX <= ClickItem.nRight) then begin
              pClickItem := ClickItem;
              nClickItemIndex := ClickItem.Index;
              IsRealArea := True;
              break;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DNewSayMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  SayDlgDown := True;
end;

procedure TFrmDlg.DNewSayMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  i: integer;
begin
  SayDlgDown := False;

    if pClickName <> nil then begin
      PlayScene.SetEditChar(pClickName.sStr);
    end
    else if pClickItem <> nil then begin
      if pClickItem.pc.s.name <> '' then begin
        OpenSayItemShow(pClickItem.pc);
      end
      else if pClickItem.ItemIndex < 0 then begin
        for I := Low(g_ItemArr) to High(g_ItemArr) do begin
          if (g_ItemArr[i].s.Name <> '') and (g_ItemArr[i].MakeIndex = (-pClickItem.ItemIndex)) then begin
            OpenSayItemShow(g_ItemArr[i]);
            pClickItem.pc := g_ItemArr[i];
            break;
          end;
        end;
      end
      else begin
        if GetTickCount > DNewSay.AppendTick then begin
          DNewSay.AppendTick := GetTickCount + 500;
          FrmMain.SendGetSayItem(pClickItem.nIndex, pClickItem.ItemIndex); //È¥·þÎñÆ÷È¡»Ø×°±¸ÊôÐÔ

        end;
      end;
    end;
end;

procedure TFrmDlg.DBTSayMoveMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  ShowMsg: string;
  ay: Integer;
begin
  pClickName := nil;
  pClickItem := nil;
  nClickNameIndex := 0;
  nClickItemIndex := 0;
   with Sender as TDControl do begin
    ay := y;
    X := SurfaceX(Left);
    y := SurfaceY(Top);
    ShowMsg := '';

    if Sender = DBTSayMove then begin
      ShowMsg := '<CO$FFFF>´ò¿ªÁÄÌì´°¿Ú<CE>(<CO$FF00>Ê¹ÓÃ¼ýÍ·<CE>)\¿ÉÒÔµ÷ÕûÁÄÌì´°¿ÚµÄ´óÐ¡';
      DSayMoveSize(SurfaceY(ay));
    end
    else if Sender = DBTFace then begin
      ShowMsg := '<CO$FFFF>±íÇé<CE>\Äã¿ÉÒÔ±í´ïÁÄÌìµÄÐÄÇé·½Ê½¡£';
    end
    else if Sender = DBotChatTrans then begin
      if g_boChatModeTrens then ShowMsg:= '<CO$FFFF>ÁÄÌì´°¿ÚÍ¸Ã÷¶È<CE>\ÁÄÌì´°¿ÚÊÇÍ¸Ã÷µÄ'
      else  ShowMsg:= '<CO$FFFF>ÁÄÌì´°¿Ú²»Í¸Ã÷<CE>\ÁÄÌì´°¿ÚÊ±²»Í¸Ã÷µÄ'
    end
    else if Sender = DBotPlusAbil then ShowMsg:= '<CO$FFFF>Ê¹ÓÃ²Ö¿â<CE>\ÔÚÈÎºÎµØ·½¶¼ÄÜÊ¹ÓÃ²Ö¿â'
    else if Sender = DBReady6 then ShowMsg:= '<CO$FFFF>ÒÆ¶¯µ½´å×¯<CE>\Äã½«»á±»´«ËÍµ½×îºóÍ£Áô¹ýµÄ´å×¯'
    else if Sender = DBotOption then ShowMsg:= '<CO$FFFF>ÌØÊâ¼¼ÄÜ<CE>'
    else if Sender = DBHome then
      if not g_boShowHealth then ShowMsg:= '<CO$FFFF>¹Ø±ÕÆ®ÑªÏÔÊ¾<CE>\µ±Ç°×´Ì¬Îª¿ÉÒÔ¿´µ½¼õÉÙ\ÉúÃüÖµÊý×ÖÏÔÊ¾'
      else ShowMsg:= '<CO$FFFF>´ò¿ªÏÔÊ¾<CE>\µ±Ç°×´Ì¬Îª¹Ø±ÕÉúÃüÖµ\Êý×ÖÏÔÊ¾¡¢Ä§Á¦ÖµµÄ±ä»¯'
    else if Sender = DBStorage then ShowMsg:= '<CO$FFFF>½±Àø»ý·Ö<CE>'
    else if Sender = DMakeAdvice then ShowMsg:= '<CO$FFFF>ÖÆÔì¼¼Êõ<CE>'
    else if Sender = DBAuction then ShowMsg:= '<CO$FFFF>¼ÄÊÛ¹¦ÄÜ<CE>\Äã¿ÉÒÔÔÚÈÎºÎµØ·½Ê¹ÓÃ¼ÄÊÛ¹¦ÄÜ'
    else if Sender = dkSayLock then begin
      if g_SayUpDownLock then
       ShowMsg := '<CO$FFFF>ÁÄÌì´°¿Ú<CE> (Ëø¶¨: <CO$FF00>ON<CE>)\Ëø¶¨ÁÄÌì´°¿Ú'
      else ShowMsg := '<CO$FFFF>ÁÄÌì´°¿Ú<CE> (Ëø¶¨: <CO$8000>OFF<CE>)\Ëø¶¨ÁÄÌì´°¿Ú';
    end
    else
    if Sender = DLoverMacro then begin
      if FrmMain.LoverMacro.Enabled then
        ShowMsg:= '<CO$FFFF>·òÆÞ¹ØÏµ(Ê¹ÓÃÖÐ)<CE>'
      else ShowMsg:= '<CO$FFFF>·òÆÞ¹ØÏµ<CE>';
    end
    else if Sender = DExpMode then if g_MoExpMsg then ShowMsg:= '<CO$FFFF>¾­ÑéÖµÏÔÊ¾<CE>\¾­ÑéÖµÏÔÊ¾ÔÚÁÄÌì´°¿Ú' else ShowMsg:= '<CO$FFFF>¾­ÑéÖµÏÔÊ¾<CE>\¾­ÑéÖµÒÔÏµÍ³ÏûÏ¢ÏÔÊ¾'
    else if Sender = DPetEat then if g_boItemAuto = 1 then ShowMsg:= '<CO$FFFF>³èÎï×Ô¶¯¼ñÈ¡<CE>\¹Ø±Õ×Ô¶¯¼ñÈ¡' else ShowMsg:= '<CO$FFFF>³èÎï×Ô¶¯¼ñÈ¡<CE>\¿ªÆô×Ô¶¯¼ñÈ¡'
    else if Sender = DBScreen then
     if not g_boShowGreenHint then  ShowMsg:= '<CO$FFFF>Ê¹ÓÃÆÁÄ»ÌáÊ¾<CE>\ÆÁÄ»ÉÏ¶ËÏÔÊ¾ÓÎÏ·»·¾³µÄÌáÊ¾¡£'
       else ShowMsg:= '<CO$FFFF>¹Ø±ÕÆÁÄ»ÌáÊ¾<CE>\ÆÁÄ»ÉÏ¶Ë¹Ø±ÕÓÎÏ·»·¾³µÄÌáÊ¾¡£'
    else if Sender = DBReady2 then ShowMsg:= '<CO$FFFF>¸öÈËÉÌµê<CE>\Ö±½Ó³ÉÎªÉÌÈË³öÊÛÎïÆ·'
    else if Sender = DBReady3 then ShowMsg:= '<CO$FFFF>¸öÈËÉÌµêº°»°<CE>\Äã¿ÉÒÔÆÁ±Î¸öÈËÉÌµêº°»°'
    else if Sender = DBCompound then ShowMsg:= '<CO$FFFF>Ç¿»¯ÎïÆ·<CE>\Äã¿ÉÒÔÇ¿»¯ÎïÆ·.'
    else
    if Sender = DBReady4 then begin
     case g_boMarkMode of
      0 : ShowMsg:= '<CO$FFFF>±ê¼ÇÉèÖÃ<CE>(±ê¼Ç: ²»Í¸Ã÷)\Äú¿ÉÒÔµ÷ÕûµØÍ¼±ê¼ÇµÄÍ¸Ã÷¶È¡£';
      1 : ShowMsg:= '<CO$FFFF>±ê¼ÇÉèÖÃ<CE>(±ê¼Ç: °ëÍ¸Ã÷)\Äú¿ÉÒÔµ÷ÕûµØÍ¼±ê¼ÇµÄÍ¸Ã÷¶È¡£';
      2 : ShowMsg:= '<CO$FFFF>±ê¼ÇÉèÖÃ<CE>(±ê¼Ç: Í¸Ã÷)\Äú¿ÉÒÔµ÷ÕûµØÍ¼±ê¼ÇµÄÍ¸Ã÷¶È¡£';
     end;
    end;

    if ShowMsg <> '' then
      DScreen.ShowHintA(x, y, ShowMsg, clWhite, True);
  end;
end;

procedure TFrmDlg.DSayMoveSize(Y: Integer);
var
  nCount: Integer;
begin
  if not DBTSayMove.Downed then exit;

  nCount := (g_FScreenHeight - Y - FrmDlg.DBottom.Height + 102 ) div (SAYLISTHEIGHT + 4);

  if nCount < 3 then
    nCount := 3;
  if nCount > 29 then
    nCount := 29;

  DNewSay.Height := 2 + nCount * (SAYLISTHEIGHT + 4);
  DNewSay.Top := g_FScreenHeight - DNewSay.Height - FrmDlg.DBottom.Height + 102;

  DSayUpDown.Top := 4;
  DSayUpDown.Height := DNewSay.Height - 15 + 8;
  if not g_boVerticalBelt then begin
    if g_FScreenHeight = DEFSCREENHEIGHT then
      DBeltWindow.Top := 498 - DNewSay.Height - 14        //Ã¤ÆÃ ±Û
    else DBeltWindow.Top :=  666 - DNewSay.Height - 14;
  end;

  if not g_boVerticaHerolBelt then begin
    if g_FScreenHeight = DEFSCREENHEIGHT then
      DBeltHero.Top := 498 - DNewSay.Height - 14        //Ã¤ÆÃ ±Û
    else DBeltHero.Top :=  666 - DNewSay.Height - 14;
  end;
end;


procedure TFrmDlg.dkSayLockClick(Sender: TObject; X, Y: Integer);
begin
  g_SayUpDownLock := not g_SayUpDownLock;
end;

procedure TFrmDlg.dkSayLockDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: integer;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      idx := FaceIndex;
      if Downed then begin
        idx := FaceIndex + 2;
      end else  if MouseMoveing then begin
        idx := FaceIndex + 1;
      end else if g_SayUpDownLock then begin
        if ((GetTickCount - AppendTick) div 200 mod 2 = 0) then begin
          idx := FaceIndex + 1;
        end;
      end;
      d := WLib.Images[idx];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBTFaceClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg2.DWndFace.Visible := not FrmDlg2.DWndFace.Visible;
end;

procedure TFrmDlg.DButtonReCallHeroClick(Sender: TObject; X, Y: Integer);
begin
  if g_MyHero = nil then begin
    if GetTickCount - g_dwRecallHeroTick > 1000 then begin
       g_dwRecallHeroTick := GetTickCount;
       SendClientMessage(CM_HEROLOGON, 0, 0, 0, 0);
    end;
  end else begin
    if GetTickCount - g_dwRecallHeroTick > 1000 then begin
       g_dwRecallHeroTick := GetTickCount;
       SendClientMessage(CM_HEROLOGOUT, g_MyHero.m_nRecogId, 0, 0, 0);
    end;
  end;
end;

procedure TFrmDlg.DHeroStateWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I, L, m, pgidx, magline, bbx, bby, mmx, Idx, ax, ay, trainlv: Integer;
  pm: PTClientMagic;
  d: TDirectDrawSurface;
  hcolor, old, keyimg: Integer;
  iname, d1, d2, d3: string;
  useable: Boolean;
  c: TColor;
  Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
begin
  if g_MyHero = nil then Exit;
  with DHeroStateWin do begin
    d := nil;
    if WLib <> nil then
      d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    case g_MyHero.m_btJob of
      0: d := g_WMainImages.Images[100];
      1: d := g_WMainImages.Images[101];
      2: d := g_WMainImages.Images[102];
      3: d := g_WMainImages.Images[103];
      4: d := g_WMainImages.Images[104];
    end;
    if d <> nil then
      dsurface.Draw (SurfaceX(Left + 15), SurfaceY(Top + 33), d.ClientRect, d, TRUE);

    case HeroStatePage of
      0: begin
          pgidx := 345;
          if g_MyHero <> nil then
            if g_MyHero.m_btSex = 1 then pgidx := 346;
          bbx := Left + 8;
          bby := Top + 90;
          d := g_WMainImages.Images[pgidx];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, True);
          d := g_WTitleImages.Images[500];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+8), SurfaceY(Top+70), d.ClientRect, d, TRUE);
          bbx := Left;
          bby := Top;
          if g_HeroUseItems[U_DRESS].s.Name <> '' then begin
            Idx := g_HeroUseItems[U_DRESS].s.looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx, ax, ay);
              if d <> nil then
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
            end;

            if (Idx = 85) or (Idx = 86) or (Idx = 595) or (Idx = 605) then begin
              if Idx = 85 then
                d := g_WMain2Images.GetCachedImage (1202, ax, ay);
              if Idx = 86 then
                d := g_WMain2Images.GetCachedImage (1203, ax, ay);
              if Idx = 595 then
                d := g_WMain2Images.GetCachedImage (1204, ax, ay);
              if Idx = 605 then
                d := g_WMain2Images.GetCachedImage (1205, ax, ay);
              if d <> nil then DrawBlend (dsurface, SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
            end;
            
          end;
          //Çì¾î
          Idx := 440 + g_MyHero.m_btHair div 2;
          if g_MyHero.m_btSex = 1 then
          idx := 480 + g_MyHero.m_btHair div 2;

          if g_HeroUseItems[U_HELMET].s.Name <> '' then begin
            Idx := g_HeroUseItems[U_HELMET].s.looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx, ax, ay);
              if d <> nil then
                if g_MyHero.m_btSex = 0 then begin
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay + 2), d.ClientRect, d, True);
                end else
                  dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
            end;
            Idx := 0;
          end;

          if Idx > 0 then begin
            d := g_WMainImages.GetCachedImage(Idx, ax, ay);
            if d <> nil then
              dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay + 2), d.ClientRect, d, True);
          end;

          if g_HeroUseItems[U_WEAPON].s.Name <> '' then begin
            Idx := g_HeroUseItems[U_WEAPON].s.looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx, ax, ay);
              if d <> nil then begin
                dsurface.Draw(SurfaceX(bbx + ax), SurfaceY(bby + ay), d.ClientRect, d, True);
              end;
              if idx = 923 then begin
                d := FrmMain.GetWStateImg(idx-1,ax,ay);
                if d <> nil then DrawBlend(dsurface, SurfaceX(bbx + ax), SurfaceY(bby + ay), d, 1);
              end;
            end;
          end;

        end;
      1: begin
          bbx := Left + 8;
          bby := Top + 90;
          d := g_WTitleImages.Images[506];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);

          d := g_WTitleImages.Images[501];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left + 70), SurfaceY(Top + 70), d.ClientRect, d, TRUE);
          L := Left + 120; //66;
          m := Top + 155;

          with dsurface.Canvas do begin
            SetBkMode (Handle, TRANSPARENT);
            Font.Color := clWhite;
            TextOut(SurfaceX(L + 0), SurfaceY(m + 0), IntToStr(Loword(g_MyHero.m_Abil.AC)) + '-' + IntToStr(Hiword(g_MyHero.m_Abil.AC)));
            TextOut(SurfaceX(L + 0), SurfaceY(m + 27), IntToStr(Loword(g_MyHero.m_Abil.MAC)) + '-' + IntToStr(Hiword(g_MyHero.m_Abil.MAC)));
            TextOut(SurfaceX(L + 0), SurfaceY(m + 54), IntToStr(Loword(g_MyHero.m_Abil.DC)) + '-' + IntToStr(Hiword(g_MyHero.m_Abil.DC)));
            TextOut(SurfaceX(L + 0), SurfaceY(m + 81), IntToStr(Loword(g_MyHero.m_Abil.MC)) + '-' + IntToStr(Hiword(g_MyHero.m_Abil.MC)));
            TextOut(SurfaceX(L + 0), SurfaceY(m + 108), IntToStr(Loword(g_MyHero.m_Abil.SC)) + '-' + IntToStr(Hiword(g_MyHero.m_Abil.SC)));
            TextOut(SurfaceX(L + 0), SurfaceY(m + 135), IntToStr(g_MyHero.m_Abil.HP) + '/' + IntToStr(g_MyHero.m_Abil.MaxHP));
            TextOut(SurfaceX(L + 0), SurfaceY(m + 162), IntToStr(g_MyHero.m_Abil.MP) + '/' + IntToStr(g_MyHero.m_Abil.MaxMP));
            Release;
          end;
        end;
      2: begin
          bbx := Left + 8;
          bby := Top + 90;
          d := g_WTitleImages.Images[507];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);
          d := g_WTitleImages.Images[502];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+132), SurfaceY(Top+70), d.ClientRect, d, TRUE);

          bbx := bbx + 42;
          bby := bby + 62;
          with dsurface.Canvas do begin
            SetBkMode (Handle, TRANSPARENT);
            mmx := bbx + 95;
            Font.Color := clSilver;
            TextOut(bbx, bby, '¾­Ñé ');
            TextOut(mmx, bby, FormatFloat('0.00%',(g_MyHero.m_Abil.Exp / g_MyHero.m_Abil.MaxExp) * 100));

            TextOut(bbx, bby + 16 * 1, '±³°ü¸ºÖØ ');
            if g_MyHero.m_Abil.Weight > g_MyHero.m_Abil.MaxWeight then
              Font.Color := clRed;
            TextOut(mmx, bby + 16 * 1, IntToStr(g_MyHero.m_Abil.Weight) + '/' + IntToStr(g_MyHero.m_Abil.MaxWeight));

            Font.Color := clSilver;
            TextOut(bbx, bby + 16 * 2, '¸ºÖØ ');
            if g_MyHero.m_Abil.WearWeight > g_MyHero.m_Abil.MaxWearWeight then
              Font.Color := clRed;
            TextOut(mmx, bby + 16 * 2, IntToStr(g_MyHero.m_Abil.WearWeight) + '/' + IntToStr(g_MyHero.m_Abil.MaxWearWeight));

            Font.Color := clSilver;
            TextOut(bbx, bby + 16 * 3, 'ÍóÁ¦ ');
            if g_MyHero.m_Abil.HandWeight > g_MyHero.m_Abil.MaxHandWeight then
              Font.Color := clRed;
            TextOut(mmx, bby + 16 * 3, IntToStr(g_MyHero.m_Abil.HandWeight) + '/' + IntToStr(g_MyHero.m_Abil.MaxHandWeight));

            Font.Color := clSilver;
            TextOut(bbx, bby + 16 * 4, '×¼È· ');
            TextOut(mmx, bby + 16 * 4, IntToStr(g_nMyHeroHitPoint));

            TextOut(bbx, bby + 16 * 5, 'Ãô½Ý ');
            TextOut(mmx, bby + 16 * 5, IntToStr(g_nMyHeroSpeedPoint));

            TextOut(bbx, bby + 16 * 6, 'Ä§·¨¶ã±Ü ');
            TextOut(mmx, bby + 16 * 6, '+' + IntToStr(g_nMyHeroAntiMagic));

            TextOut(bbx, bby + 16 * 7, '¶¾Îï¶ã±Ü ');
            TextOut(mmx, bby + 16 * 7, '+' + IntToStr(g_nMyHeroAntiPoison * 10) + '%');

            TextOut(bbx, bby + 16 * 8, 'ÖÐ¶¾»Ö¸´ ');
            TextOut(mmx, bby + 16 * 8, '+' + IntToStr(g_nMyHeroPoisonRecover * 10) + '%');

            TextOut(bbx, bby + 16 * 9, 'ÉúÃü»Ö¸´ ');
            TextOut(mmx, bby + 16 * 9, '+' + IntToStr(g_nMyHeroHealthRecover * 10) + '%');

            TextOut(bbx, bby + 16 * 10, 'Ä§·¨»Ö¸´ ');
            TextOut(mmx, bby + 16 * 10, '+' + IntToStr(g_nMyHeroSpellRecover * 10) + '%');

            TextOut(bbx, bby+16*11, 'ÐÒÔË ');

            if g_nMyLuckPoint > 200 then begin     //ÀúÁÖ Ç¥½Ã
             TextOut (mmx, bby+16*11, '-' + IntToStr(256 - g_nMyHeroLuckPoint));
            end else begin
              TextOut (mmx, bby+16*11, IntToStr(g_nMyHeroLuckPoint));
            end;
            TextOut(bbx, bby+16*12, '¹¥»÷ËÙ¶È ');
            TextOut(mmx, bby + 16 * 12, IntToStr(g_MyHero.m_nHitSpeed));
            Release;
          end;
        end;
      3: begin
          bbx := Left + 8;
          bby := Top + 90;
          d := g_WTitleImages.Images[508];
          if d <> nil then
            dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, False);
          d := g_WTitleImages.Images[503];
            if d <> nil then
               dsurface.Draw (SurfaceX(Left+194), SurfaceY(Top+70), d.ClientRect, d, TRUE);
          Heromagtop := HeroMagicPage * 6;
          magline := _MIN(HeroMagicPage * 6 + 6, g_HeroMagicList.Count);
          for I := Heromagtop to magline - 1 do begin
            pm := PTClientMagic(g_HeroMagicList[I]);
            m := I - Heromagtop;
            d := g_WMainImages.Images[1656];
            if d <> nil then
              dsurface.Draw (bbx + 9, bby + 41 + m * 33, d.ClientRect, d, TRUE);
              with dsurface.Canvas do begin
                SetBkMode (Handle, TRANSPARENT);
                Font.Size := 8;
                Font.Color := clWhite;
                Key1 := 'F1'; Key2 := 'F2'; Key3 := 'F3'; Key4 := 'F4';
                Key5 := 'F5'; Key6 := 'F6'; Key7 := 'F7'; Key9 := 'Shift'; Key10 := '+';
                if byte(pm.Key) = byte('1') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key1);
                end;
                if byte(pm.Key) = byte('2') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key2);
                end;
                if byte(pm.Key) = byte('3') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key3);
                end;
                if byte(pm.Key) = byte('4') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key4);
                end;
                if byte(pm.Key) = byte('5') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key5);
                end;
                if byte(pm.Key) = byte('6') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key6);
                end;
                if byte(pm.Key) = byte('7') then begin
                  TextOut (SurfaceX(Left + 18), SurfaceY(bby +43 + m * 33), Key9);
                  TextOut (SurfaceX(Left + 29), SurfaceY(bby +51 + m * 33), Key10);
                  TextOut (SurfaceX(Left + 19), SurfaceY(bby +60 + m * 33), Key7);
                end;
                Font.Size := 9;
                Release;
              end;
              d := g_WTitleImages.Images[516];
              if d <> nil then
                dsurface.Draw (bbx + 78, bby+46+m*33, d.ClientRect, d, TRUE);
              d := g_WTitleImages.Images[517];
              if d <> nil then
                dsurface.Draw (bbx + 78, bby+58+m*33, d.ClientRect, d, TRUE);
          end;

          with dsurface.Canvas do begin
            SetBkMode (Handle, TRANSPARENT);
            Font.Color := clSilver;       //¸¶¹ý ÆäÀÌÁö
            if (g_HeroMagicList.Count > 0) then begin
              TextOut(bbx + 112, bby + 252, inttostr(HeroMagicPage + 1)+'/'+inttostr((g_HeroMagicList.Count+5) div 6));
            end;
            for I := Heromagtop to magline - 1 do begin
              pm := PTClientMagic(g_HeroMagicList[I]);
              m := I - Heromagtop;
              if not (pm.Level in [0..3]) then pm.Level := 0;

              TextOut(bbx + 120, bby + 45 + m * 33, pm.Def.sMagicName);
              if pm.Level in [0..3] then trainlv := pm.Level
              else trainlv := 0;

              TextOut(bbx + 94, bby + 45 + m * 33, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if trainlv < 3 then
                  TextOut (bbx+120, bby+60+m*33, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))  //¹«°ø ¼ö·Ã

                else TextOut (bbx+120, bby+60+m*33, '-');   //¹«°ø ¼ö·Ã ¿Ï·á
              end;
            end;
            Release;
          end;
        end;
    end;
     //¿µ¿õ ÀÌ¸§
    with dsurface.Canvas do begin
       SetBkMode (Handle, TRANSPARENT);                //ÀÌ¸§
       Font.Color := g_MyHero.m_nNameColor;
       TextOut (SurfaceX(Left +  135 - TextWidth(g_MyHero.m_sUserName) div 2), SurfaceY(Top + 16), g_MyHero.m_sUserName);
       Font.Color := ClWhite;
       Release;
    end;
  end;
end;

procedure TFrmDlg.DHeroStateWinMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  sMsg:String;
begin
   g_MouseStateItem.S.Name := '';
   g_MouseItem.s.Name := '';
   DScreen.ClearHint;
   X := DHeroStateWin.LocalX (X) - DHeroStateWin.Left;
   Y := DHeroStateWin.LocalY (Y) - DHeroStateWin.Top;

  if HeroStatePage = 1 then begin
      if (X > 90) and (X < 212) and (Y > 152) and (Y < 167) then begin
         DScreen.ShowHintA (DHeroStateWin.Left + 175, DHeroStateWin.Top+152,
                           '·ÀÓùÁ¦', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 179) and (Y < 194) then begin
         DScreen.ShowHintA (DHeroStateWin.Left + 175, DHeroStateWin.Top+179,
                           'Ä§·¨·ÀÓùÁ¦', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 205) and (Y < 220) then begin
         DScreen.ShowHintA (DHeroStateWin.Left + 175, DHeroStateWin.Top+205,
                           '¹¥»÷Á¦', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 233) and (Y < 248) then begin
         DScreen.ShowHintA (DHeroStateWin.Left + 175, DHeroStateWin.Top+233,
                           'Ä§·¨Á¦', clYellow, FALSE);
         exit;
      end else
      if (X > 90) and (X < 212) and (Y > 260) and (Y < 274) then begin
         DScreen.ShowHintA (DHeroStateWin.Left + 175, DHeroStateWin.Top+260,
                           'µÀÊõ', clYellow, FALSE);
         exit;
      end;
   end;

   if (X > 12) and (X < 45) and (Y > 30) and (Y < 62) then begin
      case g_MyHero.m_btJob of
         0: sMsg := 'Õ½Ê¿';
         1: sMsg := '·¨Ê¦';
         2: sMsg := 'µÀÊ¿';
         3: sMsg := '´Ì¿Í';
         4: sMsg := 'ºÍÉÐ';
      end;

     DScreen.ShowHintA (DHeroStateWin.Left + 15, DHeroStateWin.Top + 15,
                           sMsg, clYellow, FALSE);
     exit;
   end;

end;

procedure TFrmDlg.DHeroCharClick(Sender: TObject; X, Y: Integer);
begin
  HeroStatePage := 0;
  HeroPageChanged;
end;

procedure TFrmDlg.DHeroStatusClick(Sender: TObject; X, Y: Integer);
begin
  HeroStatePage := 1;
  HeroPageChanged;
end;

procedure TFrmDlg.DHeroStateClick(Sender: TObject; X, Y: Integer);
begin
  HeroStatePage := 2;
  HeroPageChanged;
end;

procedure TFrmDlg.DHeroSkillClick(Sender: TObject; X, Y: Integer);
begin
  HeroStatePage := 3;
  HeroPageChanged;
end;


procedure TFrmDlg.DCloseHeroStateClick(Sender: TObject; X, Y: Integer);
begin
  DHeroStateWin.Visible := False;
end;

procedure TFrmDlg.CloseHeroAllWindows;
begin
   if DHeroItemBag.Visible then DHeroItemBag.Visible := False;
   if DHeroStateWin.Visible then DHeroStateWin.Visible := False;
   if DHeroStMag1.Visible then DHeroStMag1.Visible := False;
   if DHeroStMag2.Visible then DHeroStMag2.Visible := False;
   if DHeroStMag3.Visible then DHeroStMag3.Visible := False;
   if DHeroStMag4.Visible then DHeroStMag4.Visible := False;
   if DHeroStMag5.Visible then DHeroStMag5.Visible := False;
   if DHeroStMag6.Visible then DHeroStMag6.Visible := False;
   if DHeroKeylDlg.Visible then DHeroKeylDlg.Visible := False;
end;


procedure TFrmDlg.DHeroSWWeaponDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx, i, ax, ay: Integer;
  d: TDirectDrawSurface;
  nWhere: Integer;
begin
  if g_MyHero = nil then Exit;
  nWhere := -1;
  if HeroStatePage = 0 then begin
    if Sender = DHeroSWWeapon then nWhere := U_WEAPON;
    if Sender = DHeroSWDress then nWhere := U_DRESS;
    if Sender = DHeroSWHelmet then nWhere := U_HELMET;
    if Sender = DHeroSWNecklace then nWhere := U_NECKLACE;
    if Sender = DHeroSWLight then nWhere := U_RIGHTHAND;
    if Sender = DHeroSWArmRingR then nWhere := U_ARMRINGR;
    if Sender = DHeroSWArmRingL then nWhere := U_ARMRINGL;
    if Sender = DHeroSWRingR then nWhere := U_RINGR;
    if Sender = DHeroSWRingL then nWhere := U_RINGL;
    if Sender = DHeroSWBujuk then nWhere := U_BUJUK;
    if Sender = DHeroSWBelt then nWhere := U_BELT;
    if Sender = DHeroSWBoots then nWhere := U_BOOTS;
    if Sender = DHeroSWCharm then nWhere := U_CHARM;

    if nWhere >= 0 then begin
      if g_HeroUseItems[nWhere].s.Name <> '' then begin
        Idx := g_HeroUseItems[nWhere].s.looks;
        if Idx >= 0 then begin
          d := g_WBagItemImages.Images[Idx];
          if d <> nil then
            with TDButton(Sender) do
              dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2),
                SurfaceY(Top + (Height - d.Height) div 2),
                d.ClientRect, d, True);

          if (g_HeroUseItems[nWhere].S.btValue[19] > 2) and   //ºÀÀÎ
            (now < UnixToDateTime(DateTimeToUnix(g_HeroUseItems[nWhere].S.MaxDate))) then begin
            d := g_WStateItemImages.Images[3590];
            if d <> nil then
              with TDButton(Sender) do
              dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2) + 12,
                                SurfaceY(Top + (Height - d.Height) div 2) + 8, d.ClientRect, d, True);
          end;
          if g_HeroUseItems[nWhere].S.ItemGlow <> 0  then
          if (aiShineFrame[nWhere] <> -1) then begin
            d := g_WMainImages.GetCachedImage(ITEMSHINEOFFSET + aiShineFrame[nWhere], ax, ay);
            if d <> nil then begin
              with TDButton(Sender) do
              DrawBlend(dsurface, SurfaceX(Left + ax - 6), SurfaceY(Top + ay) + 41, d, 1);
            end;
          end;


          for i := 0 to 13 do begin
            if GetTickCount > aiShineTime[i] + 80 then begin
              aiShineTime[i] := GetTickCount;
              if aiShineFrame[i] < 9 then
                aiShineFrame[i] := aiShineFrame[i] + 1
              else begin
                aiShineFrame[i] := -1;
                aiShineTime[i] := GetTickCount + 2000 + Random(1500);
              end;
            end;
          end;


        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroSWWeaponMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  nLocalX,nLocalY:Integer;
  nHintX,nHintY:Integer;
  sel: integer;
  Butt:TDButton;
begin
   if HeroStatePage <> 0 then exit;
   sel := -1;
   Butt:=TDButton(Sender);
   if Sender = DHeroSWDress then sel := U_DRESS
   else if Sender = DHeroSWWeapon then sel := U_WEAPON
   else if Sender = DHeroSWHelmet then sel := U_HELMET
   else if Sender = DHeroSWNecklace then sel := U_NECKLACE
   else if Sender = DHeroSWLight then sel := U_RIGHTHAND
   else if Sender = DHeroSWRingL then sel := U_RINGL
   else if Sender = DHeroSWRingR then sel := U_RINGR
   else if Sender = DHeroSWArmRingL then sel := U_ARMRINGL
   else if Sender = DHeroSWArmRingR then sel := U_ARMRINGR
   else if Sender = DHeroSWBujuk then sel := U_BUJUK
   else if Sender = DHeroSWBelt then sel := U_BELT
   else if Sender = DHeroSWBoots then sel := U_BOOTS
   else if Sender = DHeroSWCharm then sel := U_CHARM;

   if sel >= 0 then begin
      g_MouseItem := g_HeroUseItems[sel];
      GetMouseItemHint(g_MyHero, @g_MouseItem);
      if HintList.Count > 0 then begin
        nLocalX:=Butt.LocalX(X - Butt.Left);
        nLocalY:=Butt.LocalY(Y - Butt.Top);
        nHintX:=Butt.SurfaceX(Butt.Left) + DHeroStateWin.SurfaceX(DHeroStateWin.Left) + nLocalX;
        nHintY:=Butt.SurfaceY(Butt.Top) + DHeroStateWin.SurfaceY(DHeroStateWin.Top) + nLocalY;
        with Sender as TDButton do
          DScreen.ShowHintB(nHintX + 10, nHintY + 24, HintList, False);
      end;
      g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DHeroSWWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: Integer;
  flag, movcancel: Boolean;
begin
  if g_MyHero = nil then Exit;
 // if g_MySelf.m_boStartStore or g_boStartStoreing then exit;
  if HeroStatePage <> 0 then Exit;

  if g_boItemMoving then begin
    flag := False;
    movcancel := False;
    if (g_MovingItem.Owner = DDealDlg) or (g_MovingItem.Owner = DStateWin) or (g_MovingItem.Owner = DItemStore) then Exit;
    if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
        (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.s.Name = '') or (g_WaitingUseItem.Item.s.Name <> '') then Exit;
    where := GetTakeOnPosition(g_MovingItem.Item.s.StdMode);
    if g_MovingItem.Index >= 0 then begin
      case where of
        U_DRESS: begin
            if Sender = DHeroSWDress then begin
              if g_MyHero.m_btSex = 0 then
                if g_MovingItem.Item.s.StdMode <> 10 then
                  Exit;
              if g_MyHero.m_btSex = 1 then
                if g_MovingItem.Item.s.StdMode <> 11 then
                  Exit;
              flag := True;
            end;
          end;
        U_WEAPON: begin
            if Sender = DHeroSWWeapon then begin
              flag := True;
            end;
          end;
        U_NECKLACE: begin
            if Sender = DHeroSWNecklace then
              flag := True;
          end;
        U_RIGHTHAND: begin
            if Sender = DHeroSWLight then
              flag := True;
          end;
        U_HELMET: begin
            if Sender = DHeroSWHelmet then
              flag := True;
          end;
        U_RINGR, U_RINGL: begin
            if Sender = DHeroSWRingL then begin
              where := U_RINGL;
              flag := True;
            end;
            if Sender = DHeroSWRingR then begin
              where := U_RINGR;
              flag := True;
            end;
          end;
        U_ARMRINGR: begin
            if Sender = DHeroSWArmRingL then begin
              where := U_ARMRINGL;
              flag := True;
            end;
            if Sender = DHeroSWArmRingR then begin
              where := U_ARMRINGR;
              flag := True;
            end;
          end;
        U_ARMRINGL: begin
            if Sender = DHeroSWArmRingL then begin
              where := U_ARMRINGL;
              flag := True;
            end;
          end;
        U_BUJUK: begin
            if Sender = DHeroSWBujuk then begin
              where := U_BUJUK;
              flag := True;
            end;
            if Sender = DHeroSWArmRingL then begin
              where := U_ARMRINGL;
              flag := True;
            end;
          end;
        U_BELT: begin
            if Sender = DHeroSWBelt then begin
              where := U_BELT;
              flag := True;
            end;
          end;
        U_BOOTS: begin
            if Sender = DHeroSWBoots then begin
              where := U_BOOTS;
              flag := True;
            end;
          end;
        U_CHARM: begin
            if Sender = DHeroSWCharm then begin
              where := U_CHARM;
              flag := True;
            end;
          end;
      end;
    end else begin
        n := -(g_MovingItem.Index + 1);
        if n in [0..MAXHEROUSEITEM] then begin
          ItemClickSound(g_MovingItem.Item.s);
          g_HeroUseItems[n] := g_MovingItem.Item;
          g_MovingItem.Item.s.Name := '';
          g_MovingItem.Owner := nil;
          g_boItemMoving := False;
        end;
    end;
    if flag then begin
      if (g_MovingItem.Owner = DHeroItemBag) or (g_MovingItem.Owner = DItemBag) then begin
        if g_MovingItem.Owner = DHeroItemBag then begin
          ItemClickSound(g_MovingItem.Item.s);
          g_WaitingUseItem := g_MovingItem;
          g_WaitingUseItem.Index := where;
          frmMain.SendHeroTakeOnItem(where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.s.Name);
          g_MovingItem.Item.s.Name := '';
          g_MovingItem.Owner := nil;
          g_boItemMoving := False;
        end else begin
          CancelItemMoving;
          DMessageDlg ('ÒÆ¶¯µ½Ó¢ÐÛ±³°üÖÐ¿ÉÒÔÊ¹ÓÃ¡£',[mbOk]);
          exit;
        end;
      end;
    end;
  end else begin
    flag := False;
    if (g_MovingItem.Item.s.Name <> '') or (g_WaitingUseItem.Item.s.Name <> '') then Exit;
    sel := -1;
    if Sender = DHeroSWDress then sel := U_DRESS;
    if Sender = DHeroSWWeapon then sel := U_WEAPON;
    if Sender = DHeroSWHelmet then sel := U_HELMET;
    if Sender = DHeroSWNecklace then sel := U_NECKLACE;
    if Sender = DHeroSWLight then sel := U_RIGHTHAND;
    if Sender = DHeroSWRingL then sel := U_RINGL;
    if Sender = DHeroSWRingR then sel := U_RINGR;
    if Sender = DHeroSWArmRingL then sel := U_ARMRINGL;
    if Sender = DHeroSWArmRingR then sel := U_ARMRINGR;
    if Sender = DHeroSWBujuk then sel := U_BUJUK;
    if Sender = DHeroSWBelt then sel := U_BELT;
    if Sender = DHeroSWBoots then sel := U_BOOTS;
    if Sender = DHeroSWCharm then sel := U_CHARM;

    if sel >= 0 then begin
      if g_HeroUseItems[sel].s.Name <> '' then begin
        ItemClickSound(g_HeroUseItems[sel].s);
        g_MovingItem.Index := -(sel + 1);
        g_MovingItem.Item := g_HeroUseItems[sel];
        g_HeroUseItems[sel].s.Name := '';
        g_boItemMoving := True;
        g_MovingItem.Owner := DHeroStateWin;
      end;
    end;
  end;
end;

procedure TFrmDlg.DCloseHeroBagClick(Sender: TObject; X, Y: Integer);
begin
  DHeroItemBag.Visible := False;
end;

procedure TFrmDlg.DHeroItemBagDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d0, d1, d2, d3: string;
  I, n, nX, nY: Integer;
  useable: Boolean;
  d, e, f: TDirectDrawSurface;
begin
  if g_MyHero = nil then Exit;
  with DHeroItemBag do begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

   { with dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);
      Font.Color := clWhite;
      TextOut(SurfaceX(Left + 24), SurfaceY(Top + 215), intToStr(g_MyHero.m_nBagCount) + '¸ñ');
      TextOut(SurfaceX(Left + 274), SurfaceY(Top + 215), intToStr(GetHeroBagItemCount) + '¸ñ');
      Release;
    end;      }

    if (g_MyHero.m_btHeroAutoDurg > 0) then begin
      DAutoPot1.Visible := True;
      DAuto1.Visible := True;
      DAuto1Per.Visible := True;
      e := nil;
    end else begin
      DAutoPot1.Visible := False;
      DAuto1.Visible := False;
      DAuto1Per.Visible := False;
      e := g_WMainImages.Images[1428];
      if e <> nil then
      dsurface.Draw(SurfaceX(Left + 56), SurfaceY(Top + 196), e.ClientRect, e, True);
    end;

    if (g_MyHero.m_btHeroAutoDurg > 1) then begin
      DAutoPot2.Visible := True;
      DAuto2.Visible := True;
      DAuto2Per.Visible := True;
      f := nil;
    end else begin
      DAutoPot2.Visible := False;
      DAuto2.Visible := False;
      DAuto2Per.Visible := False;
      f := g_WMainImages.Images[1429];
      if f <> nil then
      dsurface.Draw(SurfaceX(Left + 162), SurfaceY(Top + 196), f.ClientRect, f, True);
    end;          

    case g_MyHero.m_nBagCount of
      0..10: begin
        d := g_WMainImages.Images[1423];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 56), d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 89), d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 122), d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 155), d.ClientRect, d, True);
        end;
      end;
      11..18: begin
        d := g_WMainImages.Images[1423];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 89), d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 122), d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 155), d.ClientRect, d, True);
        end;
      end;
      19..26: begin
        d := g_WMainImages.Images[1423];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 122), d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 155), d.ClientRect, d, True);
        end;
      end;
      27..34: begin
        d := g_WMainImages.Images[1423];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(Left + 13), SurfaceY(Top + 155), d.ClientRect, d, True);
        end;
      end;
      35..42: d:= nil;
    end;


      case g_MyHero.m_nBagCount of
        0..10: begin
            DHeroItemGrid.RowCount := 1;
            DHeroItemGrid.Height := DHeroItemGrid.RowHeight * 1;
          end;
        11..18: begin
            DHeroItemGrid.RowCount := 2;
            DHeroItemGrid.Height := DHeroItemGrid.RowHeight * 2;
          end;
        19..26: begin
            DHeroItemGrid.RowCount := 3;
            DHeroItemGrid.Height := DHeroItemGrid.RowHeight * 3;
          end;
        27..34: begin
            DHeroItemGrid.RowCount := 4;
            DHeroItemGrid.Height := DHeroItemGrid.RowHeight * 4;
          end;
        35..42: begin
            DHeroItemGrid.RowCount := 5;
            DHeroItemGrid.Height := DHeroItemGrid.RowHeight * 5;
          end;
      end;
                
  end;
end;

procedure TFrmDlg.DHeroItemBagMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
Var
  sMsg : String;
  nLocalX, nLocalY, nHintX, nHintY :Integer;
begin
  DScreen.ClearHint;
  if Sender = DHeroBagUp then begin
    nLocalX:=DHeroBagUp.LocalX(X - DHeroBagUp.Left);
    nLocalY:=DHeroBagUp.LocalY(Y - DHeroBagUp.Top);
    nHintX:=DHeroBagUp.SurfaceX(DHeroBagUp.Left) + DHeroItemBag.SurfaceX(DHeroItemBag.Left) + nLocalX;
    nHintY:=DHeroBagUp.SurfaceY(DHeroBagUp.Top) + DHeroItemBag.SurfaceY(DHeroItemBag.Top) + nLocalY;
    sMsg:= 'Ë¢ÐÂ±³°ü';
    DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
  end;
end;

procedure TFrmDlg.DHeroItemGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState;
  dsurface: TDirectDrawSurface);
var
  nIdx, ax, ay: Integer;
  d: TDirectDrawSurface;
  showstr :String;
begin
  if g_MyHero = nil then Exit;
  with DHeroItemGrid do begin
    nIdx := ACol + ARow * DHeroItemGrid.ColCount + 2;
    if nIdx in [2..MAXHEROBAGITEM - 1] then begin
      if g_HeroItemArr[nIdx].s.Name <> '' then begin
        d := g_WBagItemImages.Images[g_HeroItemArr[nIdx].s.looks];
        if d <> nil then
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2),
                 SurfaceY(Rect.Top + (RowHeight - d.Height) div 2) + ARow,
                 d.ClientRect,
                 d, True);

        if (g_HeroItemArr[nIdx].S.btValue[19] > 2) and (now < UnixToDateTime(DateTimeToUnix(g_HeroItemArr[nIdx].S.MaxDate))) then begin  //ºÀÀÎ
          d := g_WStateItemImages.Images[3590];
          if d <> nil then
            dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2) + 12,
                                SurfaceY(Rect.BottomRight.y + 18), d.ClientRect, d, True);
        end;
        with dsurface.Canvas do begin
          SetBKMode(Handle, TRANSPARENT);
          if (g_HeroItemArr[nIdx].Amount > 0) and (g_HeroItemArr[nIdx].S.StdMode in [0,1,3,45,46]) then begin     //¹°¾à
            showstr := IntToStr(g_HeroItemArr[nIdx].Amount);
            TextOutA(dsurface, SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - (TextWidth(showstr)div 2) + 15),
                       SurfaceY(Rect.BottomRight.y + 21), clYellow, showstr);
          end;
          if ((g_HeroItemArr[nIdx].Dura div 10) > 0) and (g_HeroItemArr[nIdx].S.StdMode in [25]) then begin     //¹°¾à
            showstr := IntToStr(g_HeroItemArr[nIdx].Dura div 10);
            TextOutA(dsurface, SurfaceX(Rect.Left - (TextWidth(showstr)div 2) + 20),
                       SurfaceY(Rect.BottomRight.y + 21), clYellow, showstr);
          end;
          Release;
        end;

      end;
    end;


  end;


  if BoUpItemEffect then begin  // ¾ÆÀÌÅÛ ¾÷±×·¹ÀÌµå È¿°ú
      if GetTickCount - upeffecttime > 120 then begin
         upeffecttime := GetTickCount;
         Inc (CurUpItemEffect);
         if CurUpItemEffect >= UpItemMaxFrame then begin
            FrmMain.DelitemProg;
            BoUpItemEffect := FALSE;
            UpItemItem.S.Name := '';
         end;
      end;
    end;
    if BoUpItemEffect then begin

      d := g_WMagic2Images.GetCachedImage (UpItemOffset + CurUpItemEffect, ax, ay);
      if d <> nil then
         if nIdx in [2..MAXHEROBAGITEM - 1] then
            if (UpItemItem.MakeIndex = g_HeroItemArr[nIdx].MakeIndex) and
               (Trim(UpItemItem.S.Name) = Trim(g_HeroItemArr[nIdx].S.Name))  then
               DrawBlend (dsurface,
                           DHeroItemGrid.SurfaceX(Rect.Left) -9 + ax,
                           DHeroItemGrid.SurfaceY(Rect.Top) +41 + ay,
                           d, 1);
    end;    
end;

procedure TFrmDlg.DHeroItemGridGridMouseMove(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  nIdx: Integer;
  nWhere: Integer;
  List: TStringList;
begin
  DScreen.ClearHint;
  nIdx := ACol + ARow * DHeroItemGrid.ColCount + 2;
  if nIdx in [2..MAXHEROBAGITEM - 1] then begin
    g_MouseItem := g_HeroItemArr[nIdx];
    if (g_MouseItem.s.Name <> '') then begin
      nWhere := GetHeroUseItemByBagItem(g_MouseItem.s.StdMode);
      if (nWhere >= 0) then begin
        List := TStringList.Create;
        try
          GetMouseItemHint(g_MyHero, @g_MouseItem);
          List.AddStrings(HintList);

          GetMouseItemHint(g_MyHero, @g_HeroUseItems[nWhere]);
          if HintList.Count > 0 then begin
            HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0] + '<CO$DE00>[Ó¢]<CE>';     //¿µ¿õ°¡¹æ
          end;
          with DHeroItemGrid do
            DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
          HintList.Clear;
        finally
          FreeAndNil(List);
        end;
        g_MouseItem.s.Name := '';
      end else begin
        GetMouseItemHint(g_MyHero, @g_MouseItem);
        with DHeroItemGrid do
          DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
      end;
    end;
  end else begin
    g_MouseItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DHeroItemGridGridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx, mi, n: Integer;
  temp: TClientItem;
  where: Integer;
  flag: Boolean;
  msg:TDefaultMessage;
  bCheck: Boolean;
begin
  if g_MyHero = nil then Exit;
  if g_MySelf.m_boStartStore or g_boStartStoreing then exit;
  bCheck := False;
  Idx := ACol + ARow * DHeroItemGrid.ColCount + 2;
  if (not g_boItemMoving) and (g_HeroItemArr[idx].S.Name <> '') then begin
    if (ssRight in Shift) then begin
      if (g_dwHeroEatTime + 300 < GetTickCount) and (g_HeroItemArr[idx].S.StdMode < 4) then begin
        FrmMain.HeroEatItem (idx);
        Exit;
      end;
    end;
  end;

  if Idx in [2..MAXHEROBAGITEM - 1] then begin
    if not g_boItemMoving then begin
      if g_HeroItemArr[Idx].s.Name <> '' then begin
        if (ssShift in Shift) then begin      //¹°¾à  ½ÃÀcÆ®
          if (g_HeroItemArr[idx].S.StdMode in [0,1,3,45,46]) and (g_HeroItemArr[idx].Amount > 1) then begin     //¹°¾à
             QItemAmount := g_HeroItemArr[idx].Amount;
             HItemmsIdex := g_HeroItemArr[idx].MakeIndex;
             QItemmsIdex := -1;
             DWItemSepa.Visible := True;
             Exit;
          end;
        end;
        if not g_EatHeroOp then begin     //¹°¾à
          g_boItemMoving := True;
          g_MovingItem.Index := Idx;
          g_MovingItem.Item := g_HeroItemArr[Idx];
          g_HeroItemArr[Idx].s.Name := '';
          g_MovingItem.Owner := DHeroItemBag;
          ItemClickSound(g_HeroItemArr[Idx].s);
        end;
      end;
    end else begin
      if (g_MovingItem.Owner = DAutoPot1) then begin
        FrmMain.SendDelAutoItem (g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);        
        g_MovingItem.Item.S.name := '';
        g_boItemMoving := FALSE;
        exit;
      end;
      mi := g_MovingItem.Index;
      if (g_MovingItem.Owner = DDealDlg)or (g_MovingItem.Owner = DStateWin) then Exit;
      if (mi = -94) or (mi = -95) or (mi = -96) or (mi = -97) or (mi = -98) then exit;
      if (g_MovingItem.Owner = DHeroStateWin) then begin //»óÅÂÃ¢ > °¡¹æ
        frmMain.SendHeroTakeOffItem(-(g_MovingItem.Index + 1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.s.Name);
        g_WaitingUseItem := g_MovingItem;
        g_MovingItem.Item.s.Name := '';
        g_boItemMoving := False;
        g_MovingItem.Owner := nil;
      end else begin
        if (g_MovingItem.Owner = DHeroItemBag) then begin //Ó¢ÐÛ°ü¹ü×°±¸½»»»
          if (g_HeroItemArr[Idx].s.Name <> '') then begin

            if ssCtrl in Shift then begin  //º¸¿Á(±¸ ½Ã½ºÅÛ)
              if (g_MovingItem.item.S.Name <> '') and (g_MovingItem.item.S.StdMode = 37) then begin //º¸¿Á
                 if mrYes = FrmDlg.DMessageDlg ('ÄãÈ·¶¨Òª½«ÎïÆ·' + g_HeroItemArr[idx].S.Name+ 'ÒÆ¶¯µ½ ' + g_MovingItem.item.S.Name +'Âð£¿', [mbYes, mbNo]) then begin //bChack := True
                   msg := MakeDefaultMsg (CM_GEMHEROITEM, g_MovingItem.Item.makeindex, LoWord(g_HeroItemArr[idx].MakeIndex), HiWord(g_HeroItemArr[idx].MakeIndex),0);
                   frmmain.SendSocket (EncodeMessage (msg));
                   UpItemItem := g_HeroItemArr[idx];
                   UpgradeItemEffect2;

                   if AddHeroItemBag(g_MovingItem.Item) then begin
                     g_MovingItem.Item.S.name := '';
                     g_boItemMoving := FALSE;
                   end;
                 end else begin
                    CancelHeroItemMoving;
                    Exit;
                 end;
              end;

              if (g_MovingItem.Item.S.StdMode in [59,60,61]) and (Not ((g_MovingItem.Item.S.StdMode = 59) and (g_MovingItem.Item.S.Shape in [20,21,22,23])) ) then begin          //½ºÃÄ
                if mrOk = DMessageDlg ('ÄãÈ·¶¨Òª½«ÎïÆ·' + g_HeroItemArr[idx].S.Name + 'ÒÆ¶¯µ½'+g_MovingItem.Item.S.Name+'Âð£¿', [mbOk, mbCancel]) then bCheck := True
                else begin
                  CancelHeroItemMoving;
                  Exit;
                end;
              end else bCheck := True;
            end;
            if bCheck then begin
              UpItemItem := g_HeroItemArr[idx];
              FrmMain.UpgradeHeroItem(g_HeroItemArr[idx].MakeIndex, g_MovingItem.Item.MakeIndex,   //½ºÃÄ
                                      g_HeroItemArr[idx].S.Name , g_MovingItem.Item.S.Name );
              if AddHeroItemBag(g_MovingItem.Item) then begin
                g_MovingItem.Item.S.name := '';
                g_boItemMoving := FALSE;
              end;
            end else begin
            if CheckItemMode(g_MovingItem.Item,g_HeroItemArr[idx]) then begin    //¹°¾à
              FrmMain.BundleHeroItem(g_MovingItem.Item.S.StdMode,g_HeroItemArr[idx].S.MaxAmount,inttostr(g_MovingItem.Item.MakeIndex)+'/'+inttostr(g_HeroItemArr[idx].MakeIndex));
              if ((g_MovingItem.Item.S.StdMode in [0,1,3,45,46]) and ((g_MovingItem.Item.Amount + g_HeroItemArr[idx].Amount) <= g_HeroItemArr[idx].S.MaxAmount)) then begin
                g_MovingItem.Item.S.Name := '';
              end else begin
                AddHeroItemBag (g_MovingItem.Item);
                g_MovingItem.Item.S.Name := '';
              end;
              g_boItemMoving := FALSE;
            end else begin
              temp := g_HeroItemArr[Idx];
              g_HeroItemArr[Idx] := g_MovingItem.Item;
              g_MovingItem.Index := Idx;
              g_MovingItem.Item := temp;
              g_MovingItem.Owner := DHeroItemBag;
            end;
            end;
          end else begin
            g_HeroItemArr[Idx] := g_MovingItem.Item;
            g_MovingItem.Item.s.Name := '';
            g_boItemMoving := False;
            g_MovingItem.Owner := nil;
          end;
        end;
      end;

      if (g_MovingItem.Owner = DItemBag) then begin //ÁÖÀÎ > ¿µ¿õ °¡¹æÀ¸·Î
        if g_MovingItem.Item.S.boCanHeroBag then begin
          frmMain.SendItemToHeroBag((g_MovingItem.Index), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.s.Name);
          g_WaitingUseItem := g_MovingItem;
          g_MovingItem.Item.s.Name := '';
          g_boItemMoving := False;
          g_MovingItem.Owner := nil;
        end else begin
          CancelItemMoving;
          DMessageDlg ('Õâ¼þÎïÆ·²»ÄÜ·ÅÈëÓ¢ÐÛ±³°ü¡£', [mbOk]);
        end;
      end;
    end;
  end;
  ArrangeHeroItemBag;
end;

procedure TFrmDlg.DHeroItemGridDblClick(Sender: TObject);
var
  Idx, I, where: Integer;
  keyvalue: TKeyBoardState;
  cu: TClientItem;
  TempSender: TObject;
begin
  if g_MyHero = nil then exit;
  if g_MySelf.m_boStartStore or g_boStartStoreing then exit;
  Idx := DHeroItemGrid.Col + DHeroItemGrid.Row * DHeroItemGrid.ColCount + 2;
  if Idx in [2..MAXHEROBAGITEM - 1] then begin
    if g_HeroItemArr[Idx].s.Name <> '' then begin
    end else begin
      if g_boItemMoving and (g_MovingItem.Item.s.Name <> '') then begin
        FillChar(keyvalue, SizeOf(TKeyBoardState), #0);
        GetKeyboardState(keyvalue);
        if keyvalue[VK_CONTROL] = $80 then begin
          cu := g_HeroItemArr[Idx];
          g_HeroItemArr[Idx].s.Name := '';
          g_boItemMoving := False;
          AddHeroItemBag(cu);
        end else
          if (g_MovingItem.Index = Idx) and
            (g_HeroItemArr[Idx].s.StdMode <= 4) or (g_HeroItemArr[Idx].s.StdMode = 31) or (g_HeroItemArr[Idx].s.StdMode in [16, 17])
            then begin
             g_EatHeroOp :=  True;        //¹°¾à
             frmMain.HeroEatItem(-1);
          end else begin
            where := GetTakeOnPosition(g_HeroItemArr[Idx].s.StdMode);
            if g_MovingItem.Index >= 0 then begin
              case where of
                U_DRESS: TempSender := DHeroSWDress;
                U_WEAPON: TempSender := DHeroSWWeapon;
                U_NECKLACE: TempSender := DHeroSWNecklace;
                U_RIGHTHAND: TempSender := DHeroSWLight;
                U_HELMET: TempSender := DHeroSWHelmet;
                U_RINGL: begin
                  if g_HeroUseItems[U_RINGR].S.Name = '' then TempSender := DHeroSWRingR
                  else TempSender := DHeroSWRingL;
                end;
                U_ARMRINGR: begin
                  if g_HeroUseItems[U_ARMRINGR].S.Name = '' then TempSender := DHeroSWArmRingR
                  else TempSender := DHeroSWArmRingL;
                end;
                U_BUJUK: begin
                  if g_MovingItem.Item.S.Shape = 5 then TempSender := DHeroSWBujuk
                  else TempSender := DHeroSWArmRingL
                end;
                U_BELT: TempSender := DHeroSWBelt;
                U_BOOTS: TempSender := DHeroSWBoots;
                U_CHARM: TempSender := DHeroSWCharm;
              end;
            end;
            DHeroSWWeaponClick(TempSender, 1, 1);
          end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroMenuMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;
begin
  DScreen.ClearHint;

  if Sender = DButtonHeroSkill then sMsg := 'Ó¢ÐÛ×°±¸';
  if Sender = DButtonHeroBag then sMsg := 'Ó¢ÐÛ±³°ü(Ctrl + I)';
  if Sender = DButtonHeroState then sMsg := 'Ó¢ÐÛ×´Ì¬(Ctrl + C)';


  nHintX:= DBottom.Left + DHeroMenu.Left + X + 6;
  nHintY:= DBottom.Top + DHeroMenu.Top + Y + 6;

  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, False);
end;

procedure TFrmDlg.DButtonHeroSkillClick(Sender: TObject; X, Y: Integer);
begin
  if g_MyHero = nil then exit;
  FrmDlg2.DHeroBuffDlg.Visible := Not FrmDlg2.DHeroBuffDlg.Visible;
end;

procedure TFrmDlg.DButtonHeroBagClick(Sender: TObject; X, Y: Integer);
begin
  if g_MyHero = nil then exit;
  DHeroItemBag.Visible := not DHeroItemBag.Visible;
end;

procedure TFrmDlg.DButtonHeroStateClick(Sender: TObject; X, Y: Integer);
begin
  if g_MyHero = nil then Exit;
  DHeroStateWin.Visible := not DHeroStateWin.Visible;
  HeroStatePage := 0;
  DHeroStMag1.Visible := False;
  DHeroStMag2.Visible := False;
  DHeroStMag3.Visible := False;
  DHeroStMag4.Visible := False;
  DHeroStMag5.Visible := False;
  DHeroStMag6.Visible := False;
end;

procedure TFrmDlg.DButtonMenuHeroClick(Sender: TObject; X, Y: Integer);
begin
    DHeroMenu.Visible := Not DHeroMenu.Visible;
end;

procedure TFrmDlg.DBeltHeroDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d, e: TDirectDrawSurface;
begin
  if g_MyHero = nil then DBeltHero.Visible := False;

  with DBeltHero do begin
     if g_boVerticaHerolBelt then e := g_WMainImages.Images[1946]
     else  e := g_WMainImages.Images[1934];
     if e <> nil then
       DrawBlendEx (dsurface, SurfaceX(Left), SurfaceY(Top), e, 0, 0, e.Width, e.Height, 0);
     d := WLib.Images[FaceIndex];
     if d <> nil then
       dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DBeltHeroMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg: String;
begin
  DScreen.ClearHint;
  Butt:=TDButton(Sender);

  if Sender = DBeltHeroClose then sMsg := '¿ì½ÝÀ¸(Z)';

  nHintX:=Butt.SurfaceX(Butt.Left + 17);
  nHintY:=Butt.SurfaceY(Butt.Top + 18);
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, TRUE);
end;

procedure TFrmDlg.DBeltHeroSwapClick(Sender: TObject; X, Y: Integer);
begin
  g_boVerticaHerolBelt := Not g_boVerticaHerolBelt;
  DoBeltHeroSetup();
end;

procedure TFrmDlg.DBeltHeroCloseClick(Sender: TObject; X, Y: Integer);
begin
  DBeltHero.Visible := not DBeltHero.Visible;
end;

procedure TFrmDlg.DBelt1HeroDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx: Integer;
  d: TDirectDrawSurface;
  showstr: String;
begin
  with Sender as TDButton do begin
    Idx := tag;
    if Idx in [0..1] then begin
      if g_HeroItemArr[Idx].s.Name <> '' then begin
        d := g_WBagItemImages.Images[g_HeroItemArr[Idx].s.looks];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
        with dsurface.Canvas do begin
          SetBKMode(Handle, TRANSPARENT);
          if (g_HeroItemArr[Idx].Amount > 0) and (g_HeroItemArr[Idx].S.StdMode in [0,1,3,45,46]) then begin      //¹°¾à
            showstr := IntToStr(g_HeroItemArr[idx].Amount);
            TextOutA (dsurface, SurfaceX(Left -(TextWidth(showstr) div 2) + 18), SurfaceY(Top + 18), clYellow, showstr);
          end;
          if ((g_HeroItemArr[idx].Dura div 10) > 0) and (g_HeroItemArr[idx].S.StdMode in [25]) then begin      //¹°¾à
            showstr := IntToStr(g_HeroItemArr[idx].Dura div 10);
            TextOutA (dsurface, SurfaceX(Left - (TextWidth(showstr) div 2) + 18), SurfaceY(Top + 18), clYellow, showstr);
          end;
          Release;
        end;
      end;
    end;
    with Sender do begin
       with dsurface.Canvas do begin
         SetBkMode (Handle, TRANSPARENT);
         Font.Size := 8;
         Font.Color := clWhite;
          if g_boVerticaHerolBelt then begin
            TextOut (SurfaceX(Left + 1), SurfaceY(Top + 1), IntToStr(idx+7));
          end else
            TextOut (SurfaceX(Left + 1), SurfaceY(Top + 1), IntToStr(idx+7));
         Font.Size := 9;
         Release;
        end;
     end;
  end;
end;

procedure TFrmDlg.DBelt1HeroMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   idx: integer;
   nLocalX,nLocalY:Integer;
   nHintX,nHintY:Integer;                       //º§Æ® ÀÌ¸§ Å×µÎ¸® »ö
   Butt:TDButton;
begin
   idx := TDButton(Sender).Tag;
   Butt:=TDButton(Sender);
   if idx in [0..1] then begin
     if g_HeroItemArr[idx].S.Name <> '' then begin
       g_MouseItem := g_HeroItemArr[idx];
       GetMouseItemHint(g_MyHero, @g_MouseItem);
       if HintList.Count > 0 then begin
         nLocalX:=Butt.LocalX(X - Butt.Left);
         nLocalY:=Butt.LocalY(Y - Butt.Top);
         nHintX:=Butt.SurfaceX(Butt.Left) + DBeltHero.SurfaceX(DBeltHero.Left) + nLocalX;
         nHintY:=Butt.SurfaceY(Butt.Top) + DBeltHero.SurfaceY(DBeltHero.Top) + nLocalY;
         with Sender as TDButton do
          DScreen.ShowHintB(nHintX, nHintY, HintList, True);
       end;
      end;
     g_MouseItem.S.Name := '';
   end;
end;

procedure TFrmDlg.DBelt1HeroClick(Sender: TObject; X, Y: Integer);
var
  nIdx: Integer;
  temp: TClientItem;
begin
  if g_MyHero = nil then Exit;
  nIdx := TDButton(Sender).tag;
  if nIdx in [0..1] then begin
    if not g_boItemMoving then begin
      if (g_HeroItemArr[nIdx].s.Name <> '') and ((GetTickCount - LastHeroBeltDoubleClick) > 500) then begin
        ItemClickSound(g_HeroItemArr[nIdx].s);
        g_boItemMoving := True;
        g_MovingItem.Index := nIdx;
        g_MovingItem.Item := g_HeroItemArr[nIdx];
        g_HeroItemArr[nIdx].s.Name := '';
        g_MovingItem.Owner := DHeroItemBag;
      end;
    end else begin

      if (g_MovingItem.Owner = DStateWin) or (g_MovingItem.Owner = DHeroStateWin) or (g_MovingItem.Owner = DDealDlg) then Exit;
      if (g_MovingItem.Index = -94) or (g_MovingItem.Index = -95) or (g_MovingItem.Index = -96) or
            (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Owner = DHeroItemBag) then begin
        if g_HeroItemArr[nIdx].s.Name <> '' then begin

          if CheckItemMode(g_MovingItem.Item,g_HeroItemArr[nIdx]) then begin    //¹°¾à
            FrmMain.BundleHeroItem(g_MovingItem.Item.S.StdMode,g_HeroItemArr[nIdx].S.MaxAmount,inttostr(g_MovingItem.Item.MakeIndex)+'/'+inttostr(g_HeroItemArr[nIdx].MakeIndex));
            if ((g_MovingItem.Item.S.StdMode in [0,1,3,45,46]) and ((g_MovingItem.Item.Amount + g_HeroItemArr[nIdx].Amount) <= g_HeroItemArr[nIdx].S.MaxAmount)) then begin
              g_MovingItem.Item.S.Name := '';
            end else begin
              AddHeroItemBag (g_MovingItem.Item);
              g_MovingItem.Item.S.Name := '';
            end;
            g_boItemMoving := FALSE;
          end else begin
            temp := g_HeroItemArr[nIdx];
            g_HeroItemArr[nIdx] := g_MovingItem.Item;
            g_MovingItem.Index := nIdx;
            g_MovingItem.Item := temp;
            g_MovingItem.Owner := DHeroItemBag;
          end;
        end else begin
         g_HeroItemArr[nIdx] := g_MovingItem.Item;
         g_MovingItem.Item.s.Name := '';
         g_boItemMoving := False;
         g_MovingItem.Owner := nil;
        end;
      end;
      if (g_MovingItem.Owner = DItemBag) then begin //ÁÖÀÎ > ¿µ¿õ º§Æ®À¸·Î
        if g_MovingItem.Item.S.boCanHeroBag then begin
          frmMain.SendItemToHeroBag((g_MovingItem.Index), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.s.Name);
          g_WaitingUseItem := g_MovingItem;
          g_MovingItem.Item.s.Name := '';
          g_boItemMoving := False;
          g_MovingItem.Owner := nil;
        end else begin
          CancelItemMoving;
          DMessageDlg ('Õâ¼þÎïÆ·²»ÄÜ·ÅÈëÓ¢ÐÛ±³°ü¡£', [mbOk]);
        end;
      end;

    end;
  end;
end;

procedure TFrmDlg.DBelt1HeroDblClick(Sender: TObject);
var
  Idx: Integer;
begin
  LastHeroBeltDoubleClick := GetTickCount;
  Idx := TDButton(Sender).tag;
  if Idx in [0..1] then begin
    if g_HeroItemArr[Idx].s.Name <> '' then begin
      if (g_HeroItemArr[Idx].s.StdMode <= 4) or (g_HeroItemArr[Idx].s.StdMode = 31) or (g_HeroItemArr[Idx].s.StdMode in [16, 17]) then begin //»ç¿ëÇÒ ¼ö ÀÖ´Â ¾ÆÀÌÅÛ
        if (GetTickCount - BeltchekHeroClick) > 400 then begin  //¹°¾à
          frmMain.HeroEatItem(Idx);
        end;
      end;
    end else begin
      if g_boItemMoving and (g_MovingItem.Index = Idx) and
        (g_MovingItem.Item.s.StdMode <= 4) or (g_MovingItem.Item.s.StdMode = 31) or (g_MovingItem.Item.s.StdMode in [16, 17])
        then begin
        frmMain.HeroEatItem(-1);
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroStMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx, icon: Integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
begin
  if g_MyHero = nil then Exit;
  with Sender as TDButton do begin
    Idx := _MAX(tag + HeroMagicPage * 6, 0);
    if Idx < g_HeroMagicList.Count then begin
      pm := PTClientMagic(g_HeroMagicList[Idx]);
      icon := pm.Def.btIcon;
      if icon >= 0 then begin
        if not Downed then begin
          d := GetMagic2Images(pm.Def.wMagicID).Images[icon];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        end else begin
          d := GetMagic2Images(pm.Def.wMagicID).Images[icon + 1];
          if d <> nil then
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        end;
      end;
    end;
  end;

end;

procedure TFrmDlg.DHeroStMag1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
 pm: pTClientMagic;
 idx: Integer;
 nHintX, nHintY: Integer;
 MagItem:nMagicType;
 Butt :TDButton;
begin
   with Sender as TDButton do begin
    Butt := TDButton(Sender);
    idx := _MAX(tag + HeroMagicPage * 6, 0);
    nHintX:= DHeroStateWin.Left + X + 6;
    nHintY:= DHeroStateWin.Top + Y + 6;
      if idx < g_HeroMagicList.count then begin
         pm := pTClientMagic(g_HeroMagicList[idx]);
         g_MagicItem := PM;
         GetMouseMagicInfo(MagItem);   //¹«°øÁ¤º¸
         if MagItem.MagicStr[0] <> '' then begin
             DScreen.MagicShowHint(nHintX, nHintY, MagItem, clYellow , FALSE, True);
         end;
      end;
      g_MagicItem := nil;
   end;
end;

procedure TFrmDlg.DHeroStMag1Click(Sender: TObject; X, Y: Integer);
var
  I, Idx: Integer;
  selkey: Word;
  keych: Char;
  pm: PTClientMagic;
begin
  if HeroStatePage = 3 then begin
    Idx := TDButton(Sender).tag + Heromagtop;
    if (Idx >= 0) and (Idx < g_HeroMagicList.Count) then begin
      pm := PTClientMagic(g_HeroMagicList[Idx]);
      selkey := Word(pm.Key);
      SetHeroMagicKeyDlg(pm.Def.wMagicID, pm.Def.btIcon, pm.Def.sMagicName, selkey);
      keych := Char(selkey);
      for I := 0 to g_HeroMagicList.Count - 1 do begin
        pm := PTClientMagic(g_HeroMagicList[I]);
        if pm.Key = keych then begin
          pm.Key := #0;
          frmMain.SendHeroMagicKeyChange(pm.Def.wMagicId, #0);
        end;
      end;
      pm := PTClientMagic(g_HeroMagicList[Idx]);
      pm.Key := keych;
      frmMain.SendHeroMagicKeyChange(pm.Def.wMagicId, keych);
    end;
  end;
end;

procedure TFrmDlg.DHeroStPageUpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DHeroStPageUp then begin
    if HeroMagicPage > 0 then
      Dec(HeroMagicPage);
  end else begin
    if HeroMagicPage < (g_HeroMagicList.Count + 5) div 6 - 1 then
      Inc(HeroMagicPage);
  end;
end;

procedure TFrmDlg.DHeroKeylDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
   c: TColor;
begin
   DScreen.ClearHint;
   with DHeroKeylDlg do begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

      with dsurface.Canvas do begin
        SetBkMode (Handle, TRANSPARENT);
        Font.Color := clSilver;
        Font.Size := 9;
        TextOut (SurfaceX(Left + 60), SurfaceY(Top + 26), MagHKeyMagName + ' ¿ì½Ý¼ü');
        Font.Size := 8;
        Font.Name := 'MS Sans Serif';
        Font.Color := clWhite;
        Key1 := 'F1'; Key2 := 'F2'; Key3 := 'F3'; Key4 := 'F4';
        Key5 := 'F5'; Key6 := 'F6'; Key7 := 'F7'; Key9 := 'Shift'; Key10 := '+';
        TextOut (SurfaceX(Left + 39), SurfaceY(Top+95), Key1);
        TextOut (SurfaceX(Left + 71), SurfaceY(Top+95), Key2);
        TextOut (SurfaceX(Left + 103), SurfaceY(Top+95), Key3);
        TextOut (SurfaceX(Left + 135), SurfaceY(Top+95), Key4);
        TextOut (SurfaceX(Left + 167), SurfaceY(Top+95), Key5);
        TextOut (SurfaceX(Left + 199), SurfaceY(Top+95), Key6);
        TextOut (SurfaceX(Left + 231), SurfaceY(Top+95), Key7);

        TextOut (SurfaceX(Left + 39), SurfaceY(Top+79), Key9);
        TextOut (SurfaceX(Left + 71), SurfaceY(Top+79), Key9);
        TextOut (SurfaceX(Left + 103), SurfaceY(Top+79), Key9);
        TextOut (SurfaceX(Left + 135), SurfaceY(Top+79), Key9);
        TextOut (SurfaceX(Left + 167), SurfaceY(Top+79), Key9);
        TextOut (SurfaceX(Left + 199), SurfaceY(Top+79), Key9);
        TextOut (SurfaceX(Left + 231), SurfaceY(Top+79), Key9);

        TextOut (SurfaceX(Left + 48), SurfaceY(Top+86), Key10);
        TextOut (SurfaceX(Left + 80), SurfaceY(Top+86), Key10);
        TextOut (SurfaceX(Left + 112), SurfaceY(Top+86), Key10);
        TextOut (SurfaceX(Left + 144), surfaceY(Top+86), Key10);
        TextOut (SurfaceX(Left + 176), SurfaceY(Top+86), Key10);
        TextOut (SurfaceX(Left + 208), SurfaceY(Top+86), Key10);
        TextOut (SurfaceX(Left + 240), SurfaceY(Top+86), Key10);
        Font.Name := '·ÂËÎ';
        Font.Size := 9;
        Release;
      end;      
   end;
end;

procedure TFrmDlg.DKsSF1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DKsSF1 then MagHKeyCurKey := Integer('1');
  if Sender = DKsSF2 then MagHKeyCurKey := Integer('2');
  if Sender = DKsSF3 then MagHKeyCurKey := Integer('3');
  if Sender = DKsSF4 then MagHKeyCurKey := Integer('4');
  if Sender = DKsSF5 then MagHKeyCurKey := Integer('5');
  if Sender = DKsSF6 then MagHKeyCurKey := Integer('6');
  if Sender = DKsSF7 then MagHKeyCurKey := Integer('7');
  if Sender = DKsSNone then MagHKeyCurKey := 0;
end;

procedure TFrmDlg.DKsSIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DksSIcon do begin                                //¸¶¹ý Å×µÎ¸®
    d := GetMagic2Images(MagHKeyID).Images[MagHKeyIcon];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DKsSOkClick(Sender: TObject; X, Y: Integer);
begin
   DHeroKeylDlg.Visible := False;
end;

procedure TFrmDlg.DKsSF1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  b: TDButton;
  d: TDirectDrawSurface;
  Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
  c : TColor;
begin
  b := nil;
  case MagHKeyCurKey of
      Word('1'): b := DKsSF1;
      Word('2'): b := DKsSF2;
      Word('3'): b := DKsSF3;
      Word('4'): b := DKsSF4;
      Word('5'): b := DKsSF5;
      Word('6'): b := DKsSF6;
      Word('7'): b := DKsSF7;
    else b := DKsSNone;
  end;
  if b = Sender then begin
    with b do begin
      d := nil;
      if WLib <> nil then
        d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
      with dsurface.Canvas do begin
        SetBkMode(Handle, TRANSPARENT);
        Font.Size := 8;
        Font.Color := clWhite;
        Key1 := 'F1'; Key2 := 'F2'; Key3 := 'F3'; Key4 := 'F4';
        Key5 := 'F5'; Key6 := 'F6'; Key7 := 'F7'; Key9 := 'Shift';
        Key10 := '+';
        Font.Name := 'MS Sans Serif';
        TextOut (SurfaceX(Left + 3), SurfaceY(Top+2), Key9);
        TextOut (SurfaceX(Left + 12), SurfaceY(Top+9), Key10);
        if b = DKsSF1 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key1);
        end;
        if b = DKsSF2 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key2);
        end;
        if b = DKsSF3 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key3);
        end;
        if b = DKsSF4 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key4);
        end;
        if b = DKsSF5 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key5);
        end;
        if b = DKsSF6 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key6);
        end;
        if b = DKsSF7 then begin
          TextOut (SurfaceX(Left + 3), SurfaceY(Top+18), Key7);
        end;
        Font.Name := '·ÂËÎ';
        Font.Size := 9;
        Release;
      end;
    end;
  end;
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      with dsurface.Canvas do begin
        SetBkMode(Handle, TRANSPARENT);
        Font.Size := 8;
        Font.Color := clWhite;
        Font.Name := 'MS Sans Serif';
        Key1 := 'F1'; Key2 := 'F2'; Key3 := 'F3'; Key4 := 'F4'; Key5 := 'F5'; Key6 := 'F6';
        Key7 := 'F7'; Key9 := 'Shift'; Key10 := '+';
        TextOut (SurfaceX(Left + 4), SurfaceY(Top+3), Key9,);
        TextOut (SurfaceX(Left + 13), SurfaceY(Top+10), Key10);
        if Sender = DKsSF1 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key1);
        end;
        if Sender = DKsSF2 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key2);
        end;
        if Sender = DKsSF3 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key3);
        end;
        if Sender = DKsSF4 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key4);
        end;
        if Sender = DKsSF5 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key5);
        end;
        if Sender = DKsSF6 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key6);
        end;
        if Sender = DKsSF7 then begin
          TextOut (SurfaceX(Left + 4), SurfaceY(Top+19), Key7);
        end;
        Font.Name := '·ÂËÎ';
        Font.Size := 9;
        Release;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroSkillBarDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d, e ,f: TDirectDrawSurface;
   magic: PTClientMagic;
   Key1,Key2,Key3,Key4,Key5,Key6,Key7,Key8,Key9,Key10 :String;
begin
  DHeroSkillBar.Left := DSkillBar.Width;
  if DMerchantDlg.Visible then begin
    DHSkillBar1.Visible := false;
    DHSkillBar2.Visible := false;
    DHSkillBar3.Visible := false;
    DHSkillBar4.Visible := false;
    DHSkillBar5.Visible := false;
    DHSkillBar6.Visible := false;
    DHSkillBar7.Visible := false;
    exit;
  end else if not (DHSkillBar1.Visible) then begin
    DHSkillBar1.Visible := true;
    DHSkillBar2.Visible := true;
    DHSkillBar3.Visible := true;
    DHSkillBar4.Visible := true;
    DHSkillBar5.Visible := true;
    DHSkillBar6.Visible := true;
    DHSkillBar7.Visible := true;
  end;

  //draw the window
  with Sender as TDWindow do begin
    e := g_WMainImages.Images[2194];
      if e <> nil then
        DrawBlendEx (dsurface, SurfaceX(Left), SurfaceY(Top), e, 0, 0, e.Width, e.Height, 0);

    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);

    with dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);
      Font.Color := clWhite;
      Key1 := 'F1'; Key2 := 'F2'; Key3 := 'F3'; Key4 := 'F4';
      Key5 := 'F5'; Key6 := 'F6'; Key7 := 'F7'; Key9 := 'Shift';
      Key10 := '+'; Font.Size := 8;
      Font.Name := 'MS Sans Serif';
      TextOut (SurfaceX(Left + 3), SurfaceY(Top+2), Key9);
      TextOut (SurfaceX(Left + 28), SurfaceY(Top+2), Key9);
      TextOut (SurfaceX(Left + 53), SurfaceY(Top+2), Key9);
      TextOut (SurfaceX(Left + 78), SurfaceY(Top+2), Key9);
      TextOut (SurfaceX(Left + 103), SurfaceY(Top+2), Key9);
      TextOut (SurfaceX(Left + 128), SurfaceY(Top+2), Key9);
      TextOut (SurfaceX(Left + 152), SurfaceY(Top+2), Key9);

      TextOut (SurfaceX(Left + 3), SurfaceY(Top+13), Key1);
      TextOut (SurfaceX(Left + 28), SurfaceY(Top+13), Key2);
      TextOut (SurfaceX(Left + 53), SurfaceY(Top+13), Key3);
      TextOut (SurfaceX(Left + 78), SurfaceY(Top+13), Key4);
      TextOut (SurfaceX(Left + 103), SurfaceY(Top+13), Key5);
      TextOut (SurfaceX(Left + 128), SurfaceY(Top+13), Key6);
      TextOut (SurfaceX(Left + 152), SurfaceY(Top+13), Key7);
      Font.Name := '·ÂËÎ';
      Font.Size := 9;
      Release;
    end;
  end;
  if g_HeroMagicList.Count > 0 then begin
    //F1
    magic := frmmain.GetHeroMagicByKey(char ((0) + byte('1') ) );
    if magic <> nil then
      DHSkillBar1.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar1.SetImgIndex(GetMagicImages(0), -1);

    //F2
    magic := frmmain.GetHeroMagicByKey(char ((1) + byte('1') ) );
    if magic <> nil then
      DHSkillBar2.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar2.SetImgIndex(GetMagicImages(0), -1);

    //F3
    magic := frmmain.GetHeroMagicByKey(char ((2) + byte('1') ) );
    if magic <> nil then
      DHSkillBar3.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar3.SetImgIndex(GetMagicImages(0), -1);

    //F4
    magic := frmmain.GetHeroMagicByKey(char ((3) + byte('1') ) );
    if magic <> nil then
      DHSkillBar4.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar4.SetImgIndex(GetMagicImages(0), -1);

    //F5
    magic := frmmain.GetHeroMagicByKey(char ((4) + byte('1') ) );
    if magic <> nil then
      DHSkillBar5.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar5.SetImgIndex(GetMagicImages(0), -1);

    //F6
    magic := frmmain.GetHeroMagicByKey(char ((5) + byte('1') ) );
    if magic <> nil then
      DHSkillBar6.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar6.SetImgIndex(GetMagicImages(0), -1);

    //F7
    magic := frmmain.GetHeroMagicByKey(char ((6) + byte('1') ) );
    if magic <> nil then
      DHSkillBar7.SetImgIndex(GetMagicImages(magic.Def.wMagicID), magic.Def.btIcon {* 2})
    else
      DHSkillBar7.SetImgIndex(GetMagicImages(0), -1);
  end;

end;

procedure TFrmDlg.DHSkillBar1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  magic: PTClientMagic;
  key: byte;
  nHintX, nHintY: Integer;
  MagItem:nMagicType;
  butt:TDButton;
begin
  DScreen.ClearHint;

  key := 8;
  if Sender = DHSkillBar1 then key := 0;
  if Sender = DHSkillBar2 then key := 1;
  if Sender = DHSkillBar3 then key := 2;
  if Sender = DHSkillBar4 then key := 3;
  if Sender = DHSkillBar5 then key := 4;
  if Sender = DHSkillBar6 then key := 5;
  if Sender = DHSkillBar7 then key := 6;

  magic := frmmain.GetHeroMagicByKey(char ((key) + byte('1') ) );

  with Sender as TDButton do begin
    Butt := TDButton(Sender);
    nHintX:= DHeroSkillBar.Left + X + 6;
    nHintY:= DHeroSkillBar.Top + Y + 10;
      if magic <> nil then begin
         g_MagicItem := magic;
         GetMouseMagicInfo(MagItem);   //¹«°øÁ¤º¸
         if MagItem.MagicStr[0] <> '' then begin
             DScreen.MagicShowHint(nHintX, nHintY, MagItem , clYellow , FALSE, FALSE);
         end;
      end;
      g_MagicItem := nil;
   end;
end;

procedure TFrmDlg.DBotAi1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDButton;
  dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed or (g_boHeroAiMode = d.Tag) then begin
         dd := d.WLib.Images[d.FaceIndex + 4];
      end else begin
         dd := d.WLib.Images[d.FaceIndex];
      end;
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);
   end;
end;

procedure TFrmDlg.DBotAi1Click(Sender: TObject; X, Y: Integer);
begin
   if (GetTickCount > g_dwChangeAiModeTick) then begin
     if g_boHeroAiMode <> TDButton(Sender).Tag then begin
       SendClientMessage(CM_HEROAI, TDButton(Sender).Tag, 0, 0, 0);
       g_dwChangeAiModeTick := GetTickCount + 600;
     end;
   end;
end;

procedure TFrmDlg.DBotAi1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;
begin
  DScreen.ClearHint;

  if Sender = DBotAi1 then sMsg := '¹¥»÷×´Ì¬1\¹¥»÷³öÏÖÔÚÊÓÒ°·¶Î§ÄÚµÄÄ¿±ê¡£';
  if Sender = DBotAi2 then sMsg := '¹¥»÷×´Ì¬2\¹¥»÷Ï®»÷×Ô¼º»òÕßÓ¢ÐÛµÄÄ¿±ê¡£';
  if Sender = DBotAi3 then sMsg := '¸úËæ×´Ì¬\³ýÁËÇ¿ÖÆ¹¥»÷£¬Ó¢ÐÛ²»¹¥»÷Ä¿±ê¡£';
  if Sender = DBotAi4 then sMsg := '×Ô¶¨Òå¹¥»÷';

  nHintX:= DBottom.Left + X + 6;
  nHintY:= DBottom.Top + Y + 6;
  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, False);
end;

procedure TFrmDlg.DHeroControlMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
    DScreen.ClearHint;
end;

procedure TFrmDlg.DHeroHelpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nHintX, nHintY: Integer;
  Butt: TDButton;
  sMsg: string;
begin
  DScreen.ClearHint;

  if Sender = DHeroHelp then sMsg := 'Ó¢ÐÛ°ïÖú';
  if Sender = DHeroCall then sMsg := 'ÕÙ»½(Ctrl + 1)';
  if Sender = DHeroBack then sMsg := 'ÊÕ»Ø(Ctrl + 2)';
  if Sender = DHeroDefen then sMsg := 'ÊØ»¤(Ctrl + 3)';

  nHintX:= DHeroControl.Left + X + 4;
  nHintY:= DHeroControl.Top + Y + 4;

  DScreen.ShowHintA(nHintX, nHintY, sMsg, clYellow, False);
end;

procedure TFrmDlg.DHeroCallClick(Sender: TObject; X, Y: Integer);
begin
  if not g_HeroCall then begin
    SendClientMessage(CM_HEROCALL, 0, 0, 0, 0);
    with DHeroCall do begin
       g_ClientCallRect := Bounds(SurfaceX(Left), SurfaceY(Top), Width, Height);
    end;
    g_HeroCallTick := GetTickCount();
    g_HeroCall := True;
  end;
end;

procedure TFrmDlg.DHeroBackClick(Sender: TObject; X, Y: Integer);
begin
  if not g_HeroBackCall then begin
    SendClientMessage(CM_HEROBACKCALL, 0, 0, 0, 0);
    with DHeroBack do begin
       g_ClientBackCallRect := Bounds(SurfaceX(Left), SurfaceY(Top), Width, Height);
    end;
    g_HeroBackCallTick := GetTickCount();
    g_HeroBackCall := True;
  end;
end;

procedure TFrmDlg.DHeroDefenClick(Sender: TObject; X, Y: Integer);
begin
  if not g_HeroMasterDefen then begin
    SendClientMessage(CM_MASTERDEFEN, 0, 0, 0, 0);
    with DHeroDefen do begin
       g_ClientDefenRect := Bounds(SurfaceX(Left), SurfaceY(Top), Width, Height);
    end;
    g_HeroMasterDefenTick := GetTickCount();
    g_HeroMasterDefen := True;
  end;
end;

procedure TFrmDlg.DHeroHelpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDButton;
  dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.Downed then begin
         dd := d.WLib.Images[d.FaceIndex + 2];
      end else
      if d.MouseMoveing then begin
         dd := d.WLib.Images[d.FaceIndex + 1];
      end else begin
         dd := d.WLib.Images[d.FaceIndex];
      end;
      if dd <> nil then
        dsurface.Draw (d.SurfaceX(d.Left), d.SurfaceY(d.Top), dd.ClientRect, dd, TRUE);

      if (Sender = DHeroDefen) and g_HeroMasterDefen then begin
        dsurface.FillRectAlpha(g_ClientDefenRect, clblack, 150);
        if GetTickCount - g_HeroMasterDefenTick > 1500 then begin
          g_HeroMasterDefenTick := GetTickCount;
          g_ClientDefenRect.Top := g_ClientDefenRect.Top + 1;
          if g_ClientDefenRect.Top > g_ClientDefenRect.Bottom then begin
            g_HeroMasterDefen := False;
          end;
        end;
      end;

      if (Sender = DHeroCall) and g_HeroCall then begin
        dsurface.FillRectAlpha(g_ClientCallRect, clblack, 150);
        if GetTickCount - g_HeroCallTick > 9400 then begin
          g_HeroCallTick := GetTickCount;
          g_ClientCallRect.Top := g_ClientCallRect.Top + 1;
          if g_ClientCallRect.Top > g_ClientCallRect.Bottom then begin
            g_HeroCall := False;
          end;
        end;
      end;

      if (Sender = DHeroBack) and g_HeroBackCall then begin
        dsurface.FillRectAlpha(g_ClientBackCallRect, clblack, 150);
        if GetTickCount - g_HeroBackCallTick > 150 then begin
          g_HeroBackCallTick := GetTickCount;
          g_ClientBackCallRect.Top := g_ClientBackCallRect.Top + 1;
          if g_ClientBackCallRect.Top > g_ClientBackCallRect.Bottom then begin
            g_HeroBackCall := False;
          end;
        end;
      end;

   end;

end;

procedure TFrmDlg.DHeroHelpClick(Sender: TObject; X, Y: Integer);
begin
  DHelpWin.Visible:=not DHelpWin.Visible;
  HelpPage := 20;
end;

procedure TFrmDlg.DBHelpWakeClick(Sender: TObject; X, Y: Integer);
begin
  DHelpWin.Visible:=not DHelpWin.Visible;
  HelpPage := 26;
end;

procedure TFrmDlg.DAutoPot1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx: Integer;
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    Idx := tag;
    if Idx in [0..1] then begin
      if g_AutoPotItems[Idx].s.Name <> '' then begin
        d := g_WBagItemImages.Images[g_AutoPotItems[Idx].s.looks];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left + 2 + (Width - d.Width) div 2), SurfaceY(Top + (Height - d.Height) div 2), d.ClientRect, d, True);
         with dsurface.Canvas do begin
           SetBKMode(Handle, TRANSPARENT);
           Font.Color := clYellow;
           if (g_AutoPotItems[Idx].Amount > 0) and (g_AutoPotItems[Idx].S.StdMode in [0,1,3,45,46]) then begin      //¹°¾à
              TextOut (SurfaceX(Left -(TextWidth(IntToStr(g_AutoPotItems[Idx].Amount)) div 2) + 18),
                      SurfaceY(Top + 18) , IntToStr(g_AutoPotItems[Idx].Amount));
           end;
           Release;
         end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DAutoPot1Click(Sender: TObject; X, Y: Integer);
var
  nIdx: Integer;
  temp: TClientItem;
begin
  if g_MyHero = nil then Exit;
  nIdx := TDButton(Sender).tag;
  if nIdx in [0..1] then begin
    if not g_boItemMoving then begin
      if g_AutoPotItems[nIdx].s.Name <> '' then begin
        ItemClickSound(g_AutoPotItems[nIdx].s);
        g_boItemMoving := True;
        g_MovingItem.Owner := DAutoPot1;
        g_MovingItem.Index := - 53 - nIdx ;
        g_MovingItem.Item := g_AutoPotItems[nIdx];
        g_AutoPotItems[nIdx].s.Name := '';
      end;
    end else begin
      if (g_MovingItem.Owner = DAutoPot1) then begin
        if g_AutoPotItems[nIdx].S.Name <> '' then begin
          temp := g_AutoPotItems[nIdx];
          g_AutoPotItems[nIdx] := g_MovingItem.Item;
          g_MovingItem.Index := - 53 - nIdx;
          g_MovingItem.Item := temp;
          g_MovingItem.Owner := DAutoPot1;
          exit;
        end else begin
          g_AutoPotItems[nIdx] := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
          g_MovingItem.Owner := nil;
          exit;
        end;
      end;

      if (g_MovingItem.Owner = DHeroItemBag) then begin
        if (g_MovingItem.Item.S.StdMode = 0) and (g_MovingItem.Item.S.Shape in [0,3]) then begin
          FrmMain.SendAddAutoItem (g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
          g_SellDlgItemSellWait := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_MovingItem.Owner := nil;
          g_boItemMoving := FALSE;
          exit;
        end else begin
          CancelHeroItemMoving;
          DMessageDlg ('´ËÒ©Ë®²»ÔÊÐí×Ô¶¯Ê¹ÓÃ', [mbOk]);
        end;
      end;

    end;
  end;
  ArrangeHeroAutoItemBag;
end;

procedure TFrmDlg.DAutoPot1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  Idx, nHintX, nHintY : Integer;
begin
  Idx := TDButton(Sender).tag;
  if Idx in [0..1] then begin
    if g_AutoPotItems[Idx].s.Name <> '' then begin
      g_MouseItem := g_AutoPotItems[Idx];
      GetMouseItemHint(g_MyHero, @g_MouseItem);
      if HintList.Count > 0 then begin
        nHintX:= DHeroItemBag.Left + X + 6;
        nHintY:= DHeroItemBag.Top + Y + 12;
        with Sender as TDButton do
          DScreen.ShowHintB(nHintX, nHintY, HintList, False);
      end;
    end;
    g_MouseItem.S.Name := '';
  end;

end;

procedure TFrmDlg.DAuto1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  index: integer;
begin
  with Sender as TDButton do begin
     if Sender = DAuto1 then begin
       if nHero1Index = 0 then index := 560
       else index := 563;
       if Downed then begin
         d := g_WTitleImages.Images[index + 2];
       end else
       if MouseMoveing then begin
         d := g_WTitleImages.Images[index + 1];
       end else begin
         d := g_WTitleImages.Images[index];
       end;
       if d <> nil then
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
     end else begin
       if Sender = DAuto2 then begin
         if nHero2Index = 0 then index := 560
         else index := 563;
         if Downed then begin
           d := g_WTitleImages.Images[index + 2];
         end else
         if MouseMoveing then begin
           d := g_WTitleImages.Images[index + 1];
         end else begin
           d := g_WTitleImages.Images[index];
         end;
         if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
       end;
     end;

  end;
end;

procedure TFrmDlg.DAuto1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DAuto1 then begin
    if nHero1Index = 0 then nHero1Index := 1
    else nHero1Index := 0;
  end else begin
    if Sender = DAuto2 then begin
      if nHero2Index = 0 then nHero2Index := 1
      else nHero2Index := 0;
    end;
  end;
end;

procedure TFrmDlg.DAuto1PerDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d2, d3: String;
begin
  if g_MyHero = nil then Exit;
  with Sender as TDButton do begin
   // if WLib <> nil then
   //   d := WLib.Images[FaceIndex];
   // dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);

    with dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);
      Font.Color := clWhite;
      if Sender = DAuto1Per then begin
        d2 := intToStr(nHero1Percent) + '%';
        TextOut(SurfaceX(Left + 30 - TextWidth(d2) div 2), SurfaceY(Top + 2), d2);
      end;
      if Sender = DAuto2Per then begin
        d3 := intToStr(nHero2Percent) + '%';
        TextOut(SurfaceX(Left + 30 - TextWidth(d3) div 2), SurfaceY(Top + 2), d3);
      end;
      Release;
    end;
  end;
end;

procedure TFrmDlg.DAuto1PerClick(Sender: TObject; X, Y: Integer);
  function HeroAutoIndexName(index:integer) : string;
  begin
    if index = 0 then Result := 'HP'
    else Result := 'MP';
  end;
var
  Per: Integer;
  valstr: string;
begin
   if Sender = DAuto1Per then begin
    if (mrOk = FrmDlg.DMessageDlg('Ó¢ÐÛµÄÉúÃüÉèÖÃÎª ' + HeroAutoIndexName(nHero1Index) + '%Ê±×Ô¶¯Ê¹ÓÃÒ©Ë®', [mbOk, mbAbort])) then begin
      if IsStringNumber(valstr) then begin
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Per := Str_ToInt(valstr, 0);
        if (Per > 0) and (Per < 100) then begin
          nHero1Percent := Per;
        end;
      end;
    end;
  end;
  if Sender = DAuto2Per then begin
    if (mrOk = FrmDlg.DMessageDlg('Ó¢ÐÛµÄÄ§Á¦ÉèÖÃÎª ' + HeroAutoIndexName(nHero2Index) + ' %Ê±×Ô¶¯Ê¹ÓÃÒ©Ë®¡£', [mbOk, mbAbort])) then begin
      if IsStringNumber(valstr) then begin
        GetValidStrVal(DlgEditText, valstr, [' ']);
        Per := Str_ToInt(valstr, 0);
        if (Per > 0) and (Per < 100) then begin
          nHero2Percent := Per;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroBagUpClick(Sender: TObject; X, Y: Integer);
begin
  SendClientMessage(CM_QUERYHEROBAGITEMS, 0, 0, 0, 0);
end;

procedure TFrmDlg.DMakeAdviceClick(Sender: TObject; X, Y: Integer);
var
  Msg: String;
begin
  Msg:='ÄãÏëÊ¹ÓÃÖÆ×÷¼¼ÄÜÂð£¿';
  if mrOk = FrmDlg.DSimpleMessageDlg2 (Msg, [mbOk, mbCancel]) then begin
    FrmMain.SendSay ('@ÖÆ×÷¼¼ÄÜ{Á¦ÀÛ±â¼ú}');
  end
end;

procedure TFrmDlg.DGrpCheckGroupClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChangeGroupModeTick then begin
      g_boCheckGroup := not g_boCheckGroup;
      g_dwChangeGroupModeTick := GetTickCount + 1000; //timeout 5Ãë
      FrmMain.SendGroupMode ();
      PlaySound(s_norm_button_click);
   end;
end;

procedure TFrmDlg.DCBGroupItemDefClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount > g_dwChangeGroupModeTick then begin
    if Sender = DCBGroupItemDef then begin
      DCBGroupItemDef.Checked := True;
      DCBGroupItemRam.Checked := False;
    end
    else if Sender = DCBGroupItemRam then begin
      DCBGroupItemRam.Checked := True;
      DCBGroupItemDef.Checked := False;
    end;
    g_GroupItemMode := DCBGroupItemRam.Checked;
    g_dwChangeGroupModeTick := GetTickCount + 2000; //timeout 5Ãë
    FrmMain.SendGroupMode ();
    PlaySound(s_norm_button_click);
  end;
end;

procedure TFrmDlg.DGrpMemberListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ax, ay: integer;
  GroupMember: pTGroupMember;
  Actor: TActor;
  nX, nY: Integer;
  ShowName: String;
begin
  with Sender as TDWindow do begin
    ax := SurfaceX(Left);
    ay := SurfaceY(Top);
    with dsurface.Canvas do begin
      if Sender = DGrpMemberList then begin
        if g_MemberGroup.count > 1 then begin
          GroupMember := g_MemberGroup[0];
          ShowName :=  GroupMember.ClientGroup.UserName + '(' + IntToStr(GroupMember.ClientGroup.Level) + ')';
          if 0 = GroupListMoveIndex then begin
            dsurface.FillRectAlpha(Rect(ax + 4, ay + 3, ax + 108, ay + 18), clLtGray, 125);
          end
          else if 0 = GroupListIndex then begin
            dsurface.FillRectAlpha(Rect(ax + 4, ay + 3, ax + 108, ay + 18), clLtGray, 125);
          end;
          SetBkMode(Handle, TRANSPARENT);
          TextOutA(dsurface, ax + 6, ay + 4, $6090C0, ShowName);
          Release;
          for i := 1 to g_MemberGroup.count - 1 do begin
            GroupMember := g_MemberGroup[i];
            ShowName := GroupMember.ClientGroup.UserName + '(' + IntToStr(GroupMember.ClientGroup.Level) + ')';
            nX := ax + 6 + ((i - 1) mod 2) * 116;
            nY := ay + 21 + (i - 1) div 2 * 14;
            if i = GroupListMoveIndex then begin
              dsurface.FillRectAlpha(Rect(nx - 2, ny - 1, nx + 108, ny + 12), clLtGray, 125);
            end
            else if i = GroupListIndex then begin
              dsurface.FillRectAlpha(Rect(nx - 2, ny - 1, nx + 108, ny + 12), clLtGray, 125);
            end;
            SetBkMode(Handle, TRANSPARENT);
            TextOutA(dsurface, nX, ny, $B6C0A9, ShowName);
            Release;
          end;
        end;
      end
      else if Sender = DGrpUserList then begin
        if (GetTickCount - AppendTick) > 1000 then begin
          AppendTick := GetTickCount;
          RefGroupList.Clear;
          with PlayScene do begin
            for i := 0 to m_ActorList.Count - 1 do begin
              Actor := m_ActorList[i];
              if (Actor <> g_MySelf) and ((Actor.m_nState and $00000200 <> 0) or (Actor.m_nState and $00000080 <> 0)) and not (frmMain.IsGroupMember(Actor.m_sUserName)) then begin
              end else begin
                if (Actor.m_btRace = 0) and (Actor.m_Group = nil) and (Actor <> g_MySelf) and (Actor <> g_MyHero) and (not Actor.m_boisHero) then begin
                  RefGroupList.AddObject(Actor.m_sUserName, TObject(Actor));
                end;
              end;
            end;
            if RefGroupList.Count > 8 then begin
              GroupIndexMax := RefGroupList.Count - 8;
            end
            else begin
              GroupIndexMax := 0;
              GroupIndex := 0;
            end;
          end;
        end;
        if RefGroupList.count > 0 then begin
          DGpMove.listcont := GroupIndexMax;
          for i := GroupIndex to GroupIndex + 7 do begin
            if i >= RefGroupList.count then Break;
            nX := ax + 2;
            nY := ay + 2 + ((i - GroupIndex) * 14);
            if i = UserListMoveIndex then begin
              dsurface.FillRectAlpha(Rect(nX, nY, nX + 218, nY + 14), clLtGray, 125);
            end
            else if i = UserListIndex then begin
              dsurface.FillRectAlpha(Rect(nX, nY, nX + 218, nY + 14), clLtGray, 125);
            end;
            SetBkMode(Handle, TRANSPARENT);
            TextOutA(dsurface, ax + 36 - Left, ay + 3 + (i - GroupIndex) * 14, $B6C0A9, RefGroupList[i]);
            actor := TActor(RefGroupList.Objects[i]);
            if Actor <> nil then begin
              TextOutA(dsurface,ax + 112 - Left, ay + 3 + (i - GroupIndex) * 14, $B6C0A9, 'Lv.' + IntToStr(Actor.m_Abil.Level));
              TextOutA(dsurface,ax + 174 - Left, ay + 3 + (i - GroupIndex) * 14, $B6C0A9, GetJobName(Actor.m_btJob));
            end;
            Release;
          end;
        end;

      end;
    end;
  end;
end;

procedure TFrmDlg.DGrpMemberListMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  x := x - DGrpMemberList.Left;
  y := y - DGrpMemberList.Top;
  GroupListIndex := -1;
  if (X >= 6) and (x <= 125) and (y >= 4) and (y <= 17) then begin
    GroupListIndex := 0;
  end
  else if (X >= 6) and (x <= 250) and (y >= 18) and (y <= 65) then begin
    GroupListIndex := (y - 18) div 16 * 2 + (X - 6) div 125 + 1;
  end;
end;

procedure TFrmDlg.DGrpMemberListMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  x := x - DGrpMemberList.Left;
  y := y - DGrpMemberList.Top;
  GroupListMoveIndex := -1;
  if (X >= 6) and (x <= 258) and (y >= 4) and (y <= 17) then begin
    GroupListMoveIndex := 0;
  end
  else if (X >= 6) and (x <= 250) and (y >= 18) and (y <= 65) then begin
    GroupListMoveIndex := (y - 18) div 16 * 2 + (X - 6) div 125 + 1;
  end;
end;

procedure TFrmDlg.DGrpMemberListDblClick(Sender: TObject);
var
  who: string;
  GroupMember: pTGroupMember;
begin
  who := '';
  if (GroupListIndex < g_MemberGroup.count) and (GroupListIndex >= 0) then begin
    GroupMember := g_MemberGroup[GroupListIndex];
    who := GroupMember.ClientGroup.UserName;
  end;
  if who <> '' then begin
    PlayScene.SetEditChar(who);
  end;
end;

procedure TFrmDlg.DGrpCheckHeroClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChangeGroupModeTick then begin
      g_boCheckHero := not g_boCheckHero;
      g_dwChangeGroupModeTick := GetTickCount + 1000; //timeout 5Ãë
      FrmMain.SendGroupMode ();
      PlaySound(s_norm_button_click);
   end;
end;

procedure TFrmDlg.DGrpUserListDblClick(Sender: TObject);
var
  who: string;
begin
  who := '';
  if (UserListIndex < RefGroupList.count) and (UserListIndex >= 0) then begin
    who := RefGroupList[UserListIndex];
  end;
  if who <> '' then begin
    PlayScene.SetEditChar(who);
  end;
end;

procedure TFrmDlg.DGrpUserListMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  x := x - DGrpUserList.Left;
  y := y - DGrpUserList.Top;
  UserListIndex := -1;
  if (X > 6) and (x < 250) and (y > 3) and (y < 128) then begin
    UserListIndex := (y - 3) div 14 + GroupIndex;
  end;
end;

procedure TFrmDlg.DGrpUserListMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  x := x - DGrpUserList.Left;
  y := y - DGrpUserList.Top;
  UserListMoveIndex := -1;
  if (X > 6) and (x < 250) and (y > 3) and (y < 500) then begin
    UserListMoveIndex := (y - 3) div 14 + GroupIndex;
  end;
end;

procedure TFrmDlg.DGdUserUpClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DGdUserUp then begin
      if GroupIndex > 0 then
         Dec (GroupIndex);
      DGpMove.UpHeightout;
   end else begin
      if GroupIndex < GroupIndexMax then
         Inc (GroupIndex);
      DGpMove.exitHeightout;
   end;
end;

procedure TFrmDlg.DGpMoveMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  GroupIndex:=DGpMove.outidx;
end;

procedure TFrmDlg.DGpMoveDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DGpMove do begin
    if Downed then begin
     d := WLib.Images[FaceIndex + 1]
    end else
    if ((GetTickCount - AppendTick) mod 400 < 200) and (listcont > 0) then begin
      d := WLib.Images[FaceIndex + 1];
    end else
      d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DHeroStoreGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState;
  dsurface: TDirectDrawSurface);
var
   idx, i, nInt: integer;
   d: TDirectDrawSurface;
   showstr: String;
begin
   idx := ACol + ARow * DHeroStoreGrid.ColCount;
   if idx in [0..STORAGELIMIT-1] then begin
      if g_HeroStoreItem[idx].S.Name <> '' then begin
         d := g_WBagItemImages.Images[g_HeroStoreItem[idx].S.Looks];
         if d <> nil then
          with DHeroStoreGrid do begin
             dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 ){+ ACol},
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2)+ ARow,
                              d.ClientRect,
                              d, TRUE);
            if (g_HeroStoreItem[idx].Amount > 0) and (g_HeroStoreItem[idx].S.StdMode in [0,1,3,45,46]) then begin        //¹°¾à
              nInt := g_HeroStoreItem[idx].Amount;
              with dsurface.Canvas do begin
                SetBKMode(Handle, TRANSPARENT);
                showstr := IntToStr(nInt);
                TextOutA(dsurface, SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 -(TextWidth(showstr) div 2) + 20),
                        SurfaceY(Rect.BottomRight.y + 20), clYellow, showstr);
                Release;
              end;
            end;
            if ((g_HeroStoreItem[idx].Dura div 10) > 0) and (g_HeroStoreItem[idx].S.StdMode in [25]) then begin        //¹°¾à
              nInt := (g_HeroStoreItem[idx].Dura div 10);
              with dsurface.Canvas do begin
                SetBKMode(Handle, TRANSPARENT);
                showstr := IntToStr(nInt);
                TextOutA(dsurface, SurfaceX(Rect.Left -(TextWidth(showstr) div 2) + 20),
                        SurfaceY(Rect.BottomRight.y + 20), clYellow, showstr);
                Release;
              end;
            end;
          end;
      end;
   end;
end;

procedure TFrmDlg.DHeroStoreGridGridMouseMove(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx: Integer;
  nWhere: Integer;
  List: TStringList;
begin
  DScreen.ClearHint;
  Idx := ACol + ARow * DHeroStoreGrid.ColCount;
  if Idx in [0..STORAGELIMIT - 1] then begin
    g_MouseItem := g_HeroStoreItem[idx];
    if (g_MouseItem.s.Name <> '') then begin

      nWhere := GetHumUseItemByBagItem(g_MouseItem.s.StdMode);
      if (nWhere >= 0) then begin

        List := TStringList.Create;
        try
          GetMouseItemHint(g_MyHero, @g_MouseItem);
          List.AddStrings(HintList);

          GetMouseItemHint(g_MyHero, @g_UseItems[nWhere]);
          if HintList.Count > 0 then begin
            HintList.Strings[0] := '<CO$DE00>[×°±¸]<CE>' + HintList.Strings[0] + '<CO$DE00>[Ó¢]<CE>';   //¿©°ü
          end;
          with DHeroStoreGrid do
            DScreen.ShowHintL(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), List, HintList, False);
          HintList.Clear;
        finally
          FreeAndNil(List);
        end;
        g_MouseItem.s.Name := '';
      end else begin
        GetMouseItemHint(g_MyHero, @g_MouseItem);
        with DHeroStoreGrid do
          DScreen.ShowHintB(SurfaceX(Left + (x - left)), SurfaceY(Top + (y - Top) + 30), HintList, False);
      end;

    end;
  end else begin
   g_MouseItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DStore1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if m_Storemode = tag then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex + 1];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DStore1Click(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if m_Storemode <> Tag then begin
      m_Storemode := Tag;
    end;
  end;
end;

procedure TFrmDlg.DStore2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if not Enabled then
        d := WLib.Images[FaceIndex + 2]
      else if m_Storemode = tag then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex + 1];
        if d <> nil then
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DHeroStoreGridGridSelect(Sender: TObject; X, Y, ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx, mj: integer;
   temp: TClientItem;
   keyvalue: TKeyBoardState;
   sData, sData1, sData2:String;
begin
 if g_FishingOk = FALSE then begin
   FillChar(keyvalue, sizeof(TKeyboardState), #0);
   GetKeyboardState (keyvalue);
   idx := ACol + ARow * DHeroStoreGrid.ColCount;
   if idx in [0..STORAGELIMIT-1] then begin
      if not g_boItemMoving then begin
         if g_HeroStoreItem[idx].S.Name <> '' then begin
            if ssCtrl in Shift then begin  //º¸¿Á(±¸ ½Ã½ºÅÛ)
                if not PlayScene.EdChat.Visible then begin
                  PlayScene.EdChat.Visible := True;
                  PlayScene.EdChat.SetFocus;
                end;
                if PlayScene.EdChat.SelStart = Length(PlayScene.EdChat.Text) then begin
                    PlayScene.EdChat.Text := PlayScene.EdChat.Text +  '{' + '3' + '/' + IntToStr(g_HeroStoreItem[Idx].MakeIndex) + '}';
                    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
                end else begin
                  sData := Copy(PlayScene.EdChat.Text, 1, PlayScene.EdChat.SelStart);
                  sData1 := Copy(PlayScene.EdChat.Text, PlayScene.EdChat.SelStart + 1, Length(PlayScene.EdChat.Text) - PlayScene.EdChat.SelStart);
                  sData2 := '{' + '3' + '/' + IntToStr(g_HeroStoreItem[Idx].MakeIndex) + '}';
                  PlayScene.EdChat.Text := sData + sData2 + sData1;
                  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text) - Length(WideString(sData1));
                end;
                PlayScene.EdChat.SelLength := 0;
                SetImeMode (PlayScene.EdChat.Handle, imSHanguel);
                exit;
            end;
            g_boItemMoving := TRUE;
            g_MovingItem.Index := idx+600;
            g_MovingItem.Item := g_HeroStoreItem[idx];
            g_MovingItem.Owner := DItemStore;
            g_HeroStoreItem[idx].S.Name := '';
            ItemClickSound (g_HeroStoreItem[idx].S);
            g_boStoreToBag := TRUE;
         end;
      end else begin
        mj := g_MovingItem.Index;

        if (g_MovingItem.Owner = DItemStore) and (g_MovingItem.Index >= 600) then begin
          if g_HeroStoreItem[idx].S.Name <> '' then begin
            if CheckItemMode(g_MovingItem.Item,g_HeroStoreItem[idx]) then begin    //¹°¾à
              FrmMain.BundleHeroStorageItem(g_MovingItem.Item.S.StdMode,g_HeroStoreItem[idx].S.MaxAmount,inttostr(g_MovingItem.Item.MakeIndex)+'/'+inttostr(g_HeroStoreItem[idx].MakeIndex));
              if ((g_MovingItem.Item.S.StdMode in [0,1,3,45,46,49]) and ((g_MovingItem.Item.Dura + g_HeroStoreItem[idx].Dura) <= g_HeroStoreItem[idx].S.MaxAmount)) then begin
                g_MovingItem.Item.S.Name := '';
              end else begin
                AddItemHeroStore (g_MovingItem.Item);
                g_MovingItem.Item.S.Name := '';
              end;
              g_boItemMoving := FALSE;

            end else begin
              temp := g_HeroStoreItem[idx];
              g_HeroStoreItem[idx] := g_MovingItem.Item;
              g_MovingItem.Index := idx+600;
              g_MovingItem.Item := temp;
              g_MovingItem.Owner := DItemStore;
              exit;
            end;
          end else begin
            g_HeroStoreItem[idx] := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
            g_boBagToStore := FALSE;
            g_boStoreToBag := FALSE;
            g_MovingItem.Owner := nil;
            exit;
          end;
        end;

        if (g_MovingItem.Owner = DItemBag) and (SpotDlgMode = dmStorage) and g_boBagToStore and (m_nStorageMode = 0) then begin
           FrmMain.SendHeroStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 0);
           g_SellDlgItemSellWait := g_MovingItem.Item;
           g_MovingItem.Item.S.name := '';
           g_boItemMoving := FALSE;
           g_boBagToStore := FALSE;
           g_MovingItem.Owner := nil;
           exit;
        end else begin
           if (g_MovingItem.Owner = DItemBag) and (SpotDlgMode = dmStorage) and g_boBagToStore and (m_nStorageMode = 1) then begin
             FrmMain.SendHeroStorageItem (g_nCurMerchant, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name, 1);
             g_SellDlgItemSellWait := g_MovingItem.Item;
             g_MovingItem.Item.S.name := '';
             g_boItemMoving := FALSE;
             g_boBagToStore := FALSE;
             g_MovingItem.Owner := nil;
             exit;
           end;
        end;
      end;
   end;
   ArrangeItemHeroStore;
 end;
end;

procedure TFrmDlg.DStore1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nHintX, nHintY: Integer;
  smsg: string;
begin
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if Tag = 1 then begin
      if Enabled then begin
        sMsg := 'Ó¢ÐÛ±³°ü: <CO$FFFF>¿ÉÒÔÊ¹ÓÃ<CE>'
      end else
        sMsg := 'Ó¢ÐÛ±³°ü: <CO$FF>²»¿ÉÊ¹ÓÃ<CE>\ÕÙ»½³öÓ¢ÐÛºó¿ÉÒÔÊ¹ÓÃ¡£';
      nHintX := SurfaceX(Left);
      nHintY := SurfaceY(Top);
      DScreen.ShowHintA(nHintX, nHintY, smsg, clWhite, True);
    end;
  end;
end;

procedure TFrmDlg.DBCompoundClick(Sender: TObject; X, Y: Integer);
begin
  FrmDlg2.DWndCompound.Visible := Not FrmDlg2.DWndCompound.Visible;
end;

initialization

//SVNRevision('$Id: FState.pas 597 2007-04-11 19:46:11Z sean $');
end.

